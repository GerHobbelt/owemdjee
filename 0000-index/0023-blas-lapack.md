

### BLAS, LAPACK, ...

- **amd-fftw** [ğŸ“](./amd-fftw) [ğŸŒ](https://github.com/GerHobbelt/amd-fftw) -- AOCL-FFTW is AMD optimized version of FFTW implementation targeted for AMD EPYC CPUs. It is developed on top of FFTW (version fftw-3.3.10). AOCL-FFTW achieves high performance as a result of its various optimizations involving improved SIMD Kernel functions, improved copy functions (cpy2d and cpy2d_pair used in rank-0 transform and buffering plan), improved 256-bit kernels selection by Planner and an optional in-place transpose for large problem sizes. AOCL-FFTW improves the performance of in-place MPI FFTs by employing a faster in-place MPI transpose function.
- **Arduino-KalmanFilter** [ğŸ“](./Arduino-KalmanFilter) [ğŸŒ](https://github.com/GerHobbelt/Arduino-KalmanFilter) -- a Kalman filter library, which is prepared for IMU calculations. See examples: http://www.jarzebski.pl/arduino/rozwiazania-i-algorytmy/odczyty-pitch-roll-oraz-filtr-kalmana.html
- **armadillo** [ğŸ“](./armadillo) [ğŸŒ](https://github.com/GerHobbelt/armadillo-code) -- C++ library for linear algebra & scientific computing
- **autodiff** [ğŸ“](./autodiff) [ğŸŒ](https://github.com/GerHobbelt/autodiff) -- a C++17 library that uses modern and advanced programming techniques to enable automatic computation of derivatives in an efficient, easy, and intuitive way.
- **BaseMatrixOps** [ğŸ“](./BaseMatrixOps) [ğŸŒ](https://github.com/GerHobbelt/BaseMatrixOps) -- wrappers to C++ linear algebra libraries. No guarantees made about APIs or functionality.
- **blis** [ğŸ“](./blis) [ğŸŒ](https://github.com/GerHobbelt/blis) -- BLIS is an award-winning portable software framework for instantiating high-performance BLAS-like dense linear algebra libraries. The framework was designed to isolate essential kernels of computation that, when optimized, immediately enable optimized implementations of most of its commonly used and computationally intensive operations. BLIS is written in [ISO C99](http://en.wikipedia.org/wiki/C99) and available under a [new/modified/3-clause BSD license](http://opensource.org/licenses/BSD-3-Clause). While BLIS exports a [new BLAS-like API](docs/BLISTypedAPI.md), it also includes a BLAS compatibility layer which gives application developers access to BLIS implementations via traditional [BLAS routine calls](http://www.netlib.org/lapack/lug/node145.html). An [object-based API](docs/BLISObjectAPI.md) unique to BLIS is also available.
- **clBLAS** [ğŸ“](./clBLAS) [ğŸŒ](https://github.com/GerHobbelt/clBLAS) -- the OpenCLâ„¢ BLAS portion of OpenCL's `clMath`. The complete set of BLAS level 1, 2 & 3 routines is implemented. In addition to GPU devices, the library also supports running on CPU devices to facilitate debugging and multicore programming. The primary goal of `clBLAS` is to make it easier for developers to utilize the inherent performance and power efficiency benefits of heterogeneous computing. `clBLAS` interfaces do not hide nor wrap OpenCL interfaces, but rather leaves OpenCL state management to the control of the user to allow for maximum performance and flexibility. The clBLAS library does generate and enqueue optimized OpenCL kernels, relieving the user from the task of writing, optimizing and maintaining kernel code themselves.
- **CLBlast** [ğŸ“](./CLBlast) [ğŸŒ](https://github.com/GerHobbelt/CLBlast) -- the tuned OpenCL BLAS library. CLBlast is a modern, lightweight, performant and tunable OpenCL BLAS library written in C++11. It is designed to leverage the full performance potential of a wide variety of OpenCL devices from different vendors, including desktop and laptop GPUs, embedded GPUs, and other accelerators. CLBlast implements BLAS routines: basic linear algebra subprograms operating on vectors and matrices.
- **CLBlast-database** [ğŸ“](./CLBlast-database) [ğŸŒ](https://github.com/GerHobbelt/CLBlast-database) -- the full database of tuning results for the [CLBlast OpenCL BLAS library](https://github.com/CNugteren/CLBlast). Tuning results are obtained using CLBlast and the [CLTune auto-tuner](https://github.com/CNugteren/CLTune).
- **CLTune** [ğŸ“](./CLTune) [ğŸŒ](https://github.com/GerHobbelt/CLTune) -- automatic OpenCL kernel tuning for CLBlast: CLTune is a C++ library which can be used to automatically tune your OpenCL and CUDA kernels. The only thing you'll need to provide is a tuneable kernel and a list of allowed parameters and values.
- **Cmathtuts** [ğŸ“](./Cmathtuts) [ğŸŒ](https://github.com/GerHobbelt/Cmathtuts) -- a collection of linear algebra math tutorials in C for BLAS, LAPACK and other fundamental APIs. These include samples for BLAS, LAPACK, CLAPACK, LAPACKE, ATLAS, OpenBLAS ...
- **efftw** [ğŸ“](./efftw) [ğŸŒ](https://github.com/GerHobbelt/efftw) -- Eigen-FFTW is a modern C++20 wrapper library around [FFTW](http://www.fftw.org) for [Eigen](https://eigen.tuxfamily.org/index.php?title=Main_Page).
- **ensmallen** [ğŸ“](./ensmallen) [ğŸŒ](https://github.com/GerHobbelt/ensmallen) -- a high-quality C++ library for non-linear numerical optimization. `ensmallen` provides many types of optimizers that can be used for virtually any numerical optimization task. This includes gradient descent techniques, gradient-free optimizers, and constrained optimization. Examples include L-BFGS, SGD, CMAES and Simulated Annealing.
- **fastapprox** [ğŸ“](./fastapprox) [ğŸŒ](https://github.com/GerHobbelt/fastapprox) -- approximate and vectorized versions of common mathematical functions (e.g. exponential, logarithm, and power, lgamma and digamma, cosh, sinh, tanh, cos, sin, tan, sigmoid and erf, Lambert W)
- **fastrange** [ğŸ“](./fastrange) [ğŸŒ](https://github.com/GerHobbelt/fastrange) -- a fast alternative to the modulo reduction. [It has accelerated some operations in Google's Tensorflow by 10% to 20%](https://github.com/tensorflow/tensorflow/commit/a47a300185026fe7829990def9113bf3a5109fed). Further reading : http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/ See also: Daniel Lemire, [Fast Random Integer Generation in an Interval](https://arxiv.org/abs/1805.10941), ACM Transactions on Modeling and Computer Simulation, January 2019 Article No. 3 https://doi.org/10.1145/3230636
- **ffts** [ğŸ“](./ffts) [ğŸŒ](https://github.com/GerHobbelt/ffts) -- FFTS -- The Fastest Fourier Transform in the South.
- **gcem** [ğŸ“](./gcem) [ğŸŒ](https://github.com/GerHobbelt/gcem) -- GCE-Math (**G**eneralized **C**onstant **E**xpression Math) is a templated C++ library enabling compile-time computation of mathematical functions.
- **gemmlowp** [ğŸ“](./gemmlowp) [ğŸŒ](https://github.com/GerHobbelt/gemmlowp) -- a small self-contained low-precision GEMM library. `gemmlowp` is not a full linear algebra library, only a GEMM library: it only does general matrix multiplication ("GEMM").
- **GraphBLAS** [ğŸ“](./GraphBLAS) [ğŸŒ](https://github.com/GerHobbelt/GraphBLAS) -- SuiteSparse:GraphBLAS is a complete implementation of the GraphBLAS standard, which defines a set of sparse matrix operations on an extended algebra of semirings using an almost unlimited variety of operators and types.  When applied to sparse adjacency matrices, these algebraic operations are equivalent to computations on graphs.  GraphBLAS provides a powerful and expressive framework for creating graph algorithms based on the elegant mathematics of sparse matrix operations on a semiring.
- **h5cpp** [ğŸ“](./h5cpp) [ğŸŒ](https://github.com/GerHobbelt/h5cpp) -- easy to use HDF5 C++ templates for Serial and Paralel HDF5. Hierarchical Data Format HDF5 is prevalent in high performance scientific computing, sits directly on top of sequential or parallel file systems, providing block and stream operations on standardized or custom binary/text objects. Scientific computing platforms come with the necessary libraries to read write HDF5 dataset. H5CPP simplifies interactions with popular linear algebra libraries, provides compiler assisted seamless object persistence, Standard Template Library support and comes equipped with a novel error handling architecture.
- **Imath** [ğŸ“](./Imath) [ğŸŒ](https://github.com/GerHobbelt/Imath) -- a basic, light-weight, and efficient C++ representation of 2D and 3D vectors and matrices and other simple but useful mathematical objects, functions, and data types common in computer graphics applications, including the â€œhalfâ€ 16-bit floating-point type.
- **itpp** [ğŸ“](./itpp) [ğŸŒ](https://github.com/GerHobbelt/itpp) -- IT++ is a C++ library of mathematical, signal processing and communication classes and functions. Its main use is in simulation of communication systems and for performing research in the area of communications. The kernel of the library consists of generic vector and matrix classes, and a set of accompanying routines. Such a kernel makes IT++ similar to MATLAB or GNU Octave. The IT++ library originates from the former department of Information Theory at the Chalmers University of Technology, Gothenburg, Sweden.
- **kalman-cpp** [ğŸ“](./kalman-cpp) [ğŸŒ](https://github.com/GerHobbelt/kalman-cpp) -- Kalman filter and extended Kalman filter implementation in C++. Implements Kalman, Extended Kalman, Second-order extended Kalman and Unscented Kalman filters.
- **kissfft** [ğŸ“](./kissfft) [ğŸŒ](https://github.com/GerHobbelt/kissfft) -- KISS FFT - a mixed-radix Fast Fourier Transform based up on the principle, "Keep It Simple, Stupid."
- **lapack** [ğŸ“](./lapack) [ğŸŒ](https://github.com/GerHobbelt/lapack) -- [CBLAS](http://www.netlib.org/blas/) + [LAPACK](http://www.netlib.org/lapack/index.html) optimized linear algebra libs
- **libalg** [ğŸ“](./libalg) [ğŸŒ](https://github.com/GerHobbelt/alglib) -- the mathematical *ALGLIB* library for C++.
- **libbf** [ğŸ“](./libbf) [ğŸŒ](https://github.com/GerHobbelt/libbf) -- a small library to handle arbitrary precision binary or decimal floating point numbers
- **libcnl** [ğŸ“](./libcnl) [ğŸŒ](https://github.com/GerHobbelt/cnl) -- The Compositional Numeric Library (CNL) is a C++ library of fixed-precision numeric classes which enhance integers to deliver safer, simpler, cheaper arithmetic types. CNL is particularly well-suited to: (1) compute on energy-constrained environments where FPUs are absent or costly; (2) compute on energy-intensive environments where arithmetic is the bottleneck such as simulations, machine learning applications and DSPs; and (3) domains such as finance where precision is essential.
- **libeigen** [ğŸ“](./libeigen) [ğŸŒ](https://github.com/GerHobbelt/eigen-git-mirror) -- a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.
- **math-atlas** [ğŸ“](./math-atlas) [ğŸŒ](https://github.com/GerHobbelt/math-atlas) -- The ATLAS (Automatically Tuned Linear Algebra Software) project is an ongoing research effort focusing on applying empirical techniques in order to provide portable performance, delivering an efficient BLAS implementation, as well as a few routines from LAPACK.
- **mipp** [ğŸ“](./mipp) [ğŸŒ](https://github.com/GerHobbelt/MIPP) -- MyIntrinsics++ (MIPP): a portable wrapper for vector intrinsic functions (SIMD) written in C++11. It works for SSE, AVX, AVX-512 and ARM NEON (32-bit and 64-bit) instructions. MIPP wrapper supports simple/double precision floating-point numbers and also signed integer arithmetic (64-bit, 32-bit, 16-bit and 8-bit). With the MIPP wrapper you do not need to write a specific intrinsic code anymore. Just use provided functions and the wrapper will automatically generate the right intrisic calls for your specific architecture.
- **mlpack** [ğŸ“](./mlpack) [ğŸŒ](https://github.com/GerHobbelt/mlpack) -- an intuitive, fast, and flexible C++ machine learning library, meant to be a machine learning analog to LAPACK, aiming to implement a wide array of machine learning methods and functions as a "swiss army knife" for machine learning researchers.
- **nfft** [ğŸ“](./nfft) [ğŸŒ](https://github.com/GerHobbelt/nfft) -- Nonequispaced FFT (NFFT) is a software library, written in C, for computing non-equispaced fast Fourier transforms and related variations.
- **OpenBLAS** [ğŸ“](./OpenBLAS) [ğŸŒ](https://github.com/GerHobbelt/OpenBLAS) -- an optimized BLAS (Basic Linear Algebra Subprograms) library based on GotoBLAS2 1.13 BSD version.
- **OpenCL-CLHPP** [ğŸ“](./OpenCL-CLHPP) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-CLHPP) -- Khronos OpenCL C++ Bindings: the interface is contained with a single C++ header file `opencl.hpp` and all definitions are contained within the namespace `cl`. There is no additional requirement to include `cl.h` and to use either the C++ or original C bindings; it is enough to simply include `opencl.hpp`. The bindings themselves are lightweight and correspond closely to the underlying C API. Using the C++ bindings introduces no additional execution overhead.
- **OpenCL-CTS** [ğŸ“](./OpenCL-CTS) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-CTS) -- the OpenCL Conformance Test Suite (CTS) for all versions of the Khronos [OpenCL](https://www.khronos.org/opencl/) standard.
- **OpenCL-Guide** [ğŸ“](./OpenCL-Guide) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-Guide) -- OpenCL Guide: written to help developers get up and running quickly with the KhronosÂ® Group's OpenCLâ„¢ programming framework. It is an introductory read that covers the background and key concepts of OpenCL, but also contains links to more detailed materials that developers can use to explore the capabilities of OpenCL that interest them most.
- **OpenCL-Headers** [ğŸ“](./OpenCL-Headers) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-Headers) -- C language headers for the OpenCL API.
- **OpenCL-SDK** [ğŸ“](./OpenCL-SDK) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-SDK) -- the Khronos OpenCL SDK. It brings together all the components needed to develop OpenCL applications.
- **OpenCL-Wrapper** [ğŸ“](./OpenCL-Wrapper) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-Wrapper) -- OpenCL is the most powerful programming language ever created, yet the OpenCL C++ bindings are cumbersome and the code overhead prevents many people from getting started. Lightweight C++17 OpenCL-Wrapper greatly simplifies OpenCL software development with C++ while keeping functionality and performance.
- **optim** [ğŸ“](./optim) [ğŸŒ](https://github.com/GerHobbelt/optim) -- OptimLib is a lightweight C++ library of numerical optimization methods for nonlinear functions. Features a C++11/14/17 library of local and global optimization algorithms, as well as root finding techniques, derivative-free optimization using advanced, parallelized metaheuristic methods and constrained optimization routines to handle simple box constraints, as well as systems of nonlinear constraints.
- **poisson-disc-distribution-bridson** [ğŸ“](./poisson-disc-distribution-bridson) [ğŸŒ](https://github.com/GerHobbelt/poisson-disc-distribution-bridson) -- a Poisson disc distribution produces randomised points that are close together but not closer than a lower bound. It is a form of [blue noise](https://en.wikipedia.org/wiki/Blue_noise#Blue_noise) that emulates the arrangement of the eye's retina cells and works well for sampling. The result is more aesthetically pleasing than uniform or jittered-grid approaches.
- **QuantLib** [ğŸ“](./QuantLib) [ğŸŒ](https://github.com/GerHobbelt/QuantLib) -- the free/open-source library for quantitative finance, providing a comprehensive software framework for quantitative finance. QuantLib is a free/open-source library for modeling, trading, and risk management in real-life.
- **sdsl-lite** [ğŸ“](./sdsl-lite) [ğŸŒ](https://github.com/GerHobbelt/sdsl-lite) -- The Succinct Data Structure Library (SDSL) is a powerful and flexible C++11 library implementing succinct data structures. In total, the library contains the highlights of 40 [research publications][SDSLLIT]. Succinct data structures can represent an object (such as a bitvector or a tree) in space close to the information-theoretic lower bound of the object while supporting operations of the original object efficiently. The theoretical time complexity of an operation performed on the classical data structure and the equivalent succinct data structure are (most of the time) identical.
- **stan-math** [ğŸ“](./stan-math) [ğŸŒ](https://github.com/GerHobbelt/stan-math) -- the Stan Math Library is a C++, reverse-mode automatic differentiation library designed to be usable, extensive and extensible, efficient, scalable, stable, portable, and redistributable in order to facilitate the construction and utilization of algorithms that utilize derivatives.
- **stats** [ğŸ“](./stats) [ğŸŒ](https://github.com/GerHobbelt/stats) -- StatsLib is a templated C++ library of statistical distribution functions, featuring unique compile-time computing capabilities and seamless integration with several popular linear algebra libraries. Features a header-only library of probability density functions, cumulative distribution functions, quantile functions, and random sampling methods. Functions are written in C++11 `constexpr` format, enabling the library to operate as both a compile-time and run-time computation engine. Provides functions to compute the cdf, pdf, quantile, as well as random sampling methods, are available for the following distributions: Bernoulli, Beta, Binomial, Cauchy, Chi-squared, Exponential, F, Gamma, Inverse-Gamma, Inverse-Gaussian, Laplace, Logistic, Log-Normal, Normal (Gaussian), Poisson, Rademacher, Student's t, Uniform and Weibull. In addition, pdf and random sampling functions are available for several multivariate distributions: inverse-Wishart, Multivariate Normal and Wishart.
- **SuiteSparse** [ğŸ“](./SuiteSparse) [ğŸŒ](https://github.com/GerHobbelt/SuiteSparse) -- a set of sparse-matrix-related packages written or co-authored by Tim Davis, available at https://github.com/DrTimothyAldenDavis/SuiteSparse . Packages:
  
  * `AMD` - approximate minimum degree ordering.  This is the built-in AMD function in MATLAB.
  * `BTF` - permutation to block triangular form
  * `CAMD` - constrained approximate minimum degree ordering
  * `CCOLAMD` - constrained column approximate minimum degree ordering
  * `CHOLMOD` - sparse Cholesky factorization.  Requires AMD, COLAMD, CCOLAMD, the BLAS, and LAPACK.  Optionally uses METIS.  This is `chol` and `x=A\b` in MATLAB.
  * `COLAMD` - column approximate minimum degree ordering.  This is the built-in COLAMD function in MATLAB.
  * `CSparse` - a concise sparse matrix package, developed for my book, "Direct Methods for Sparse Linear Systems", published by SIAM.  Intended primarily for teaching. For production, use `CXSparse` instead.
  * `CXSparse` - CSparse Extended.  Includes support for complex matrices and both int or long integers.  Use this instead of CSparse for production use; it creates a libcsparse.so (or dylib on the Mac) with the same name as CSparse.  It is a superset of CSparse.
  * `GraphBLAS` - graph algorithms in the language of linear algebra. https://graphblas.org
  * `KLU` - sparse LU factorization, primarily for circuit simulation.  Requires AMD, COLAMD, and BTF.  Optionally uses CHOLMOD, CAMD, CCOLAMD, and METIS.
  * `LAGraph` - a graph algorithms library based on GraphBLAS.  See also https://github.com/GraphBLAS/LAGraph
  * `LDL` - a very concise LDL' factorization package

- **tindicators** [ğŸ“](./tindicators) [ğŸŒ](https://github.com/GerHobbelt/tindicators) -- a library of technical analysis indicators. It provides over 160 indicators and is blazing fast.
- **tinyexpr** [ğŸ“](./tinyexpr) [ğŸŒ](https://github.com/GerHobbelt/tinyexpr) -- a very small recursive descent parser and evaluation engine for math expressions.
- **UDDSketch** [ğŸ“](./UDDSketch) [ğŸŒ](https://github.com/GerHobbelt/UDDSketch) -- Uniform DDSketch is a C implementation of the DDSketch algorithm (a fast and fully-mergeable quantile sketch with relative-error guarantees) for quantile estimation of very large data sets & data streams with the following additions: (1) uniform collapsing strategy, and (2) additional sketch implementation for dealing with negative values.
- **universal-numbers** [ğŸ“](./universal-numbers) [ğŸŒ](https://github.com/GerHobbelt/universal) -- a header-only C++ template library for universal number arithmetic. The goal of the Universal Numbers Library is to offer applications alternatives to IEEE floating-point that are more efficient and mathematically robust. The Universal library is a ready-to-use header-only library that provides plug-in replacement for native types, and provides a low-friction environment to start exploring alternatives to IEEE floating-point in your own algorithms.
- **xsimd** [ğŸ“](./xsimd) [ğŸŒ](https://github.com/GerHobbelt/xsimd) -- SIMD (Single Instruction, Multiple Data) instructions differ between microprocessor vendors and compilers. `xsimd` provides a unified means for using these features for library authors. It enables manipulation of batches of numbers with the same arithmetic operators as for single values. It also provides accelerated implementation of common mathematical functions operating on batches.















	
----

ğŸ¡¸ [prev](./0022-pattern.md)  |  ğŸ¡¹ [up](./0022-pattern.md)  |  ğŸ¡º [next](./0024-delta-features-other-feature.md)
