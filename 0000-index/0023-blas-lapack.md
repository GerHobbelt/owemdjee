

### BLAS, LAPACK, ...

- **amd-fftw** [📁](./amd-fftw) [🌐](https://github.com/GerHobbelt/amd-fftw) -- AOCL-FFTW is AMD optimized version of FFTW implementation targeted for AMD EPYC CPUs. It is developed on top of FFTW (version fftw-3.3.10). AOCL-FFTW achieves high performance as a result of its various optimizations involving improved SIMD Kernel functions, improved copy functions (cpy2d and cpy2d_pair used in rank-0 transform and buffering plan), improved 256-bit kernels selection by Planner and an optional in-place transpose for large problem sizes. AOCL-FFTW improves the performance of in-place MPI FFTs by employing a faster in-place MPI transpose function.
- **Arduino-KalmanFilter** [📁](./Arduino-KalmanFilter) [🌐](https://github.com/GerHobbelt/Arduino-KalmanFilter) -- a Kalman filter library, which is prepared for IMU calculations. See examples: http://www.jarzebski.pl/arduino/rozwiazania-i-algorytmy/odczyty-pitch-roll-oraz-filtr-kalmana.html
- **armadillo** [📁](./armadillo) [🌐](https://github.com/GerHobbelt/armadillo-code) -- C++ library for linear algebra & scientific computing
- **autodiff** [📁](./autodiff) [🌐](https://github.com/GerHobbelt/autodiff) -- a C++17 library that uses modern and advanced programming techniques to enable automatic computation of derivatives in an efficient, easy, and intuitive way.
- **BaseMatrixOps** [📁](./BaseMatrixOps) [🌐](https://github.com/GerHobbelt/BaseMatrixOps) -- wrappers to C++ linear algebra libraries. No guarantees made about APIs or functionality.
- **blis** [📁](./blis) [🌐](https://github.com/GerHobbelt/blis) -- BLIS is an award-winning portable software framework for instantiating high-performance BLAS-like dense linear algebra libraries. The framework was designed to isolate essential kernels of computation that, when optimized, immediately enable optimized implementations of most of its commonly used and computationally intensive operations. BLIS is written in [ISO C99](http://en.wikipedia.org/wiki/C99) and available under a [new/modified/3-clause BSD license](http://opensource.org/licenses/BSD-3-Clause). While BLIS exports a [new BLAS-like API](docs/BLISTypedAPI.md), it also includes a BLAS compatibility layer which gives application developers access to BLIS implementations via traditional [BLAS routine calls](http://www.netlib.org/lapack/lug/node145.html). An [object-based API](docs/BLISObjectAPI.md) unique to BLIS is also available.
- **clBLAS** [📁](./clBLAS) [🌐](https://github.com/GerHobbelt/clBLAS) -- the OpenCL™ BLAS portion of OpenCL's `clMath`. The complete set of BLAS level 1, 2 & 3 routines is implemented. In addition to GPU devices, the library also supports running on CPU devices to facilitate debugging and multicore programming. The primary goal of `clBLAS` is to make it easier for developers to utilize the inherent performance and power efficiency benefits of heterogeneous computing. `clBLAS` interfaces do not hide nor wrap OpenCL interfaces, but rather leaves OpenCL state management to the control of the user to allow for maximum performance and flexibility. The clBLAS library does generate and enqueue optimized OpenCL kernels, relieving the user from the task of writing, optimizing and maintaining kernel code themselves.
- **CLBlast** [📁](./CLBlast) [🌐](https://github.com/GerHobbelt/CLBlast) -- the tuned OpenCL BLAS library. CLBlast is a modern, lightweight, performant and tunable OpenCL BLAS library written in C++11. It is designed to leverage the full performance potential of a wide variety of OpenCL devices from different vendors, including desktop and laptop GPUs, embedded GPUs, and other accelerators. CLBlast implements BLAS routines: basic linear algebra subprograms operating on vectors and matrices.
- **CLBlast-database** [📁](./CLBlast-database) [🌐](https://github.com/GerHobbelt/CLBlast-database) -- the full database of tuning results for the [CLBlast OpenCL BLAS library](https://github.com/CNugteren/CLBlast). Tuning results are obtained using CLBlast and the [CLTune auto-tuner](https://github.com/CNugteren/CLTune).
- **CLTune** [📁](./CLTune) [🌐](https://github.com/GerHobbelt/CLTune) -- automatic OpenCL kernel tuning for CLBlast: CLTune is a C++ library which can be used to automatically tune your OpenCL and CUDA kernels. The only thing you'll need to provide is a tuneable kernel and a list of allowed parameters and values.
- **Cmathtuts** [📁](./Cmathtuts) [🌐](https://github.com/GerHobbelt/Cmathtuts) -- a collection of linear algebra math tutorials in C for BLAS, LAPACK and other fundamental APIs. These include samples for BLAS, LAPACK, CLAPACK, LAPACKE, ATLAS, OpenBLAS ...
- **efftw** [📁](./efftw) [🌐](https://github.com/GerHobbelt/efftw) -- Eigen-FFTW is a modern C++20 wrapper library around [FFTW](http://www.fftw.org) for [Eigen](https://eigen.tuxfamily.org/index.php?title=Main_Page).
- **ensmallen** [📁](./ensmallen) [🌐](https://github.com/GerHobbelt/ensmallen) -- a high-quality C++ library for non-linear numerical optimization. `ensmallen` provides many types of optimizers that can be used for virtually any numerical optimization task. This includes gradient descent techniques, gradient-free optimizers, and constrained optimization. Examples include L-BFGS, SGD, CMAES and Simulated Annealing.
- **fastapprox** [📁](./fastapprox) [🌐](https://github.com/GerHobbelt/fastapprox) -- approximate and vectorized versions of common mathematical functions (e.g. exponential, logarithm, and power, lgamma and digamma, cosh, sinh, tanh, cos, sin, tan, sigmoid and erf, Lambert W)
- **fastrange** [📁](./fastrange) [🌐](https://github.com/GerHobbelt/fastrange) -- a fast alternative to the modulo reduction. [It has accelerated some operations in Google's Tensorflow by 10% to 20%](https://github.com/tensorflow/tensorflow/commit/a47a300185026fe7829990def9113bf3a5109fed). Further reading : http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/ See also: Daniel Lemire, [Fast Random Integer Generation in an Interval](https://arxiv.org/abs/1805.10941), ACM Transactions on Modeling and Computer Simulation, January 2019 Article No. 3 https://doi.org/10.1145/3230636
- **ffts** [📁](./ffts) [🌐](https://github.com/GerHobbelt/ffts) -- FFTS -- The Fastest Fourier Transform in the South.
- **gcem** [📁](./gcem) [🌐](https://github.com/GerHobbelt/gcem) -- GCE-Math (**G**eneralized **C**onstant **E**xpression Math) is a templated C++ library enabling compile-time computation of mathematical functions.
- **gemmlowp** [📁](./gemmlowp) [🌐](https://github.com/GerHobbelt/gemmlowp) -- a small self-contained low-precision GEMM library. `gemmlowp` is not a full linear algebra library, only a GEMM library: it only does general matrix multiplication ("GEMM").
- **GraphBLAS** [📁](./GraphBLAS) [🌐](https://github.com/GerHobbelt/GraphBLAS) -- SuiteSparse:GraphBLAS is a complete implementation of the GraphBLAS standard, which defines a set of sparse matrix operations on an extended algebra of semirings using an almost unlimited variety of operators and types.  When applied to sparse adjacency matrices, these algebraic operations are equivalent to computations on graphs.  GraphBLAS provides a powerful and expressive framework for creating graph algorithms based on the elegant mathematics of sparse matrix operations on a semiring.
- **h5cpp** [📁](./h5cpp) [🌐](https://github.com/GerHobbelt/h5cpp) -- easy to use HDF5 C++ templates for Serial and Paralel HDF5. Hierarchical Data Format HDF5 is prevalent in high performance scientific computing, sits directly on top of sequential or parallel file systems, providing block and stream operations on standardized or custom binary/text objects. Scientific computing platforms come with the necessary libraries to read write HDF5 dataset. H5CPP simplifies interactions with popular linear algebra libraries, provides compiler assisted seamless object persistence, Standard Template Library support and comes equipped with a novel error handling architecture.
- **Imath** [📁](./Imath) [🌐](https://github.com/GerHobbelt/Imath) -- a basic, light-weight, and efficient C++ representation of 2D and 3D vectors and matrices and other simple but useful mathematical objects, functions, and data types common in computer graphics applications, including the “half” 16-bit floating-point type.
- **itpp** [📁](./itpp) [🌐](https://github.com/GerHobbelt/itpp) -- IT++ is a C++ library of mathematical, signal processing and communication classes and functions. Its main use is in simulation of communication systems and for performing research in the area of communications. The kernel of the library consists of generic vector and matrix classes, and a set of accompanying routines. Such a kernel makes IT++ similar to MATLAB or GNU Octave. The IT++ library originates from the former department of Information Theory at the Chalmers University of Technology, Gothenburg, Sweden.
- **kalman-cpp** [📁](./kalman-cpp) [🌐](https://github.com/GerHobbelt/kalman-cpp) -- Kalman filter and extended Kalman filter implementation in C++. Implements Kalman, Extended Kalman, Second-order extended Kalman and Unscented Kalman filters.
- **kissfft** [📁](./kissfft) [🌐](https://github.com/GerHobbelt/kissfft) -- KISS FFT - a mixed-radix Fast Fourier Transform based up on the principle, "Keep It Simple, Stupid."
- **lapack** [📁](./lapack) [🌐](https://github.com/GerHobbelt/lapack) -- [CBLAS](http://www.netlib.org/blas/) + [LAPACK](http://www.netlib.org/lapack/index.html) optimized linear algebra libs
- **libalg** [📁](./libalg) [🌐](https://github.com/GerHobbelt/alglib) -- the mathematical *ALGLIB* library for C++.
- **libbf** [📁](./libbf) [🌐](https://github.com/GerHobbelt/libbf) -- a small library to handle arbitrary precision binary or decimal floating point numbers
- **libcnl** [📁](./libcnl) [🌐](https://github.com/GerHobbelt/cnl) -- The Compositional Numeric Library (CNL) is a C++ library of fixed-precision numeric classes which enhance integers to deliver safer, simpler, cheaper arithmetic types. CNL is particularly well-suited to: (1) compute on energy-constrained environments where FPUs are absent or costly; (2) compute on energy-intensive environments where arithmetic is the bottleneck such as simulations, machine learning applications and DSPs; and (3) domains such as finance where precision is essential.
- **libeigen** [📁](./libeigen) [🌐](https://github.com/GerHobbelt/eigen-git-mirror) -- a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.
- **math-atlas** [📁](./math-atlas) [🌐](https://github.com/GerHobbelt/math-atlas) -- The ATLAS (Automatically Tuned Linear Algebra Software) project is an ongoing research effort focusing on applying empirical techniques in order to provide portable performance, delivering an efficient BLAS implementation, as well as a few routines from LAPACK.
- **mipp** [📁](./mipp) [🌐](https://github.com/GerHobbelt/MIPP) -- MyIntrinsics++ (MIPP): a portable wrapper for vector intrinsic functions (SIMD) written in C++11. It works for SSE, AVX, AVX-512 and ARM NEON (32-bit and 64-bit) instructions. MIPP wrapper supports simple/double precision floating-point numbers and also signed integer arithmetic (64-bit, 32-bit, 16-bit and 8-bit). With the MIPP wrapper you do not need to write a specific intrinsic code anymore. Just use provided functions and the wrapper will automatically generate the right intrisic calls for your specific architecture.
- **mlpack** [📁](./mlpack) [🌐](https://github.com/GerHobbelt/mlpack) -- an intuitive, fast, and flexible C++ machine learning library, meant to be a machine learning analog to LAPACK, aiming to implement a wide array of machine learning methods and functions as a "swiss army knife" for machine learning researchers.
- **nfft** [📁](./nfft) [🌐](https://github.com/GerHobbelt/nfft) -- Nonequispaced FFT (NFFT) is a software library, written in C, for computing non-equispaced fast Fourier transforms and related variations.
- **OpenBLAS** [📁](./OpenBLAS) [🌐](https://github.com/GerHobbelt/OpenBLAS) -- an optimized BLAS (Basic Linear Algebra Subprograms) library based on GotoBLAS2 1.13 BSD version.
- **OpenCL-CLHPP** [📁](./OpenCL-CLHPP) [🌐](https://github.com/GerHobbelt/OpenCL-CLHPP) -- Khronos OpenCL C++ Bindings: the interface is contained with a single C++ header file `opencl.hpp` and all definitions are contained within the namespace `cl`. There is no additional requirement to include `cl.h` and to use either the C++ or original C bindings; it is enough to simply include `opencl.hpp`. The bindings themselves are lightweight and correspond closely to the underlying C API. Using the C++ bindings introduces no additional execution overhead.
- **OpenCL-CTS** [📁](./OpenCL-CTS) [🌐](https://github.com/GerHobbelt/OpenCL-CTS) -- the OpenCL Conformance Test Suite (CTS) for all versions of the Khronos [OpenCL](https://www.khronos.org/opencl/) standard.
- **OpenCL-Guide** [📁](./OpenCL-Guide) [🌐](https://github.com/GerHobbelt/OpenCL-Guide) -- OpenCL Guide: written to help developers get up and running quickly with the Khronos® Group's OpenCL™ programming framework. It is an introductory read that covers the background and key concepts of OpenCL, but also contains links to more detailed materials that developers can use to explore the capabilities of OpenCL that interest them most.
- **OpenCL-Headers** [📁](./OpenCL-Headers) [🌐](https://github.com/GerHobbelt/OpenCL-Headers) -- C language headers for the OpenCL API.
- **OpenCL-SDK** [📁](./OpenCL-SDK) [🌐](https://github.com/GerHobbelt/OpenCL-SDK) -- the Khronos OpenCL SDK. It brings together all the components needed to develop OpenCL applications.
- **OpenCL-Wrapper** [📁](./OpenCL-Wrapper) [🌐](https://github.com/GerHobbelt/OpenCL-Wrapper) -- OpenCL is the most powerful programming language ever created, yet the OpenCL C++ bindings are cumbersome and the code overhead prevents many people from getting started. Lightweight C++17 OpenCL-Wrapper greatly simplifies OpenCL software development with C++ while keeping functionality and performance.
- **optim** [📁](./optim) [🌐](https://github.com/GerHobbelt/optim) -- OptimLib is a lightweight C++ library of numerical optimization methods for nonlinear functions. Features a C++11/14/17 library of local and global optimization algorithms, as well as root finding techniques, derivative-free optimization using advanced, parallelized metaheuristic methods and constrained optimization routines to handle simple box constraints, as well as systems of nonlinear constraints.
- **poisson-disc-distribution-bridson** [📁](./poisson-disc-distribution-bridson) [🌐](https://github.com/GerHobbelt/poisson-disc-distribution-bridson) -- a Poisson disc distribution produces randomised points that are close together but not closer than a lower bound. It is a form of [blue noise](https://en.wikipedia.org/wiki/Blue_noise#Blue_noise) that emulates the arrangement of the eye's retina cells and works well for sampling. The result is more aesthetically pleasing than uniform or jittered-grid approaches.
- **QuantLib** [📁](./QuantLib) [🌐](https://github.com/GerHobbelt/QuantLib) -- the free/open-source library for quantitative finance, providing a comprehensive software framework for quantitative finance. QuantLib is a free/open-source library for modeling, trading, and risk management in real-life.
- **sdsl-lite** [📁](./sdsl-lite) [🌐](https://github.com/GerHobbelt/sdsl-lite) -- The Succinct Data Structure Library (SDSL) is a powerful and flexible C++11 library implementing succinct data structures. In total, the library contains the highlights of 40 [research publications][SDSLLIT]. Succinct data structures can represent an object (such as a bitvector or a tree) in space close to the information-theoretic lower bound of the object while supporting operations of the original object efficiently. The theoretical time complexity of an operation performed on the classical data structure and the equivalent succinct data structure are (most of the time) identical.
- **stan-math** [📁](./stan-math) [🌐](https://github.com/GerHobbelt/stan-math) -- the Stan Math Library is a C++, reverse-mode automatic differentiation library designed to be usable, extensive and extensible, efficient, scalable, stable, portable, and redistributable in order to facilitate the construction and utilization of algorithms that utilize derivatives.
- **stats** [📁](./stats) [🌐](https://github.com/GerHobbelt/stats) -- StatsLib is a templated C++ library of statistical distribution functions, featuring unique compile-time computing capabilities and seamless integration with several popular linear algebra libraries. Features a header-only library of probability density functions, cumulative distribution functions, quantile functions, and random sampling methods. Functions are written in C++11 `constexpr` format, enabling the library to operate as both a compile-time and run-time computation engine. Provides functions to compute the cdf, pdf, quantile, as well as random sampling methods, are available for the following distributions: Bernoulli, Beta, Binomial, Cauchy, Chi-squared, Exponential, F, Gamma, Inverse-Gamma, Inverse-Gaussian, Laplace, Logistic, Log-Normal, Normal (Gaussian), Poisson, Rademacher, Student's t, Uniform and Weibull. In addition, pdf and random sampling functions are available for several multivariate distributions: inverse-Wishart, Multivariate Normal and Wishart.
- **SuiteSparse** [📁](./SuiteSparse) [🌐](https://github.com/GerHobbelt/SuiteSparse) -- a set of sparse-matrix-related packages written or co-authored by Tim Davis, available at https://github.com/DrTimothyAldenDavis/SuiteSparse . Packages:
  
  * `AMD` - approximate minimum degree ordering.  This is the built-in AMD function in MATLAB.
  * `BTF` - permutation to block triangular form
  * `CAMD` - constrained approximate minimum degree ordering
  * `CCOLAMD` - constrained column approximate minimum degree ordering
  * `CHOLMOD` - sparse Cholesky factorization.  Requires AMD, COLAMD, CCOLAMD, the BLAS, and LAPACK.  Optionally uses METIS.  This is `chol` and `x=A\b` in MATLAB.
  * `COLAMD` - column approximate minimum degree ordering.  This is the built-in COLAMD function in MATLAB.
  * `CSparse` - a concise sparse matrix package, developed for my book, "Direct Methods for Sparse Linear Systems", published by SIAM.  Intended primarily for teaching. For production, use `CXSparse` instead.
  * `CXSparse` - CSparse Extended.  Includes support for complex matrices and both int or long integers.  Use this instead of CSparse for production use; it creates a libcsparse.so (or dylib on the Mac) with the same name as CSparse.  It is a superset of CSparse.
  * `GraphBLAS` - graph algorithms in the language of linear algebra. https://graphblas.org
  * `KLU` - sparse LU factorization, primarily for circuit simulation.  Requires AMD, COLAMD, and BTF.  Optionally uses CHOLMOD, CAMD, CCOLAMD, and METIS.
  * `LAGraph` - a graph algorithms library based on GraphBLAS.  See also https://github.com/GraphBLAS/LAGraph
  * `LDL` - a very concise LDL' factorization package

- **tindicators** [📁](./tindicators) [🌐](https://github.com/GerHobbelt/tindicators) -- a library of technical analysis indicators. It provides over 160 indicators and is blazing fast.
- **tinyexpr** [📁](./tinyexpr) [🌐](https://github.com/GerHobbelt/tinyexpr) -- a very small recursive descent parser and evaluation engine for math expressions.
- **UDDSketch** [📁](./UDDSketch) [🌐](https://github.com/GerHobbelt/UDDSketch) -- Uniform DDSketch is a C implementation of the DDSketch algorithm (a fast and fully-mergeable quantile sketch with relative-error guarantees) for quantile estimation of very large data sets & data streams with the following additions: (1) uniform collapsing strategy, and (2) additional sketch implementation for dealing with negative values.
- **universal-numbers** [📁](./universal-numbers) [🌐](https://github.com/GerHobbelt/universal) -- a header-only C++ template library for universal number arithmetic. The goal of the Universal Numbers Library is to offer applications alternatives to IEEE floating-point that are more efficient and mathematically robust. The Universal library is a ready-to-use header-only library that provides plug-in replacement for native types, and provides a low-friction environment to start exploring alternatives to IEEE floating-point in your own algorithms.
- **xsimd** [📁](./xsimd) [🌐](https://github.com/GerHobbelt/xsimd) -- SIMD (Single Instruction, Multiple Data) instructions differ between microprocessor vendors and compilers. `xsimd` provides a unified means for using these features for library authors. It enables manipulation of batches of numbers with the same arithmetic operators as for single values. It also provides accelerated implementation of common mathematical functions operating on batches.















	
----

🡸 [prev](./0022-pattern.md)  |  🡹 [up](./0022-pattern.md)  |  🡺 [next](./0024-delta-features-other-feature.md)
