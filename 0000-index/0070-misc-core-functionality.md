









### Misc. core functionality

- **adaptive-radix-tree** [📁](./adaptive-radix-tree) [🌐](https://github.com/GerHobbelt/adaptive-radix-tree) -- implements the Adaptive Radix Tree (ART), as proposed by Leis et al. ART, which is a trie based data structure, achieves its performance, and space efficiency, by compressing the tree both vertically, i.e., if a node has no siblings it is merged with its parent, and horizontally, i.e., uses an array which grows as the number of children increases. Vertical compression reduces the tree height and horizontal compression decreases a node’s size.
- **Allocator** [📁](./Allocator) [🌐](https://github.com/GerHobbelt/Allocator) -- fast C++11 allocator for STL containers.
- **asio** [📁](./asio) [🌐](https://github.com/GerHobbelt/asio) -- a cross-platform C++ library for network and low-level I/O programming that provides developers with a consistent asynchronous model using a modern C++ approach.
  
  Note: (older) Boost.Asio is also included in Boost.

- **backward-cpp** [📁](./backward-cpp) [🌐](https://github.com/GerHobbelt/backward-cpp) -- a beautiful stack trace pretty printer for C++. Backward supports pretty printed stack traces on GNU/Linux, macOS and Windows.
- **binary_search** [📁](./binary_search) [🌐](https://github.com/GerHobbelt/binary_search) -- includes both the most commonly used binary search variant, as first published by Hermann Bottenbruch in 1962, plus several novel variants with improved performance. The most notable variant, the monobound binary search, executes two to four times faster than the standard binary search on arrays smaller than 1 million 32 bit integers: Boundless Binary Search, Doubletapped Binary Search, Monobound Binary Search, Tripletapped Binary Search, Quaternary Binary Search, Monobound Interpolated Binary Search, Adaptive Binary Search.
- **blitsort** [📁](./blitsort) [🌐](https://github.com/GerHobbelt/blitsort) -- Blitsort is an in-place rotate quick/merge sort based on the stable out-of-place merge sort [quadsort](https://github.com/scandum/quadsort), stable out-of-place quicksort [fluxsort](https://github.com/scandum/fluxsort), and unstable in-place [crumsort](https://github.com/scandum/crumsort).
- **bplustree** [📁](./bplustree) [🌐](https://github.com/GerHobbelt/bplustree) -- a minimal B+Tree implementation for millions (even billions) of key-value storage based on POSIX.
- **capture-thread** [📁](./capture-thread) [🌐](https://github.com/GerHobbelt/capture-thread) -- framework for loggers, tracers, and mockers in multithreaded C++ programs. When developing C++ projects, [instrumentation][instrumentation] is frequently used to collect information from the system, inject information into the system, or both. The role of this information within the system rarely lines up with the actual structure of the project. This library is designed to handle all of these situations with minimal intrusion into your project, and without leaking details in your API. The **Capture Thread Library** is designed around the concept of thread-locality, which allows the sharing of static variables *only within the current thread*. Canonical static variables, on the other hand, are problematic due to ownership and thread-safety issues.
- **cfgpath** [📁](./cfgpath) [🌐](https://github.com/GerHobbelt/cfgpath) -- cross platform methods for obtaining paths to configuration files
- **colorm** [📁](./colorm) [🌐](https://github.com/GerHobbelt/colorm) -- ColorM is a C++11 header-only color conversion and manipulation library for [CSS colors](https://www.w3.org/TR/css-color-4/) with an API similar to [chroma.js](https://github.com/gka/chroma.js/)'s API.
- **colormap-shaders** [📁](./colormap-shaders) [🌐](https://github.com/GerHobbelt/colormap-shaders) -- a collection of shaders to draw color maps.
- **colormap-tools** [📁](./colormap-tools) [🌐](https://github.com/GerHobbelt/colormap-tools) -- read, manage & generate colors, colormaps and color gradients for various other applications (gnuplot, Photoshop, ...), in diverse output formats and color spaces (sRGB, OKLab, CMYK, ...). Also provide a C++ API for the same functionality, i.e. also serve as an in-app library providing these services.
- **color-util** [📁](./color-util) [🌐](https://github.com/GerHobbelt/color-util) -- a header-only C++11 library for handling colors, including color space converters between RGB, XYZ, Lab, etc. and color difference calculators such as CIEDE2000.
- **concat** [📁](./concat) [🌐](https://github.com/GerHobbelt/concat) -- because string concatenation deserves one-liners in C++11 too. **concat** concatenates strings using optional separators, but also works with containers, tuples, other scalar types (including `nullptr`) and any mixes thereof. You can print/concatenate **arrays**, **containers**, **tuples**, **pairs** or other **stringstreams** in a uniform and concise manner.
- **Containers** [📁](./Containers) [🌐](https://github.com/GerHobbelt/Containers) -- a library of associative array data structures implemented as binary trees in C: `bstree`: a binary search tree; `dstree`: a digital search tree, `trie`: a Fredkin tree, `critbit`: a crit-bit tree and `patricia`: a PATRICIA trie.
- **convert_floating_point_to_fraction** [📁](./convert_floating_point_to_fraction) [🌐](https://github.com/GerHobbelt/convert_floating_point_to_fraction) -- convert any floating point value to a classic rational a.k.a. fraction a.k.a. ratio with integer numerator and denominator.
- **coost** [📁](./coost) [🌐](https://github.com/GerHobbelt/coost) -- A tiny boost library in C++11. `coost` (formerly known as `cocoyaxi`) is an elegant and efficient cross-platform C++ base library, it is not as heavy as `boost`, but still provides enough powerful features.
- **cppdap** [📁](./cppdap) [🌐](https://github.com/GerHobbelt/cppdap) -- a C++11 library (["SDK"](https://microsoft.github.io/debug-adapter-protocol/implementors/sdks/)) implementation of the [Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/), providing an API for implementing a DAP client or server. `cppdap` provides C++ type-safe structures for the full [DAP specification](https://microsoft.github.io/debug-adapter-protocol/specification), and provides a simple way to add custom protocol messages.
- **cpplocate** [📁](./cpplocate) [🌐](https://github.com/GerHobbelt/cpplocate) -- a cross-platform C++ library that provides tools for applications to locate their binary files and data assets, as well as those of dependent modules.
- **cpp-terminal** [📁](./cpp-terminal) [🌐](https://github.com/GerHobbelt/cpp-terminal) -- CPP-Terminal is a small C++ library for writing platform independent terminal-based applications. It follows the "Zero-overhead principle" and limits externally included files to the C++ STL. Being crossplatform we support Windows, Linux and MacOS and provide a unified API across all platforms. Our main features are consisting of Colors, Keyboard input, terminal resize handling, as well as other common terminal functionality. It's also possible to open a managed terminal from a windows GUI application.
- **cpptrace** [📁](./cpptrace) [🌐](https://github.com/GerHobbelt/cpptrace) -- a simple and portable C++ stacktrace library supporting C++11 and greater on Linux, macOS, and Windows including MinGW and Cygwin environments. The goal: Make stack traces simple for once.
- **cr** [📁](./cr) [🌐](https://github.com/GerHobbelt/cr) -- a single file header-only live reload solution for C, written in C++: simple public API, 3 functions to use only (and another to export); works and tested on Linux, MacOSX and Windows; based on dynamic reloadable binary (.so/.dylib/.dll).
- **crumsort** [📁](./crumsort) [🌐](https://github.com/GerHobbelt/crumsort) -- is a hybrid quicksort / mergesort algorithm. The sort is in-place, unstable, adaptive, branchless, and has exceptional performance.
- **DataFrame** [📁](./DataFrame) [🌐](https://github.com/GerHobbelt/DataFrame) -- a C++ analytical library designed for data analysis similar to libraries in Python and R. For example, you would compare this to [Pandas](https://pandas.pydata.org) or [R data.frame](https://www.w3schools.com/r/r_data_frames.asp). The depth and breadth of functionalities offered by C++ DataFrame alone are many times greater than functionalities offered by packages such as Pandas, data.frame, and Polars combined. You can slice the data in many different ways. You can join, merge, group-by the data. You can run various statistical, summarization, financial, and ML algorithms on the data. You can add your custom algorithms easily. You can multi-column sort, custom pick and delete the data. And more …
- **debugbreak** [📁](./debugbreak) [🌐](https://github.com/GerHobbelt/debugbreak) -- allows you to put breakpoints in your C/C++ code with a call to **`debug_break()`**.
- **delegate** [📁](./delegate) [🌐](https://github.com/GerHobbelt/delegate) -- an embedded friendly alternative to `std::function`. The main purpose is to store callable things such as free functions, member functions, and functors. Once stored, the delegate can be called without knowledge of the type of stored thing. The `delegate` guarantees no heap allocation and [is `trivially_copyable`](https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable). It will never throw exceptions itself. Intended use is as general callback storage (think function pointer analog). The price to pay is that the delegate only stores a pointer to referenced functor objects or objects to call member functions on. The user needs to handle the lifetime of a referred object. In addition, the delegation object has a smaller footprint compared to common `std::function` implementations, using only 2 pointers (free function pointer and void pointer). This is small enough so that a delegate will use small object optimization.
- **detect-character-encoding** [📁](./detect-character-encoding) [🌐](https://github.com/GerHobbelt/detect-character-encoding) -- detect character encoding using [ICU](http://site.icu-project.org).  **Tip:** If you don’t need ICU in particular, consider using [ced](https://github.com/sonicdoe/ced), which is based on Google’s lighter [compact_enc_det](https://github.com/google/compact_enc_det) library.
- **detox** [📁](./detox) [🌐](https://github.com/GerHobbelt/detox) -- renames files to make them easier to work with under Linux and other Unix-like operating systems.  Spaces and various other unsafe characters (such as "`$`") get replaced with "`_`".  The upper portion of ISO-8859-1 (Latin-1) can be transcoded to UTF-8, as can CP-1252.
- **dunce** [📁](./dunce) [🌐](https://github.com/GerHobbelt/dunce) -- Dunce (de-UNC): in Windows the regular paths (`C:\foo`) are supported by all programs, but have lots of bizarre restrictions for backwards compatibility with MS-DOS. There are also Windows NT UNC paths (`\\?\C:\foo`), which are more robust and with fewer gotchas, but are rarely supported by Windows programs — even Microsoft's own! Dunce converts Windows UNC paths to the MS-DOS-compatible format whenever possible, but leaves UNC paths as-is when they can't be unambiguously expressed in a simpler way. This allows legacy programs to access all paths they can possibly access, and doesn't break any paths for UNC-aware programs. For example, `\\?\C:\Windows` will be converted to `C:\Windows`, but `\\?\C:\COM` will be left as-is, because it contains a reserved filename.  Dunce's handling of UNC paths is safer than just unconditionally stripping the `\\` prefix, because naively stripped UNC paths with hostnames change to relative directory paths. There are other normalization rules, special characters, and length limits that could change meaning of the path. Parsing is based on <https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx>.
- **expected** [📁](./expected) [🌐](https://github.com/GerHobbelt/expected) -- a C++ single header implementation of `std::expected` with functional-style extensions. [`std::expected`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf) is proposed as the preferred way to represent object which will either have an expected value, or an unexpected value giving information about why something failed. Unfortunately, chaining together many computations which may fail can be verbose, as error-checking code will be mixed in with the actual programming logic. This implementation provides a number of utilities to make coding with `expected` cleaner.
- **eytzinger** [📁](./eytzinger) [🌐](https://github.com/GerHobbelt/eytzinger) -- `fixed_eytzinger_map` is a free implementation of Eytzinger’s layout, in a form of an STL-like generic associative container, broadly compatible with a well-established access patterns. An Eytzinger map, or BFS(breadth-first search) map, places elements in a lookup order, which leads to a better memory locality. In practice, such container can outperform searching in sorted arrays, like `boost::flat_map`, due to less cache misses made in a lookup process. In comparison with RB-based trees, like `std::map`, lookup in Eytzinger map can be multiple times faster. Some comparison graphs are [given here](https://kazakov.life/2017/03/06/cache-friendly-associative-container/).
- **fast_float** [📁](./fast_float) [🌐](https://github.com/GerHobbelt/fast_float) -- fast and exact implementation of the C++ `from_chars` functions for float and double types: 4x faster than `strtod`
- **fastrange** [📁](./fastrange) [🌐](https://github.com/GerHobbelt/fastrange) -- a fast alternative to the modulo reduction. [It has accelerated some operations in Google's Tensorflow by 10% to 20%](https://github.com/tensorflow/tensorflow/commit/a47a300185026fe7829990def9113bf3a5109fed). Further reading : http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/ See also: Daniel Lemire, [Fast Random Integer Generation in an Interval](https://arxiv.org/abs/1805.10941), ACM Transactions on Modeling and Computer Simulation, January 2019 Article No. 3 https://doi.org/10.1145/3230636
- **FastString** [📁](./FastString) [🌐](https://github.com/GerHobbelt/FastString) -- fast, in stack, fixed size string implementation with **constexpr noexcept** constructors and accessors. **FastString** improves **memory locality and latency** of strings by avoiding heap allocations.
- **float_compare** [📁](./float_compare) [🌐](https://github.com/GerHobbelt/float_compare) -- C++ header providing floating point value comparators with user-specifiable tolerances and behaviour.
- **fluxsort** [📁](./fluxsort) [🌐](https://github.com/GerHobbelt/fluxsort) -- is a stable quicksort / mergesort hybrid algorithm. The sort is stable, adaptive, branchless, and has exceptional performance.
- **fnmatch** [📁](./fnmatch) [🌐](https://github.com/GerHobbelt/fnmatch) -- match a filename string or a pathname using POSIX wildcards.
- **getopt** [📁](./getopt) [🌐](https://github.com/GerHobbelt/getopt_port) -- an original implementation of `getopt` and `getopt_long` with limited GNU extensions. Provided under the BSD license, to allow non-GPL projects to use `getopt`-style command-line parsing.
- **highway** [📁](./highway) [🌐](https://github.com/GerHobbelt/highway) -- dependency of JpegXL
- **immer** [📁](./immer) [🌐](https://github.com/GerHobbelt/immer) -- a library of persistent_ and immutable_ data structures written in C++.  These enable whole new kinds of architectures for interactive and concurrent programs of striking simplicity, correctness, and performance.
- **inih** [📁](./inih) [🌐](https://github.com/GerHobbelt/inih) -- **inih (INI Not Invented Here)** is a simple [.INI file](http://en.wikipedia.org/wiki/INI_file) parser written in C. It's only a couple of pages of code, and it was designed to be _small and simple_, so it's good for embedded systems. It's also more or less compatible with Python's [ConfigParser](http://docs.python.org/library/configparser.html) style of .INI files, including RFC 822-style multi-line syntax and `name: value` entries.
- **klib** [📁](./klib) [🌐](https://github.com/GerHobbelt/klib) -- Klib is a standalone and lightweight C library. Most components are independent of external libraries, except the standard C library, and independent of each other. To use a component of this library, you only need to copy a couple of files to your source code tree without worrying about library dependencies. Klib strives for efficiency and a small memory footprint. Some components, such as khash.h, kbtree.h, ksort.h and kvec.h, are among the most efficient implementations of similar algorithms or data structures in all programming languages, in terms of both speed and memory use.
- **lager** [📁](./lager) [🌐](https://github.com/GerHobbelt/lager) -- a C++ library to assist `value-oriented design`_ by implementing the `unidirectional data-flow architecture`_.  It is heavily inspired by Elm_ and Redux_, and enables composable designs by promoting the use of simple value types and testable application logic via pure functions.
- **libart** [📁](./libart) [🌐](https://github.com/GerHobbelt/libart) -- provides the Adaptive Radix Tree or ART. The ART operates similar to a traditional radix tree but avoids the wasted space of internal nodes by changing the node size. It makes use of 4 node sizes (4, 16, 48, 256), and can guarantee that the overhead is no more than 52 bytes per key, though in practice it is much lower.
- **libascii** [📁](./libascii) [🌐](https://github.com/GerHobbelt/libascii) -- C/C++ header files carrying the ASCII, Z-modem, etc. control codes as named definitions.
- **libccpalette** [📁](./libccpalette) [🌐](https://github.com/GerHobbelt/libccpalette) -- a C++ library to load, save, pick and interpolate colors from any color palette.
- **libcds** [📁](./libcds) [🌐](https://github.com/GerHobbelt/libcds) -- the Concurrent Data Structures (CDS) library is a collection of concurrent containers that don't require external (manual) synchronization for shared access, and safe memory reclamation (SMR) algorithms like [Hazard Pointer](http://en.wikipedia.org/wiki/Hazard_pointer) and user-space [RCU](http://en.wikipedia.org/wiki/Read-copy-update) that is used as an epoch-based SMR.
- **libclip** [📁](./libclip) [🌐](https://github.com/GerHobbelt/clip) -- a library to copy/retrieve content to/from the clipboard/pasteboard.
- **libclipboard** [📁](./libclipboard) [🌐](https://github.com/GerHobbelt/libclipboard) -- a lightweight cross-platform clipboard library.
- **libcnl** [📁](./libcnl) [🌐](https://github.com/GerHobbelt/cnl) -- The Compositional Numeric Library (CNL) is a C++ library of fixed-precision numeric classes which enhance integers to deliver safer, simpler, cheaper arithmetic types. CNL is particularly well-suited to: (1) compute on energy-constrained environments where FPUs are absent or costly; (2) compute on energy-intensive environments where arithmetic is the bottleneck such as simulations, machine learning applications and DSPs; and (3) domains such as finance where precision is essential.
- **libdi-dependency-injection** [📁](./libdi-dependency-injection) [🌐](https://github.com/GerHobbelt/di) -- \[Boost::ext\].DI :: your C++14 **one header only** Dependency Injection library with no dependencies
- **libdivide** [📁](./libdivide) [🌐](https://github.com/GerHobbelt/libdivide) -- libdivide.h is a header-only C/C++ library for optimizing integer division. Integer division is one of the slowest instructions on most CPUs e.g. on current x64 CPUs a 64-bit integer division has a latency of up to 90 clock cycles whereas a multiplication has a latency of only 3 clock cycles. `libdivide` allows you to replace expensive integer divsion instructions by a sequence of shift, add and multiply instructions that will calculate the integer division much faster.
- **libffi** [📁](./libffi) [🌐](https://github.com/GerHobbelt/libffi) -- provides a portable, high level programming interface to various calling conventions. This allows a programmer to call any function specified by a call interface description at run time.
- **libintrinsics** [📁](./libintrinsics) [🌐](https://github.com/GerHobbelt/libintrinsics) -- C/C++ compiler / CPU intrinsics for bit ops and various other math.
- **libnatspec** [📁](./libnatspec) [🌐](https://github.com/GerHobbelt/libnatspec) -- The Nation Specifity Library is designed to smooth out national peculiarities when using software. Its primary objectives are: (1) Addressing encoding issues in most popular scenarios, (2) Providing various auxiliary tools that facilitate software localization.
- **libpathutils** [📁](./libpathutils) [🌐](https://github.com/GerHobbelt/libpathutils) -- cross-platform filesystem path utility functions
- **libpopcnt** [📁](./libpopcnt) [🌐](https://github.com/GerHobbelt/libpopcnt) -- a header-only C/C++ library for counting the number of 1 bits (bit population count) in an array as quickly as possible using specialized CPU instructions.
- **libstb** [📁](./libstb) [🌐](https://github.com/GerHobbelt/stb) -- single-file public domain (or MIT licensed) libraries for C/C++.
- **libuuid** [📁](./libuuid) [🌐](https://github.com/GerHobbelt/libuuid) -- a library to generate unique identifiers for objects that may be accessible beyond the local system. The UUIDs generated by this library can be reasonably expected to be unique within a system, and unique across all systems. They could be used, for instance, to generate unique HTTP cookies across multiple web servers without communication between the servers, and without fear of a name clash.
- **libwil** [📁](./libwil) [🌐](https://github.com/GerHobbelt/wil) -- The Windows Implementation Libraries (WIL) is a header-only C++ library created to make life easier for developers on Windows through readable type-safe C++ interfaces for common Windows coding patterns.
- **lockfree** [📁](./lockfree) [🌐](https://github.com/GerHobbelt/lockfree) -- a collection of lock-free data structures written in standard C++11 and suitable for all platforms - from deeply embedded to HPC.
- **memory** [📁](./memory) [🌐](https://github.com/GerHobbelt/memory) -- the C++ STL allocator model has various flaws. For example, they are fixed to a certain type, because they are almost necessarily required to be templates. So you can't easily share a single allocator for multiple types. In addition, you can only get a copy from the containers and not the original allocator object. At least with C++11 they are allowed to be stateful and so can be made object not instance based. But still, the model has many flaws. Over the course of the years many solutions have been proposed, for example [EASTL]. This library is another. But instead of trying to change the STL, it works with the current implementation.
- **merror** [📁](./merror) [🌐](https://github.com/GerHobbelt/merror) -- **MError** C++ Macro Error Handling Library is a library for error handling in C++ without exceptions. It requires C++17 and only works for gcc or clang compilers.
- **mesh-allocator** [📁](./mesh-allocator) [🌐](https://github.com/GerHobbelt/Mesh) -- Mesh: Compacting Memory Management for C/C++ -- Mesh is a drop in replacement for [malloc(3)](http://man7.org/linux/man-pages/man3/malloc.3.html) that can transparently recover from memory fragmentation without any changes to application code. Mesh is described in detail in a [paper (PDF)](https://github.com/plasma-umass/Mesh/raw/master/mesh-pldi19-powers.pdf) that appeared at PLDI 2019.
- **msgpack-c** [📁](./msgpack-c) [🌐](https://github.com/GerHobbelt/msgpack-c) -- [MessagePack](http://msgpack.org/) (a.k.a. `msgpack`) for C/C++ is an efficient binary serialization format, which lets you exchange data among multiple languages like JSON, except that it's faster and smaller. Small integers are encoded into a single byte and short strings require only one extra byte in addition to the strings themselves.
- **nameof** [📁](./nameof) [🌐](https://github.com/GerHobbelt/nameof) -- header-only C++17 library providing nameof macros and functions to simply obtain the name of a variable, type, function, macro, and enum.
- **oof** [📁](./oof) [🌐](https://github.com/GerHobbelt/oof) -- OOF (omnipotent output friend) is a single C++20 header that wraps so-called [Virtual Terminal sequences](https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences) (sometimes also confusingly called ["escape codes"](https://en.wikipedia.org/wiki/ANSI_escape_code)) in a convenient way, enabling console applications using OOF to be far more capable than usual: complete control over position, color and other properties of written characters.
- **pdiff** [📁](./pdiff) [🌐](https://github.com/GerHobbelt/pdiff) -- perceptualdiff (pdiff): a program that compares two images using a perceptually based image metric.
- **perfetto** [📁](./perfetto) [🌐](https://github.com/GerHobbelt/perfetto) -- a suite of SDKs, daemons and tools which use **tracing** to help developers understand the behaviour of complex systems and root-cause functional and performance issues on client and embedded systems.
- **pfp-cst** [📁](./pfp-cst) [🌐](https://github.com/GerHobbelt/pfp-cst) -- Prefix-Free Parsing Compressed Suffix Tree is a compressed suffix tree, built on the prefix-free parsing of the text. If you use the PFP-CST in your research, please cite: Christina Boucher, Ondřej Cvacho, Travis Gagie, Jan Holub, Giovanni Manzini, Gonzalo Navarro, and Massimiliano Rossi . *"PFP Compressed Suffix Tree"*, In Proc. of the SIAM Symposium onAlgorithm Engineering and Experiments (ALENEX21), pp. 60-72. (2021).
- **piposort** [📁](./piposort) [🌐](https://github.com/GerHobbelt/piposort) -- a stable top-down adaptive branchless merge sort named piposort. It is intended as a simplified [quadsort](https://github.com/scandum/quadsort) with reduced adaptivity, but a great reduction in lines of code and overall complexity. The name stands for ping-pong.
- **PruningRadixTrie** [📁](./PruningRadixTrie) [🌐](https://github.com/GerHobbelt/PruningRadixTrie) -- a 1000x faster Radix trie for prefix search & auto-complete, the PruningRadixTrie is a novel data structure, derived from a radix trie - but 3 orders of magnitude faster. A **Pruning Radix trie** is a novel Radix trie algorithm, that allows pruning of the Radix trie and early termination of the lookup. In many cases, we are not interested in a complete set of all children for a given prefix, but only in the top-k most relevant terms. Especially for short prefixes, this results in a **massive reduction of lookup time** for the top-10 results. On the other hand, a complete result set of millions of suggestions wouldn't be helpful at all for autocompletion. The lookup acceleration is achieved by storing in each node the maximum rank of all its children. By comparing this maximum child rank with the lowest rank of the results retrieved so far, we can heavily prune the trie and do early termination of the lookup for non-promising branches with low child ranks.
- **pystring** [📁](./pystring) [🌐](https://github.com/GerHobbelt/pystring) -- a collection of C++ functions which match the interface and behavior of python's string class methods using std::string. It provides convenience and familiarity for common string operations not included in the standard C++ library.
- **quadsort** [📁](./quadsort) [🌐](https://github.com/GerHobbelt/quadsort) -- a high performance stable bottom-up adaptive branchless merge sort algorithm.
- **radix_tree** [📁](./radix_tree) [🌐](https://github.com/GerHobbelt/radix_tree) -- STL like container of radix tree in C++.
- **rax** [📁](./rax) [🌐](https://github.com/GerHobbelt/rax) -- an ANSI C radix tree implementation initially written to be used in a specific place of Redis in order to solve a performance problem, but immediately converted into a stand alone project to make it reusable for Redis itself, outside the initial intended application, and for other projects as well. The primary goal was to find a suitable balance between performances and memory usage, while providing a fully featured implementation of radix trees that can cope with many different requirements.
- **recycle** [📁](./recycle) [🌐](https://github.com/GerHobbelt/recycle) -- an implementation of a simple resource pool for recycling resources in C++.
- **refl-cpp** [📁](./refl-cpp) [🌐](https://github.com/GerHobbelt/refl-cpp) -- static reflection for C++17 (compile-time enumeration, attributes, proxies, overloads, template functions, metaprogramming).
- **reflect** [📁](./reflect) [🌐](https://github.com/GerHobbelt/reflect) -- a C++20 Static Reflection library with optimized run-time execution and binary size, fast compilation times and platform agnostic, minimal API. The library only provides basic reflection primitives and is not a full-fledged, heavy, implementation for https://wg21.link/P2996 which is a language proposal with many more features and capabilities.
- **reflect-cpp** [📁](./reflect-cpp) [🌐](https://github.com/GerHobbelt/reflect-cpp) -- a C++-20 library for **fast serialization, deserialization and validation** using reflection, similar to [pydantic](https://github.com/pydantic/pydantic) in Python, [serde](https://github.com/serde-rs) in Rust, [encoding](https://github.com/golang/go/tree/master/src/encoding) in Go or [aeson](https://github.com/haskell/aeson/tree/master) in Haskell. As the aforementioned libraries are among the most widely used in the respective languages, reflect-cpp fills an important gap in C++ development. It reduces boilerplate code and increases code safety.
- **result-cpp** [📁](./result-cpp) [🌐](https://github.com/GerHobbelt/result) -- `Result<T, E>` is a modern, simple, and light-weight error-handling alternative to C++ exceptions with a rich feature-set.
- **rttr** [📁](./rttr) [🌐](https://github.com/GerHobbelt/rttr) -- RTTR - Run Time Type Reflection - provides the ability to introspect and modify an object at runtime and is written in C++. Features:
- **safestringlib** [📁](./safestringlib) [🌐](https://github.com/GerHobbelt/safestringlib) -- The Safe String Library is based on the Safe C Library by Cisco, and provides routines for safe string operations (like `strcpy`) and memory routines (like `memcpy`) that are recommended for Linux/Android operating systems, and will also work for Windows. This library is especially useful for cross-platform situations where one library for these routines is preferred.
- **simdcomp** [📁](./simdcomp) [🌐](https://github.com/GerHobbelt/simdcomp) -- SIMDComp is a simple C library for compressing lists of integers using binary packing and SIMD instructions. The assumption is either that you have a list of 32-bit integers where most of them are small, or a list of 32-bit integers where differences between successive integers are small. No software is able to reliably compress an array of 32-bit random numbers.
- **simde** [📁](./simde) [🌐](https://github.com/GerHobbelt/simde) -- SIMD Everywhere: the SIMDe header-only library provides fast, portable implementations of [SIMD intrinsics](https://en.wikipedia.org/wiki/SIMD) on hardware which doesn't natively support them, such as calling [SSE](https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions) functions on ARM.  There is no performance penalty if the hardware supports the native implementation (*e.g.*, SSE/[AVX](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions) runs at full speed on [x86](https://en.wikipedia.org/wiki/X86), [NEON](https://en.wikipedia.org/wiki/ARM_architecture#Advanced_SIMD_(Neon)) on [ARM](https://en.wikipedia.org/wiki/ARM_architecture), *etc.*).
- **SIMDString** [📁](./SIMDString) [🌐](https://github.com/GerHobbelt/SIMDString) -- a [MIT-licensed](https://opensource.org/licenses/MIT) open source implementation of a fast C++ string class designed for use in games. It is a drop-in replacement for `std::string` that is 10-100x faster for many common operations, such as small `string::operator+=(const char*)`, `string::string(const string&)`, `string::string(const char*)`, and `string::c_str()`.
- **small_vectors** [📁](./small_vectors) [🌐](https://github.com/GerHobbelt/small_vectors) -- C++23 utilities library, including features such as static vectors, trivially copyable, enabling compiler optimizations such as `memcpy` for copying operations, static vectors' and static string in-class storage making them address-independent and suitable for interprocess data exchange, and a C++23 `std::expected/unexpected` implementation with monadic operations for C++20 and up.
- **sml** [📁](./sml) [🌐](https://github.com/GerHobbelt/sml) -- SML (State Machine Language) is your scalable C++14 **one header only** State Machine Library with no dependencies.
- **sse2neon** [📁](./sse2neon) [🌐](https://github.com/GerHobbelt/sse2neon) -- converts Intel SSE intrinsics to Arm/Aarch64 NEON intrinsics, shortening the time needed to get an Arm working program that then can be used to extract profiles and to identify hot paths in the code.
- **stl-allocator** [📁](./stl-allocator) [🌐](https://github.com/GerHobbelt/stl-allocator) -- a set of memory allocators for use with the C++ Standard Template Library, inspired by [John Wellbelove](http://www.codeguru.com/member.php/John+Wellbelove/)'s article, [Stack Allocators for STL Containers](http://www.codeguru.com/cpp/article.php/c18503/C-Programming-Stack-Allocators-for-STL-Containers.htm), and is an attempt to offer an alternative solution to John's implementation (which needs a few tweaks to run on Linux).
- **stringi** [📁](./stringi) [🌐](https://github.com/GerHobbelt/stringi) -- fast and portable character string processing in R (with the Unicode ICU).
- **strings2** [📁](./strings2) [🌐](https://github.com/GerHobbelt/strings2) -- Strings2 is a Windows command-line tool for extracting strings from binary data: either binary files or process memory. On top of the classic Sysinternals strings approach, this tool includes multi-lingual string extraction, such as Russian, Chinese, etc. while a machine learning model filters out junk erroneous string extractions to reduce noise.
- **StringViewTests** [📁](./StringViewTests) [🌐](https://github.com/GerHobbelt/StringViewTests) -- some performance tests for `std::string_view` on MSVC.
- **StringZilla** [📁](./StringZilla) [🌐](https://github.com/GerHobbelt/StringZilla) -- StringZilla 🦖 : The world wastes a minimum of $100M annually due to inefficient string operations. A typical codebase processes strings character by character, resulting in too many branches and data-dependencies, neglecting 90% of modern CPU's potential. That's why StringZilla was created. To provide predictably high performance, portable to any modern platform, operating system, and programming language. StringZilla is the GodZilla of string libraries, using SIMD and SWAR to accelerate string operations on modern CPUs. It is up to __10x faster than the default and even other SIMD-accelerated string libraries__ in C, C++, Python, and other languages, while covering broad functionality. It __accelerates exact and fuzzy string matching, edit distance computations, sorting, lazily-evaluated ranges to avoid memory allocations, and even random-string generators__.
- **strtk** [📁](./strtk) [🌐](https://github.com/GerHobbelt/strtk) -- the C++ String Toolkit Library (StrTk) consists of robust, optimized and portable string processing algorithms for the C++ language. StrTk is designed to be easy to use and integrate within existing code bases. Furthermore the library has a rich set of features  that makes light work of any kind of string processing task.
- **stx-error-handling** [📁](./stx-error-handling) [🌐](https://github.com/GerHobbelt/STX) -- C++ 17 & C++ 20 error-handling and utility extensions.
- **stxxl** [📁](./stxxl) [🌐](https://github.com/GerHobbelt/stxxl) -- STXXL is an implementation of the C++ standard template library STL for external memory (out-of-core) computations, i. e. STXXL implements containers and algorithms that can process huge volumes of data that only fit on disks.
- **SuperString** [📁](./SuperString) [🌐](https://github.com/GerHobbelt/SuperString) -- an efficient string library for C++, that achieves a remarkable memory and CPU optimization. SuperString uses Rope (data structure) and optimization techniques.
- **swig** [📁](./swig) [🌐](https://github.com/GerHobbelt/swig) -- SWIG (Simplified Wrapper and Interface Generator) is a software development tool (code generator) that connects programs written in C and C++ with a variety of high-level programming languages. It is used for building scripting language interfaces to C and C++ programs. SWIG simplifies development by largely automating the task of scripting language integration, allowing developers and users to focus on more important problems.
  
  *[SWIG 🌐](https://swig.readthedocs.io/en/latest/Manual/SWIG.html) was not considered initially; more suitable for RPC than what we have in mind, which is purely data messages enchange. MAY be of use for transitional applications which are mixed-(programming-)language based, e.g. where we want to mix C/C++ and C# in a single Test Application.*

- **SZ** [📁](./SZ) [🌐](https://github.com/GerHobbelt/SZ) -- SZ2: Error-bounded Lossy Compressor for HPC Data, (C) 2016-2022 by Mathematics and Computer Science (MCS), Argonne National Laboratory.
- **SZ3** [📁](./SZ3) [🌐](https://github.com/GerHobbelt/SZ3) -- SZ3: A Modular Error-bounded Lossy Compression Framework for Scientific Datasets, 2016 by Mathematics and Computer Science (MCS), Argonne National Laboratory.
- **termcolor** [📁](./termcolor) [🌐](https://github.com/GerHobbelt/termcolor) -- a header-only C++ library for printing colored messages to the terminal. Termcolor uses ANSI color formatting, so you can use it on every system that is used such terminals (most *nix systems, including Linux and Mac OS).
  
  On MS Windows the Windows API is used instead of escape codes but some limitations apply (not everything is supported). That's why it's recommended to enter virtual terminal processing mode and set the TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES macro to trick termcolor to use ANSI color codes.

- **text-wrangler** [📁](./text-wrangler) [🌐](https://github.com/GerHobbelt/text-wrangler) -- a library + utility for text wrangling: text from in images, text from text. text line detection, text keyphrase extraction, text metadata extraction, ...
- **the-yabbering-politician** [📁](./the-yabbering-politician) [🌐](https://github.com/GerHobbelt/the-yabbering-politician) -- provides a cross-platform structure-aware generation-based fuzzer toolkit, which does not need coverage tooling nor injects code into your application.
- **tinycolormap** [📁](./tinycolormap) [🌐](https://github.com/GerHobbelt/tinycolormap) -- a header-only, single-file library for colormaps written in C++11.
- **tiny-utf8** [📁](./tiny-utf8) [🌐](https://github.com/GerHobbelt/tiny-utf8) -- a library for extremely easy integration of Unicode into an arbitrary C++11 project. The library consists solely of the class `utf8_string`, which acts as a drop-in replacement for `std::string`. Its implementation is successfully in the middle between small memory footprint and fast access. All functionality of `std::string` is therefore replaced by the corresponding codepoint-based UTF-32 version - translating every access to UTF-8 under the hood.
- **u8_to_std_string** [📁](./u8_to_std_string) [🌐](https://github.com/GerHobbelt/u8_to_std_string) -- C++ u8_to_std_string (`u8` and `char8_t` based string to `std::string`) inlines to convert between `u8` (`char8_t[]`) string constants and `char`-based `std::string` types to shut up C++17 ➜ C++20 transitioning codebases & compilers.
- **units** [📁](./units) [🌐](https://github.com/GerHobbelt/units) -- the Units library provides a means of working with units of measurement at runtime, including conversion to and from strings. It provides a small number of types for working with units and measurements and operations necessary for user input and output with units.
- **units_cpp** [📁](./units_cpp) [🌐](https://github.com/GerHobbelt/units_cpp) -- a compile-time, header-only, dimensional analysis library built on C++14 with no dependencies.
- **UniversalStacktrace** [📁](./UniversalStacktrace) [🌐](https://github.com/GerHobbelt/UniversalStacktrace) -- C++ Stacktrace for MS Windows, Linux and Apple OS/X.
- **utf8proc** [📁](./utf8proc) [🌐](https://github.com/GerHobbelt/utf8proc) -- [utf8proc](http://juliastrings.github.io/utf8proc/) is a small, clean C library that provides Unicode normalization, case-folding, and other operations for data in the [UTF-8 encoding](http://en.wikipedia.org/wiki/UTF-8).
- **uuid_v4** [📁](./uuid_v4) [🌐](https://github.com/GerHobbelt/uuid_v4) -- a fast C++ library to generate, serialize, print and parse UUIDs version 4 variant 1 as specified in RFC-4122. It heavily relies on SIMD operations (instruction sets **SSE4.1**/**AVX**/**AVX2**), c\++11 `<random>` PRNG library and some c\++17 features. This library generates UUIDs with pseudo-random numbers, seeded by true (hardware) random. It is *not* a cryptographically secure way of generating UUIDs.
- **wcwidth9** [📁](./wcwidth9) [🌐](https://github.com/GerHobbelt/wcwidth9) -- platform independent, header only, `wcwidth` with full Unicode 9 wide character support.
- **win32-fileapi-demo** [📁](./win32-fileapi-demo) [🌐](https://github.com/GerHobbelt/win32-fileapi-demo) -- demo-ing Win32 file api 'A' (ANSI) and UCS2/UTF16 'W' (Wide/Unicode) interfaces / UNC paths and "long filename support" / Linux file paths: regulars, limitations, mistakes, disasters and related stuff begging for a CVE if you haven't already.
- **wolfsort** [📁](./wolfsort) [🌐](https://github.com/GerHobbelt/wolfsort) -- a stable adaptive hybrid bucket / quick / merge / drop sort named wolfsort. The bucket sort, forming the core of wolfsort, is not a comparison sort, so wolfsort can be considered a member of the radix-sort family. Quicksort and mergesort are well known. Dropsort gained popularity after it was reinvented as Stalin sort.
- **xcdat** [📁](./xcdat) [🌐](https://github.com/GerHobbelt/xcdat) -- a C++17 header-only library of a fast compressed string dictionary based on an improved double-array trie structure described in the paper: [Compressed double-array tries for string dictionaries supporting fast lookup](https://doi.org/10.1007/s10115-016-0999-8), *Knowledge and Information Systems*, 2017, available [here](https://kampersanda.github.io/pdf/KAIS2017.pdf).
- **zvec** [📁](./zvec) [🌐](https://github.com/GerHobbelt/zvec) -- _zip_vector_ is a compressed variable length array that uses vectorized block codecs to compress and decompress integers using variable bit-width deltas. The integer block codecs are optimized for vector instruction sets using Google's Highway C++ library for portable SIMD/vector intrinsics.
- ~~**merror** [📁](./merror) [🌐](https://github.com/GerHobbelt/merror) -- a library for error handling in C++ without exceptions.~~
  
  - **removed**; reason: code is non-portable to compilers other than GCC, or at least would require more effort than we're willing to expend on this.













	
----

🡸 [previous section](./0069-date-time-functionality.md)  |  🡹 [up](./0066-multi-processing-core-technologies.md)  |  🡻 [all (index)](./0103-libraries-in-this-collection.md)  |  🡺 [next section](./0071-multi-processing-invoking-external-applications.md)
