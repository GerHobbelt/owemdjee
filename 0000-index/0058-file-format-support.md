









## file format support

- **AudioFile** [ğŸ“](./AudioFile) [ğŸŒ](https://github.com/GerHobbelt/AudioFile) -- a simple header-only C++ library for reading and writing audio files. (WAV, AIFF)
- **basez** [ğŸ“](./basez) [ğŸŒ](https://github.com/GerHobbelt/basez) -- encode data into/decode data from base16, base32, base32hex, base64 or base64url stream per RFC 4648; MIME base64 Content-Transfer-Encoding per RFC 2045; or PEM Printable Encoding per RFC 1421.
- **CHM-lib** [ğŸ“](./CHM-lib) [ğŸŒ](https://github.com/GerHobbelt/CHMLib) -- as I have several HTML pages stored in this format. See also MHTML: `mht-rip`
- **cpp-base64** [ğŸ“](./cpp-base64) [ğŸŒ](https://github.com/GerHobbelt/cpp-base64) -- base64 encoding and decoding with C++
- **csv-parser** [ğŸ“](./csv-parser) [ğŸŒ](https://github.com/GerHobbelt/csv-parser) -- Vince's CSV Parser: there's plenty of other CSV parsers in the wild, but I had a hard time finding what I wanted. Inspired by Python's `csv` module, I wanted a library with **simple, intuitive syntax**. Furthermore, I wanted support for special use cases such as calculating statistics on very large files. Thus, this library was created with these following goals in mind.
- **cvmatio** [ğŸ“](./cvmatio) [ğŸŒ](https://github.com/GerHobbelt/cvmatio) -- an open source Matlab v7 MAT file parser written in C++, giving users the ability to interact with binary MAT files in their own projects.
- **datamash** [ğŸ“](./datamash) [ğŸŒ](https://github.com/GerHobbelt/datamash) -- GNU Datamash is a command-line program which performs basic numeric, textual and statistical operations on input textual data files. It is designed to be portable and reliable, and aid researchers to easily automate analysis pipelines, without writing code or even short scripts.
- **dcmtk** [ğŸ“](./dcmtk) [ğŸŒ](https://github.com/GerHobbelt/dcmtk) -- the DICOM toolkit (DCMTK) package consists of source code, documentation and installation instructions for a set of software libraries and applications implementing part of the DICOM/MEDICOM Standard.
- **djvulibre** [ğŸ“](./djvulibre) [ğŸŒ](https://github.com/GerHobbelt/djvulibre) -- DjVu (pronounced "dÃ©jÃ  vu") a set of compression technologies, a file format, and a software platform for the delivery over the Web of digital documents, scanned documents, and high resolution images.
- **extract** [ğŸ“](../../thirdparty/extract) [ğŸŒ](https://github.com/GerHobbelt/thirdparty_extract) -- clone of git://git.ghostscript.com/extract.git
- **fast-cpp-csv-parser** [ğŸ“](./fast-cpp-csv-parser) [ğŸŒ](https://github.com/GerHobbelt/fast-cpp-csv-parser) -- a small, easy-to-use and fast header-only library for reading comma separated value (CSV) files.
- **fastgron** [ğŸ“](./fastgron) [ğŸŒ](https://github.com/GerHobbelt/fastgron) -- `fastgron` makes JSON greppable super fast! `fastgron` transforms JSON into discrete assignments to make it easier to grep for what you want and see the absolute 'path' to it. It eases the exploration of APIs that return large blobs of JSON but lack documentation.
- **FFmpeg** [ğŸ“](./FFmpeg) [ğŸŒ](https://github.com/GerHobbelt/FFmpeg) -- a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata.
- **file** [ğŸ“](./file) [ğŸŒ](https://github.com/GerHobbelt/file) -- `file` filetype recognizer tool & mimemagic
- **flac** [ğŸ“](./flac) [ğŸŒ](https://github.com/GerHobbelt/flac) -- a software that can reduce the amount of storage space needed to store digital audio signals without needing to remove information in doing so. The files read and produced by this software are called FLAC files. As these files (which follow the [FLAC format](https://xiph.org/flac/format.html)) can be read from and written to by other software as well, this software is often referred to as the FLAC reference implementation.
- **gmt** [ğŸ“](./gmt) [ğŸŒ](https://github.com/GerHobbelt/gmt) -- GMT (Generic Mapping Tools) is an open source collection of about 100 command-line tools for manipulating geographic and Cartesian data sets (including filtering, trend fitting, gridding, projecting, etc.) and producing high-quality illustrations ranging from simple x-y plots via contour maps to artificially illuminated surfaces, 3D perspective views and animations. The GMT supplements add another 50 more specialized and discipline-specific tools. GMT supports over 30 map projections and transformations and requires support data such as [GSHHG](http://www.soest.hawaii.edu/pwessel/gshhg/) coastlines, rivers, and political boundaries and optionally [DCW](http://www.soest.hawaii.edu/pwessel/dcw) country polygons.
- **gumbo-libxml** [ğŸ“](./gumbo-libxml) [ğŸŒ](https://github.com/GerHobbelt/gumbo-libxml) -- LibXML2 bindings for the Gumbo HTML5 parser: this provides a libxml2 API on top of the Gumbo parser.  It lets you use a modern parser - Gumbo now passes all html5lib tests, including the template tag, and should be fully conformant with the HTML5 spec - with the full ecosystem of libxml tools, including XPath, tree modification, DTD validation, etc.
- **gumbo-parser** [ğŸ“](../../thirdparty/gumbo-parser) [ğŸŒ](https://github.com/GerHobbelt/gumbo-parser) -- HTML parser
- **gumbo_pp** [ğŸ“](./gumbo_pp) [ğŸŒ](https://github.com/GerHobbelt/gumbo_pp) -- a C++ wrapper over Gumbo that provides a higher level query mechanism.
- **gumbo-query** [ğŸ“](./gumbo-query) [ğŸŒ](https://github.com/GerHobbelt/gumbo-query) -- HTML DOM access in C/C++
- **html5-parser** [ğŸ“](./html5-parser) [ğŸŒ](https://github.com/GerHobbelt/html5-parser) -- a *fast*, standards compliant, C based, HTML 5 parser for python. Over **thirty** times as fast as pure python based parsers, such as html5lib.
- **http-parser** [ğŸ“](./http-parser) [ğŸŒ](https://github.com/GerHobbelt/http-parser) -- a parser for HTTP messages written in C. It parses both requests and responses. The parser is designed to be used in performance HTTP applications. It does not make any syscalls nor allocations, it does not buffer data, it can be interrupted at anytime. Depending on your architecture, it only requires about 40 bytes of data per message stream (in a web server that is per connection).
- **id3-tagparser** [ğŸ“](./id3-tagparser) [ğŸŒ](https://github.com/GerHobbelt/tagparser) -- a C++ library for reading and writing MP4 (iTunes), ID3, Vorbis, Opus, FLAC and Matroska tags.
- **imageio-freeimage** [ğŸ“](./imageio-freeimage) [ğŸŒ](https://github.com/GerHobbelt/imageio-freeimage) -- ImageIO FreeImage is an ImageIO plugin for the FreeImage library, which allows using [FreeImage](https://freeimage.sourceforge.io/) with [ImageIO](https://github.com/imageio/imageio).
- **jq** [ğŸ“](./jq) [ğŸŒ](https://github.com/GerHobbelt/jq) -- a lightweight and flexible command-line JSON processor.
- **jtc** [ğŸ“](./jtc) [ğŸŒ](https://github.com/GerHobbelt/jtc) -- `jtc` stand for: **_JSON transformational chains_** (used to be _JSON test console_) and is a cli tool to extract, manipulate and transform source JSON, offering powerful ways to select one or multiple elements from a source JSON and apply various actions on the selected elements at once (wrap selected elements into a new JSON, filter in/out, sort elements, update elements, insert new elements, remove, copy, move, compare, transform, swap around and many other operations).
- **lazycsv** [ğŸ“](./lazycsv) [ğŸŒ](https://github.com/GerHobbelt/lazycsv) -- a c++17, posix-compliant, single-header library for reading and parsing csv files. It's fast and lightweight and does not allocate any memory in the constructor or while parsing. It parses each row and cell just on demand on each iteration, that's why it's called lazy.
- **lexbor** [ğŸ“](./lexbor) [ğŸŒ](https://github.com/GerHobbelt/lexbor) -- fast HTML5 fully-conformant HTML + CSS parser.
- **libaom** [ğŸ“](./libaom) [ğŸŒ](https://github.com/GerHobbelt/libaom) -- AV1 Codec Library
- **libarchive** [ğŸ“](./libarchive) [ğŸŒ](https://github.com/GerHobbelt/libarchive) -- a portable, efficient C library that can read and write streaming archives in a variety of formats. It also includes implementations of the common `tar`, `cpio`, and `zcat` command-line tools that use the libarchive library.
- **libase** [ğŸ“](./libase) [ğŸŒ](https://github.com/GerHobbelt/libase) -- a tiny library for interpreting the Adobe Swatch Exchange (`.ase`) file format for color palettes since Adobe Creative Suite 3.
- **libass** [ğŸ“](./libass) [ğŸŒ](https://github.com/GerHobbelt/libass) -- `libass` is a portable subtitle renderer for the ASS/SSA (Advanced Substation Alpha/Substation Alpha) subtitle format.
- **libavif** [ğŸ“](./libavif) [ğŸŒ](https://github.com/GerHobbelt/libavif) -- a friendly, portable C implementation of the AV1 Image File Format, as described here: <https://aomediacodec.github.io/av1-avif/>
- **libcmime** [ğŸ“](./libcmime) [ğŸŒ](https://github.com/GerHobbelt/libcmime) -- MIME extract/insert/encode/decode: use for MHTML support
- **libcsv2** [ğŸ“](./libcsv2) [ğŸŒ](https://github.com/GerHobbelt/csv2) -- CSV file format reader/writer library.
- **libde265** [ğŸ“](./libde265) [ğŸŒ](https://github.com/GerHobbelt/libde265) -- libde265 is an open source implementation of the h.265 video codec. It is written from scratch and has a plain C API to enable a simple integration into other software. libde265 supports WPP and tile-based multithreading and includes SSE optimizations. The decoder includes all features of the Main profile and correctly decodes almost all conformance streams (see [[wiki page](https://github.com/strukturag/libde265/wiki/Decoder-conformance)]).
- **libexpat** [ğŸ“](./libexpat) [ğŸŒ](https://github.com/GerHobbelt/libexpat) -- XML read/write
- **libheif** [ğŸ“](./libheif) [ğŸŒ](https://github.com/GerHobbelt/heif) -- High Efficiency Image File Format (HEIF) :: a visual media container format standardized by the Moving Picture Experts Group (MPEG) for storage and sharing of images and image sequences. It is based on the well-known ISO Base Media File Format (ISOBMFF) standard. HEIF Reader/Writer Engine is an implementation of HEIF standard in order to demonstrate its powerful features and capabilities.
- **libheif-alt** [ğŸ“](./libheif-alt) [ğŸŒ](https://github.com/GerHobbelt/libheif) -- an ISO/IEC 23008-12:2017 HEIF and AVIF (AV1 Image File Format) file format decoder and encoder. HEIF and AVIF are new image file formats employing HEVC (h.265) or AV1 image coding, respectively, for the best compression ratios currently possible.
- **libics** [ğŸ“](./libics) [ğŸŒ](https://github.com/GerHobbelt/libics) -- the reference library for ICS (Image Cytometry Standard), an open standard for writing images of any dimensionality and data type to file, together with associated information regarding the recording equipment or recorded subject.
  
  ICS stands for Image Cytometry Standard, and was first proposed in: P. Dean, L. Mascio, D. Ow, D. Sudar, J. Mullikin, "Propsed standard for image cytometry data files", Cytometry, n.11, pp.561-569, 1990. 
  
  It writes 2 files, one is the header, with an '.ics' extension, and the other is the actual image data (with an '.ids' extension.)
  
  ICS version 2.0 extends this standard to allow for a more versatile placement of the image data. It can now be placed either in the same '.ics' file or inbedded in any other file, by specifying the file name and the byte offset for the data.
  
  The advantage of ICS over other open standards such as TIFF is that it allows data of any type and dimensionality to be stored. A TIFF file can contain a collection of 2D images; it's up to the user to determine how these relate to each other. An ICS file can contain, for exmaple, a 5D image in which the 4th dimension is the light frequency and the 5th time. Also, all of the information regarding the microscope settings (or whatever instument was used to acquire the image) and the sample preparation can be included in the file.

- **libmetalink** [ğŸ“](./libmetalink) [ğŸŒ](https://github.com/GerHobbelt/libmetalink) -- a library to read Metalink XML download description format. It supports both [_Metalink version 3_](http://www.metalinker.org/Metalink_3.0_Spec.pdf) and [_Metalink version 4 (RFC 5854)_](https://tools.ietf.org/html/rfc5854).
- **libmobi** [ğŸ“](./libmobi) [ğŸŒ](https://github.com/GerHobbelt/libmobi) -- a library for handling Mobipocket/Kindle (MOBI) ebook format documents.
- **libpsd** [ğŸ“](./libpsd) [ğŸŒ](https://github.com/GerHobbelt/libpsd) -- a library for Adobe Photoshop `.psd` file's decoding and rendering.
- **LibRaw** [ğŸ“](./LibRaw) [ğŸŒ](https://github.com/GerHobbelt/LibRaw) -- a library for reading and processing of RAW files generated by digital photo cameras.
- **libsndfile** [ğŸ“](./libsndfile) [ğŸŒ](https://github.com/GerHobbelt/libsndfile) -- a C library for reading and writing files containing sampled audio data, e.g. Ogg, Vorbis and FLAC.
- **libultrahdr** [ğŸ“](./libultrahdr) [ğŸŒ](https://github.com/GerHobbelt/libultrahdr) -- libultrahdr is an image compression library that uses gain map technology to store and distribute HDR images. Conceptually on the encoding side, the library accepts SDR and HDR rendition of an image and from these a Gain Map (quotient between the two renditions) is computed. The library then uses backward compatible means to store the base image (SDR), gain map image and some associated metadata.
- **libwarc** [ğŸ“](./libwarc) [ğŸŒ](https://github.com/GerHobbelt/libwarc) -- C++ library to parse WARC files. WARC is the official storage format of the Internet Archive for storing scraped content. WARC format used: http://bibnum.bnf.fr/WARC/WARC_ISO_28500_version1_latestdraft.pdf
- **libxml2** [ğŸ“](./libxml2) [ğŸŒ](https://github.com/GerHobbelt/libxml2) -- [libxml](http://xmlsoft.org/): XML read/write
- **libzip** [ğŸ“](./libzip) [ğŸŒ](https://github.com/GerHobbelt/libzip) -- a C library for reading, creating, and modifying zip and zip64 archives.
- **LLhttp-parser** [ğŸ“](./LLhttp-parser) [ğŸŒ](https://github.com/GerHobbelt/llhttp) -- a port and replacement of [http_parser](https://github.com/nodejs/http-parser) to TypeScript. [llparse](https://github.com/nodejs/llparse) is used to generate the output C source file, which could be compiled and linked with the embedder's program (like Node.js).
- **magika** [ğŸ“](./magika) [ğŸŒ](https://github.com/GerHobbelt/magika) -- is a novel AI-powered file type detection tool that relies on the recent advance of deep learning to provide accurate detection. Under the hood, Magika employs a custom, highly optimized model that only weighs about a few MBs, and enables precise file identification within milliseconds, even when running on a single CPU. Magika has been trained and evaluated on a dataset of ~100M samples across 200+ content types (covering both binary and textual file formats), and it achieves an average ~99% accuracy on our test set.
- **mcmd** [ğŸ“](./mcmd) [ğŸŒ](https://github.com/GerHobbelt/mcmd) -- MCMD (M-Command): a set of commands for handling large scale CSV data. **MCMD** (called as M-Command) is a set of commands that are developed for the purpose of high-speed processing of large-scale structured tabular data in CSV format. It is possible to efficiently process large scale data with hundred millions row of records on a standard PC.
- **metalink-cli** [ğŸ“](./metalink-cli) [ğŸŒ](https://github.com/GerHobbelt/command) -- a small program which generates a metalink record on `stdout` for every file given on the commandline and using the mirror list from `stdin`.
- **metalink-mini-downloader** [ğŸ“](./metalink-mini-downloader) [ğŸŒ](https://github.com/GerHobbelt/mini-downloader) -- a small metalink downloader written in C++, using boost, libcurl and expat. It can either be compiled so that it downloads a specific file and then (optionally) launches it or be compiled into a "downloader template", which can later be used to create a custom downloader by replacing text strings inside the executable (they are marked in a special way, to make this easy).
- **mht-rip** [ğŸ“](./mht-rip) [ğŸŒ](https://github.com/GerHobbelt/mht-rip) -- as I have several HTML pages stored in this MHTML format. See also CHM: `CHM-lib`
- **mime-mega** [ğŸ“](./mime-mega) [ğŸŒ](https://github.com/GerHobbelt/MegaMimes) -- MIME extract/insert/encode/decode: use for MHTML support
- **mimetic** [ğŸ“](./mimetic) [ğŸŒ](https://github.com/GerHobbelt/mimetic) -- MIME: use for MHTML support
- **minizip-ng** [ğŸ“](./minizip-ng) [ğŸŒ](https://github.com/GerHobbelt/minizip-ng) -- a zip manipulation library written in C that is supported on Windows, macOS, and Linux. Minizip was originally developed by [Gilles Vollant](https://www.winimage.com/zLibDll/minizip.html) in 1998. It was first included in the zlib distribution as an additional code contribution starting in zlib 1.1.2. Since that time, it has been continually improved upon and contributed to by many people. The original [project](https://github.com/madler/zlib/tree/master/contrib/minizip) can still be found in the zlib distribution that is maintained by Mark Adler.
- **netpbm** [ğŸ“](./netpbm) [ğŸŒ](https://github.com/GerHobbelt/netpbm-mirror) -- a toolkit for manipulation of graphic images, including conversion of images between a variety of different formats.  There are over 300 separate tools in the package including converters for about 100 graphics formats.  Examples of the sort of image manipulation we're talking about are: Shrinking an image by 10%; Cutting the top half off of an image; Making a mirror image; Creating a sequence of images that fade from one image to another, etc.
- **OpenEXR** [ğŸ“](./OpenEXR) [ğŸŒ](https://github.com/GerHobbelt/openexr) -- a high dynamic-range (HDR) image file format developed by Industrial Light & Magic (ILM) for use in computer imaging applications.
- **openexr-images** [ğŸ“](./openexr-images) [ğŸŒ](https://github.com/GerHobbelt/openexr-images) -- collection of images associated with the OpenEXR distribution.
- **OpenImageIO** [ğŸ“](./oiio) [ğŸŒ](https://github.com/GerHobbelt/oiio) -- Reading, writing, and processing images in a wide variety of file formats, using a format-agnostic API, aimed at VFX applications.
  
  Also includes:
  
  - an ImageCache class that transparently manages a cache so that it can access truly vast amounts of image data (tens of thousands of image files totaling multiple TB) very efficiently using only a tiny amount (tens of megabytes at most) of runtime memory.
  - ImageBuf and ImageBufAlgo functions, which constitute a simple class for storing and manipulating whole images in memory, plus a collection of the most useful computations you might want to do involving those images, including many image processing operations.
  
  The primary target audience for OIIO is VFX studios and developers of tools such as renderers, compositors, viewers, and other image-related software you'd find in a production pipeline.

- **openimageio-mupdf** [ğŸ“](./openimageio-mupdf) [ğŸŒ](https://github.com/GerHobbelt/openimageio-mupdf) -- an [OpenImageIO](https://github.com/imageio/imageio) plugin for the mupdf library which enables us to read/fetch/view every page in a given PDF file as a ready-to-use image.
- **pdf2htmlEX** [ğŸ“](./pdf2htmlEX) [ğŸŒ](https://github.com/GerHobbelt/pdf2htmlEX) -- convert PDF to HTML without losing text or format.
- **PhotoshopAPI** [ğŸ“](./PhotoshopAPI) [ğŸŒ](https://github.com/GerHobbelt/PhotoshopAPI) -- a C++20 Library for reading and writing of Photoshop Files (`*.psd` and `*.psb`) based on previous works from [psd_sdk](https://github.com/MolecularMatters/psd_sdk), [pytoshop](https://github.com/mdboom/pytoshop) and [psd-tools](https://github.com/psd-tools/psd-tools). As well as the official [Photoshop File Format Specification](https://web.archive.org/web/20231122064257/https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/), where applicable. The motivation to create another library despite all the other works present is that there isn't a library which has layer editing as a first class citizen while also supporting all bit-depths known to Photoshop ("8-bits", "16-bits", "32-bits").
- **picohttpparser** [ğŸ“](./picohttpparser) [ğŸŒ](https://github.com/GerHobbelt/picohttpparser) -- PicoHTTPParser is a tiny, primitive, fast HTTP request/response parser. Unlike most parsers, it is stateless and does not allocate memory by itself. All it does is accept pointer to buffer and the output structure, and setups the pointers in the latter to point at the necessary portions of the buffer.
- **pisa_formatter** [ğŸ“](./pisa_formatter) [ğŸŒ](https://github.com/GerHobbelt/pisa_formatter) -- converts list of documents to the [pisa-engine](https://github.com/pisa-engine/pisa) binary format: {.docs, .freqs, .sizes}. Its input should be a text file where each line is a document.  Each document starts with the document name (which should not have whitespaces) followed by a list of ascii terms separated by whitespaces which define the document. This also generates a binary .terms file which has the information to convert from term to index and is used by the query_transformer executable. This file stores all the unique terms from all the documents.
- **psd_sdk** [ğŸ“](./psd_sdk) [ğŸŒ](https://github.com/GerHobbelt/psd_sdk) -- a C++ library that directly reads Photoshop PSD files. The library supports:
  
  * Groups
  * Nested layers
  * Smart Objects
  * User and vector masks
  * Transparency masks and additional alpha channels
  * 8-bit, 16-bit, and 32-bit data in grayscale and RGB color mode
  * All compression types known to Photoshop
  
  Additionally, limited export functionality is also supported.

- **qs_parse** [ğŸ“](./qs_parse) [ğŸŒ](https://github.com/GerHobbelt/qs_parse) -- a set of simple and easy functions for parsing URL query strings, such as those generated in an HTTP GET form submission.
- **rapidcsv** [ğŸ“](./rapidcsv) [ğŸŒ](https://github.com/GerHobbelt/rapidcsv) -- an easy-to-use C++ CSV parser library. It supports C++11 (and later), is header-only and comes with a basic test suite. The library was featured in the book [C++20 for Programmers](https://deitel.com/c-plus-plus-20-for-programmers/).
- **rawspeed** [ğŸ“](./rawspeed) [ğŸŒ](https://github.com/GerHobbelt/rawspeed) -- a library for decoding various images in RAW file format, while providing the fastest decoding speed possible. Supports the most common DSLR and similar class brands.
- **robotstxt** [ğŸ“](./robotstxt) [ğŸŒ](https://github.com/GerHobbelt/robotstxt) -- Google `robots.txt` Parser and Matcher Library. The Robots Exclusion Protocol (REP) is a standard that enables website owners to control which URLs may be accessed by automated clients (i.e. crawlers) through a simple text file with a specific syntax. It's one of the basic building blocks of the internet as we know it and what allows search engines to operate. Because the REP was only a de-facto standard for the past 25 years, different implementers implement parsing of robots.txt slightly differently, leading to confusion. This project aims to fix that by releasing the parser that Google uses.
- **SFML** [ğŸ“](./SFML) [ğŸŒ](https://github.com/GerHobbelt/SFML) -- Simple and Fast Multimedia Library (SFML) is a simple, fast, cross-platform and object-oriented multimedia API. It provides access to windowing, graphics, audio and network.
- **silk-codec** [ğŸ“](./silk-codec) [ğŸŒ](https://github.com/GerHobbelt/silk-codec) -- a library to convert PCM to TenCent Silk files and vice versa.
- **silk-v3-decoder** [ğŸ“](./silk-v3-decoder) [ğŸŒ](https://github.com/GerHobbelt/silk-v3-decoder) -- decodes Silk v3 audio files (like WeChat amr, aud files, qq slk files) and converts to other formats (like mp3).
- **sqawk** [ğŸ“](./sqawk) [ğŸŒ](https://github.com/GerHobbelt/sqawk) -- apply SQL on CSV files in the shell: `sqawk` imports CSV files into an on-the-fly SQLite database, and runs a user-supplied query on the data.
- **ssp** [ğŸ“](./ssp) [ğŸŒ](https://github.com/GerHobbelt/ssp) -- a header only CSV parser which is fast and versatile with modern C++ API. Requires compiler with C++17 support. Can also be used to efficiently convert strings to specific types. Conversion for floating point values invoked using [fast-float](https://github.com/fastfloat/fast_float).
- **taglib** [ğŸ“](./taglib) [ğŸŒ](https://github.com/GerHobbelt/taglib) -- TagLib is a library for reading and editing the metadata of several popular audio formats. Currently it supports both ID3v1 and [ID3v2][] for MP3 files, [Ogg Vorbis][] comments and ID3 tags in [FLAC][], MPC, Speex, WavPack, TrueAudio, WAV, AIFF, MP4, APE, and ASF files.
- **ticpp** [ğŸ“](./ticpp) [ğŸŒ](https://github.com/GerHobbelt/ticpp) -- TinyXML++: XML read/write
- **tidy-html5** [ğŸ“](./tidy-html5) [ğŸŒ](https://github.com/GerHobbelt/tidy-html5) -- clean up HTML documents before archiving/processing
- **tinyexr** [ğŸ“](./tinyexr) [ğŸŒ](https://github.com/GerHobbelt/tinyexr) -- Tiny OpenEXR: `tinyexr` is a small, single header-only library to load and save OpenEXR (.exr) images.
- **upskirt-markdown** [ğŸ“](./upskirt-markdown) [ğŸŒ](https://github.com/GerHobbelt/soldout) -- MarkDown renderer
  
  - **svg-charter** [ğŸ“](./svg-charter) [ğŸŒ](https://github.com/GerHobbelt/charter) -- SVG chart renderer
    
    - **tinyexpr** [ğŸ“](./tinyexpr) [ğŸŒ](https://github.com/GerHobbelt/tinyexpr) -- a very small recursive descent parser and evaluation engine for math expressions.

- **url-parser** [ğŸ“](./url-parser) [ğŸŒ](https://github.com/GerHobbelt/url.h) -- parse URLs much like Node's [url](http://nodejs.org/api/url.html) module.
- **warc2text** [ğŸ“](./warc2text) [ğŸŒ](https://github.com/GerHobbelt/warc2text) -- Extracts plain text, language identification and more metadata from WARC records.
- **xlnt** [ğŸ“](./xlnt) [ğŸŒ](https://github.com/GerHobbelt/xlnt) -- a modern C++ library for manipulating spreadsheets in memory and reading/writing them from/to XLSX files as described in [ECMA 376 4th edition](http://www.ecma-international.org/publications/standards/Ecma-376.htm).
- **xml-pugixml** [ğŸ“](./xml-pugixml) [ğŸŒ](https://github.com/GerHobbelt/pugixml) -- light-weight, simple and fast XML parser for C++ with XPath support.
- **xmlwrapp** [ğŸ“](./xmlwrapp) [ğŸŒ](https://github.com/GerHobbelt/xmlwrapp) -- a modern style C++ library for working with XML data, built atop the venerable libxml2 and libxslt C libraries.
- **xmunch** [ğŸ“](./xmunch) [ğŸŒ](https://github.com/GerHobbelt/xmunch) -- xmunch essentially does, what the 'munch' command of, for example, hunspell does, but is not compatible with hunspell affix definition files. So why use it then? What makes xmunch different from the other tools is the ability to extend incomplete word-lists. For hunspell's munch to identify a stem and add an affix mark, every word formed by the affix with the stem has to be in the original word-list. This makes sense for a compression tool. However if your word list is incomplete, you have to add all possible word-forms of a word first, before any compression is done. Using xmunch instead, you can define a subset of forms which are required to be in the word-list to allow the word to be used as stem. Like this, you can extend the word-list.
- **zsv** [ğŸ“](./zsv) [ğŸŒ](https://github.com/GerHobbelt/zsv) -- the world's fastest (SIMD) CSV parser, with an extensible CLI for SQL querying, format conversion and more.
- ~~**gmime** [ğŸŒ](https://github.com/jstedfast/gmime) (alternative repo [here](https://github.com/GNOME/gmime)) -- multipart MIME library; serves as a fundamental building block for full MHTML file format I/O support~~
  
  - **removed**; reason: GNOME libraries are horrible to integrate with other codebases.













	
----

ğŸ¡¸ [previous section](./0057-audio-files-processing.md)  |  ğŸ¡¹ [up](./0016-libraries-we-re-looking-at-for-this-intent.md)  |  ğŸ¡» [all (index)](./0103-libraries-in-this-collection.md)  |  ğŸ¡º [next section](./0059-bibtex-and-similar-library-metadata-formats-support.md)
