

### Solvers, Clustering, Monte Carlo, Decision Trees

- **adaptive_clustering** [ğŸ“](./adaptive_clustering) [ğŸŒ](https://github.com/GerHobbelt/adaptive_clustering) -- a lightweight and accurate point cloud clustering method from the paper Online learning for 3D LiDAR-based human detection: Experimental analysis of point cloud clustering and classification methods, Zhi Yan and Tom Duckett and Nicola Bellotto, 2019.
- **agglomerative-hierarchical-clustering** [ğŸ“](./agglomerative-hierarchical-clustering) [ğŸŒ](https://github.com/GerHobbelt/agglomerative-hierarchical-clustering) -- implements the [Agglomerative Hierarchical Clustering](http://en.wikipedia.org/wiki/Hierarchical_clustering) algorithm.
- **ArborX** [ğŸ“](./ArborX) [ğŸŒ](https://github.com/GerHobbelt/ArborX) -- a library designed to provide performance portable algorithms for geometric search, similarly to nanoflann and Boost Geometry.
- **baobzi** [ğŸ“](./baobzi) [ğŸŒ](https://github.com/GerHobbelt/baobzi) -- an adaptive fast function approximator based on tree search. Word salad aside, `baobzi` is a tool to convert very CPU intensive function calculations into relatively cheap ones (at the cost of memory). This is similar to functions like `chebeval` in `MATLAB`, but can be significantly faster since the order of the polynomial fit can be much much lower to meet similar tolerances. It also isn't constrained for use only in `MATLAB`. Internally, `baobzi` represents your function by a grid of binary/quad/oct/N trees, where the leaves represent the function in some small sub-box of the function's domain with chebyshev polynomials. When you evaluate your function at a point with baobzi, it searches the tree for the box containing your point and evaluates using this approximant.
- **brown-cluster** [ğŸ“](./brown-cluster) [ğŸŒ](https://github.com/GerHobbelt/brown-cluster) -- the Brown hierarchical word clustering algorithm. Runs in $O(N C^2)$, where $N$ is the number of word types and $C$ is the number of clusters. Algorithm by Brown, et al.: Class-Based n-gram Models of Natural Language, http://acl.ldc.upenn.edu/J/J92/J92-4003.pdf
- **clustercat** [ğŸ“](./clustercat) [ğŸŒ](https://github.com/GerHobbelt/clustercat) -- a fast, flexible word clustering software, ClusterCat induces word classes from unannotated text. Word classes are unsupervised part-of-speech tags, requiring no manually-annotated corpus. Words are grouped together that share syntactic/semantic similarities. They are used in many dozens of applications within natural language processing, machine translation, neural net training, and related fields.
- **CppNumericalSolvers** [ğŸ“](./CppNumericalSolvers) [ğŸŒ](https://github.com/GerHobbelt/CppNumericalSolvers) -- a header-only C++17 BFGS / L-BFGS-B optimization library.
- **dbscan** [ğŸ“](./dbscan) [ğŸŒ](https://github.com/GerHobbelt/dbscan) -- Density-Based Spatial Clustering of Applications with Noise (DBSCAN) and Related Algorithms: a fast C++ (re)implementation of several density-based algorithms with a focus on the DBSCAN family for clustering spatial data. The package includes: DBSCAN, HDBSCAN, OPTICS/OPTICSXi, FOSC, Jarvis-Patrick clustering, LOF (Local outlier factor), GLOSH (Global-Local Outlier Score from Hierarchies), kd-tree based kNN search, Fixed-radius NN search
- **dbscan_kdtree** [ğŸ“](./dbscan_kdtree) [ğŸŒ](https://github.com/GerHobbelt/dbscan_kdtree) -- fast Implementation of DBSCAN using Kd-tree for acceleration. The use case is clustering point cloud (PCL library used).
- **depth_clustering** [ğŸ“](./depth_clustering) [ğŸŒ](https://github.com/GerHobbelt/depth_clustering) -- a fast and robust algorithm to segment point clouds taken with Velodyne sensor into objects. It works with all available Velodyne sensors, i.e. 16, 32 and 64 beam ones.
- **FIt-SNE** [ğŸ“](./FIt-SNE) [ğŸŒ](https://github.com/GerHobbelt/FIt-SNE) -- FFT-accelerated implementation of t-Stochastic Neighborhood Embedding ([t-SNE](https://lvdmaaten.github.io/tsne/)), which is a highly successful method for dimensionality reduction and visualization of high dimensional datasets.  A popular [implementation](https://github.com/lvdmaaten/bhtsne) of t-SNE uses the Barnes-Hut algorithm to approximate the gradient at each iteration of gradient descent.
- **fityk** [ğŸ“](./fityk) [ğŸŒ](https://github.com/GerHobbelt/fityk) -- a program for nonlinear fitting of analytical functions (especially peak-shaped) to data (usually experimental data). To put it differently, it is primarily peak fitting software, but can handle other types of functions as well. Apart from the actual fitting, the program helps with data processing and provides ergonomic graphical interface (and also command line interface and scripting API -- but if the program is popular in some fields, it's thanks to its graphical interface). It is reportedly__ used in crystallography, chromatography, photoluminescence and photoelectron spectroscopy, infrared and Raman spectroscopy, to name but a few. Fityk offers various nonlinear fitting methods, simple background subtraction and other manipulations to the dataset, easy placement of peaks and changing of peak parameters, support for analysis of series of datasets, automation of common tasks with scripts, and much more.
- **GALGO-2.0** [ğŸ“](./GALGO-2.0) [ğŸŒ](https://github.com/GerHobbelt/GALGO-2.0) -- Genetic Algorithm in C++ with template metaprogramming and abstraction for constrained optimization. GALGO is a C++ template library, header only, designed to solve a problem under constraints (or not) by maximizing or minimizing an objective function on given boundaries. GALGO can also achieve multi-objective optimization. GALGO is based on chromosomes represented as a binary string of 0 and 1 containing the encoded parameters to be estimated. The user is free to choose the number of bits N to encode each one of them within the interval \[1,64].
- **galib** [ğŸ“](./galib) [ğŸŒ](https://github.com/GerHobbelt/galib) -- modern GAlib: a (modernized) C++ Genetic Algorithm Library. With GAlib you can add evolutionary algorithm optimization to almost any program using any data representation and standard or custom selection, crossover, mutation, scaling, and termination methods.
- **genieclust** [ğŸ“](./genieclust) [ğŸŒ](https://github.com/GerHobbelt/genieclust) -- a faster and more powerful version of *Genie* (Fast and Robust Hierarchical Clustering with Noise Point Detection) â€“ a robust and outlier resistant clustering algorithm (see Gagolewski, Bartoszuk, Cena, 2016).
- **gram_savitzky_golay** [ğŸ“](./gram_savitzky_golay) [ğŸŒ](https://github.com/GerHobbelt/gram_savitzky_golay) -- Savitzky-Golay filtering based on Gram polynomials, as described in [General Least-Squares Smoothing and Differentiation by the Convolution (Savitzky-Golay) Method](http://pubs.acs.org/doi/pdf/10.1021/ac00205a007)
- **hdbscan** [ğŸ“](./hdbscan) [ğŸŒ](https://github.com/GerHobbelt/hdbscan) -- a fast parallel implementation for HDBSCAN* [[1]](https://dl.acm.org/doi/10.1145/2733381) (hierarchical DBSCAN). The implementation stems from our parallel algorithms [[2]](https://arxiv.org/pdf/2104.01126.pdf) developed at MIT, and presented at SIGMOD 2021. Our approach is based on generating a well-separated pair decomposition followed by using Kruskal's minimum spanning tree algorithm and bichromatic closest pair computations. We also give a new parallel divide-and-conquer algorithm for computing the dendrogram, which are used in visualizing clusters of different scale that arise for HDBSCAN*.
- **hdbscan-cpp** [ğŸ“](./hdbscan-cpp) [ğŸŒ](https://github.com/GerHobbelt/hdbscan-cpp) -- Fast and Efficient Implementation of HDBSCAN in C++ using STL. HDBSCAN - Hierarchical Density-Based Spatial Clustering of Applications with Noise. Performs DBSCAN over varying epsilon values and integrates the result to find a clustering that gives the best stability over epsilon. This allows HDBSCAN to find clusters of varying densities (unlike DBSCAN), and be more robust to parameter selection. In practice this means that HDBSCAN returns a good clustering straight away with little or no parameter tuning -- and the primary parameter, minimum cluster size, is intuitive and easy to select. HDBSCAN is ideal for exploratory data analysis; it's a fast and robust algorithm that you can trust to return meaningful clusters (if there are any).
- **ifopt** [ğŸ“](./ifopt) [ğŸŒ](https://github.com/GerHobbelt/ifopt) -- a modern, light-weight, [Eigen]-based C++ interface to Nonlinear Programming solvers, such as Ipopt and Snopt.
- **Ipopt** [ğŸ“](./Ipopt) [ğŸŒ](https://github.com/GerHobbelt/Ipopt) -- Ipopt (Interior Point OPTimizer, pronounced eye-pea-Opt) is a software package for large-scale [nonlinear optimization](http://wiki.mcs.anl.gov/NEOS/index.php/Nonlinear_Programming_FAQ). It is designed to find (local) solutions of mathematical optimization problems.
- **kiwi** [ğŸ“](./kiwi) [ğŸŒ](https://github.com/GerHobbelt/kiwi) -- Kiwi is an efficient C++ implementation of the Cassowary constraint solving algorithm. Kiwi is an implementation of the algorithm based on the `seminal Cassowary paper <https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf>`_. It is *not* a refactoring of the original C++ solver. Kiwi has been designed from the ground up to be lightweight and fast. Kiwi ranges from 10x to 500x faster than the original Cassowary solver with typical use cases gaining a 40x improvement. Memory savings are consistently > 5x.
- **LBFGS-Lite** [ğŸ“](./LBFGS-Lite) [ğŸŒ](https://github.com/GerHobbelt/LBFGS-Lite) -- a header-only L-BFGS unconstrained optimizer.
- **libclustering_dim_redux** [ğŸ“](./libclustering_dim_redux) [ğŸŒ](https://github.com/GerHobbelt/libclustering_dim_redux) -- C++ code for dimension reduction, Kohonen maps (SOMs), t-SNE, PCA, kNN, ...
- **liblbfgs** [ğŸ“](./liblbfgs) [ğŸŒ](https://github.com/GerHobbelt/liblbfgs) -- libLBFGS: C library of limited-memory BFGS (L-BFGS), a C port of the implementation of Limited-memory Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) method written by Jorge Nocedal. The original FORTRAN source code is available at: http://www.ece.northwestern.edu/~nocedal/lbfgs.html
- **libMultiRobotPlanning** [ğŸ“](./libMultiRobotPlanning) [ğŸŒ](https://github.com/GerHobbelt/libMultiRobotPlanning) -- a library with search algorithms primarily for task and path planning for multi robot/agent systems. It is written in C++(14), highly templated for good performance, and comes with useful examples. The following algorithms are currently supported: A\*, A\* epsilon (also known as focal search), SIPP (Safe Interval Path Planning), Conflict-Based Search (CBS), Enhanced Conflict-Based Search (ECBS), Conflict-Based Search with Optimal Task Assignment (CBS-TA), Enhanced Conflict-Based Search with Optimal Task Assignment (ECBS-TA), Prioritized Planning using SIPP (example code for SIPP), Minimum sum-of-cost (flow-based; integer costs; any number of agents/tasks) and Best Next Assignment (series of optimal solutions)
- **lmfit** [ğŸ“](./lmfit) [ğŸŒ](https://github.com/GerHobbelt/lmfit) -- least squares fitting Files Levenberg-Marquardt least squares minimization and curve fitting. To minimize arbitrary user-provided functions, or to fit user-provided data. No need to provide derivatives.
- **LMW-tree** [ğŸ“](./LMW-tree) [ğŸŒ](https://github.com/GerHobbelt/LMW-tree) -- LMW-tree: learning m-way tree is a generic template library written in C++ that implements several algorithms that use the m-way nearest neighbor tree structure to store their data. See the related [PhD thesis](http://eprints.qut.edu.au/75862/) for more details on m-way nn trees. The algorithms are primarily focussed on computationally efficient clustering. Clustering is an unsupervised machine learning process that finds interesting patterns in data. It places similar items into clusters and dissimilar items into different clusters. The data structures and algorithms can also be used for nearest neighbor search, supervised learning and other machine learning applications. The package includes EM-tree, K-tree, k-means, TSVQ, repeated k-means, clustering, random projections, random indexing, hashing, bit signatures. See the related [PhD thesis](http://eprints.qut.edu.au/75862/) for more details these algorithms and representations.
- **mapreduce** [ğŸ“](./mapreduce) [ğŸŒ](https://github.com/GerHobbelt/mapreduce) -- the MapReduce-MPI (MR-MPI) library. MapReduce is the operation popularized by Google for computing on large distributed data sets.  See the Wikipedia entry on MapReduce for an overview of what a MapReduce is. The MR-MPI library is a simple, portable implementation of MapReduce that runs on any serial desktop machine or large parallel machine using MPI message passing.
- **mathtoolbox** [ğŸ“](./mathtoolbox) [ğŸŒ](https://github.com/GerHobbelt/mathtoolbox) -- mathematical tools (interpolation, dimensionality reduction, optimization, etc.) written in C++11 and [Eigen](http://eigen.tuxfamily.org/).
- **mcl** [ğŸ“](./mcl) [ğŸŒ](https://github.com/GerHobbelt/mcl) -- MCL: Markov CLustering or the Markov CLuster algorithm, MCL is a method for clustering weighted or simple networks, a.k.a. graphs.  It is accompanied in this source code by other network-related programs, one of which is RCL (restricted contingency linkage) for fast multi-resolution consensus clustering.  The algorithm was conceived in 1998 and [first published in a technical report in 1998](https://ir.cwi.nl/pub/4604). A PhD thesis and three more technical reports [followed in 2000](https://micans.org/mcl/index.html?sec_thesisetc). The paper "van Dongen, Stijn: Graph clustering via a discrete uncoupling process, Siam Journal on Matrix Analysis and Applications 30-1, p121-141, 2008" [https://doi.org/10.1137/040608635](https://doi.org/10.1137/040608635)  is the result of a long-winded review process that started in 2000 and lay dormant for a long time, for reasons not entirely untypical within the realms of scientific publishing. This MCL implementation is fast, threaded, and uses sparse matrices. It runs on a single machine and can use multiple CPUs.
- **mcmc-jags** [ğŸ“](./mcmc-jags) [ğŸŒ](https://github.com/GerHobbelt/mcmc-jags) -- JAGS (Just Another Gibbs Sampler), a program for analysis of Bayesian Graphical models by Gibbs Sampling.
- **MicroPather** [ğŸ“](./MicroPather) [ğŸŒ](https://github.com/GerHobbelt/MicroPather) -- a path finder and A* solver (astar or a-star) written in platform independent C++ that can be easily integrated into existing code. MicroPather focuses on being a path finding engine for video games but is a generic A* solver.
- **Multicore-TSNE** [ğŸ“](./Multicore-TSNE) [ğŸŒ](https://github.com/GerHobbelt/Multicore-TSNE) -- Multicore t-SNE is a multicore modification of [Barnes-Hut t-SNE](https://github.com/lvdmaaten/bhtsne) by L. Van der Maaten with Python CFFI-based wrappers. This code also works **faster than sklearn.TSNE** on 1 core (as of version 0.18).
- **nlopt** [ğŸ“](./nlopt) [ğŸŒ](https://github.com/GerHobbelt/nlopt) -- a library for nonlinear local and global optimization, for functions with and without gradient information.  It is designed as a simple, unified interface and packaging of several free/open-source nonlinear optimization libraries.
- **nlopt-util** [ğŸ“](./nlopt-util) [ğŸŒ](https://github.com/GerHobbelt/nlopt-util) -- a single-header utility library for calling NLopt optimization in a single line using Eigen::VectorXd.
- **openGA** [ğŸ“](./openGA) [ğŸŒ](https://github.com/GerHobbelt/openGA) -- a free C++ Genetic Algorithm library.
- **openlibm** [ğŸ“](./openlibm) [ğŸŒ](https://github.com/GerHobbelt/openlibm) -- [OpenLibm](https://openlibm.org/) is an effort to have a high quality, portable, standalone C mathematical library ([`libm`](http://en.wikipedia.org/wiki/libm)). The project was born out of a need to have a good `libm` for the [Julia programming language](http://www.julialang.org) that worked consistently across compilers and operating systems, and in 32-bit and 64-bit environments.
- **optframe** [ğŸ“](./optframe) [ğŸŒ](https://github.com/GerHobbelt/optframe) -- OptFrame: a C++ Optimization Framework from the paper: OptFrame: a computational framework for combinatorial optimization problems. Coelho, I.M., Ribas, S., PerchÃ©, M.H.P., Munhoz, P., Souza, M.J.F., Ochi, L.S. (2010), in Anais do XLII SimpÃ³sio Brasileiro de Pesquisa Operacional (SBPO). Bento GonÃ§alves-RS, pp 1887-1898.
- **or-tools** [ğŸ“](./or-tools) [ğŸŒ](https://github.com/GerHobbelt/or-tools) -- Google Optimization Tools (a.k.a., OR-Tools) is an open-source, fast and portable software suite for solving combinatorial optimization problems. The suite includes a constraint programming solver, a linear programming solver and various graph algorithms.
- **osqp** [ğŸ“](./osqp) [ğŸŒ](https://github.com/GerHobbelt/osqp) -- the Operator Splitting Quadratic Program Solver.
- **osqp-cpp** [ğŸ“](./osqp-cpp) [ğŸŒ](https://github.com/GerHobbelt/osqp-cpp) -- a C++ wrapper for [OSQP](https://github.com/oxfordcontrol/osqp), an [ADMM](http://stanford.edu/~boyd/admm.html)-based solver for [quadratic programming](https://en.wikipedia.org/wiki/Quadratic_programming). Compared with OSQP's native C interface, the wrapper provides a more convenient input format using Eigen sparse matrices and handles the lifetime of the `OSQPWorkspace` struct. This package has similar functionality to [osqp-eigen](https://github.com/robotology/osqp-eigen).
- **osqp-eigen** [ğŸ“](./osqp-eigen) [ğŸŒ](https://github.com/GerHobbelt/osqp-eigen) -- a simple C++ wrapper for [osqp](http://osqp.readthedocs.io/en/latest/index.html) library.
- **paramonte** [ğŸ“](./paramonte) [ğŸŒ](https://github.com/GerHobbelt/paramonte) -- ParaMonte (Plain Powerful Parallel Monte Carlo Library) is a serial/parallel library of Monte Carlo routines for sampling mathematical objective functions of arbitrary-dimensions, in particular, the posterior distributions of Bayesian models in data science, Machine Learning, and scientific inference, with the design goal of unifying the **automation** (of Monte Carlo simulations), **user-friendliness** (of the library), **accessibility** (from multiple programming environments), **high-performance** (at runtime), and **scalability** (across many parallel processors).
- **quile** [ğŸ“](./quile) [ğŸŒ](https://github.com/GerHobbelt/quile) -- QuilÃ« is a C++20 header-only general purpose genetic algorithms library with no external dependencies supporting floating-point, integer, binary and permutation representations.
- **rgf** [ğŸ“](./rgf) [ğŸŒ](https://github.com/GerHobbelt/rgf) -- Regularized Greedy Forest (RGF) is a tree ensemble machine learning method described in [this paper](https://arxiv.org/abs/1109.0887). RGF can deliver better results than gradient boosted decision trees (GBDT) on a number of datasets and it has been used to win a few Kaggle competitions. Unlike the traditional boosted decision tree approach, RGF works directly with the underlying forest structure. RGF integrates two ideas: one is to include tree-structured regularization into the learning formulation; and the other is to employ the fully-corrective regularized greedy algorithm.
- **RNGSobol** [ğŸ“](./RNGSobol) [ğŸŒ](https://github.com/GerHobbelt/RNGSobol) -- Sobol quadi-random numbers generator (C++). Note that unlike pseudo-random numbers, quasi-random numbers care about dimensionality of points.
- **scilab** [ğŸ“](./scilab) [ğŸŒ](https://github.com/GerHobbelt/scilab) -- Scilab includes hundreds of mathematical functions. It has a high-level programming language allowing access to advanced data structures, 2-D and 3-D graphical functions.
- **SDLP** [ğŸ“](./SDLP) [ğŸŒ](https://github.com/GerHobbelt/SDLP) -- Seidel's LP Algorithm: Linear-Complexity Linear Programming (LP) for Small-Dimensions: this solver is super efficient for small-dimensional LP with any constraint number, mostly encountered in computational geometry. It enjoys [__linear complexity about the constraint number__](https://dl.acm.org/doi/10.1145/2422.322418).
- **sequential-line-search** [ğŸ“](./sequential-line-search) [ğŸŒ](https://github.com/GerHobbelt/sequential-line-search) -- a C++ library for performing the **sequential line search** method (which is a human-in-the-loop variant of **Bayesian optimization**), following the paper "Yuki Koyama, Issei Sato, Daisuke Sakamoto, and Takeo Igarashi. 2017. Sequential Line Search for Efficient Visual Design Optimization by Crowds. ACM Trans. Graph. 36, 4, pp.48:1--48:11 (2017). (a.k.a. Proceedings of SIGGRAPH 2017), DOI: https://doi.org/10.1145/3072959.3073598"
- **somoclu** [ğŸ“](./somoclu) [ğŸŒ](https://github.com/GerHobbelt/somoclu) -- a massively parallel implementation of self-organizing maps. It exploits multicore CPUs, it is able to rely on MPI for distributing the workload in a cluster, and it can be accelerated by CUDA. A sparse kernel is also included, which is useful for training maps on vector spaces generated in text mining processes.
- **sundials** [ğŸ“](./sundials) [ğŸŒ](https://github.com/GerHobbelt/sundials) -- SUNDIALS (SUite of Nonlinear and DIfferential/ALgebraic equation Solvers) is a family of software packages providing robust and efficient time integrators and nonlinear solvers that can easily be incorporated into existing simulation codes. The packages are designed to require minimal information from the user, allow users to supply their own data structures underneath the packages, and enable interfacing with user-supplied or third-party algebraic solvers and preconditioners.
- **theoretica** [ğŸ“](./theoretica) [ğŸŒ](https://github.com/GerHobbelt/theoretica) -- a numerical and automatic math library for scientific research and graphical applications. Theoretica is a header-only mathematical library which provides algorithms for **systems simulation**, **statistical analysis** of lab data and **numerical approximation**, using a **functional** oriented paradigm to mimic **mathematical notation** and formulas. The aim of the library is to provide _simple_ access to powerful algorithms while keeping an _elegant_ and _transparent_ interface, enabling the user to focus on the problem at hand.
- **thrill** [ğŸ“](./thrill) [ğŸŒ](https://github.com/GerHobbelt/thrill) -- an *EXPERIMENTAL* C++ framework for algorithmic distributed Big Data batch computations on a cluster of machines. More information at [http://project-thrill.org](http://project-thrill.org).
- **uno-solver** [ğŸ“](./uno-solver) [ğŸŒ](https://github.com/GerHobbelt/Uno) -- a modern, modular solver for nonlinearly constrained nonconvex optimization.















	
----

ğŸ¡¸ [prev](./0038-regression-curve-fitting-polynomials-splines-geometrics-interpolation.md)  |  ğŸ¡¹ [up](./0022-pattern.md)  |  ğŸ¡º [next](./0040-distance-metrics-image-quality-metrics-image.md)
