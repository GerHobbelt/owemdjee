

### Regression, curve fitting, polynomials, splines, geometrics, interpolation, math

- **baobzi** [ğŸ“](./baobzi) [ğŸŒ](https://github.com/GerHobbelt/baobzi) -- an adaptive fast function approximator based on tree search. Word salad aside, `baobzi` is a tool to convert very CPU intensive function calculations into relatively cheap ones (at the cost of memory). This is similar to functions like `chebeval` in `MATLAB`, but can be significantly faster since the order of the polynomial fit can be much much lower to meet similar tolerances. It also isn't constrained for use only in `MATLAB`. Internally, `baobzi` represents your function by a grid of binary/quad/oct/N trees, where the leaves represent the function in some small sub-box of the function's domain with chebyshev polynomials. When you evaluate your function at a point with baobzi, it searches the tree for the box containing your point and evaluates using this approximant.
- **blaze** [ğŸ“](./blaze) [ğŸŒ](https://github.com/GerHobbelt/blaze) -- a high-performance C++ math library for dense and sparse arithmetic. With its state-of-the-art *Smart Expression Template* implementation **Blaze** combines the elegance and ease of use of a domain-specific language with HPC-grade performance, making it one of the most intuitive and fastest C++ math libraries available.
- **CDT** [ğŸ“](./CDT) [ğŸŒ](https://github.com/GerHobbelt/CDT) -- a numerically robust library for generating constraint or conforming Delaunay triangulations, while properly handling the corner-cases.
- **Clipper2** [ğŸ“](./Clipper2) [ğŸŒ](https://github.com/GerHobbelt/Clipper2) -- a Polygon <a href="https://en.wikipedia.org/wiki/Clipping_(computer_graphics)">Clipping</a> and <a href="https://en.wikipedia.org/wiki/Parallel_curve">Offsetting</a> library.
- **delaunator-cpp** [ğŸ“](./delaunator-cpp) [ğŸŒ](https://github.com/GerHobbelt/delaunator-cpp) -- a really fast C++ library for [Delaunay triangulation](https://en.wikipedia.org/wiki/Delaunay_triangulation) of 2D points.
- **fastops** [ğŸ“](./fastops) [ğŸŒ](https://github.com/GerHobbelt/fastops) -- vector operations library, which enables acceleration of bulk calls of certain math functions on AVX and AVX2 hardware. Currently supported operations are exp, log, sigmoid and tanh. The library itself implements operations using AVX and AVX2, but will work on any hardware with at least SSE2 support.
- **fastrange** [ğŸ“](./fastrange) [ğŸŒ](https://github.com/GerHobbelt/fastrange) -- a fast alternative to the modulo reduction. [It has accelerated some operations in Google's Tensorflow by 10% to 20%](https://github.com/tensorflow/tensorflow/commit/a47a300185026fe7829990def9113bf3a5109fed). Further reading : http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/ See also: Daniel Lemire, [Fast Random Integer Generation in an Interval](https://arxiv.org/abs/1805.10941), ACM Transactions on Modeling and Computer Simulation, January 2019 Article No. 3 https://doi.org/10.1145/3230636
- **figtree** [ğŸ“](./figtree) [ğŸŒ](https://github.com/GerHobbelt/figtree) -- FIGTree is a library that provides a C/C++ and MATLAB interface for speeding up the computation of the Gauss Transform.
- **fityk** [ğŸ“](./fityk) [ğŸŒ](https://github.com/GerHobbelt/fityk) -- a program for nonlinear fitting of analytical functions (especially peak-shaped) to data (usually experimental data). To put it differently, it is primarily peak fitting software, but can handle other types of functions as well. Apart from the actual fitting, the program helps with data processing and provides ergonomic graphical interface (and also command line interface and scripting API -- but if the program is popular in some fields, it's thanks to its graphical interface). It is reportedly__ used in crystallography, chromatography, photoluminescence and photoelectron spectroscopy, infrared and Raman spectroscopy, to name but a few. Fityk offers various nonlinear fitting methods, simple background subtraction and other manipulations to the dataset, easy placement of peaks and changing of peak parameters, support for analysis of series of datasets, automation of common tasks with scripts, and much more.
- **float_compare** [ğŸ“](./float_compare) [ğŸŒ](https://github.com/GerHobbelt/float_compare) -- C++ header providing floating point value comparators with user-specifiable tolerances and behaviour.
- **fmath** [ğŸ“](./fmath) [ğŸŒ](https://github.com/GerHobbelt/fmath) -- fast approximate function of exponential function exp and log: includes `fmath::log`, `fmath::exp`, `fmath::expd`.
- **gmt** [ğŸ“](./gmt) [ğŸŒ](https://github.com/GerHobbelt/gmt) -- GMT (Generic Mapping Tools) is an open source collection of about 100 command-line tools for manipulating geographic and Cartesian data sets (including filtering, trend fitting, gridding, projecting, etc.) and producing high-quality illustrations ranging from simple x-y plots via contour maps to artificially illuminated surfaces, 3D perspective views and animations. The GMT supplements add another 50 more specialized and discipline-specific tools. GMT supports over 30 map projections and transformations and requires support data such as [GSHHG](http://www.soest.hawaii.edu/pwessel/gshhg/) coastlines, rivers, and political boundaries and optionally [DCW](http://www.soest.hawaii.edu/pwessel/dcw) country polygons.
- **half** [ğŸ“](./half) [ğŸŒ](https://github.com/GerHobbelt/half) -- IEEE 754-based half-precision floating point library forked from http://half.sourceforge.net/. This is a C++ header-only library to provide an IEEE 754 conformant 16-bit half-precision floating-point type along with corresponding arithmetic operators, type conversions and common mathematical functions. It aims for both efficiency and ease of use, trying to accurately mimic the behaviour of the built-in floating-point types at the best performance possible.
- **hilbert_curves** [ğŸ“](./hilbert_curves) [ğŸŒ](https://github.com/GerHobbelt/hilbert_curves) -- the world's fastest implementations of 2D and 3D hilbert curve functions.
- **hilbert_hpp** [ğŸ“](./hilbert_hpp) [ğŸŒ](https://github.com/GerHobbelt/hilbert_hpp) -- contains two implementations of the hilbert curve encoding & decoding algorithm described by John Skilling in his paper "Programming the Hilbert Curve".
- **ifopt** [ğŸ“](./ifopt) [ğŸŒ](https://github.com/GerHobbelt/ifopt) -- a modern, light-weight, [Eigen]-based C++ interface to Nonlinear Programming solvers, such as Ipopt and Snopt.
- **ink-stroke-modeler** [ğŸ“](./ink-stroke-modeler) [ğŸŒ](https://github.com/GerHobbelt/ink-stroke-modeler) -- smoothes raw freehand input and predicts the input's motion to minimize display latency. It turns noisy pointer input from touch/stylus/etc. into the beautiful stroke patterns of brushes/markers/pens/etc. Be advised that this library was designed to model handwriting, and as such, prioritizes smooth, good-looking curves over precise recreation of the input.
- **Ipopt** [ğŸ“](./Ipopt) [ğŸŒ](https://github.com/GerHobbelt/Ipopt) -- Ipopt (Interior Point OPTimizer, pronounced eye-pea-Opt) is a software package for large-scale [nonlinear optimization](http://wiki.mcs.anl.gov/NEOS/index.php/Nonlinear_Programming_FAQ). It is designed to find (local) solutions of mathematical optimization problems.
- **libhilbert** [ğŸ“](./libhilbert) [ğŸŒ](https://github.com/GerHobbelt/libhilbert) -- an implementation of the Chenyang, Hong, Nengchao 2008 IEEE N-dimensional Hilber mapping algorithm. The Hilbert generating genes are statically compiled into the library, thus producing a rather large executable size.  This library support the forward and backward mapping algorithms from  R_N -> R_1 and R_1 -> R_N. The library is used straigth forwardly and for guidance and documentation, see hilbertKey.h.
- **libInterpolate** [ğŸ“](./libInterpolate) [ğŸŒ](https://github.com/GerHobbelt/libInterpolate) -- a C++ interpolation library, which provides classes to perform various types of 1D and 2D function interpolation (linear, spline, etc.).
- **libMultiRobotPlanning** [ğŸ“](./libMultiRobotPlanning) [ğŸŒ](https://github.com/GerHobbelt/libMultiRobotPlanning) -- a library with search algorithms primarily for task and path planning for multi robot/agent systems. It is written in C++(14), highly templated for good performance, and comes with useful examples. The following algorithms are currently supported: A\*, A\* epsilon (also known as focal search), SIPP (Safe Interval Path Planning), Conflict-Based Search (CBS), Enhanced Conflict-Based Search (ECBS), Conflict-Based Search with Optimal Task Assignment (CBS-TA), Enhanced Conflict-Based Search with Optimal Task Assignment (ECBS-TA), Prioritized Planning using SIPP (example code for SIPP), Minimum sum-of-cost (flow-based; integer costs; any number of agents/tasks) and Best Next Assignment (series of optimal solutions)
- **lmfit** [ğŸ“](./lmfit) [ğŸŒ](https://github.com/GerHobbelt/lmfit) -- least squares fitting Files Levenberg-Marquardt least squares minimization and curve fitting. To minimize arbitrary user-provided functions, or to fit user-provided data. No need to provide derivatives.
- **lol** [ğŸ“](./lol) [ğŸŒ](https://github.com/GerHobbelt/lol) -- the header-only part of the Lol (Math) Engine framework.
- **lolremez** [ğŸ“](./lolremez) [ğŸŒ](https://github.com/GerHobbelt/lolremez) -- LolRemez is a Remez algorithm implementation to approximate functions using polynomials.
- **magsac** [ğŸ“](./magsac) [ğŸŒ](https://github.com/GerHobbelt/magsac) -- (MAGSAC++ had been included in OpenCV) the MAGSAC and MAGSAC++ algorithms for robust model fitting without using a single inlier-outlier threshold.
- **mathtoolbox** [ğŸ“](./mathtoolbox) [ğŸŒ](https://github.com/GerHobbelt/mathtoolbox) -- mathematical tools (interpolation, dimensionality reduction, optimization, etc.) written in C++11 and [Eigen](http://eigen.tuxfamily.org/).
- **mlinterp** [ğŸ“](./mlinterp) [ğŸŒ](https://github.com/GerHobbelt/mlinterp) -- a fast C++ routine for linear interpolation in arbitrary dimensions (i.e., multilinear interpolation).
- **nlopt-util** [ğŸ“](./nlopt-util) [ğŸŒ](https://github.com/GerHobbelt/nlopt-util) -- a single-header utility library for calling NLopt optimization in a single line using Eigen::VectorXd.
- **openlibm** [ğŸ“](./openlibm) [ğŸŒ](https://github.com/GerHobbelt/openlibm) -- [OpenLibm](https://openlibm.org/) is an effort to have a high quality, portable, standalone C mathematical library ([`libm`](http://en.wikipedia.org/wiki/libm)). The project was born out of a need to have a good `libm` for the [Julia programming language](http://www.julialang.org) that worked consistently across compilers and operating systems, and in 32-bit and 64-bit environments.
- **PointCloudSegmentation** [ğŸ“](./PointCloudSegmentation) [ğŸŒ](https://github.com/GerHobbelt/PointCloudSegmentation) -- three algorithms on point cloud segmentation used in the following paper: Pairwise Linkage for Point Cloud Segmentation, Xiaohu Lu, etc. ISPRS2016. https://github.com/xiaohulugo/xiaohulugo.github.com/blob/master/papers/PLinkage_Point_Segmentation_ISPRS2016.pdf
- **polatory** [ğŸ“](./polatory) [ğŸŒ](https://github.com/GerHobbelt/polatory) -- a fast and memory-efficient framework for RBF (radial basis function) interpolation. Polatory can perform kriging prediction via RBF interpolation (dual kriging). Although different terminologies are used, both methods produce the same results.
- **poly2tri** [ğŸ“](./poly2tri) [ğŸŒ](https://github.com/GerHobbelt/poly2tri) -- Sweepâ€line algorithm for constrained Delaunay triangulation, Domiter V. and Zalik B. (2008). Note: since there are no Input validation of the data given for triangulation you need to think about this. Poly2Tri does not support repeat points within epsilon.
- **qHilbert** [ğŸ“](./qHilbert) [ğŸŒ](https://github.com/GerHobbelt/qHilbert) -- a vectorized speedup of Hilbert curve generation using SIMD intrinsics. A hilbert curve is a space filling self-similar curve that provides a mapping between 2D space to 1D, and 1D to 2D space while preserving locality between mappings. Hilbert curves split a finite 2D space into recursive quadrants(similar to a [full quad-tree](https://en.wikipedia.org/wiki/Quadtree)) and traverse each quadrant in recursive "U" shapes at each iteration such that every quadrant gets fully visited before moving onto the next one. qHilbert is an attempt at a vectorized speedup of mapping multiple linear 1D indices into planar 2D points in parallel that is based on the Butz Algorithm's utilization of Gray code.
- **radon-tf** [ğŸ“](./radon-tf) [ğŸŒ](https://github.com/GerHobbelt/radon-tf) -- simple implementation of the radon transform. Faster when using more than one thread to execute it. No inverse function is provided. CPU implementation only.
- **RNGSobol** [ğŸ“](./RNGSobol) [ğŸŒ](https://github.com/GerHobbelt/RNGSobol) -- Sobol quadi-random numbers generator (C++). Note that unlike pseudo-random numbers, quasi-random numbers care about dimensionality of points.
- **rotate** [ğŸ“](./rotate) [ğŸŒ](https://github.com/GerHobbelt/rotate) -- provides several classic, commonly used and novel rotation algorithms (aka block swaps), which were documented since around 1981 up to 2021: three novel rotation algorithms were introduced in 2021, notably the [trinity rotation](https://github.com/scandum/rotate#Trinity-Rotation).
- **RRD** [ğŸ“](./RRD) [ğŸŒ](https://github.com/GerHobbelt/RRD) -- RRD: Rotation-Sensitive Regression for Oriented Scene Text Detection
- **RRPN** [ğŸ“](./RRPN) [ğŸŒ](https://github.com/GerHobbelt/RRPN) -- (Arbitrary-Oriented Scene Text Detection via Rotation Proposals)[https://arxiv.org/abs/1703.01086]
- **rtl** [ğŸ“](./rtl) [ğŸŒ](https://github.com/GerHobbelt/rtl) -- _RANSAC Template Library (RTL)_ is an open-source robust regression tool especially with RANSAC family. RTL aims to provide fast, accurate, and easy ways to estimate any model parameters with data contaminated with outliers (incorrect data). RTL includes recent RANSAC variants with their performance evaluation with several models with synthetic and real data. _RANdom SAmple Consensus (RANSAC)_ is an iterative method to make any parameter estimator strong against outliers. For example of line fitting, RANSAC enable to estimate a line parameter even though data points include wrong point observations far from the true line.
- **ruy** [ğŸ“](./ruy) [ğŸŒ](https://github.com/GerHobbelt/ruy) -- a matrix multiplication library. Its focus is to cover the matrix multiplication needs of neural network inference engines. Its initial user has been TensorFlow Lite, where it is used by default on the ARM CPU architecture. `ruy` supports both floating-point and 8-bit-integer-quantized matrices.
- **scilab** [ğŸ“](./scilab) [ğŸŒ](https://github.com/GerHobbelt/scilab) -- Scilab includes hundreds of mathematical functions. It has a high-level programming language allowing access to advanced data structures, 2-D and 3-D graphical functions.
- **sequential-line-search** [ğŸ“](./sequential-line-search) [ğŸŒ](https://github.com/GerHobbelt/sequential-line-search) -- a C++ library for performing the **sequential line search** method (which is a human-in-the-loop variant of **Bayesian optimization**), following the paper "Yuki Koyama, Issei Sato, Daisuke Sakamoto, and Takeo Igarashi. 2017. Sequential Line Search for Efficient Visual Design Optimization by Crowds. ACM Trans. Graph. 36, 4, pp.48:1--48:11 (2017). (a.k.a. Proceedings of SIGGRAPH 2017), DOI: https://doi.org/10.1145/3072959.3073598"
- **sod** [ğŸ“](./sod) [ğŸŒ](https://github.com/GerHobbelt/sod) -- SOD is an embedded, modern cross-platform computer vision and machine learning software library that exposes a set of APIs for deep-learning, advanced media analysis & processing including real-time, multi-class object detection and model training on embedded systems with limited computational resource and IoT devices. SOD was built to provide a common infrastructure for computer vision applications and to accelerate the use of machine perception in open source as well commercial products.
- **Sophus** [ğŸ“](./Sophus) [ğŸŒ](https://github.com/GerHobbelt/Sophus) -- a C++ implementation of Lie groups commonly used for 2d and 3d geometric problems (i.e. for Computer Vision or Robotics applications). Among others, this package includes the special orthogonal groups SO(2) and SO(3) to present rotations in 2d and 3d as well as the special Euclidean group SE(2) and SE(3) to represent rigid body transformations (i.e. rotations and translations) in 2d and 3d.
- **spline** [ğŸ“](./spline) [ğŸŒ](https://github.com/GerHobbelt/spline) -- a lightweight C++ cubic spline interpolation library.
- **splinter** [ğŸ“](./splinter) [ğŸŒ](https://github.com/GerHobbelt/splinter) -- SPLINTER (SPLine INTERpolation) is a library for *multivariate function approximation with splines*. The library can be used for function approximation, regression, data smoothing, data reduction, and much more. Spline approximations are represented by a speedy C++ implementation of the tensor product B-spline. The B-spline consists of piecewise polynomial basis functions, offering a high flexibility and smoothness. The B-spline can be fitted to data using ordinary least squares (OLS), possibly with regularization. The library also offers construction of penalized splines (P-splines).
- **sse2neon** [ğŸ“](./sse2neon) [ğŸŒ](https://github.com/GerHobbelt/sse2neon) -- converts Intel SSE intrinsics to Arm/Aarch64 NEON intrinsics, shortening the time needed to get an Arm working program that then can be used to extract profiles and to identify hot paths in the code.
- **sse-popcount** [ğŸ“](./sse-popcount) [ğŸŒ](https://github.com/GerHobbelt/sse-popcount) -- SIMD popcount; sample programs for my article http://0x80.pl/articles/sse-popcount.html / Faster Population Counts using AVX2 Instructions (https://arxiv.org/abs/1611.07612)
- **theoretica** [ğŸ“](./theoretica) [ğŸŒ](https://github.com/GerHobbelt/theoretica) -- a numerical and automatic math library for scientific research and graphical applications. Theoretica is a header-only mathematical library which provides algorithms for **systems simulation**, **statistical analysis** of lab data and **numerical approximation**, using a **functional** oriented paradigm to mimic **mathematical notation** and formulas. The aim of the library is to provide _simple_ access to powerful algorithms while keeping an _elegant_ and _transparent_ interface, enabling the user to focus on the problem at hand.
- **tindicators** [ğŸ“](./tindicators) [ğŸŒ](https://github.com/GerHobbelt/tindicators) -- a library of technical analysis indicators. It provides over 160 indicators and is blazing fast.
- **tinynurbs** [ğŸ“](./tinynurbs) [ğŸŒ](https://github.com/GerHobbelt/tinynurbs) -- a lightweight header-only C++14 library for Non-Uniform Rational B-Spline curves and surfaces. The API is simple to use and the code is readable while being efficient.
- **tinyspline** [ğŸ“](./tinyspline) [ğŸŒ](https://github.com/GerHobbelt/tinyspline) -- TinySpline is a small, yet powerful library for interpolating, transforming, and querying arbitrary NURBS, B-Splines, and BÃ©zier curves.
- **TrianglePP** [ğŸ“](./TrianglePP) [ğŸŒ](https://github.com/GerHobbelt/TrianglePP) -- Triangle++ is a C++ wrapper for the original J.P. Shevchuk's 2005 C-language *Triangle* package. The library can create standard **Delaunay** triangulations and their duals, i.e. **Voronoi** diagrams (aka Dirichlet tessellations). Additionally it can generate **quality Delaunay** triangulations (where we can set bounds on the areas and angles of the resulting triangles) and **constrained Delaunay** triangulations (where we can connect some points with and edge and require that this edge will be part of the result).
- **tweeny** [ğŸ“](./tweeny) [ğŸŒ](https://github.com/GerHobbelt/tweeny) -- an inbetweening library designed for the creation of complex animations for games and other beautiful interactive software. It leverages features of modern C++ to empower developers with an intuitive API for declaring tweenings of any type of value, as long as they support arithmetic operations. The goal of Tweeny is to provide means to create fluid interpolations when animating position, scale, rotation, frames or other values of screen objects, by setting their values as the tween starting point and then, after each tween step, plugging back the result.















	
----

ğŸ¡¸ [prev](./0037-random-generators-all-things.md)  |  ğŸ¡¹ [up](./0022-pattern.md)  |  ğŸ¡º [next](./0039-solvers-clustering-monte-carlo-decision.md)
