











### run-time library core features: logging, formatting, ...

- **binary_log** [ğŸ“](./binary_log) [ğŸŒ](https://github.com/GerHobbelt/binary_log) -- a fast C++20 library which logs messages in a compact binary format while using [fmtlib](https://github.com/fmtlib/fmt) to format the logs.
- **cfgpath** [ğŸ“](./cfgpath) [ğŸŒ](https://github.com/GerHobbelt/cfgpath) -- cross platform methods for obtaining paths to configuration files
- **clp** [ğŸ“](./clp) [ğŸŒ](https://github.com/GerHobbelt/clp) -- YScope's Compressed Log Processor (CLP) compresses your logs, and allows you to search the compressed logs without decompression. CLP supports both JSON logs and unstructured (i.e., free text) logs. It also supports real-time log compression within several logging libraries. CLP also includes purpose-built web interfaces for searching and viewing the compressed logs.
- **cpptrace** [ğŸ“](./cpptrace) [ğŸŒ](https://github.com/GerHobbelt/cpptrace) -- a simple and portable C++ stacktrace library supporting C++11 and greater on Linux, macOS, and Windows including MinGW and Cygwin environments. The goal: Make stack traces simple for once.
- **detect-character-encoding** [ğŸ“](./detect-character-encoding) [ğŸŒ](https://github.com/GerHobbelt/detect-character-encoding) -- detect character encoding using [ICU](http://site.icu-project.org).  **Tip:** If you donâ€™t need ICU in particular, consider using [ced](https://github.com/sonicdoe/ced), which is based on Googleâ€™s lighter [compact_enc_det](https://github.com/google/compact_enc_det) library.
- **detox** [ğŸ“](./detox) [ğŸŒ](https://github.com/GerHobbelt/detox) -- renames files to make them easier to work with under Linux and other Unix-like operating systems.  Spaces and various other unsafe characters (such as "`$`") get replaced with "`_`".  The upper portion of ISO-8859-1 (Latin-1) can be transcoded to UTF-8, as can CP-1252.
- **dunce** [ğŸ“](./dunce) [ğŸŒ](https://github.com/GerHobbelt/dunce) -- Dunce (de-UNC): in Windows the regular paths (`C:\foo`) are supported by all programs, but have lots of bizarre restrictions for backwards compatibility with MS-DOS. There are also Windows NT UNC paths (`\\?\C:\foo`), which are more robust and with fewer gotchas, but are rarely supported by Windows programs â€” even Microsoft's own! Dunce converts Windows UNC paths to the MS-DOS-compatible format whenever possible, but leaves UNC paths as-is when they can't be unambiguously expressed in a simpler way. This allows legacy programs to access all paths they can possibly access, and doesn't break any paths for UNC-aware programs. For example, `\\?\C:\Windows` will be converted to `C:\Windows`, but `\\?\C:\COM` will be left as-is, because it contains a reserved filename.  Dunce's handling of UNC paths is safer than just unconditionally stripping the `\\` prefix, because naively stripped UNC paths with hostnames change to relative directory paths. There are
- **easyloggingpp** [ğŸ“](./easyloggingpp) [ğŸŒ](https://github.com/GerHobbelt/easyloggingpp) -- Easylogging++ is single header efficient logging library for C++ applications. It is extremely powerful, highly extendable and configurable to user's requirements. It provides ability to write your own _sinks_ (via a feature referred as `LogDispatchCallback`).
- **expected-lite** [ğŸ“](./expected-lite) [ğŸŒ](https://github.com/GerHobbelt/expected-lite) -- a single-file header-only library to represent value objects that either contain a valid value or an error. The library is a partly implementation of the proposal for [`std::expected`](https://en.cppreference.com/w/cpp/utility/expected) for use with C++11 and later.
- **fast_double_parser** [ğŸ“](./fast_double_parser) [ğŸŒ](https://github.com/GerHobbelt/fast_double_parser) -- 4x faster than `strtod()`. Unless you need support for [RFC 7159](https://tools.ietf.org/html/rfc7159) (JSON standard), we encourage users to adopt [fast_float](https://github.com/fastfloat/fast_float) library instead. It has more functionality. Fast function to parse ASCII strings containing decimal numbers into double-precision (binary64) floating-point values.  That is, given the string "1.0e10", it should return a 64-bit floating-point value equal to 10000000000. We do not sacrifice accuracy. The function will match exactly (down the smallest bit) the result of a standard function like `strtod`.
- **fast_float** [ğŸ“](./fast_float) [ğŸŒ](https://github.com/GerHobbelt/fast_float) -- fast and exact implementation of the C++ `from_chars` functions for float and double types: 4x faster than `strtod`
- **fast-hex** [ğŸ“](./fast-hex) [ğŸŒ](https://github.com/GerHobbelt/fast-hex) -- a fast, SIMD (vectorized) hex string encoder/decoder.
- **fast_io** [ğŸ“](./fast_io) [ğŸŒ](https://github.com/GerHobbelt/fast_io) -- a C++20 input/output library that provides exceptional speed and is designed to replace the commonly used `<iostream>` and `<cstdio>` libraries.
- **FastString** [ğŸ“](./FastString) [ğŸŒ](https://github.com/GerHobbelt/FastString) -- fast, in stack, fixed size string implementation with **constexpr noexcept** constructors and accessors. **FastString** improves **memory locality and latency** of strings by avoiding heap allocations.
- **fluent-bit** [ğŸ“](./fluent-bit) [ğŸŒ](https://github.com/GerHobbelt/fluent-bit) -- [Fluent Bit](http://fluentbit.io) is a fast Log Processor and Forwarder for Linux, Windows, Embedded Linux, MacOS and BSD family operating systems. It's part of the Graduated [Fluentd](http://fluentd.org) Ecosystem and a [CNCF](https://cncf.io) sub-project. Fluent Bit allows to collect log events or metrics from different sources, process them and deliver them to different backends such as [Fluentd](http://fluentd.org), Elasticsearch, Splunk, DataDog, Kafka, New Relic, Azure services, AWS services, Google services, NATS, InfluxDB or any custom HTTP end-point.
- **fmt** [ğŸ“](./fmt) [ğŸŒ](https://github.com/GerHobbelt/fmt) -- advanced C++ data-to-text formatter. The modern answer to classic `printf()`.
- **fmtlog** [ğŸ“](./fmtlog) [ğŸŒ](https://github.com/GerHobbelt/fmtlog) -- a performant fmtlib-style logging library with latency in nanoseconds (i.e. using fmt library format).
- **frozen** [ğŸ“](./frozen) [ğŸŒ](https://github.com/GerHobbelt/frozen) -- provides 0 cost initialization for immutable containers, fixed-size containers, and various algorithms.
- **hedley** [ğŸ“](./hedley) [ğŸŒ](https://github.com/GerHobbelt/hedley) -- a C/C++ header file designed to smooth over some platform-specific annoyances.
- **hypertextcpp** [ğŸ“](./hypertextcpp) [ğŸŒ](https://github.com/GerHobbelt/hypertextcpp) -- string/text template engine & source-to-source compiler.
- **libetpan** [ğŸ“](./libetpan) [ğŸŒ](https://github.com/GerHobbelt/libetpan) -- this mail library provides a portable, efficient framework for different kinds of mail access: IMAP, SMTP, POP and NNTP.
- **libpathutils** [ğŸ“](./libpathutils) [ğŸŒ](https://github.com/GerHobbelt/libpathutils) -- cross-platform filesystem path utility functions
- **libpfm4** [ğŸ“](./libpfm4) [ğŸŒ](https://github.com/GerHobbelt/libpfm4) -- a helper library to develop monitoring tools exploiting the performance monitoring events such as those provided by the Performance Monitoring Unit (PMU) of modern processors.
- **libquill** [ğŸ“](./libquill) [ğŸŒ](https://github.com/GerHobbelt/quill) -- a cross-platform low latency logging library based on C++14.
- **libscanf** [ğŸ“](./libscanf) [ğŸŒ](https://github.com/GerHobbelt/scnlib) -- a modern C++ library for replacing `scanf` and `std::istream`. This library attempts to move us ever so closer to replacing `iostream`s and C stdio altogether. It's faster than `iostream` (see Benchmarks) and type-safe, unlike `scanf`. Think [{fmt}](https://github.com/fmtlib/fmt) but in the other direction.
- **libwil** [ğŸ“](./libwil) [ğŸŒ](https://github.com/GerHobbelt/wil) -- The Windows Implementation Libraries (WIL) is a header-only C++ library created to make life easier for developers on Windows through readable type-safe C++ interfaces for common Windows coding patterns.
- **libxo** [ğŸ“](./libxo) [ğŸŒ](https://github.com/GerHobbelt/libxo) -- `libxo` allows an application to generate text, XML, JSON, and HTML output using a common set of function calls (rather than the application using old skool `printf()`).  The application decides at run time which output style should be produced.
- **linecook** [ğŸ“](./linecook) [ğŸŒ](https://github.com/GerHobbelt/linecook) -- a C library for editing the command line, much like the [readline](https://tiswww.cwru.edu/php/chet/readline/readline.html) library used in <b>bash</b> and <b>gdb</b>.
- **lnav** [ğŸ“](./lnav) [ğŸŒ](https://github.com/GerHobbelt/lnav) -- the Log File Navigator, **lnav** for short, is an advanced log file viewer for the small-scale.  It is a terminal application that can understand your log files and make it easy for you to find problems with little to no setup.
- **lwlog** [ğŸ“](./lwlog) [ğŸŒ](https://github.com/GerHobbelt/lwlog) -- a very fast C++17 logging library, which includes a static pre-allocated memory buffer for string manipulations to minimize dynamic memory allocations and promotes memory reuse and improves performance for high-frequency logging scenarios.
- **magic_enum** [ğŸ“](./magic_enum) [ğŸŒ](https://github.com/GerHobbelt/magic_enum) -- Header-only C++17 library provides static reflection for enums; works with any enum type without any macro or boilerplate code.
- **messagebox-windows** [ğŸ“](./messagebox-windows) [ğŸŒ](https://github.com/GerHobbelt/messagebox-windows) -- drive `MessageBox` and `MessageBeep` Win32 APIs
- **microsoft-performance-toolkit-sdk** [ğŸ“](./microsoft-performance-toolkit-sdk) [ğŸŒ](https://github.com/GerHobbelt/microsoft-performance-toolkit-sdk) -- The Microsoft Performance Toolkit is a collection of cross-platform tools developers can use to create and extend performance analysis applications. It serves as the runtime of the Windows Performance Analyzer, a Windows program included in the Windows Performance Toolkit. By using the Microsoft Performance Toolkit SDK, Windows Performance Analyzer - or any performance analysis application - can be configured to process and display performance data from arbitrary sources.
- **NanoLog** [ğŸ“](./NanoLog) [ğŸŒ](https://github.com/GerHobbelt/NanoLog) -- an extremely performant nanosecond scale logging system for C++ that exposes a simple printf-like API and achieves over 80 million logs/second at a median latency of just over 7 nanoseconds.
- **numero** [ğŸ“](./numero) [ğŸŒ](https://github.com/GerHobbelt/numero) -- a library which parses/extracts a decimal number, either integer or floating-point, either in scientific notation or not, from the given input string. It uses the thousands and decimal separator symbols given in the conversion options. It also provides methods for the inverse operation, i.e. converting a value to a (English) human-readable text, e.g. "one thousand and twenty four" for `1024`.
- **oppat** [ğŸ“](./oppat) [ğŸŒ](https://github.com/GerHobbelt/oppat) -- Open Power/Performance Analysis Tool (OPPAT) is a cross-OS, cross-architecture Power and Performance Analysis Tool. cross-OS: supports Windows ETW trace files and Linux/Android perf/trace-cmd trace files. cross-architecture: supports Intel and ARM chips hardware events (using perf and/or PCM).
- **pcg-cpp-random** [ğŸ“](./pcg-cpp-random) [ğŸŒ](https://github.com/GerHobbelt/pcg-cpp) -- a C++ implementation of the PCG family of random number generators, which are fast, statistically excellent, and offer a number of useful features.
- **pcg-c-random** [ğŸ“](./pcg-c-random) [ğŸŒ](https://github.com/GerHobbelt/pcg-c) -- a C implementation of the PCG family of random number generators, which are fast, statistically excellent, and offer a number of useful features.
- **plf_nanotimer** [ğŸ“](./plf_nanotimer) [ğŸŒ](https://github.com/GerHobbelt/plf_nanotimer) -- high precision cross-platform performance timer
- **prio_queue** [ğŸ“](./prio_queue) [ğŸŒ](https://github.com/GerHobbelt/prio_queue) -- a cache friendly priority queue, done as a B-heap.
- **randen** [ğŸ“](./randen) [ğŸŒ](https://github.com/GerHobbelt/randen) -- What if we could default to attack-resistant random generators without excessive CPU cost? We introduce 'Randen', a new generator with security guarantees; it outperforms MT19937, pcg64_c32, Philox, ISAAC and ChaCha8 in real-world benchmarks. This is made possible by AES hardware acceleration and a large Feistel permutation.
- **random** [ğŸ“](./random) [ğŸŒ](https://github.com/GerHobbelt/random) -- random for modern C++ with a convenient API.
- **refl-cpp** [ğŸ“](./refl-cpp) [ğŸŒ](https://github.com/GerHobbelt/refl-cpp) -- static reflection for C++17 (compile-time enumeration, attributes, proxies, overloads, template functions, metaprogramming).
- **reflect** [ğŸ“](./reflect) [ğŸŒ](https://github.com/GerHobbelt/reflect) -- a C++20 Static Reflection library with optimized run-time execution and binary size, fast compilation times and platform agnostic, minimal API. The library only provides basic reflection primitives and is not a full-fledged, heavy, implementation for https://wg21.link/P2996 which is a language proposal with many more features and capabilities.
- **result-cpp** [ğŸ“](./result-cpp) [ğŸŒ](https://github.com/GerHobbelt/result) -- `Result<T, E>` is a modern, simple, and light-weight error-handling alternative to C++ exceptions with a rich feature-set.
- **spdlog** [ğŸ“](./spdlog) [ğŸŒ](https://github.com/GerHobbelt/spdlog) -- very fast, header-only/compiled, C++ logging library.
- **spdlog_setup** [ğŸ“](./spdlog_setup) [ğŸŒ](https://github.com/GerHobbelt/spdlog_setup) -- file-based setup library for convenience in initializing spdlog.
- **sqlplot-tools** [ğŸ“](./sqlplot-tools) [ğŸŒ](https://github.com/GerHobbelt/sqlplot-tools) -- a tool to **process data series** from algorithm experiments **using SQL statements** and embed the results in **gnuplot** datafiles or **pgfplots** LaTeX files. Using SQL to generate plots can be see as **cracking a nut with a sledgehammer**, but it really works well in practice.
- **stdext-path** [ğŸ“](./stdext-path) [ğŸŒ](https://github.com/GerHobbelt/stdext-path) -- path manipulations (`dirname` et al)
  
  - **taolog** [ğŸ“](./taolog) [ğŸŒ](https://github.com/GerHobbelt/taolog) -- A Win32 logger based on DebugView & ETW.

- **stx-error-handling** [ğŸ“](./stx-error-handling) [ğŸŒ](https://github.com/GerHobbelt/STX) -- C++ 17 & C++ 20 error-handling and utility extensions.
- **TraceETW** [ğŸ“](./TraceETW) [ğŸŒ](https://github.com/GerHobbelt/TraceEtw) -- [Event Tracing for Windows (ETW)](http://msdn.microsoft.com/en-us/library/windows/desktop/aa363668(v=vs.85).aspx) is  powerful but notoriously complex. In C#, [EventSource](http://msdn.microsoft.com/en-us/library/system.diagnostics.tracing.eventsource(v=vs.110).aspx) made that technology much more approachable. This project aims at providing a similar solution for C++, both for Desktop apps and for Windows/Windows Phone Universal Store apps.
- **tscns** [ğŸ“](./tscns) [ğŸŒ](https://github.com/GerHobbelt/tscns) -- What's the problem with clock_gettime/gettimeofday/std::chrono::XXX_clock? Although current Linux systems are using VDSO to implement clock_gettime/gettimeofday/std::chrono::XXX_clock, they still have a nonnegligible overhead with latency from 20 to 100 ns. The problem is even worse on Windows as the latency is more unstable and could be as high as 1 us. Also on Windows, the high resolution clock is at only 100 ns precision. These problems are not good for time-critical tasks where high precison timestamp is required and latency of getting timestamp itself should be minimized.  TSCNS uses `rdtsc` instruction and simple arithmetic operations to implement a thread-safe clock with 1 ns precision, and is much faster and stable in terms of latency at less than 10 ns, comprising latency of `rdtsc` (4 ~ 7 ns depending on platforms) plus calculations in less than 1 ns.  TSCNS can be closely synchronized with the system clock, which makes it a good alternative of standard system clocks. However, real-time synchronization requires the clock to be calibrated at a proper interval, but it's a easy and cheap job to do.
- **utf8proc** [ğŸ“](./utf8proc) [ğŸŒ](https://github.com/GerHobbelt/utf8proc) -- [utf8proc](http://juliastrings.github.io/utf8proc/) is a small, clean C library that provides Unicode normalization, case-folding, and other operations for data in the [UTF-8 encoding](http://en.wikipedia.org/wiki/UTF-8).
- **wcwidth9** [ğŸ“](./wcwidth9) [ğŸŒ](https://github.com/GerHobbelt/wcwidth9) -- platform independent, header only, `wcwidth` with full Unicode 9 wide character support.
- **WinToast** [ğŸ“](./WinToast) [ğŸŒ](https://github.com/GerHobbelt/WinToast) -- a library which delivers a complete integration of the modern **toast notifications** of **Windows 8**, **Windows 10** and **Windows 11**.  Toast notifications allows your app to inform the users about relevant information and timely events that they should see and take action upon inside your app, such as a new instant message, a new friend request, breaking news, or a calendar event.
- ~~**merror** [ğŸ“](./merror) [ğŸŒ](https://github.com/GerHobbelt/merror) -- a library for error handling in C++ without exceptions.~~
  
  - **removed**; reason: code is non-portable to compilers other than GCC, or at least would require more effort than we're willing to expend on this.






	
----

ğŸ¡¸ [previous section](./0066-multi-processing-thread.md)  |  ğŸ¡¹ [up](./0056-multi-processing-core.md)  |  ğŸ¡» [all (index)](./0093-libraries-in-this.md)  |  ğŸ¡º [next section](./0068-web-servers-generic-sockets-i.md)
