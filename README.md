# owemdjee

Data Science & Image Processing amalgam library in C/C++.

This place is a gathering spot & integration workplace for the C & C++ libraries we choose to use.  Think "*FaÃ§ade Pattern*" and you're getting warm. ğŸ˜‰
The heavy data lifting will be done in the referenced libraries, while this lib will provide some glue and common ground for them to work in/with.


* [TOC](#owemdjee)
    * [Reason for this repo](#reason-for-this-repo)
        * [And?](#and)
        * [Critique?](#critique)
        * [Why is this repo a *solution*? And does it scale?](#why-is-this-repo-a-solution-and-does-it-scale)
* [Intent](#intent)
  * [Inter-process communications (IPC)](#inter-process-communications-ipc)
  * [Programming Languages used: *intent and purposes*](#programming-languages-used-intent-and-purposes)
  * [Scripting the System: Languages Considered for Scripting by Users](#scripting-the-system-languages-considered-for-scripting-by-users)
* [Libraries we're looking at for this *intent*](#libraries-were-looking-at-for-this-intent)











## Reason for this repo

`git submodules` hasn't been the most, ah, "user-friendly" methods to track and manage a set of libraries that you wish to track at *source level*.

A few problems have been repeatedly observed over our lifetime with `git`:

+ when it so happens that the importance & interest in a submoduled library is perhaps waning and you want to migrate to another, you can of course invoke `git` to ditch the old sow and bring in the shiny new one, but that stuff gets quite finicky when you are pedalling back & forth through your commit tree when, e.g. bughunting or maintenance work on a release branch which isn't up to snuff with the fashion kids yet.

  Yup, that's been much less of a problem since about 2018, but old scars need more than a pat on the arm to heal, if you get my drift.

+ folks haven't always been the happy campers they were supposed to be when they're facing a set of submodules and want to feel safe and sure in their "knowledge" that each library X is at commit Y, when the top of the module tree is itself at commit Z, for we are busy producing a production release, perhaps? That's a wee bit stressful and there have been enough "flukes" with git to make that a not-so-ironclad-as-we-would-like position.

  Over time, [I've created several bash shell scripts to help with that buzzin' feelin' of *absolute certainty*](https://github.com/GerHobbelt/developer-utility-commands). Useful perhaps, but the cuteness of those wears off pretty darn quickly when many nodes in the submodule tree start cluttering their git repo with those.











### And?

This repo is made to ensure we have a single point of reference for all the data munching stuff, at least.

We don't need to `git submodule add` all those data processing libs in our applications this way, as this is a single submodule to bother that project with. The scripts and other material in here will provide the means to ensure your build and test tools can quickly and easily ensure that everyone in here is at the commit spot they're supposed to be.

And when we want to add another lib about data/image processing, we do that in here, so the application-level git repo sees a very stable singular submodule all the time: this repo/lib, not the stuff that will change over time as external libs gain and loose momentum over time. (We're talking multiyear timespans here!)











### Critique?

It's not the most brilliant solution to our problems, as this, of course, becomes a single point of failure that way, but experience in the past with similar "solutions" has shown that it's maybe not always fun, but at least we keep track of the management crap in one place and that was worth it, every time.

And why not do away with `git submodule` entirely and use packages instead? Because this stuff is important enough that *other, quite painful experience* has shown us that (binary & source) packages are a wonder and a hassle too: I'ld rather have my code tracked and tagged at source level **all the way** because that has reduced several bug situations from man-*weeks* to man-*hours*: like Gentoo, compile it all, one compiler only.  Doesn't matter if the bug is in your own code or elsewhere, there are enough moments like that where one is helped enormously by the ability to step through *and possibly tweak a bit of code here or there temporarily to help the debugging process* that I, at least, prefer full source code.

And that's what this repo is here to provide: the source code gathered and ready for use on our machines.











### Why is this repo a *solution*? And does it scale?

The worst bit first: it scales like rotten eggs. The problem there is two-fold: first, there's (relatively) few people who want to track progress at the bleeding edge, so tooling is consequently limited in power and availability, compared to conservative approaches (count the number of *package managers* lately?).

Meanwhile, I'm in a spot where I *want* to ride the bleeding edge, at least most of the time, and I happen to *like* it that way: my world is much more *R&D* than *product maintenance*, so having a means to track, relatively easy, the latest developments in subjects and materiel of interest is a boon to me. Sure, I'll moan and rant about it once in a while, but if I wanted to really get rid of the need to be flexible and *adapt to changes*, sometimes often, I'ld have gone with the conservative stability of *package managers* and *LTS releases* already. Which I've done for other parts of my environment, but do not intend to do for the part which is largely covered by this repo: source libraries which I intend to use or am using already in research tools I'm developing for others and myself.

For that purpose, this repo is a *solution*, though -- granted -- a *sub-optimal one* in that it doesn't scale very well. I don't think there's any automated process available to make this **significantly faster and more scalable** anyway: the fact that I'm riding the bleeding edge and wish to be able to backpedal at will when the latest change of direction or state of affairs of a component is off the rails (from my perspective at least), requires me to be flexible and adaptable to the full gamut of change. There are alternative approaches, also within the `git` world, but they haven't shown real appeal vs. *old skool* `git submodules` -- which is cranky at times and a pain in the neck when you want to ditch something but still need it in another dev branch, *moan moan moan*, but anyway... -- so here we are.

> **Side note**: submodules which have been picked up for experimentation and inspection **but have been deleted from this A list later on** are ~~struck through~~ in the overview below: the rationale there is that we can thus still observe **why** we struck it off the list, *plus* never make the mistake of re-introducing it after a long time, forgetting that we once had a look already, *without* running into the struck-through entry and having to re-evaluate the reason at least, before we re-introduce an item.
>





---













# Intent

<!--```toc
```-->

* [TOC](#intent)
    * [Inter-process communications (IPC)](#inter-process-communications-ipc)
    * [Programming Languages used: *intent and purposes*](#programming-languages-used-intent-and-purposes)
    * [Scripting the System: Languages Considered for Scripting by Users](#scripting-the-system-languages-considered-for-scripting-by-users)











## Inter-process communications (IPC)

Lowest possible **run-time** cost, a.k.a. "run-time overhead": the aim is to have IPC which does not noticably impact UX (User Experience of the application: responsiveness / UI) on reeasonably powered machines. (Users are *not* expected to have the latest or fastest hardware.)

As *at least* large images will be transfered (PDF page renders) we need to have a binary-able protocol.











## Programming Languages used: *intent and purposes*

We expect to use these languages in processes which require this type of IPC:

- C / C++ (**backend No.1**)
  + PDF renderer ([mupdf](https://mupdf.com/))
  + metadata & annotations extractor ([mupdf](https://mupdf.com/) et al)
  + *very* probably also the database interface (SQLite)
  + \[page] image processing (leptonica, openCV, ImageMagick?, what-ever turns out to be useful and reasonable to integrate (particularly between PDF page renderer and OCR engine to help us provide a *user-tunable* PDF text+metadata extractor
  + OCR (tesseract)
  + "A.I."-assisted tooling to help process and *clean* PDFs: cover pages, abstract/summary extraction for meta-research, etc. (think ngrams, xdelta, SVM, tensors, author identification, document categorization, document similarity / \[*near*-]duplicate / revision detection, tagging, ...)
  + document identifier key generator a.k.a. **content hasher** for creating **unique** key for each document, which can be used as database record index, etc.
    * old: Qiqqa SHA1B
    * new: BLAKE3+Base36

- C# (**"business logic" / "middleware"**: the glue logic)
- Java (SOLR / Lucene: our choice for the "full text search database" ~ **backend No.2**)
- JavaScript (**UI**, mostly. Think [*electron*](https://www.electronjs.org/), *web browser*, [*Chromely*](https://chromely.net/)<sup>[also](https://github.com/chromelyapps/Chromely)</sup>, [*WebView2*](https://docs.microsoft.com/en-us/microsoft-edge/webview2/)<sup>[plus](https://developer.microsoft.com/en-us/microsoft-edge/webview2/)</sup>, that sort of thing)

Here we *intend* to use the regular SOLR APIs, which does not require specialized binary IPC.

We **may** **probably** choose to use a web-centric UI approach where images are *compressed* and *cached* in the *backend*, while being provided as \<picture> or \<img> tag references (URLs) in the HTML generated by the backend. *However*, we keep our options open ATM as furtheer testing is expected to hit a few obstacles there (smart caching required as we will be processing lots of documents in "background **bulk processes**" alongside the browsing and other more *direct* user activity) so a *websocket* or similar push technology may be employed: there we may benefit from dedicated IPC for large binary and text data transfers.











## Scripting the System: Languages Considered for Scripting by Users

Python has been considered. Given its loud presence in the AI communities, we still may integrate it one day. However, personally I'm not a big fan of the language and don't use it unless it's *prudent to do*, e.g. when extending or tweaking previous works produced by others.
Also, it turns out, it's not exactly *easy* to integrate (CPython) and I don't see a need for it beyond this one project / product: Qiqqa.

I've looked at Lua for a scripting language suitable for users (used quite a lot in the gaming industries and elsewhere); initial trials to get something going did not uncover major obstacles, but the question "_how do I **debug** Lua scripts?_" does not produce any viable project / product that goes beyond the *old skool `printf`-style debugging method*. Not a prime candidate therefor, as we expect that users will pick this up, when they like it, and grow the user scripts to unanticipated size and complexity: I've seen this happen multiple times in my career. Lua does not provide a scalable growth path from my perspective due to the lack of a *decent, customizable, debugger*.

Third candidate is JavaScript. While Artifex/mupdf comes with `mujs`, which is a simple engine it suffers from *two* drawbacks: it's ES5 and also does not provide a debugger mechanism beyond old skool `print`. Nice for nerds, but this is user-facing and thus not a viable option.

The other JavaScript engines considered are of varying size, performance and complexity. *Some* of them offer ways to integrate them with the \[F12] Chrome browser Developer Tools debugger, which would be *very nice to have available*. The road traveled there, along the various JavaScript engines is this:

- **cel-cpp** [ğŸ“](./cel-cpp) [ğŸŒ](https://github.com/GerHobbelt/cel-cpp) -- C++ Implementations of the Common Expression Language. For background on the Common Expression Language see the cel-spec repo. Common Expression Language specification: the Common Expression Language (CEL) implements common semantics for expression evaluation, enabling different applications to more easily interoperate. Key Applications are (1) Security policy: organizations have complex infrastructure and need common tooling to reason about the system as a whole and (2) Protocols: expressions are a useful data type and require interoperability across programming languages and platforms.
- **cel-spec** [ğŸ“](./cel-spec) [ğŸŒ](https://github.com/GerHobbelt/cel-spec) -- Common Expression Language specification: the Common Expression Language (CEL) implements common semantics for expression evaluation, enabling different applications to more easily interoperate. Key Applications are (1) Security policy: organizations have complex infrastructure and need common tooling to reason about the system as a whole and (2) Protocols: expressions are a useful data type and require interoperability across programming languages and platforms.
- **chibi-scheme** [ğŸ“](./chibi-scheme) [ğŸŒ](https://github.com/GerHobbelt/chibi-scheme) -- Chibi-Scheme is a very small library intended for use as an extension and scripting language in C programs.  In addition to support for lightweight VM-based threads, each VM itself runs in an isolated heap allowing multiple VMs to run simultaneously in different OS threads.
- **guile** [ğŸ“](./guile) [ğŸŒ](https://github.com/GerHobbelt/guile) -- Guile is Project GNU's extension language library. Guile is an implementation of the Scheme programming language, packaged as a library that can be linked into applications to give them their own extension language.  Guile supports other languages as well, giving users of Guile-based applications a choice of languages.
- **itcl** [ğŸ“](./itcl) [ğŸŒ](https://github.com/GerHobbelt/itcl) -- Itcl is an object oriented extension for Tcl.
- **jimtcl** [ğŸ“](./jimtcl) [ğŸŒ](https://github.com/GerHobbelt/jimtcl) -- the Jim Interpreter is a small-footprint implementation of the Tcl programming language written from scratch. Currently Jim Tcl is very feature complete with an extensive test suite (see the tests directory). There are some Tcl commands and features which are not implemented (and likely never will be), including traces and Tk. However, Jim Tcl offers a number of both Tcl8.5 and Tcl8.6 features ({*}, dict, lassign, tailcall and optional UTF-8 support) and some unique features. These unique features include [lambda] with garbage collection, a general GC/references system, arrays as syntax sugar for [dict]tionaries, object-based I/O and more. Other common features of the Tcl programming language are present, like the "everything is a string" behaviour, implemented internally as dual ported objects to ensure that the execution time does not reflect the semantic of the language :)
- **newlisp** [ğŸ“](./newlisp) [ğŸŒ](https://github.com/GerHobbelt/newlisp) -- newLISP is a LISP-like scripting language for doing things you typically do with scripting languages: programming for the internet, system administration, text processing, gluing other programs together, etc. newLISP is a scripting LISP for people who are fascinated by LISP's beauty and power of expression, but who need it stripped down to easy-to-learn essentials. newLISP is LISP reborn as a scripting language: pragmatic and casual, simple to learn without requiring you to know advanced computer science concepts. Like any good scripting language, newLISP is quick to get into and gets the job done without fuss. newLISP has a very fast startup time, is small on resources like disk space and memory and has a deep, practical API with functions for networking, statistics, machine learning, regular expressions, multiprocessing and distributed computing built right into it, not added as a second thought in external modules.
- **ScriptX** [ğŸ“](./ScriptX) [ğŸŒ](https://github.com/GerHobbelt/ScriptX) -- Tencent's [ScriptX](https://github.com/Tencent/ScriptX) is a script engine abstraction layer. A variety of script engines are encapsulated on the bottom and a unified API is exposed on the top, so that the upper-layer caller can completely isolate the underlying engine implementation (back-end).
  
  ScriptX not only isolates several JavaScript engines (e.g. V8 and QuickJS), but can even isolate different scripting languages, so that the upper layer can seamlessly switch between scripting engine and scripting language without changing the code.

- **tcl** [ğŸ“](./tcl) [ğŸŒ](https://github.com/GerHobbelt/tcl) -- the latest **Tcl** source distribution. Tcl provides a powerful platform for creating integration applications that tie together diverse applications, protocols, devices, and frameworks.
- **tclclockmod** [ğŸ“](./tclclockmod) [ğŸŒ](https://github.com/GerHobbelt/tclclockmod) -- TclClockMod is the fastest, most powerful Tcl clock engine written in C. This Tcl clock extension is the faster Tcl-module for the replacement of the standard "clock" ensemble of tcl.
- [Facebook's Hermes](https://github.com/facebook/hermes), [Samsung's Escargot](https://github.com/Samsung/escargot) and [XS/moddable](https://www.moddable.com/)<sup>[also](https://github.com/Moddable-OpenSource/moddable) [here](https://github.com/Moddable-OpenSource/moddable-xst)</sup>, which led me to [a webpage where various embeddable JS engines are compared size- and *performance*-wise](https://bellard.org/quickjs/bench.html).
- [Google's V8](https://v8.dev/)<sup>[here](https://github.com/v8/v8) [too](https://chromium.googlesource.com/v8/v8/+/84450a2239672109bcf537d6740b8babda521567)</sup>, as available in NodeJS, is deemed too complex for integration: when we go there, we could spend the same amount of effort on CPython integration -- though there again is the ever-present "how to debug this visually?!" question...)
- [JerryScript](https://github.com/jerryscript-project/jerryscript/): ES2017/2020 (good!), there's noises about Chrome Developer Tools on the Net for this one. Small, designed for embedded devices. I like that.
- mujs: ES5, no visual debugger. **Out.**
- [QuickJS](https://github.com/bellard/quickjs): ES2020, DevTools or [VS Code debugging](https://github.com/koush/vscode-quickjs-debug) seems to be available. Also comes with an interesting runtime: [txiki](https://github.com/saghul/txiki.js), which we still need to take a good look at.

**UPDATE 2021/June**: [JerryScript](https://github.com/jerryscript-project/jerryscript/), duktape, XS/moddable, escargot: these have been dropped as we picked QuickJS. After some initial hassle with that codebase, we picked a different branch to test, which was cleaner and compiled out of the box (CMake > MSVC), which is always a good omen for a codebase when you have cross-platform portability in mind.





---













# Libraries we're looking at for this *intent*:

<!--```toc
```-->

* [TOC](#libraries-we-re-looking-at-for-this-intent)
    * [IPC: flatbuffer et al for protocol design](#ipc-flatbuffer-et-al-for-protocol-design)
    * [IPC: websockets, etc.: all communication means](#ipc-websockets-etc-all-communication-means)
        * [ZeroMQ a.k.a. Ã˜MQ](#ipc-zeromq-aka-Ã¸mq)
        * [memory mapping](#ipc-memory-mapping)
    * [IPC: JSON for protocol design](#ipc-json-for-protocol-design)
    * [IPC: CBOR for protocol design](#ipc-cbor-for-protocol-design)
    * [IPC: YAML, TOML, etc. for protocol design](#ipc-yaml-toml-etc-for-protocol-design)
    * [Content Hashing (cryptographic strength i.e. *"guaranteed"* collision-free)](#content-hashing-cryptographic-strength-ie-guaranteed-collision-free)
    * [Hash-like Filters & Fast Hashing for Hash Tables et al (64 bits and less, mostly)](#hash-like-filters--fast-hashing-for-hash-tables-et-al-64-bits-and-less-mostly)
    * [Intermediate Data Storage / Caching / Hierarchical Data Stores (binary hOCR; document text revisions; ...)](#intermediate-data-storage--caching--hierarchical-data-stores-binary-hocr-document-text-revisions-)
        * [RAM-/disk-based large queues and stores: B+tree, LSM-tree, ...](#ram-disk-based-large-queues-and-stores-btree-lsm-tree-)
        * [HDF5 file format](#hdf5-file-format)
    * [Data Storage / Caching / IPC: loss-less data compression](#data-storage--caching--ipc-loss-less-data-compression)
    * [File / Directory Tree Synchronization (local and remote)](#file--directory-tree-synchronization-local-and-remote)
    * [OCR: hOCR output format, other output formats? (dedicated binary?)](#ocr-hocr-output-format-other-output-formats-dedicated-binary)
    * [Pattern Recognition](#pattern-recognition)
        * [BLAS, LAPACK, ...](#blas-lapack-)
        * [_delta features_ & other feature extraction (see Qiqqa research notes)](#delta-features--other-feature-extraction-see-qiqqa-research-notes)
        * [fuzzy matching](#fuzzy-matching)
        * [decision trees](#decision-trees)
        * [GMM/HMM/kM](#gmmhmmkm)
        * [graph analysis, graph databases](#graph-analysis-graph-databases)
        * [NN, ...](#nn-)
        * [similarity search](#similarity-search)
        * [text tokenization (as a preprocessing step for LDA et al)](#text-tokenization-as-a-preprocessing-step-for-lda-et-al)
        * [regex matchers (manual edit - pattern recognition)](#regex-matchers-manual-edit-pattern-recognition)
        * [OCR: quality improvements, language detect, ...](#ocr-quality-improvements-language-detect-)
        * [OCR page image preprocessing, \[scanner\] tooling: getting the pages to the OCR engine](#ocr-page-image-preprocessing-scanner-tooling-getting-the-pages-to-the-ocr-engine)
        * [image export, image / \[scanned\] document import](#image-export-image--scanned-document-import)
        * [Monte Carlo simulations, LDA, keyword inference/extraction, etc.](#monte-carlo-simulations-lda-keyword-inferenceextraction-etc)
        * [Random generators & all things random](#random-generators--all-things-random)
        * [Regression, curve fitting, polynomials, splines, geometrics, interpolation, math](#regression-curve-fitting-polynomials-splines-geometrics-interpolation-math)
        * [Solvers, Clustering, Monte Carlo, Decision Trees](#solvers-clustering-monte-carlo-decision-trees)
        * [Distance Metrics, Image Quality Metrics, Image Comparison](#distance-metrics-image-quality-metrics-image-comparison)
    * [database "backend storage"](#database-backend-storage)
        * [LMDB, NoSQL and key/value stores](#lmdb-nosql-and-keyvalue-stores)
        * [SQLite specific modules & related materials](#sqLite-specific-modules-related-materials)
    * [metadata & text (OCR et al) -- language detect, suggesting fixes, ...](#metadata--text-ocr-et-al----language-detect-suggesting-fixes-)
    * [PDF (XML) metadata editing](#pdf-xml-metadata-editing)
    * [web scraping (document extraction, cleaning, metadata extraction, BibTeX, ...)](#web-scraping-document-extraction-cleaning-metadata-extraction-bibtex-)
    * [audio files & processing](#audio-files--processing)
    * [file format support](#file-format-support)
    * [BibTeX and similar library metadata formats' support](#bibtex-and-similar-library-metadata-formats-support)
    * [export / output file formats, text formatting, etc.](#export--output-file-formats-text-formatting-etc)
    * [FTS (*Full Text Search*) and related: SOLR/Lucene et al: document content search](#fts-full-text-search-and-related-solrlucene-et-al-document-content-search)
        * [stemmers](#stemmers)
        * [language detection / inference](#language-detection--inference)
    * [scripting *user-tunable tasks* such as OCR preprocessing, metadata extraction, metadata cleaning & other \[post-\]processing, ...](#scripting-user-tunable-tasks-such-as-ocr-preprocessing-metadata-extraction-metadata-cleaning--other-post-processing-)
      * [QuickJS specific modules & related materials](#quickjs-specific-modules-related-materials)
    * [multi-processing core technologies](#multi-processing-core-technologies)
        * [CLI: commandline parsing & perusing](#cli-commandline-parsing--perusing)
        * [CPU features & capabilities detection](#cpu-features--capabilities-detection)
        * [Date & time functionality](#date--time-functionality)
        * [Misc. core functionality](#misc-core-functionality)
        * [multi-processing: invoking external applications](#multi-processing-invoking-external-applications)
        * [multi-processing: Promise/A+](#multi-processing-promisea)
        * [multi-processing: running tasks in parallel: multi-processing, multithreading, async, ...](#multi-processing-running-tasks-in-parallel-multi-processing-multithreading-async-)
        * [multi-processing: task schedulers](#multi-processing-task-schedulers)
        * [multi-processing: thread pools](#multi-processing-thread-pools)
        * [run-time library core features: logging, formatting, ...](#run-time-library-core-features-logging-formatting-)
    * [web servers, generic sockets I/O (IPC)](#web-servers-generic-sockets-io-ipc)
    * [socket I/O: websockets](#socket-io-websockets)
    * [disk I/O, monitoring import locations, ...](#disk-io-monitoring-import-locations-)
    * [configuration / parameterization](#configuration--parameterization)
        * [TOML](#toml)
        * [YAML](#yaml)
        * [INI](#ini)
    * [testing, benchmarking & fuzzing](#testing-benchmarking--fuzzing)
    * [logging & debugging](#logging--debugging)
        * [ETW (Event Tracing for Microsoft Windows)](#etw-event-tracing-for-microsoft-windows)
    * [colour processing & conversion](#colour-processing--conversion)
    * [visualization](#visualization)
    * [telemetry](#telemetry)
    * [OCR core (*tesseract*)](#ocr-core-tesseract)
    * [PDF render & metadata core (*mupdf*)](#pdf-render--metadata-core-mupdf)
    * [UI / GUI](#ui--gui)
    * [Language translation & transliteration](####language-translation--transliteration)
    * [Application Installers (NSIS, et al)](#application-installers-nsis-et-al)
    * [checking out the competition / compatriots for Qiqqa + re-use useful components](#checking-out-the-competition--compatriots-for-qiqqa--re-use-useful-components)
    * [citations output (CSL)](#citations-output-csl)
    * [Microsoft Word, Google Docs, LibreOffice: application integration](#microsoft-word-google-docs-libreoffice-application-integration)
    * [XML & XSLT tooling](#xml--xslt-tooling)
    * [Microsoft DOCX ~ OpenXML & other XML & XSLT tooling](#microsoft-docx--openxml--other-xml--xslt-tooling)
    * [Misc. / Other](#misc--other)
    * [sub-dependencies (libraries which are required by any of the above)](#sub-dependencies-libraries-which-are-required-by-any-of-the-above)
* [Libraries in this collection (All of the above, listed in alphabetical order)](#libraries-in-this-collection-all-of-the-above-listed-in-alphabetical-order)
* [TBD: Libraries which still need to be moved into the overview / categories above...](#tbd-libraries-which-still-need-to-be-moved-into-the-overview--categories-above)











## IPC: flatbuffer et al for protocol design

- **arrow** [ğŸ“](./arrow) [ğŸŒ](https://github.com/GerHobbelt/arrow) -- Apache Arrow is a development platform for in-memory analytics. It contains a set of technologies that enable big data systems to process and move data fast. The reference Arrow libraries contain many distinct software components:
  
  - Columnar vector and table-like containers (similar to data frames) supporting
    flat or nested types
  
  - Conversions to and from other in-memory data structures
  - Integration tests for verifying binary compatibility between the
    implementations (e.g. sending data from Java to C++)
  
  - IO interfaces to local and remote filesystems
  - Readers and writers for various widely-used file formats (such as Parquet, CSV)
  - Reference-counted off-heap buffer memory management, for zero-copy memory
    sharing and handling memory-mapped files
  
  - Self-describing binary wire formats (streaming and batch/file-like) for
    remote procedure calls (RPC) and interprocess communication (IPC)

- **avro** [ğŸ“](./avro) [ğŸŒ](https://github.com/GerHobbelt/avro) -- Apache Avroâ„¢ is a data serialization system.
- **bebop** [ğŸ“](./bebop) [ğŸŒ](https://github.com/GerHobbelt/bebop) -- an extremely simple, fast, efficient, cross-platform serialization format. Bebop is a schema-based binary serialization technology, similar to Protocol Buffers or MessagePack. In particular, Bebop tries to be a good fit for clientâ€“server or distributed web apps that need something faster, more concise, and more type-safe than JSON or MessagePack, while also avoiding some of the complexity of Protocol Buffers, FlatBuffers and the like.
- **bitsery** [ğŸ“](./bitsery) [ğŸŒ](https://github.com/GerHobbelt/bitsery) -- header only C++ binary serialization library, designed around the networking requirements for real-time data delivery, especially for games. All cross-platform requirements are enforced at compile time, so serialized data do not store any meta-data information and is as small as possible.
- **capnproto** [ğŸ“](./capnproto) [ğŸŒ](https://github.com/GerHobbelt/capnproto) -- Cap'n Proto is an insanely fast data interchange format and capability-based RPC system. Think JSON, except binary. Or think [Protocol Buffers](https://github.com/google/protobuf), except faster.
- **cereal** [ğŸ“](./cereal) [ğŸŒ](https://github.com/GerHobbelt/cereal) -- C++11 serialization library
- **GoldFish-CBOR** [ğŸ“](./GoldFish-CBOR) [ğŸŒ](https://github.com/GerHobbelt/GoldFish) -- a fast JSON and CBOR streaming library, without using memory. GoldFish can parse and generate very large [JSON](http://json.org) or [CBOR](http://cbor.io) documents. It has some similarities to a [SAX](https://en.wikipedia.org/wiki/Simple_API_for_XML) parser, but doesn't use an event driven API, instead the user of the GoldFish interface is in control. GoldFish intends to be the easiest and one of the fastest JSON and CBOR streaming parser and serializer to use.
- **ion-c** [ğŸ“](./ion-c) [ğŸŒ](https://github.com/GerHobbelt/ion-c) -- a C implementation of the [Ion data notation](http://amzn.github.io/ion-docs). Amazon Ion is a richly-typed, self-describing, hierarchical data serialization format offering interchangeable binary and text representations. The text format (a superset of JSON) is easy to read and author, supporting rapid prototyping. The binary representation is efficient to store, transmit, and skip-scan parse. The rich type system provides unambiguous semantics for long-term preservation of data which can survive multiple generations of software evolution.
- **libnop** [ğŸ“](./libnop) [ğŸŒ](https://github.com/GerHobbelt/libnop) -- libnop (C++ Native Object Protocols) is a header-only library for serializing and deserializing C++ data types without external code generators or runtime support libraries. The only mandatory requirement is a compiler that supports the C++14 standard.
- **libsmile** [ğŸ“](./libsmile) [ğŸŒ](https://github.com/GerHobbelt/libsmile) -- C implementation of the Smile binary format (https://github.com/FasterXML/smile-format-specification).
- **mosquitto** [ğŸ“](./mosquitto) [ğŸŒ](https://github.com/GerHobbelt/mosquitto) -- Eclipse Mosquitto is an open source implementation of a server for version 5.0, 3.1.1, and 3.1 of the MQTT protocol. It also includes a C and C++ client library, and the `mosquitto_pub` and `mosquitto_sub` utilities for publishing and subscribing.
- **protobuf** [ğŸ“](./protobuf) [ğŸŒ](https://github.com/GerHobbelt/protobuf) -- Protocol Buffers - Google's data interchange format that is a language-neutral, platform-neutral, extensible mechanism for serializing structured data.
  
  - **â˜¹discouragedğŸ¤§**; reason: relatively slow run-time and (in my opinion) rather ugly & convoluted approach at build time. Has too much of a Java/CorporateProgramming smell, which has not lessened over the years, unfortunately.

- **serde-cpp** [ğŸ“](./serde-cpp) [ğŸŒ](https://github.com/GerHobbelt/serde-cpp) -- serialization framework for C++17, inspired by Rust [serde](https://serde.rs/) project.
- **serdepp** [ğŸ“](./serdepp) [ğŸŒ](https://github.com/GerHobbelt/serdepp) -- a C++17 low cost serialize deserialize adaptor library like Rust [serde](https://serde.rs/) project.
- **swig** [ğŸ“](./swig) [ğŸŒ](https://github.com/GerHobbelt/swig) -- SWIG (Simplified Wrapper and Interface Generator) is a software development tool (code generator) that connects programs written in C and C++ with a variety of high-level programming languages. It is used for building scripting language interfaces to C and C++ programs. SWIG simplifies development by largely automating the task of scripting language integration, allowing developers and users to focus on more important problems.
  
  *[SWIG ğŸŒ](https://swig.readthedocs.io/en/latest/Manual/SWIG.html) was not considered initially; more suitable for RPC than what we have in mind, which is purely data messages enchange. MAY be of use for transitional applications which are mixed-(programming-)language based, e.g. where we want to mix C/C++ and C# in a single Test Application.*

- **thrift** [ğŸ“](./thrift) [ğŸŒ](https://github.com/GerHobbelt/thrift) -- Apache Thrift is a lightweight, language-independent software stack for point-to-point RPC implementation. Thrift provides clean abstractions and implementations for data transport, data serialization, and application level processing. The code generation system takes a simple definition language as input and generates code across programming languages that uses the abstracted stack to build interoperable RPC clients and servers.
- **velocypack** [ğŸ“](./velocypack) [ğŸŒ](https://github.com/GerHobbelt/velocypack) -- a fast and compact format for serialization and storage.  These days, JSON (JavaScript Object Notation, see ECMA-404) is used in many cases where data has to be exchanged. Lots of protocols between different services use it, databases store JSON (document stores naturally, but others increasingly as well). It is popular, because it is simple, human-readable, and yet surprisingly versatile, despite its limitations. At the same time there is a plethora of alternatives ranging from XML over Universal Binary JSON, MongoDB's BSON, MessagePack, BJSON (binary JSON), Apache Thrift till Google's protocol buffers and ArangoDB's shaped JSON. When looking into this, we were surprised to find that none of these formats manages to combine compactness, platform independence, fast access to sub-objects and rapid conversion from and to JSON.
- ZeroMQ a.k.a. Ã˜MQ:
  
  - **cppzmq** [ğŸ“](./cppzmq) [ğŸŒ](https://github.com/GerHobbelt/cppzmq) -- header-only C++ binding for libzmq.
  - **libCZMQ** [ğŸ“](./libCZMQ) [ğŸŒ](https://github.com/GerHobbelt/czmq) -- High-level C binding for Ã˜MQ. (http://czmq.zeromq.org/)
  - **libzmq** [ğŸ“](./libzmq) [ğŸŒ](https://github.com/GerHobbelt/libzmq) -- ZeroMQ core engine in C++, implements [ZMTP/3.1](https://zguide.zeromq.org/).

- **zpp_bits** [ğŸ“](./zpp_bits) [ğŸŒ](https://github.com/GerHobbelt/zpp_bits) -- A modern, *fast*, C++20 binary serialization and RPC library, with just one header file.See also the [benchmark](https://github.com/GerHobbelt/zpp_bits#benchmark).
- ~~**FastBinaryEncoding** [ğŸŒ](https://github.com/chronoxor/FastBinaryEncoding)~~
  
  - **removed**; reason: for binary format record serialization we will be using `bebop` exclusively. All other communications will be JSON/JSON5/XML based.

- ~~**flatbuffers** [ğŸŒ](https://github.com/google/flatbuffers)~~
  
  - **removed**; reason: see `protobuf`: same smell rising. Faster at run time, but still a bit hairy to my tastes while `bebop` et al are on to something *potentially nice*.

- ~~**flatcc** [ğŸŒ](https://github.com/dvidelabs/flatcc)~~
  
  - **removed**; reason: see `flatbuffers`. When we don't dig `flatbuffers`, then `flatcc` is automatically pretty useless to us. Let's rephrase that professionally: "`flatcc` has moved out of scope for our project."

- ~~**libsmile** [ğŸŒ](https://github.com/pierre/libsmile) -- ["Smile" format](https://en.wikipedia.org/wiki/Smile_%28data_interchange_format%29), i.e. a compact binary JSON format~~
  
  - **removed**; reason: for binary format record serialization we will be using `bebop` exclusively. All other communications will be JSON/JSON5/XML based.












## IPC: websockets, etc.: all communication means

- **blazingmq** [ğŸ“](./blazingmq) [ğŸŒ](https://github.com/GerHobbelt/blazingmq) -- BlazingMQ is a modern, High-Performance Message Queue, which focuses on efficiency, reliability, and a rich feature set for modern-day workflows. At its core, BlazingMQ provides durable, fault-tolerant, highly performant, and highly available queues, along with features like various message routing strategies (e.g., work queues, priority, fan-out, broadcast, etc.), compression, strong consistency, poison pill detection, etc.  Message queues generally provide a loosely-coupled, asynchronous communication channel ("queue") between application services (producers and consumers) that send messages to one another. You can think about it like a mailbox for communication between application programs, where 'producer' drops a message in a mailbox and 'consumer' picks it up at its own leisure. Messages placed into the queue are stored until the recipient retrieves and processes them. In other words, producer and consumer applications can temporally and spatially isolate themselves from each other by using a message queue to facilitate communication.
- **boringssl** [ğŸ“](./boringssl) [ğŸŒ](https://github.com/GerHobbelt/boringssl) -- BoringSSL is a fork of OpenSSL that is designed to meet Google's needs.
- **cpp-httplib** [ğŸ“](./cpp-httplib) [ğŸŒ](https://github.com/GerHobbelt/cpp-httplib) -- an extremely easy to setup C++11 cross platform HTTP/HTTPS library. 
  
  **NOTE**: This library uses 'blocking' socket I/O. If you are looking for a library with 'non-blocking' socket I/O, this is not the one that you want.

- **cpp-ipc** [ğŸ“](./cpp-ipc) [ğŸŒ](https://github.com/GerHobbelt/cpp-ipc) -- a high-performance inter-process communication using shared memory on Linux/Windows.
- **cpp-netlib** [ğŸ“](./cpp-netlib) [ğŸŒ](https://github.com/GerHobbelt/cpp-netlib) -- modern C++ network programming library: `cpp-netlib` is a collection of network-related routines/implementations geared towards providing a robust cross-platform networking library.
- **cpp_rest_sdk** [ğŸ“](./cpp_rest_sdk) [ğŸŒ](https://github.com/GerHobbelt/cpprestsdk) -- the C++ REST SDK is a Microsoft project for cloud-based client-server communication in native code using a modern asynchronous C++ API design. This project aims to help C++ developers connect to and interact with services.
- **crow** [ğŸ“](./crow) [ğŸŒ](https://github.com/GerHobbelt/crow) -- IPC / server framework. Crow is a very fast and easy to use C++ micro web framework (inspired by Python Flask).
  
  Interface looks nicer than `oatpp`...

- **ecal** [ğŸ“](./ecal) [ğŸŒ](https://github.com/GerHobbelt/ecal) -- the *enhanced Communication Abstraction Layer* (*eCAL*) is a middleware that enables scalable, high performance interprocess communication on a single computer node or between different nodes in a computer network. eCAL uses a publish-subscribe pattern to automatically connect different nodes in the network. eCAL automatically chooses the best available data transport mechanism for each link:
  
  - Shared memory for local communication (incredible fast!)
  - UDP for network communication

- **iceoryx** [ğŸ“](./iceoryx) [ğŸŒ](https://github.com/GerHobbelt/iceoryx) -- true zero-copy inter-process-communication. iceoryx is an inter-process-communication (IPC) middleware for various operating systems (currently we support Linux, macOS, QNX, FreeBSD and Windows 10). It has its origins in the automotive industry, where large amounts of data have to be transferred between different processes when it comes to driver assistance or automated driving systems. However, the efficient communication mechanisms can also be applied to a wider range of use cases, e.g. in the field of robotics or game development.
- **libwebsocketpp** [ğŸ“](./libwebsocketpp) [ğŸŒ](https://github.com/GerHobbelt/websocketpp) -- WebSocket++ is a header only C++ library that implements RFC6455 The WebSocket Protocol.
- **libwebsockets** [ğŸ“](./libwebsockets) [ğŸŒ](https://github.com/GerHobbelt/libwebsockets) -- a simple-to-use C library providing client and server for HTTP/1, HTTP/2, WebSockets, MQTT and other protocols. It supports a lot of lightweight ancilliary implementations for things like JSON, CBOR, JOSE, COSE. It's very gregarious when it comes to event loop sharing, supporting libuv, libevent, libev, sdevent, glib and uloop, as well as custom event libs.
- **MPMCQueue** [ğŸ“](./MPMCQueue) [ğŸŒ](https://github.com/GerHobbelt/MPMCQueue) -- a bounded multi-producer multi-consumer concurrent queue written in C++11.
- **MultipartEncoder** [ğŸ“](./MultipartEncoder) [ğŸŒ](https://github.com/GerHobbelt/MultipartEncoder) -- a C++ implementation of encoding multipart/form-data. You may find the asynchronous http-client, i.e. [cpprestsdk](https://github.com/Microsoft/cpprestsdk), does not support posting a multipart/form-data request. This MultipartEncoder is a work around to generate the body content of multipart/form-data format, so that then you can use a cpp HTTP-client, which is not limited to cpprestsdk, to post a multipart/form-data request by setting the encoded body content.
- **nanomsg-nng** [ğŸ“](./nanomsg-nng) [ğŸŒ](https://github.com/GerHobbelt/nng) -- a rewrite of the Scalability Protocols library known as https://github.com/nanomsg/nanomsg[libnanomsg], which adds significant new capabilities, while retaining compatibility with the original. NNG is a lightweight, broker-less library, offering a simple API to solve common recurring messaging problems, such as publish/subscribe, RPC-style request/reply, or service discovery.
- **nghttp3** [ğŸ“](./nghttp3) [ğŸŒ](https://github.com/GerHobbelt/nghttp3) -- an implementation of `RFC 9114 <https://datatracker.ietf.org/doc/html/rfc9114>`_ HTTP/3 mapping over QUIC and `RFC 9204 <https://datatracker.ietf.org/doc/html/rfc9204>`_ QPACK in C.
- **ngtcp2** [ğŸ“](./ngtcp2) [ğŸŒ](https://github.com/GerHobbelt/ngtcp2) -- ngtcp2 project is an effort to implement `RFC9000 <https://datatracker.ietf.org/doc/html/rfc9000>`_ QUIC protocol.
- **OpenSSL** [ğŸ“](./openssl) [ğŸŒ](https://github.com/GerHobbelt/openssl) -- OpenSSL is a robust, commercial-grade, full-featured Open Source Toolkit for the Transport Layer Security (TLS) protocol formerly known as the Secure Sockets Layer (SSL) protocol. The protocol implementation is based on a full-strength general purpose cryptographic library, which can also be used stand-alone.
- **readerwriterqueue** [ğŸ“](./readerwriterqueue) [ğŸŒ](https://github.com/GerHobbelt/readerwriterqueue) -- a single-producer, single-consumer lock-free queue for C++.
- **restc-cpp** [ğŸ“](./restc-cpp) [ğŸŒ](https://github.com/GerHobbelt/restc-cpp) -- a modern C++ REST Client library. The magic that takes the pain out of accessing JSON API's from C++. The design goal of this project is to make external REST API's simple and safe to use in C++ projects, but still fast and memory efficient.
- **shadesmar** [ğŸ“](./shadesmar) [ğŸŒ](https://github.com/GerHobbelt/shadesmar) -- an IPC library that uses the system's shared memory to pass messages. Supports publish-subscribe and RPC.
- **sharedhashfile** [ğŸ“](./sharedhashfile) [ğŸŒ](https://github.com/GerHobbelt/sharedhashfile) -- share hash tables with stable key hints stored in memory mapped files between arbitrary processes.
- **shmdata** [ğŸ“](./shmdata) [ğŸŒ](https://github.com/GerHobbelt/shmdata) -- shares streams of framed data between processes (1 writer to many readers) via shared memory. It supports any kind of data stream:  it has been used with multichannel audio, video frames, 3D models, OSC messages, and various others types of data. Shmdata is very fast and allows processes to access data streams without the need for extra copies.
- **SPSCQueue** [ğŸ“](./SPSCQueue) [ğŸŒ](https://github.com/GerHobbelt/SPSCQueue) -- a single producer single consumer wait-free and lock-free fixed size queue written in C++11.
- **tcp_pubsub** [ğŸ“](./tcp_pubsub) [ğŸŒ](https://github.com/GerHobbelt/tcp_pubsub) -- a minimal publish-subscribe library that transports data via TCP. `tcp_pubsub` does not define a message format but only transports binary blobs. It does however define a protocol around that, which is kept as lightweight as possible.
- **tcpshm** [ğŸ“](./tcpshm) [ğŸŒ](https://github.com/GerHobbelt/tcpshm) -- a connection-oriented persistent message queue framework based on TCP or SHM IPC for Linux. TCPSHM provides a reliable and efficient solution based on a sequence number and acknowledge mechanism, that every sent out msg is persisted in a send queue until sender got ack that it's been consumed by the receiver, so that disconnects/crashes are tolerated and the recovery process is purely automatic.
- **telegram-bot-api** [ğŸ“](./telegram-bot-api) [ğŸŒ](https://github.com/GerHobbelt/telegram-bot-api) -- the Telegram Bot API provides an HTTP API for creating Telegram Bots.
- **telegram-td** [ğŸ“](./telegram-td) [ğŸŒ](https://github.com/GerHobbelt/td) -- TDLib (Telegram Database library) is a cross-platform library for building [Telegram](https://telegram.org) clients. It can be easily used from almost any programming language.
- **ucx** [ğŸ“](./ucx) [ğŸŒ](https://github.com/GerHobbelt/ucx) -- Unified Communication X (UCX) is an optimized production proven-communication framework for modern, high-bandwidth and low-latency networks. UCX exposes a set of abstract communication primitives that utilize the best of available hardware resources and offloads. These include RDMA (InfiniBand and RoCE), TCP, GPUs, shared memory, and network atomic operations.
- **userver** [ğŸ“](./userver) [ğŸŒ](https://github.com/GerHobbelt/userver) -- an open source asynchronous framework with a rich set of abstractions for fast and comfortable creation of C++ microservices, services and utilities. The framework solves the problem of efficient I/O interactions transparently for the developers. Operations that would typically suspend the thread of execution do not suspend it. Instead of that, the thread processes other requests and tasks and returns to the handling of the operation only when it is guaranteed to execute immediately. As a result you get straightforward source code and avoid CPU-consuming context switches from OS, efficiently utilizing the CPU with a small amount of execution threads.
- **uvw** [ğŸ“](./uvw) [ğŸŒ](https://github.com/GerHobbelt/uvw) -- `libuv` wrapper in modern C++. `uvw` started as a header-only, event based, tiny and easy to use wrapper for [`libuv`](https://github.com/libuv/libuv) written in modern C++.  Now it's finally available also as a compilable static library. The basic idea is to wrap the *C-ish* interface of `libuv` behind a graceful C++ API.
- **websocket-sharp** [ğŸ“](./websocket-sharp) [ğŸŒ](https://github.com/GerHobbelt/websocket-sharp) -- a C# implementation of the WebSocket protocol client and server.
- **WinHttpPAL** [ğŸ“](./WinHttpPAL) [ğŸŒ](https://github.com/GerHobbelt/WinHttpPAL) -- implements [WinHttp API](https://docs.microsoft.com/en-us/windows/win32/winhttp/winhttp-start-page) Platform Abstraction Layer for POSIX systems using libcurl
- ~~**ice** [ğŸŒ](https://github.com/zeroc-ice/ice) -- Comprehensive RPC Framework: helps you network your software with minimal effort.~~
  
  - **removed**; reason: has a strong focus on the *remote*, i.e. `R` in `RPC` (thus a focus on things such as encryption, authentication, firewalling, etc.), which we don't want or need: all services are supposed to run on a single machine and comms go through `localhost` *only*. When folks find they need to distribute the workload across multiple machines, then we'll be entering a new era in Qiqqa usage and then will be soon enough to (re-)investigate the usefulness of this package.


Also, we are currently more interested in *fast data serialization* then RPC *per se* as we aim for a solution that's more akin to a REST API interface style.

- ~~**oatpp** [ğŸŒ](https://github.com/oatpp/oatpp) -- IPC / server framework~~
  
  - **removed**; reason: see `crow`. We have picked `crow` as the preferred way forward, so any similar/competing product is out of scope unless `crow` throws a tantrum on our test bench after all, the chances of that being *very slim*.












### IPC: ZeroMQ a.k.a. Ã˜MQ

- **cppzmq** [ğŸ“](./cppzmq) [ğŸŒ](https://github.com/GerHobbelt/cppzmq) -- header-only C++ binding for libzmq.
- **libCZMQ** [ğŸ“](./libCZMQ) [ğŸŒ](https://github.com/GerHobbelt/czmq) -- High-level C binding for Ã˜MQ. (http://czmq.zeromq.org/)
- **libzmq** [ğŸ“](./libzmq) [ğŸŒ](https://github.com/GerHobbelt/libzmq) -- ZeroMQ core engine in C++, implements [ZMTP/3.1](https://zguide.zeromq.org/).











### IPC: memory mapping

- **arrow** [ğŸ“](./arrow) [ğŸŒ](https://github.com/GerHobbelt/arrow) -- Apache Arrow is a development platform for in-memory analytics. It contains a set of technologies that enable big data systems to process and move data fast. The reference Arrow libraries contain many distinct software components:
  
  - Columnar vector and table-like containers (similar to data frames) supporting
    flat or nested types
  
  - Conversions to and from other in-memory data structures
  - Integration tests for verifying binary compatibility between the
    implementations (e.g. sending data from Java to C++)
  
  - IO interfaces to local and remote filesystems
  - Readers and writers for various widely-used file formats (such as Parquet, CSV)
  - Reference-counted off-heap buffer memory management, for zero-copy memory
    sharing and handling memory-mapped files
  
  - Self-describing binary wire formats (streaming and batch/file-like) for
    remote procedure calls (RPC) and interprocess communication (IPC)

- **fmem** [ğŸ“](./fmem) [ğŸŒ](https://github.com/GerHobbelt/fmem) -- a cross-platform library for opening memory-backed libc streams (a la UNIX `fmemopen()`).
- **fmemopen_windows** [ğŸ“](./fmemopen_windows) [ğŸŒ](https://github.com/GerHobbelt/fmemopen_windows) -- provides **FILE\*** handler based on memory backend for fread,fwrite etc. just like `fmemopen` on linux, but now on MS Windows.
- **libmio** [ğŸ“](./libmio) [ğŸŒ](https://github.com/GerHobbelt/mio) -- An easy to use header-only cross-platform C++11 memory mapping library. `mio` has been created with the goal to be easily includable (i.e. no dependencies) in any C++ project that needs memory mapped file IO without the need to pull in Boost.
- **libvrb** [ğŸ“](./libvrb) [ğŸŒ](https://github.com/GerHobbelt/vrb) -- implements a ring buffer, also known as a character FIFO or circular buffer, with a special property that any data present in the buffer, as well as any empty space, are always seen as a single contiguous extent by the calling program.  This is implemented with virtual memory mapping by creating a mirror image of the buffer contents at the memory location in the virtual address space immediately after the main buffer location.  This allows the mirror image to always be seen without doing any copying of data.
- **portable-memory-mapping** [ğŸ“](./portable-memory-mapping) [ğŸŒ](https://github.com/GerHobbelt/portable-memory-mapping) -- portable Memory Mapping C++ Class (Windows/Linux)
- **shadesmar** [ğŸ“](./shadesmar) [ğŸŒ](https://github.com/GerHobbelt/shadesmar) -- an IPC library that uses the system's shared memory to pass messages. Supports publish-subscribe and RPC.
- **sharedhashfile** [ğŸ“](./sharedhashfile) [ğŸŒ](https://github.com/GerHobbelt/sharedhashfile) -- share hash tables with stable key hints stored in memory mapped files between arbitrary processes.
- **shmdata** [ğŸ“](./shmdata) [ğŸŒ](https://github.com/GerHobbelt/shmdata) -- shares streams of framed data between processes (1 writer to many readers) via shared memory. It supports any kind of data stream:  it has been used with multichannel audio, video frames, 3D models, OSC messages, and various others types of data. Shmdata is very fast and allows processes to access data streams without the need for extra copies.
- **tcpshm** [ğŸ“](./tcpshm) [ğŸŒ](https://github.com/GerHobbelt/tcpshm) -- a connection-oriented persistent message queue framework based on TCP or SHM IPC for Linux. TCPSHM provides a reliable and efficient solution based on a sequence number and acknowledge mechanism, that every sent out msg is persisted in a send queue until sender got ack that it's been consumed by the receiver, so that disconnects/crashes are tolerated and the recovery process is purely automatic.











## IPC: JSON for protocol design

- **glaze** [ğŸ“](./glaze) [ğŸŒ](https://github.com/GerHobbelt/glaze) -- one of the fastest JSON libraries in the world. Glaze reads and writes from object memory, simplifying interfaces and offering incredible performance. Glaze also supports [BEVE](https://github.com/beve-org/beve) (binary efficient versatile encoding), CSV (comma separated value) and Binary data through the same API for maximum performance
- **GoldFish-CBOR** [ğŸ“](./GoldFish-CBOR) [ğŸŒ](https://github.com/GerHobbelt/GoldFish) -- a fast JSON and CBOR streaming library, without using memory. GoldFish can parse and generate very large [JSON](http://json.org) or [CBOR](http://cbor.io) documents. It has some similarities to a [SAX](https://en.wikipedia.org/wiki/Simple_API_for_XML) parser, but doesn't use an event driven API, instead the user of the GoldFish interface is in control. GoldFish intends to be the easiest and one of the fastest JSON and CBOR streaming parser and serializer to use.
- **json** [ğŸ“](./json) [ğŸŒ](https://github.com/GerHobbelt/nlohmann-json) -- N. Lohmann's JSON for Modern C++.
- **jsoncons** [ğŸ“](./jsoncons) [ğŸŒ](https://github.com/GerHobbelt/jsoncons) -- a C++, header-only library for constructing [JSON](http://www.json.org) and JSON-like data formats such as [CBOR](http://cbor.io/). Compared to other JSON libraries, jsoncons has been designed to handle very large JSON texts. At its heart are SAX-style parsers and serializers. It supports reading an entire JSON text in memory in a variant-like structure. But it also supports efficient access to the underlying data using StAX-style pull parsing and push serializing. It supports incremental parsing into a user's preferred form, using information about user types provided by specializations of `json_type_traits`.
- **jsoncpp** [ğŸ“](./jsoncpp) [ğŸŒ](https://github.com/GerHobbelt/jsoncpp) -- JsonCpp is a C++ library that allows manipulating JSON values, including serialization and deserialization to and from strings. It can also preserve existing comment in unserialization/serialization steps, making it a convenient format to store user input files.
- **json-jansson** [ğŸ“](./json-jansson) [ğŸŒ](https://github.com/GerHobbelt/jansson) -- _Jansson_ is a C library for encoding, decoding and manipulating JSON data.
- **rapidJSON** [ğŸ“](./rapidJSON) [ğŸŒ](https://github.com/GerHobbelt/rapidjson) -- TenCent's fast JSON parser/generator for C++ with both SAX & DOM style APIs.
- **simdjson** [ğŸ“](./simdjson) [ğŸŒ](https://github.com/GerHobbelt/simdjson) -- simdjson : Parsing gigabytes of JSON per second. For NDJSON files, we can exceed 3 GB/s with our multithreaded parsing functions](https://github.com/simdjson/simdjson/blob/master/doc/parse_many.md).
- **tao-json** [ğŸ“](./tao-json) [ğŸŒ](https://github.com/GerHobbelt/tao-json) -- taoJSON is a C++ header-only JSON library that provides a generic [Value Class](doc/Value-Class.md), uses [Type Traits](doc/Type-Traits.md) to interoperate with C++ types, uses an [Events Interface](doc/Events-Interface.md) to convert from and to JSON, JAXN, CBOR, MsgPack and UBJSON, and much more...
- **yyjson** [ğŸ“](./yyjson) [ğŸŒ](https://github.com/GerHobbelt/yyjson) -- allegedly the fastest JSON library in C.
- ~~**libsmile** [ğŸŒ](https://github.com/pierre/libsmile) -- ["Smile" format](https://en.wikipedia.org/wiki/Smile_%28data_interchange_format%29), i.e. a compact binary JSON format~~
  
  - **removed**; reason: I think we'd better standardize on using one or more of these:
    
    - custom binary exchange formats for those interchanges that demand highest performance and MAY carry large transfer loads.
    - JSON
    - TOML
    - XML
    - YAML












## IPC: CBOR for protocol design

- **glaze** [ğŸ“](./glaze) [ğŸŒ](https://github.com/GerHobbelt/glaze) -- one of the fastest JSON libraries in the world. Glaze reads and writes from object memory, simplifying interfaces and offering incredible performance. Glaze also supports [BEVE](https://github.com/beve-org/beve) (binary efficient versatile encoding), CSV (comma separated value) and Binary data through the same API for maximum performance
- **GoldFish-CBOR** [ğŸ“](./GoldFish-CBOR) [ğŸŒ](https://github.com/GerHobbelt/GoldFish) -- a fast JSON and CBOR streaming library, without using memory. GoldFish can parse and generate very large [JSON](http://json.org) or [CBOR](http://cbor.io) documents. It has some similarities to a [SAX](https://en.wikipedia.org/wiki/Simple_API_for_XML) parser, but doesn't use an event driven API, instead the user of the GoldFish interface is in control. GoldFish intends to be the easiest and one of the fastest JSON and CBOR streaming parser and serializer to use.
- **jsoncons** [ğŸ“](./jsoncons) [ğŸŒ](https://github.com/GerHobbelt/jsoncons) -- a C++, header-only library for constructing [JSON](http://www.json.org) and JSON-like data formats such as [CBOR](http://cbor.io/). Compared to other JSON libraries, jsoncons has been designed to handle very large JSON texts. At its heart are SAX-style parsers and serializers. It supports reading an entire JSON text in memory in a variant-like structure. But it also supports efficient access to the underlying data using StAX-style pull parsing and push serializing. It supports incremental parsing into a user's preferred form, using information about user types provided by specializations of `json_type_traits`.
- **libcbor** [ğŸ“](./libcbor) [ğŸŒ](https://github.com/GerHobbelt/libcbor) -- a C library for parsing and generating [CBOR](https://tools.ietf.org/html/rfc7049), the general-purpose schema-less binary data format.
- **QCBOR** [ğŸ“](./QCBOR) [ğŸŒ](https://github.com/GerHobbelt/QCBOR) -- a powerful, commercial-quality CBOR encoder/decoder that implements these RFCs:
  
  * [RFC7049](https://tools.ietf.org/html/rfc7049) The previous CBOR standard. Replaced by RFC 8949.
  * [RFC8742](https://tools.ietf.org/html/rfc8742) CBOR Sequences
  * [RFC8943](https://tools.ietf.org/html/rfc8943) CBOR Dates
  * [RFC8949](https://tools.ietf.org/html/rfc8949) The CBOR Standard. (Everything except sorting of encoded maps)

- **tinycbor** [ğŸ“](./tinycbor) [ğŸŒ](https://github.com/GerHobbelt/tinycbor) -- Concise Binary Object Representation (CBOR) library for serializing data to disk or message channel.











## IPC: YAML, TOML, etc. for protocol design

**Not considered**: reason: when we want the IPC protocol to be "human readable" in any form/approximation, we've decided to stick with JSON or XML (if we cannot help it -- I particularly dislike the verbosity and tag redundancy (open+close) in XML and consider it a lousy design choice for *any* purpose).

The more human readable formats (YAML, TOML, ...) are intended for human to machine communications, e.g. for feeding configurations into applications, and **SHOULD NOT** be used for IPC anywhere. (Though I must say I'm on the fence where it comes using YAML as an alternative IPC format where it replaces JSON; another contender there are the JSON5/JSON6 formats.)











## Content Hashing (cryptographic strength i.e. *"guaranteed"* collision-free)

The bit about **_"guaranteed"_ collision-free** is to be read as: hash algorithms in this section must come with *strong statistical guarantees* that any chance at a **hash collision** is negligible, even for *extremely large* collections. In practice this means: use *cryptographic* hash algorithms with a *strength* of 128 bits or more. (Qiqqa used a b0rked version SHA1 thus far, which is considered too weak as we already sample PDFs which cause a hash collision for the *official* SHA1 algo (and thus also collide in our b0rked SHA1 variant): while those can still be argued to be fringe case, I don't want to be bothered with this at all and thus choose to err on the side of 'better than SHA1B' here. Meanwhile, any library in here *may* contain weaker cryptographic hashes alongside: we won't be using those for **content hashing**.

- **BLAKE3** [ğŸ“](./BLAKE3) [ğŸŒ](https://github.com/GerHobbelt/BLAKE3) -- cryptographic hash
- **boringssl** [ğŸ“](./boringssl) [ğŸŒ](https://github.com/GerHobbelt/boringssl) -- BoringSSL is a fork of OpenSSL that is designed to meet Google's needs.
- **cryptopp** [ğŸ“](./cryptopp) [ğŸŒ](https://github.com/GerHobbelt/cryptopp) -- crypto library
- **OpenSSL** [ğŸ“](./openssl) [ğŸŒ](https://github.com/GerHobbelt/openssl) -- its crypto library part, more specifically.
- **prvhash** [ğŸ“](./prvhash) [ğŸŒ](https://github.com/GerHobbelt/prvhash) -- PRVHASH is a hash function that generates a [uniform pseudo-random number sequence](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) derived from the message. PRVHASH is conceptually similar (in the sense of using a pseudo-random number sequence as a hash) to [`keccak`](https://en.wikipedia.org/wiki/SHA-3) and [`RadioGatun`](https://en.wikipedia.org/wiki/RadioGat%C3%BAn) schemes, but is a completely different implementation of such concept. PRVHASH is both a ["randomness extractor"](https://en.wikipedia.org/wiki/Randomness_extractor) and an "extendable-output function" (XOF).
- **SipHash** [ğŸ“](./SipHash) [ğŸŒ](https://github.com/GerHobbelt/SipHash) -- SipHash is a family of pseudorandom functions (PRFs) optimized for speed on short messages. This is the reference C code of SipHash: portable, simple, optimized for clarity and debugging. SipHash was designed in 2012 by [Jean-Philippe Aumasson](https://aumasson.jp) and [Daniel J. Bernstein](https://cr.yp.to) as a defense against [hash-flooding DoS attacks](https://aumasson.jp/siphash/siphashdos_29c3_slides.pdf).
  
  It is *simpler and faster* on short messages than previous cryptographic algorithms, such as MACs based on universal hashing, *competitive in performance* with insecure non-cryptographic algorithms, such as [fhhash](https://github.com/cbreeden/fxhash), *cryptographically secure*, with no sign of weakness despite multiple [cryptanalysis](https://eprint.iacr.org/2019/865) [projects](https://eprint.iacr.org/2019/865) by leading cryptographers, *battle-tested*, with successful integration in OSs (Linux kernel, OpenBSD, FreeBSD, FreeRTOS), languages (Perl, Python, Ruby, etc.), libraries (OpenSSL libcrypto, Sodium, etc.) and applications (Wireguard, Redis, etc.).
  
  As a secure pseudorandom function (a.k.a. keyed hash function), SipHash can also be used as a secure message authentication code (MAC). But SipHash is *not a hash* in the sense of general-purpose key-less hash function such as BLAKE3 or SHA-3. SipHash should therefore always be used with a secret key in order to be secure.

- **tink** [ğŸ“](./tink) [ğŸŒ](https://github.com/GerHobbelt/tink) -- A multi-language, cross-platform library that provides cryptographic APIs that are secure, easy to use correctly, and hard(er) to misuse.
- **tink-cc** [ğŸ“](./tink-cc) [ğŸŒ](https://github.com/GerHobbelt/tink-cc) -- Tink C++: Using crypto in your application shouldn't feel like juggling chainsaws in the dark. Tink is a crypto library written by a group of cryptographers and security engineers at Google. It was born out of our extensive experience working with Google's product teams, [fixing weaknesses in implementations](https://github.com/google/wycheproof), and providing simple APIs that can be used safely without needing a crypto background. Tink provides secure APIs that are easy to use correctly and hard(er) to misuse. It reduces common crypto pitfalls with user-centered design, careful implementation and code reviews, and extensive testing. At Google, Tink is one of the standard crypto libraries, and has been deployed in hundreds of products and systems.











## Hash-like Filters & Fast Hashing for Hash Tables et al (64 bits and less, mostly)

These hashes are for other purposes, e.g. fast lookup in dictionaries, fast approximate hit testing and set reduction through fast filtering (think *bloom filter*). These *may* be **machine specific** (and some of them *are*): these are **never supposed to be used for encoding in storage or other means which crosses machine boundaries**: if you want to use them for a database index, that is fine *as long as* you don't expect that database index to be readable by any other machine than the one which produced and uses these hash numbers.

> As you can see from the list below, I went on a shopping spree, having fun with all the latest, including some *possibly insane* stuff that's only really useful for particular edge cases -- which we *hope to avoid ourselves, for a while at least*. Anyway, I'ld say we've got the motherlode here. Simple fun for those days when your brain-flag is at half-mast. Enjoy.

- **adaptiveqf** [ğŸ“](./adaptiveqf) [ğŸŒ](https://github.com/GerHobbelt/adaptiveqf) -- [Adaptive Quotient Filter (AQF)](https://arxiv.org/abs/2107.02866) supports approximate membership testing and counting the occurrences of items in a data set. Like other AMQs, the AQF has a chance for false positives during queries. However, the AQF has the ability to adapt to false positives after they have occurred so they are not repeated. At the same time, the AQF maintains the benefits of a quotient filter, as it is small and fast, has good locality of reference, scales out of RAM to SSD, and supports deletions, counting, resizing, merging, and highly concurrent access.
- **BBHash** [ğŸ“](./BBHash) [ğŸŒ](https://github.com/GerHobbelt/BBHash) -- Bloom-filter based minimal perfect hash function library.
  
  - **left-for-dead**; reason: has some GCC + Linux specific coding constructs; code isn't clean, which doesn't make my porting effort 'trustworthy'. Overall, if this is the alternative, we'll stick with `gperf`.

- **BCF-cuckoo-index** [ğŸ“](./BCF-cuckoo-index) [ğŸŒ](https://github.com/GerHobbelt/BCF) -- Better Choice Cuckoo Filter (BCF) is an efficient approximate set representation data structure. Different from the standard Cuckoo Filter (CF), BCF leverages the principle of the power of two choices to select the better candidate bucket during insertion. BCF reduces the average number of relocations of the state-of-the-art CF by 35%.
  
  - **left-for-dead**; reason: has some GCC + Linux specific coding constructs: intrinsics + Linux-only API calls, which increase the cost of porting.

- **bitrush-index** [ğŸ“](./bitrush-index) [ğŸŒ](https://github.com/GerHobbelt/bitrush-index) -- provides a serializable bitmap index able to index millions values/sec on a single thread. By default this library uses [ozbcbitmap] but if you want you can also use another compressed/uncrompressed bitmap. Only equality-queries (A = X) are supported.
- **bloom** [ğŸ“](./bloom) [ğŸŒ](https://github.com/GerHobbelt/bloom) -- C++ Bloom Filter Library, which offers optimal parameter selection based on expected false positive rate, union, intersection and difference operations between bloom filters and compression of in-use table (increase of false positive probability vs space).
- **cmph-hasher** [ğŸ“](./cmph-hasher) [ğŸŒ](https://github.com/GerHobbelt/cmph) -- C Minimal Perfect Hashing Library for both small and (very) large hash sets.
- **cqf** [ğŸ“](./cqf) [ğŸŒ](https://github.com/GerHobbelt/cqf) -- [A General-Purpose Counting Filter: Counting Quotient Filter (CQF)](https://dl.acm.org/doi/10.1145/3035918.3035963) supports approximate membership testing and counting the occurrences of items in a data set. This general-purpose AMQ is small and fast, has good locality of reference, scales out of RAM to SSD, and supports deletions, counting (even on skewed data sets), resizing, merging, and highly concurrent access.
- **crc32c** [ğŸ“](./crc32c) [ğŸŒ](https://github.com/GerHobbelt/crc32c) -- a few CRC32C implementations under an umbrella that dispatches to a suitable implementation based on the host computer's hardware capabilities. CRC32C is specified as the CRC that uses the iSCSI polynomial in [RFC 3720](https://tools.ietf.org/html/rfc3720#section-12.1). The polynomial was introduced by G. Castagnoli, S. Braeuer and M. Herrmann. CRC32C is used in software such as Btrfs, ext4, Ceph and leveldb.
- **CRoaring** [ğŸ“](./CRoaring) [ğŸŒ](https://github.com/GerHobbelt/CRoaring) -- portable Roaring bitmaps in C (and C++). Bitsets, also called bitmaps, are commonly used as fast data structures. Unfortunately, they can use too much memory. To compensate, we often use compressed bitmaps. Roaring bitmaps are compressed bitmaps which tend to outperform conventional compressed bitmaps such as WAH, EWAH or Concise. They are used by several major systems such as Apache Lucene and derivative systems such as Solr and Elasticsearch, etc.. The CRoaring library is used in several systems such as Apache Doris.
- **cuckoofilter** [ğŸ“](./cuckoofilter) [ğŸŒ](https://github.com/GerHobbelt/cuckoofilter) -- Cuckoo Filter is a Bloom filter replacement for approximated set-membership queries. While Bloom filters are well-known space-efficient data structures to serve queries like "if item x is in a set?", they do not support deletion. Their variances to enable deletion (like counting Bloom filters) usually require much more space. Cuckoo ï¬lters provide the ï¬‚exibility to add and remove items dynamically. A cuckoo filter is based on cuckoo hashing (and therefore named as cuckoo filter).  It is essentially a cuckoo hash table storing each key's fingerprint. Cuckoo hash tables can be highly compact, thus a cuckoo filter could use less space than conventional Bloom ï¬lters, for applications that require low false positive rates (< 3%).
- **cuckoo-index** [ğŸ“](./cuckoo-index) [ğŸŒ](https://github.com/GerHobbelt/cuckoo-index) -- Cuckoo Index (CI) is a lightweight secondary index structure that represents the many-to-many relationship between keys and partitions of columns in a highly space-efficient way. CI associates variable-sized fingerprints in a Cuckoo filter with compressed bitmaps indicating qualifying partitions. The problem of finding all partitions that possibly contain a given lookup key is traditionally solved by maintaining one filter (e.g., a Bloom filter) per partition that indexes all unique key values contained in this partition. To identify all partitions containing a key, we would need to probe all per-partition filters (which could be many). Depending on the storage medium, a false positive there can be very expensive. Furthermore, secondary columns typically contain many duplicates (also across partitions). Cuckoo Index (CI) addresses these drawbacks of per-partition filters. (It must know all keys at build time, though.)
- **DCF-cuckoo-index** [ğŸ“](./DCF-cuckoo-index) [ğŸŒ](https://github.com/GerHobbelt/DCF) -- the Dynamic Cuckoo Filter (DCF) is an efficient approximate membership test data structure. Different from the classic Bloom filter and its variants, DCF is especially designed for highly dynamic datasets and supports extending and reducing its capacity. The DCF design is the first to achieve both reliable item deletion and flexibly extending/reducing for approximate set representation and membership testing. DCF outperforms the state-of-the-art DBF designs in both speed and memory consumption.
- **emphf-hash** [ğŸ“](./emphf-hash) [ğŸŒ](https://github.com/GerHobbelt/emphf) -- an efficient external-memory algorithm for the construction of minimal perfect hash functions for large-scale key sets, focusing on speed and low memory usage (2.61 N bits plus a small constant factor).
- **EWAHBoolArray** [ğŸ“](./EWAHBoolArray) [ğŸŒ](https://github.com/GerHobbelt/EWAHBoolArray) -- a C++ compressed bitset data structure (also called bitset or bit vector). It supports several word sizes by a template parameter (16-bit, 32-bit, 64-bit). You should expect the 64-bit word-size to provide better performance, but higher memory usage, while a 32-bit word-size might compress a bit better, at the expense of some performance.
- **eytzinger** [ğŸ“](./eytzinger) [ğŸŒ](https://github.com/GerHobbelt/eytzinger) -- `fixed_eytzinger_map` is a free implementation of Eytzingerâ€™s layout, in a form of an STL-like generic associative container, broadly compatible with a well-established access patterns. An Eytzinger map, or BFS(breadth-first search) map, places elements in a lookup order, which leads to a better memory locality. In practice, such container can outperform searching in sorted arrays, like `boost::flat_map`, due to less cache misses made in a lookup process. In comparison with RB-based trees, like `std::map`, lookup in Eytzinger map can be multiple times faster. Some comparison graphs are [given here](https://kazakov.life/2017/03/06/cache-friendly-associative-container/).
- **farmhash** [ğŸ“](./farmhash) [ğŸŒ](https://github.com/GerHobbelt/farmhash) -- FarmHash, a family of hash functions. FarmHash provides hash functions for strings and other data.  The functions mix the input bits thoroughly but are not suitable for cryptography.
- **fastfilter_cpp** [ğŸ“](./fastfilter_cpp) [ğŸŒ](https://github.com/GerHobbelt/fastfilter_cpp) -- Fast Filter: Fast approximate membership filter implementations (C++, research library)
- **fasthashing** [ğŸ“](./fasthashing) [ğŸŒ](https://github.com/GerHobbelt/fasthashing) -- a few very fast (almost) strongly universal hash functions over 32-bit strings, as described by the paper:  Owen Kaser and Daniel Lemire, Strongly universal string hashing is fast, Computer Journal (2014) 57 (11): 1624-1638. http://arxiv.org/abs/1202.4961
- **fifo_map** [ğŸ“](./fifo_map) [ğŸŒ](https://github.com/GerHobbelt/fifo_map) -- a FIFO-ordered associative container for C++. It has the same interface as `std::map`, it can be used as drop-in replacement.
- **flat_hash_map** [ğŸ“](./flat_hash_map) [ğŸŒ](https://github.com/GerHobbelt/flat_hash_map) -- a very fast hashtable.
- **flat.hpp** [ğŸ“](./flat.hpp) [ğŸŒ](https://github.com/GerHobbelt/flat.hpp) -- a library of flat vector-like based associative containers.
- **fph-table** [ğŸ“](./fph-table) [ğŸŒ](https://github.com/GerHobbelt/fph-table) -- the Flash Perfect Hash (FPH) library is a modern C++/17 implementation of a dynamic [perfect hash](https://en.wikipedia.org/wiki/Perfect_hash_function) table (no collisions for the hash), which makes the hash map/set extremely fast for lookup operations. We provide four container classes `fph::DynamicFphSet`,`fph::DynamicFphMap`,`fph::MetaFphSet` and `fph::MetaFphMap`. The APIs of these four classes are almost the same as those of `std::unordered_set` and `std::unordered_map`.
- **fsst** [ğŸ“](./fsst) [ğŸŒ](https://github.com/GerHobbelt/fsst) -- Fast Static Symbol Table (FSST): fast text compression that allows random access. See also the PVLDB paper https://github.com/cwida/fsst/raw/master/fsstcompression.pdf. FSST is a compression scheme focused on string/text data: it can compress strings from distributions with many different values (i.e. where dictionary compression will not work well). It allows *random-access* to compressed data: it is not block-based, so individual strings can be decompressed without touching the surrounding data in a compressed block. When compared to e.g. LZ4 (which is block-based), FSST further achieves similar decompression speed and compression speed, and better compression ratio. FSST encodes strings using a symbol table -- but it works on pieces of the string, as it maps "symbols" (1-8 byte sequences) onto "codes" (single-bytes). FSST can also represent a byte as an exception (255 followed by the original byte). Hence, compression transforms a sequence of bytes into a (supposedly shorter) sequence of codes or escaped bytes. These shorter byte-sequences could be seen as strings again and fit in whatever your program is that manipulates strings. An optional 0-terminated mode (like, C-strings) is also supported.
- **gperf-hash** [ğŸ“](./gperf-hash) [ğŸŒ](https://github.com/GerHobbelt/gperf) -- This is GNU gperf, a program that generates C/C++ perfect hash functions for sets of key words.
- **HashMap** [ğŸ“](./HashMap) [ğŸŒ](https://github.com/GerHobbelt/HashMap) -- a hash table mostly compatible with the C++11 *std::unordered_map* interface, but with much higher performance for many workloads. This hash table uses open addressing with linear probing and backshift deletion. Open addressing and linear probing minimizes memory allocations and achieves high cache efficiency. Backshift deletion keeps performance high for delete heavy workloads by not clobbering the hash table with tombestones.
- **highwayhash** [ğŸ“](./highwayhash) [ğŸŒ](https://github.com/GerHobbelt/highwayhash) -- Fast strong hash functions: SipHash/HighwayHash
- **hopscotch-map** [ğŸ“](./hopscotch-map) [ğŸŒ](https://github.com/GerHobbelt/hopscotch-map) -- a C++ implementation of a fast hash map and hash set using hopscotch hashing and open-addressing to resolve collisions. It is a cache-friendly data structure offering better performances than `std::unordered_map` in most cases and is closely similar to `google::dense_hash_map` while using less memory and providing more functionalities.
- **iceberghashtable** [ğŸ“](./iceberghashtable) [ğŸŒ](https://github.com/GerHobbelt/iceberghashtable) -- [IcebergDB: High Performance Hash Tables Through Stability and Low Associativity](https://arxiv.org/abs/2210.04068) is a fast, concurrent, and resizeable hash table implementation. It supports insertions, deletions and queries for 64-bit keys and values.
- **LDCF-hash** [ğŸ“](./LDCF-hash) [ğŸŒ](https://github.com/GerHobbelt/LDCF) -- The Logarithmic Dynamic Cuckoo Filter (LDCF) is an efficient approximate membership test data structure for dynamic big data sets. LDCF uses a novel multi-level tree structure and reduces the worst insertion and membership testing time from O(N) to O(1), while simultaneously reducing the memory cost of DCF as the cardinality of the set increases.
- **libbloom** [ğŸ“](./libbloom) [ğŸŒ](https://github.com/GerHobbelt/bloomd) -- a high-performance C server, exposing bloom filters and operations over them. The rate of false positives can be tuned to meet application demands, but reducing the error rate rapidly increases the amount of memory required for the representation. Example: Bloom filters enable you to represent 1MM items with a false positive rate of 0.1% in 2.4MB of RAM.
- **libbloomfilters** [ğŸ“](./libbloomfilters) [ğŸŒ](https://github.com/GerHobbelt/libbloomfilters) -- **libbf** is a C++11 library which implements various Bloom filters, including:
  
  - A^2
  - Basic
  - Bitwise
  - Counting
  - Spectral MI
  - Spectral RM
  - Stable

- **libCRCpp** [ğŸ“](./libCRCpp) [ğŸŒ](https://github.com/GerHobbelt/CRCpp) -- easy to use and fast C++ CRC library.
- **libCSD** [ğŸ“](./libCSD) [ğŸŒ](https://github.com/GerHobbelt/libCSD) -- a C++ library providing some different techniques for managing string dictionaries in compressed space. These approaches are inspired on the paper: "Compressed String Dictionaries", Nieves R. Brisaboa, Rodrigo CÃ¡novas, Francisco Claude, Miguel A. MartÃ­nez-Prieto, and Gonzalo Navarro, 10th Symposium on Experimental Algorithms (SEA'2011), p.136-147, 2011.
- **libcuckoo** [ğŸ“](./libcuckoo) [ğŸŒ](https://github.com/GerHobbelt/libcuckoo) -- provides a high-performance, compact hash table that allows multiple concurrent reader and writer threads.
- **lshbox** [ğŸ“](./lshbox) [ğŸŒ](https://github.com/GerHobbelt/LSHBOX) -- a C++ Toolbox of Locality-Sensitive Hashing for Large Scale Image Retrieval. Locality-Sensitive Hashing (LSH) is an efficient method for large scale image retrieval, and it achieves great performance in approximate nearest neighborhood searching.
  
  LSHBOX is a simple but robust C++ toolbox that provides several LSH algrithms, in addition, it can be integrated into Python and MATLAB languages. The following LSH algrithms have been implemented in LSHBOX, they are:
  
  * LSH Based on Random Bits Sampling
  * Random Hyperplane Hashing
  * LSH Based on Thresholding
  * LSH Based on p-Stable Distributions
  * [Spectral Hashing](http://www.cs.huji.ac.il/~yweiss/SpectralHashing/) (SH)
  * [Iterative Quantization](http://www.unc.edu/~yunchao/itq.htm) (ITQ)
  * Double-Bit Quantization Hashing (DBQ)
  * K-means Based Double-Bit Quantization Hashing (KDBQ)

- **morton_filter** [ğŸ“](./morton_filter) [ğŸŒ](https://github.com/GerHobbelt/morton_filter) -- a [Morton filter](https://www.vldb.org/pvldb/vol11/p1041-breslow.pdf) -- a new approximate set membership data structure. A Morton filter is a modified cuckoo filter that is optimized for bandwidth-constrained systems. Morton filters use additional computation in order to reduce their off-chip memory traffic. Like a cuckoo filter, a Morton filter supports insertions, deletions, and lookup operations. It additionally adds high-throughput self-resizing, a feature of quotient filters, which allows a Morton filter to increase its capacity solely by leveraging its internal representation. This capability is in contrast to existing vanilla cuckoo filter implementations, which are static and thus require using a backing data structure that contains the full set of items to resize the filter. Morton filters can also be configured to use less memory than a cuckoo filter for the same error rate while simultaneously delivering insertion, deletion, and lookup throughputs that are, respectively, up to 15.5x, 1.3x, and 2.5x higher than a cuckoo filter. Morton filters in contrast to vanilla cuckoo filters do not require a power of two number of buckets but rather only a number that is a multiple of two. They also use fewer bits per item than a Bloom filter when the target false positive rate is less than around 1% to 3%.
- **mutable_rank_select** [ğŸ“](./mutable_rank_select) [ğŸŒ](https://github.com/GerHobbelt/mutable_rank_select) -- Rank/Select Queries over Mutable Bitmaps. Given a *mutable* bitmap `B[0..u)` where `n` bits are set, the *rank/select problem* asks for a data structure built from `B` that supports `rank(i)` (the number of bits set in `B[0..i]`, for 0 â‰¤ i < u), `select(i)` (the position of the i-th bit set, for 0 â‰¤ i < n), `flip(i)` (toggles `B[i]`, for 0 â‰¤ i < u) and `access(i)` (return `B[i]`, for 0 â‰¤ i < u). The input bitmap is partitioned into blocks and a tree index is built over them. The tree index implemented in the library is an optimized b-ary Segment-Tree with SIMD AVX2/AVX-512 instructions. You can test a block size of 256 or 512 bits, and various rank/select algorithms for the blocks such as broadword techniques, CPU intrinsics, and SIMD instructions.
- **nedtries** [ğŸ“](./nedtries) [ğŸŒ](https://github.com/GerHobbelt/nedtries) -- an in-place bitwise binary Fredkin trie algorithm which allows for near constant time insertions, deletions, finds, closest fit finds and iteration. On modern hardware it is approximately 50-100% faster than red-black binary trees, it handily beats even the venerable O(1) hash table for less than 3000 objects and it is barely slower than the hash table for 10000 objects. Past 10000 objects you probably ought to use a hash table though, and if you need nearest fit rather than close fit then red-black trees are still optimal.
- **OZBCBitmap** [ğŸ“](./OZBCBitmap) [ğŸŒ](https://github.com/GerHobbelt/OZBCBitmap) -- OZBC provides an efficent compressed bitmap to create bitmap indexes on high-cardinality columns. Bitmap indexes have traditionally been considered to work well for low-cardinality columns, which have a modest number of distinct values. The simplest and most common method of bitmap indexing on attribute A with K cardinality associates a bitmap with every attribute value V then the Vth bitmap rapresent the predicate A=V. This approach ensures an efficient solution for performing search but on high-cardinality attributes the size of the bitmap index increase dramatically. OZBC is a run-length-encoded hybrid compressed bitmap designed exclusively to create a bitmap indexes on L cardinality attributes where L>=16 and provide bitwise logical operations in running time complexity proportianl to the compressed bitmap size.
- **parallel-hashmap** [ğŸ“](./parallel-hashmap) [ğŸŒ](https://github.com/GerHobbelt/parallel-hashmap) -- a set of hash map implementations, as well as a btree alternative to std::map and std::set
- **phf-hash** [ğŸ“](./phf-hash) [ğŸŒ](https://github.com/GerHobbelt/phf) -- a simple implementation of the CHD perfect hash algorithm. CHD can generate perfect hash functions for very large key sets -- on the order of millions of keys -- in a very short time.
- **poplar-trie** [ğŸ“](./poplar-trie) [ğŸŒ](https://github.com/GerHobbelt/poplar-trie) -- a C++17 library of a memory-efficient associative array whose keys are strings. The data structure is based on a dynamic path-decomposed trie (DynPDT) described in the paper, Shunsuke Kanda, Dominik KÃ¶ppl, Yasuo Tabei, Kazuhiro Morita, and Masao Fuketa: [Dynamic Path-decomposed Tries](https://arxiv.org/abs/1906.06015), *ACM Journal of Experimental Algorithmics (JEA)*, *25*(1): 1â€“28, 2020. Poplar-trie is a memory-efficient updatable associative array implementation which maps key strings to values of any type like `std::map<std::string,anytype>`. DynPDT is composed of two structures: dynamic trie and node label map (NLM) structures.
- **prvhash** [ğŸ“](./prvhash) [ğŸŒ](https://github.com/GerHobbelt/prvhash) -- PRVHASH is a hash function that generates a [uniform pseudo-random number sequence](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) derived from the message. PRVHASH is conceptually similar (in the sense of using a pseudo-random number sequence as a hash) to [`keccak`](https://en.wikipedia.org/wiki/SHA-3) and [`RadioGatun`](https://en.wikipedia.org/wiki/RadioGat%C3%BAn) schemes, but is a completely different implementation of such concept. PRVHASH is both a ["randomness extractor"](https://en.wikipedia.org/wiki/Randomness_extractor) and an "extendable-output function" (XOF).
- **QALSH** [ğŸ“](./QALSH) [ğŸŒ](https://github.com/GerHobbelt/QALSH) -- QALSH: Query-Aware Locality-Sensitive Hashing, is a package for the problem of Nearest Neighbor Search (NNS) over high-dimensional Euclidean spaces. Given a set of data points and a query, the problem of NNS aims to find the nearest data point to the query. It is a very fundamental probelm and has wide applications in many data mining and machine learning tasks. This package provides the external memory implementations (disk-based) of QALSH and QALSH<sup>+</sup> for *c*-Approximate Nearest Neighbor Search (c-ANNS) under *l<sub>p</sub>* norm, where *0 < p â©½ 2*. The internel memory version can be found [here](https://github.com/HuangQiang/QALSH_Mem).
- **QALSH_Mem** [ğŸ“](./QALSH_Mem) [ğŸŒ](https://github.com/GerHobbelt/QALSH_Mem) -- Memory Version of QALSH: **QALSH_Mem** is a package for the problem of Nearest Neighbor Search (NNS). Given a set of data points and a query, the problem of NNS aims to find the nearest data point to the query. It has wide applications in many data mining and machine learning tasks. This package provides the internal memory implementations of two LSH schemes QALSH and QALSH<sup>+</sup> for *c*-Approximate Nearest Neighbor Search (c-ANNS) under *l<sub>p</sub>* norm, where *0 < p â©½ 2*. The external version of QALSH and QALSH<sup>+</sup> can be found [here](https://github.com/HuangQiang/QALSH).
- **RectangleBinPack** [ğŸ“](./RectangleBinPack) [ğŸŒ](https://github.com/GerHobbelt/RectangleBinPack) -- the source code used in "A Thousand Ways to Pack the Bin - A Practical Approach to Two-Dimensional Rectangle Bin Packing." The code can be
- **RoaringBitmap** [ğŸ“](./RoaringBitmap) [ğŸŒ](https://github.com/GerHobbelt/RoaringBitmap) -- Roaring bitmaps are compressed bitmaps which tend to outperform conventional compressed bitmaps such as WAH, EWAH or Concise. In some instances, roaring bitmaps can be hundreds of times faster and they often offer significantly better compression. They can even be faster than uncompressed bitmaps.
- **robin-hood-hashing** [ğŸ“](./robin-hood-hashing) [ğŸŒ](https://github.com/GerHobbelt/robin-hood-hashing) -- robin_hood unordered map & set.
- **robin-map** [ğŸ“](./robin-map) [ğŸŒ](https://github.com/GerHobbelt/robin-map) -- a C++ implementation of a fast hash map and hash set using open-addressing and linear robin hood hashing with backward shift deletion to resolve collisions.
- **rollinghashcpp** [ğŸ“](./rollinghashcpp) [ğŸŒ](https://github.com/GerHobbelt/rollinghashcpp) -- randomized rolling hash functions in C++. This is a set of C++ classes implementing various recursive n-gram hashing techniques, also called rolling hashing (http://en.wikipedia.org/wiki/Rolling_hash), including Randomized Karp-Rabin (sometimes called Rabin-Karp), Hashing by Cyclic Polynomials (also known as Buzhash) and Hashing by Irreducible Polynomials.
- **semimap** [ğŸ“](./semimap) [ğŸŒ](https://github.com/GerHobbelt/semimap) -- semi::static_map and semi::map: associative map containers with compile-time lookup! Normally, associative containers require some runtime overhead when looking up their values from a key. However, when the key is known at compile-time (for example, when the key is a literal) then this run-time lookup could technically be avoided. This is exactly what the goal of `semi::static_map` and `semi::map` is.
- **SipHash** [ğŸ“](./SipHash) [ğŸŒ](https://github.com/GerHobbelt/SipHash) -- SipHash is a family of pseudorandom functions (PRFs) optimized for speed on short messages. This is the reference C code of SipHash: portable, simple, optimized for clarity and debugging. SipHash was designed in 2012 by [Jean-Philippe Aumasson](https://aumasson.jp) and [Daniel J. Bernstein](https://cr.yp.to) as a defense against [hash-flooding DoS attacks](https://aumasson.jp/siphash/siphashdos_29c3_slides.pdf).
  
  It is *simpler and faster* on short messages than previous cryptographic algorithms, such as MACs based on universal hashing, *competitive in performance* with insecure non-cryptographic algorithms, such as [fhhash](https://github.com/cbreeden/fxhash), *cryptographically secure*, with no sign of weakness despite multiple [cryptanalysis](https://eprint.iacr.org/2019/865) [projects](https://eprint.iacr.org/2019/865) by leading cryptographers, *battle-tested*, with successful integration in OSs (Linux kernel, OpenBSD, FreeBSD, FreeRTOS), languages (Perl, Python, Ruby, etc.), libraries (OpenSSL libcrypto, Sodium, etc.) and applications (Wireguard, Redis, etc.).
  
  As a secure pseudorandom function (a.k.a. keyed hash function), SipHash can also be used as a secure message authentication code (MAC). But SipHash is *not a hash* in the sense of general-purpose key-less hash function such as BLAKE3 or SHA-3. SipHash should therefore always be used with a secret key in order to be secure.

- **slot_map** [ğŸ“](./slot_map) [ğŸŒ](https://github.com/GerHobbelt/slot_map) -- a Slot Map is a high-performance associative container with persistent unique keys to access stored values. Upon insertion, a key is returned that can be used to later access or remove the values. Insertion, removal, and access are all guaranteed to take `O(1)` time (best, worst, and average case). Great for storing collections of objects that need stable, safe references but have no clear ownership. The difference between a `std::unordered_map` and a `dod::slot_map` is that the slot map generates and returns the key when inserting a value. A key is always unique and will only refer to the value that was inserted.
- **smhasher** [ğŸ“](./smhasher) [ğŸŒ](https://github.com/GerHobbelt/smhasher) -- benchmark and collection of fast hash functions for symbol tables or hash tables.
- **sparsehash** [ğŸ“](./sparsehash) [ğŸŒ](https://github.com/GerHobbelt/sparsehash) -- fast (non-cryptographic) hash algorithms
- **sparsepp** [ğŸ“](./sparsepp) [ğŸŒ](https://github.com/GerHobbelt/sparsepp) -- a fast, memory efficient hash map for C++. Sparsepp is derived from Google's excellent [sparsehash](https://github.com/sparsehash/sparsehash) implementation.
- **spookyhash** [ğŸ“](./spookyhash) [ğŸŒ](https://github.com/GerHobbelt/spookyhash) -- a very fast non cryptographic hash function, [designed by Bob Jenkins](http://burtleburtle.net/bob/hash/spooky.html). It produces well-distributed 128-bit hash values for byte arrays of any length. It can produce 64-bit and 32-bit hash values too, at the same speed.
- **StronglyUniversalStringHashing** [ğŸ“](./StronglyUniversalStringHashing) [ğŸŒ](https://github.com/GerHobbelt/StronglyUniversalStringHashing) -- very fast [universal hash families](https://en.wikipedia.org/wiki/Universal_hashing) on strings.
- **tensorstore** [ğŸ“](./tensorstore) [ğŸŒ](https://github.com/GerHobbelt/tensorstore) -- TensorStore is an open-source C++ and Python software library designed for storage and manipulation of large multi-dimensional arrays.
- **wyhash** [ğŸ“](./wyhash) [ğŸŒ](https://github.com/GerHobbelt/wyhash) -- No hash function is perfect, but some are useful. `wyhash` and `wyrand` are the ideal 64-bit hash function and PRNG respectively: solid, portable, fastest (especially for short keys), salted (using a dynamic secret to avoid intended attack).
- **xor-and-binary-fuse-filter** [ğŸ“](./xor-and-binary-fuse-filter) [ğŸŒ](https://github.com/GerHobbelt/xor_singleheader) -- XOR and Binary Fuse Filter library: Bloom filters are used to quickly check whether an element is part of a set. Xor filters and binary fuse filters are faster and more concise alternative to Bloom filters. They are also smaller than cuckoo filters. They are used in [production systems](https://github.com/datafuselabs/databend).
- **xsg** [ğŸ“](./xsg) [ğŸŒ](https://github.com/GerHobbelt/xsg) -- XOR [BST](https://en.wikipedia.org/wiki/Binary_search_tree) implementations are related to the [XOR linked list](https://en.wikipedia.org/wiki/XOR_linked_list), a [doubly linked list](https://en.wikipedia.org/wiki/Doubly_linked_list) variant, from where we borrow the idea about how links between nodes are to be implemented. Modest resource requirements and simplicity make XOR [scapegoat trees](https://en.wikipedia.org/wiki/Scapegoat_tree) stand out of the [BST](https://en.wikipedia.org/wiki/Binary_search_tree) crowd. All iterators (except `end()` iterators), but not references and pointers, are invalidated, after inserting or erasing from this XOR [scapegoat tree](https://en.wikipedia.org/wiki/Scapegoat_tree) implementation. You can dereference invalidated iterators, if they were not erased, but you cannot iterate with them. `end()` iterators are constant and always valid, but dereferencing them results in undefined behavior.
- **xxHash** [ğŸ“](./xxHash) [ğŸŒ](https://github.com/GerHobbelt/xxHash) -- fast (non-cryptographic) hash algorithm
- ~~**circlehash** [ğŸ“](./circlehash) [ğŸŒ](https://github.com/GerHobbelt/circlehash) -- a family of non-cryptographic hash functions that pass every test in SMHasher.~~
  
  - **removed**; reason: written in Go; port to C/C++ is easy but just too much effort for too little gain; when we're looking for *fast* non-cryptographic hashes like this, we don't it to include 128-bit / 64-bit multiplications as those are generally slower than shift, add, xor. While this will surely be a nice hash, it doesn't fit our purposes.












## Intermediate Data Storage / Caching / Hierarchical Data Stores (binary hOCR; document text revisions; ...)

- **CacheLib** [ğŸ“](./CacheLib) [ğŸŒ](https://github.com/GerHobbelt/CacheLib) -- provides an in-process high performance caching mechanism, thread-safe API to build high throughput, low overhead caching services, with built-in ability to leverage DRAM and SSD caching transparently.
- **cachelot** [ğŸ“](./cachelot) [ğŸŒ](https://github.com/GerHobbelt/cachelot) -- is an LRU cache that works at the speed of light. The library works with a fixed pre-allocated memory. You tell the memory size and LRU cache is ready. Small metadata, up to 98% memory utilization.
- **caches** [ğŸ“](./caches) [ğŸŒ](https://github.com/GerHobbelt/caches) -- implements a simple thread-safe cache with several page replacement policies: LRU (Least Recently Used), FIFO (First-In/First-Out), LFU (Least Frequently Used)
- **c-blosc2** [ğŸ“](./c-blosc2) [ğŸŒ](https://github.com/GerHobbelt/c-blosc2) -- a high performance compressor optimized for binary data (i.e. floating point numbers, integers and booleans), designed to transmit data to the processor cache faster than the traditional, non-compressed, direct memory fetch approach via a `memcpy()` OS call.
- **localmemcache** [ğŸ“](./localmemcache) [ğŸŒ](https://github.com/GerHobbelt/localmemcache) -- a key-value database and library that provides an interface similar to `memcached` but for accessing local data instead of remote data.  It's based on mmap()'ed shared memory for maximum speed. It supports persistence, also making it a fast alternative to GDBM and Berkeley DB.
- **lru_cache** [ğŸ“](./lru_cache) [ğŸŒ](https://github.com/GerHobbelt/lru_cache) -- LRU cache is a fast, header-only, generic C++ 17 [LRU cache][1] library, with customizable backend.
- **lrucache11** [ğŸ“](./lrucache11) [ğŸŒ](https://github.com/GerHobbelt/lrucache11) -- A header only C++11 LRU Cache template class that allows you to define key, value and optionally the `Map` type. uses a double linked list and a `std::unordered_map` style container to provide fast insert, delete and update No dependencies other than the C++ standard library.
- **pelikan** [ğŸ“](./pelikan) [ğŸŒ](https://github.com/GerHobbelt/pelikan) -- Pelikan is Twitter's unified cache backend.
- **stlcache** [ğŸ“](./stlcache) [ğŸŒ](https://github.com/GerHobbelt/stlcache) -- STL::Cache is an in-memory cache for C++ applications. STL::Cache is just a simple wrapper over standard map, that implements some cache algorithms, thus allowing you to limit the storage size and automatically remove unused items from it. It is intended to be used for keeping any key/value data, especially when data's size are too big, to just put it into the map and keep the whole thing. With STL::Cache you could put enormous (really unlimited) amount of data into it, but it will store only some small part of your data. So re-usable data will be kept near your code and not so popular data will not spend expensive memory. STL::Cache uses configurable policies, for decisions, whether data are good, to be kept in cache or they should be thrown away. It is shipped with 8 policies and you are free to implement your own.











### RAM-/disk-based large queues and stores: B+tree, LSM-tree, ...

- **arrow** [ğŸ“](./arrow) [ğŸŒ](https://github.com/GerHobbelt/arrow) -- Apache Arrow is a development platform for in-memory analytics. It contains a set of technologies that enable big data systems to process and move data fast. The reference Arrow libraries contain many distinct software components:
  
  - Columnar vector and table-like containers (similar to data frames) supporting
    flat or nested types
  
  - Conversions to and from other in-memory data structures
  - Integration tests for verifying binary compatibility between the
    implementations (e.g. sending data from Java to C++)
  
  - IO interfaces to local and remote filesystems
  - Readers and writers for various widely-used file formats (such as Parquet, CSV)
  - Reference-counted off-heap buffer memory management, for zero-copy memory
    sharing and handling memory-mapped files
  
  - Self-describing binary wire formats (streaming and batch/file-like) for
    remote procedure calls (RPC) and interprocess communication (IPC)

- **cpp-btree** [ğŸ“](./cpp-btree) [ğŸŒ](https://github.com/GerHobbelt/cpp-btree) -- in-memory B+-tree: an alternative for the priority queue as we expect the queue to grow huge, given past experience with Qiqqa.
- **libmdbx** [ğŸ“](./libmdbx) [ğŸŒ](https://github.com/GerHobbelt/libmdbx) -- one of the fastest embeddable key-value ACID database without WAL. `libmdbx` surpasses the legendary LMDB in terms of reliability, features and performance.
- **libpmemobj-cpp** [ğŸ“](./libpmemobj-cpp) [ğŸŒ](https://github.com/GerHobbelt/libpmemobj-cpp) -- a C++ binding for **libpmemobj** (a library which is a part of [PMDK collection](https://github.com/pmem/pmdk)).
- **libshmcache** [ğŸ“](./libshmcache) [ğŸŒ](https://github.com/GerHobbelt/libshmcache) -- a local share memory cache for multi processes. it is a high performance library because read mechanism is lockless. libshmcache is 100+ times faster than a remote interface such as redis.
- **Lightning.NET** [ğŸ“](./Lightning.NET) [ğŸŒ](https://github.com/GerHobbelt/Lightning.NET) -- .NET library for OpenLDAP's LMDB key-value store
- **ligra-graph** [ğŸ“](./ligra-graph) [ğŸŒ](https://github.com/GerHobbelt/ligra) -- LIGRA: a Lightweight Graph Processing Framework for Shared Memory; works on both uncompressed and compressed graphs and hypergraphs.
- **lmdb** [ğŸ“](./lmdb) [ğŸŒ](https://github.com/GerHobbelt/lmdb) -- OpenLDAP [LMDB](http://www.lmdb.tech/doc/index.html) is an outrageously fast key/value store with semantics that make it highly interesting for many applications.  Of specific note, besides speed, is the full support for transactions and good read/write concurrency.  LMDB is also famed for its robustness **when used correctly**.
- **lmdb-safe** [ğŸ“](./lmdb-safe) [ğŸŒ](https://github.com/GerHobbelt/lmdb-safe) -- A safe modern & performant C++ wrapper of LMDB. LMDB is an outrageously fast key/value store with semantics that make it highly interesting for many applications. Of specific note, besides speed, is the full support for transactions and good read/write concurrency. LMDB is also famed for its robustness.. **when used correctly**. The design of LMDB is elegant and simple, which aids both the performance and stability. The downside of this elegant design is a nontrivial set of rules that need to be followed to not break things. In other words, LMDB delivers great things but only if you use it exactly right. This is by conscious design. The `lmdb-safe` library aims to deliver the full LMDB performance while programmatically making sure the LMDB semantics are adhered to, with very limited overhead.
- **lmdb.spreads.net** [ğŸ“](./lmdb.spreads.net) [ğŸŒ](https://github.com/GerHobbelt/Spreads.LMDB) -- Low-level zero-overhead and [the fastest](https://github.com/Spreads/Spreads.LMDB/commit/4085dde649ef9ebb64310f2627299762dd62d5ce) LMDB .NET wrapper with some additional native methods useful for [Spreads](https://github.com/Spreads/).
- **lmdb-store** [ğŸ“](./lmdb-store) [ğŸŒ](https://github.com/GerHobbelt/lmdb-store) -- an ultra-fast NodeJS interface to LMDB; probably the fastest and most efficient NodeJS key-value/database interface that exists for full storage and retrieval of structured JS data (objects, arrays, etc.) in a true persisted, scalable, [ACID compliant](https://en.wikipedia.org/wiki/ACID) database. It provides a simple interface for interacting with LMDB.
- **lmdbxx** [ğŸ“](./lmdbxx) [ğŸŒ](https://github.com/GerHobbelt/lmdbxx) -- lmdb++: a comprehensive C++11 wrapper for the LMDB embedded database library, offering both an error-checked procedural interface and an object-oriented resource interface with RAII semantics.
- **palmtree** [ğŸ“](./palmtree) [ğŸŒ](https://github.com/GerHobbelt/palmtree) -- concurrent lock free B+Tree
- **parallel-hashmap** [ğŸ“](./parallel-hashmap) [ğŸŒ](https://github.com/GerHobbelt/parallel-hashmap) -- a set of hash map implementations, as well as a btree alternative to std::map and std::set
- **pmdk** [ğŸ“](./pmdk) [ğŸŒ](https://github.com/GerHobbelt/pmdk) -- the **Persistent Memory Development Kit (PMDK)** is a collection of libraries and tools for System Administrators and Application Developers to simplify managing and accessing persistent memory devices.
- **pmdk-tests** [ğŸ“](./pmdk-tests) [ğŸŒ](https://github.com/GerHobbelt/pmdk-tests) -- tests for [Persistent Memory Development Kit](https://github.com/pmem/pmdk)
- **pmemkv** [ğŸ“](./pmemkv) [ğŸŒ](https://github.com/GerHobbelt/pmemkv) -- `pmemkv` is a local/embedded key-value datastore optimized for persistent memory. Rather than being tied to a single language or backing implementation, `pmemkv` provides different options for language bindings and storage engines.
- **pmemkv-bench** [ğŸ“](./pmemkv-bench) [ğŸŒ](https://github.com/GerHobbelt/pmemkv-bench) -- benchmark for [libpmemkv](https://github.com/pmem/pmemkv/) and its underlying libraries, based on [leveldb's db_bench](https://github.com/google/leveldb). The `pmemkv_bench` utility provides some standard read, write & remove benchmarks. It's based on the `db_bench` utility included with LevelDB and RocksDB, although the list of supported parameters is slightly different.
- **riegeli** [ğŸ“](./riegeli) [ğŸŒ](https://github.com/GerHobbelt/riegeli) -- *Riegeli/records* is a file format for storing a sequence of string records, typically serialized protocol buffers. It supports dense compression, fast decoding, seeking, detection and optional skipping of data corruption, filtering of proto message fields for even faster decoding, and parallel encoding.
- **tlx-btree** [ğŸ“](./tlx-btree) [ğŸŒ](https://github.com/GerHobbelt/tlx) -- in-memory B+-tree: an alternative for the priority queue as we expect the queue to grow huge, given past experience with Qiqqa.
- **vmem** [ğŸ“](./vmem) [ğŸŒ](https://github.com/GerHobbelt/vmem) -- **libvmem** and **libvmmalloc** are a couple of libraries for using persistent memory for malloc-like volatile uses.  They have historically been a part of [PMDK](https://pmem.io/pmdk) despite being solely for volatile uses. You may want consider using [memkind](https://github.com/memkind/memkind) instead in code that benefits from extra features like NUMA awareness.
- **vmemcache** [ğŸ“](./vmemcache) [ğŸŒ](https://github.com/GerHobbelt/vmemcache) -- **libvmemcache** is an embeddable and lightweight in-memory buffered LRU caching solution. It's designed to fully take advantage of large capacity memory, such as Persistent Memory with DAX, through memory mapping in an efficient and scalable way.











### HDF5 file format

- **h5cpp** [ğŸ“](./h5cpp) [ğŸŒ](https://github.com/GerHobbelt/h5cpp) -- easy to use HDF5 C++ templates for Serial and Paralel HDF5. Hierarchical Data Format HDF5 is prevalent in high performance scientific computing, sits directly on top of sequential or parallel file systems, providing block and stream operations on standardized or custom binary/text objects. Scientific computing platforms come with the necessary libraries to read write HDF5 dataset. H5CPP simplifies interactions with popular linear algebra libraries, provides compiler assisted seamless object persistence, Standard Template Library support and comes equipped with a novel error handling architecture.
  
  - **in-purgatory**; reason: see the `HDF5` entry below. But advertises to be an interface between OpenCV, Eigen, etc. at the same time...

- ~~**HDF5** [ğŸŒ](https://github.com/HDFGroup/hdf5)~~
  
  - **removed**; reason: HDF5 is a nice concept but considered *overkill* right now; where we need disk stores, we'll be using SQLite or LMDB-like key-value stores instead. Such stores are not meant to be interchangeable with other software in their raw shape and we'll provide public access APIs instead, where applicable.

- ~~**HighFive-HDF5** [ğŸŒ](https://github.com/BlueBrain/HighFive)~~
  
  - **removed**; reason: see the `HDF5` entry above.












## Data Storage / Caching / IPC: loss-less data compression

- **brotli** [ğŸ“](./brotli) [ğŸŒ](https://github.com/GerHobbelt/brotli) -- compression
- **c-blosc2** [ğŸ“](./c-blosc2) [ğŸŒ](https://github.com/GerHobbelt/c-blosc2) -- a high performance compressor optimized for binary data (i.e. floating point numbers, integers and booleans), designed to transmit data to the processor cache faster than the traditional, non-compressed, direct memory fetch approach via a `memcpy()` OS call.
- **density** [ğŸ“](./density) [ğŸŒ](https://github.com/GerHobbelt/density) -- a superfast compression library. It is focused on high-speed compression, at the best ratio possible. **All three** of DENSITY's algorithms are currently at the **pareto frontier** of compression speed vs ratio (cf. [here](https://github.com/inikep/lzbench/blob/master/lzbench18_sorted.md) for an independent benchmark).
- **densityxx** [ğŸ“](./densityxx) [ğŸŒ](https://github.com/GerHobbelt/densityxx) -- the c++ version of `density`, which is a super fast compress library.
- **fast-lzma2** [ğŸ“](./fast-lzma2) [ğŸŒ](https://github.com/GerHobbelt/fast-lzma2) -- the __Fast LZMA2 Library__ is a lossless high-ratio data compression library based on Igor Pavlov's LZMA2 codec from 7-zip. Binaries of 7-Zip forks which use the algorithm are available in the [7-Zip-FL2 project](https://github.com/conor42/7-Zip-FL2/releases/), the [7-Zip-zstd project](https://github.com/mcmilk/7-Zip-zstd/releases/), and the active fork of [p7zip](https://github.com/szcnick/p7zip/releases/). The library is also embedded in a fork of XZ Utils, named [FXZ Utils](https://github.com/conor42/fxz).
- **fast_pfor** [ğŸ“](./fast_pfor) [ğŸŒ](https://github.com/GerHobbelt/FastPFor) -- a research library with integer compression schemes. It is broadly applicable to the compression of arrays of 32-bit integers where most integers are small. The library seeks to exploit SIMD instructions (SSE) whenever possible.
- **fsst** [ğŸ“](./fsst) [ğŸŒ](https://github.com/GerHobbelt/fsst) -- Fast Static Symbol Table (FSST): fast text compression that allows random access. See also the PVLDB paper https://github.com/cwida/fsst/raw/master/fsstcompression.pdf. FSST is a compression scheme focused on string/text data: it can compress strings from distributions with many different values (i.e. where dictionary compression will not work well). It allows *random-access* to compressed data: it is not block-based, so individual strings can be decompressed without touching the surrounding data in a compressed block. When compared to e.g. LZ4 (which is block-based), FSST further achieves similar decompression speed and compression speed, and better compression ratio. FSST encodes strings using a symbol table -- but it works on pieces of the string, as it maps "symbols" (1-8 byte sequences) onto "codes" (single-bytes). FSST can also represent a byte as an exception (255 followed by the original byte). Hence, compression transforms a sequence of bytes into a (supposedly shorter) sequence of codes or escaped bytes. These shorter byte-sequences could be seen as strings again and fit in whatever your program is that manipulates strings. An optional 0-terminated mode (like, C-strings) is also supported.
- **libCSD** [ğŸ“](./libCSD) [ğŸŒ](https://github.com/GerHobbelt/libCSD) -- a C++ library providing some different techniques for managing string dictionaries in compressed space. These approaches are inspired on the paper: "Compressed String Dictionaries", Nieves R. Brisaboa, Rodrigo CÃ¡novas, Francisco Claude, Miguel A. MartÃ­nez-Prieto, and Gonzalo Navarro, 10th Symposium on Experimental Algorithms (SEA'2011), p.136-147, 2011.
- **libdeflate** [ğŸ“](./libdeflate) [ğŸŒ](https://github.com/GerHobbelt/libdeflate) -- heavily optimized library for DEFLATE/zlib/gzip compression and decompression.
- **libzip** [ğŸ“](./libzip) [ğŸŒ](https://github.com/GerHobbelt/libzip) -- a C library for reading, creating, and modifying zip and zip64 archives.
- **libzopfli** [ğŸ“](./libzopfli) [ğŸŒ](https://github.com/GerHobbelt/zopfli) -- Zopfli Compression Algorithm is a compression library programmed in C to perform very good, but slow, deflate or zlib compression.
- **lizard** [ğŸ“](./lizard) [ğŸŒ](https://github.com/GerHobbelt/lizard) -- efficient compression with very fast decompression. Lizard (formerly LZ5) is a lossless compression algorithm which contains 4 compression methods:
  
  - fastLZ4 : compression levels -10...-19 are designed to give better decompression speed than [LZ4] i.e. over 2000 MB/s
  - fastLZ4 + Huffman : compression levels -30...-39 add Huffman coding to fastLZ4
  - LIZv1 : compression levels -20...-29 are designed to give better ratio than [LZ4] keeping 75% decompression speed
  - LIZv1 + Huffman : compression levels -40...-49 give the best ratio (comparable to [zlib] and low levels of [zstd]/[brotli]) at decompression speed of 1000 MB/s

- **lz4** [ğŸ“](./lz4) [ğŸŒ](https://github.com/GerHobbelt/lz4) -- LZ4 is lossless compression algorithm, providing compression speed > 500 MB/s per core, scalable with multi-cores CPU. It features an extremely fast decoder, with speed in multiple GB/s per core, typically reaching RAM speed limits on multi-core systems.
- **lzbench** [ğŸ“](./lzbench) [ğŸŒ](https://github.com/GerHobbelt/lzbench) -- an in-memory benchmark of open-source LZ77/LZSS/LZMA compressors. It joins all compressors into a single exe.
- **lzham_codec** [ğŸ“](./lzham_codec) [ğŸŒ](https://github.com/GerHobbelt/lzham_codec) -- LZHAM is a lossless data compression codec, with a compression ratio similar to LZMA but with 1.5x-8x faster decompression speed.
- **p7zip** [ğŸ“](./p7zip) [ğŸŒ](https://github.com/GerHobbelt/p7zip) -- p7zip-zstd = 7zip with extensions, including major modern codecs such as Brotli, Fast LZMA2, LZ4, LZ5, Lizard and Zstd.
- **shoco** [ğŸ“](./shoco) [ğŸŒ](https://github.com/GerHobbelt/shoco) -- a fast compressor for short strings
- **snappy** [ğŸ“](./snappy) [ğŸŒ](https://github.com/GerHobbelt/snappy) -- an up-to-date fork of google/snappy, a fast compression/decompression library. It does not aim for maximum compression, or compatibility with any other compression library; instead, it aims for very high speeds and reasonable compression.
  
  - **second-choice**; reason: see `lzo2` above. LZ4 either overtakes this one or is on par (anno 2022 AD) and I don't see a lot happening here, so the coolness factor is slowly fading. See also [How do I decide between LZ4 and Snappy compression?](https://stackoverflow.com/questions/67537111/how-do-i-decide-between-lz4-and-snappy-compression)

- **squash** [ğŸ“](./squash) [ğŸŒ](https://github.com/GerHobbelt/squash) -- an abstraction library which provides a single API to access many compression libraries, allowing applications a great deal of flexibility when choosing a compression algorithm, or allowing a choice between several of them.
- **zfp-compressed-arrays** [ğŸ“](./zfp-compressed-arrays) [ğŸŒ](https://github.com/GerHobbelt/zfp) -- zfp is a compressed format for representing multidimensional floating-point and integer arrays. zfp provides compressed-array classes that support high throughput read and write random access to individual array elements. zfp also supports serial and parallel (OpenMP and CUDA) compression of whole arrays, e.g., for applications that read and write large data sets to and from disk.
- **zstd** [ğŸ“](./zstd) [ğŸŒ](https://github.com/GerHobbelt/zstd) -- Zstandard, a.k.a. `zstd`, is a fast lossless compression algorithm, targeting real-time compression scenarios at zlib-level and better compression ratios.
- ~~**bzip2** [ğŸŒ](https://github.com/nemequ/bzip2)~~
  
  - **removed**; reason: see `lzo` below. When we want this, we can go through [Apache Tika](https://tika.apache.org/) or other thirdparty pipelines.

- ~~**lzo** [ğŸŒ](https://github.com/nemequ/lzo)~~
  
  - **removed**; reason: gone as part of the first round of compression libraries' cleanup: we intend to support lz4 for fast work, plus zstd and *maybe* brotli for higher compression ratios, while we won't bother with anything else: the rest can be dealt with through [Apache Tika](https://tika.apache.org/) or other thirdparty pipelines when we need to read (or write) them. See also: [7zip-Zstd](https://github.com/mcmilk/7-Zip-zstd), which is what I use for accessing almost all compressed material anywhere.

- ~~**lzsse** [ğŸŒ](https://github.com/ConorStokes/LZSSE)~~
  
  - **removed**; reason: see `lzo` above. LZ4 either overtakes this one or is on par (anno 2022 AD) and I don't see a lot happening here, so the coolness factor is slowly fading...

- ~~**pithy** [ğŸŒ](https://github.com/johnezang/pithy)~~
  
  - **removed**; reason: see `lzo` above. LZ4 either overtakes this one or is on par (anno 2022 AD) and I don't see a lot happening here, so the coolness factor is slowly fading...

- ~~**xz-utils** [ğŸŒ](https://github.com/xz-mirror/xz)~~
  
  - **removed**; reason: see `lzo2` above. When we want this, we can go through [Apache Tika](https://tika.apache.org/) or other thirdparty pipelines.


See also [lzbench](https://github.com/inikep/lzbench).











## File / Directory Tree Synchronization (local and remote)

- **cdc-file-transfer** [ğŸ“](./cdc-file-transfer) [ğŸŒ](https://github.com/GerHobbelt/cdc-file-transfer) -- CDC File Transfer contains tools for syncing and streaming files from Windows to Windows or Linux. The tools are based on Content Defined Chunking (CDC), in particular [FastCDC](https://www.usenix.org/conference/atc16/technical-sessions/presentation/xia), to split up files into chunks.
- **CryptSync** [ğŸ“](./CryptSync) [ğŸŒ](https://github.com/GerHobbelt/CryptSync) -- a small utility that synchronizes two folders while encrypting the contents in one folder. That means one of the two folders has all files unencrypted (the files you work with) and the other folder has all the files encrypted. This is best used together with cloud storage tools like OneDrive, DropBox or Google Drive.
- **csync2** [ğŸ“](./csync2) [ğŸŒ](https://github.com/GerHobbelt/csync2) -- a cluster synchronization tool. It can be used to keep files on multiple hosts in a cluster in sync. Csync2 can handle complex setups with much more than just 2 hosts, handle file deletions and can detect conflicts.
- **filecopyex3** [ğŸ“](./filecopyex3) [ğŸŒ](https://github.com/GerHobbelt/filecopyex3) -- a FAR plugin designed to bring to life all kinds of perverted fantasies on the topic of file copying, each of which will speed up the process by 5% :smile:. At the moment, it has implemented the main features that are sometimes quite lacking in standard copiers.
- **FreeFileSync** [ğŸ“](./FreeFileSync) [ğŸŒ](https://github.com/GerHobbelt/FreeFileSync) -- a folder comparison and synchronization application that creates and manages backup copies of all your important files. Instead of copying every file every time, FreeFileSync determines the differences between a source and a target folder and transfers only the minimum amount of data needed. FreeFileSync is available for Windows, macOS, and Linux.
- **lib_nas_lockfile** [ğŸ“](./lib_nas_lockfile) [ğŸŒ](https://github.com/GerHobbelt/lib_nas_lockfile) -- lockfile management on NAS and other disparate network filesystem storage. To be combined with SQLite to create a proper Qiqqa Sync operation.
- **librsync** [ğŸ“](./librsync) [ğŸŒ](https://github.com/GerHobbelt/librsync) -- a library for calculating and applying network deltas. librsync encapsulates the core algorithms of the rsync protocol, which help with efficient calculation of the differences between two files. The rsync algorithm is different from most differencing algorithms because it does not require the presence of the two files to calculate the delta.  Instead, it requires a set of checksums of each block of one file, which together form a signature for that file.  Blocks at any position in the other file which have the same checksum are likely to be identical, and whatever remains is the difference. This algorithm transfers the differences between two files without needing both files on the same system.
- **rclone** [ğŸ“](./rclone) [ğŸŒ](https://github.com/GerHobbelt/rclone) -- Rclone *("rsync for cloud storage")* is a command-line program to sync files and directories to and from different cloud storage providers. See [the full list of all storage providers and their features](https://rclone.org/overview/).
- **rsync** [ğŸ“](./rsync) [ğŸŒ](https://github.com/GerHobbelt/rsync) -- Rsync is a fast and extraordinarily versatile file copying tool for both remote and local files. Rsync uses a delta-transfer algorithm which provides a very fast method for bringing remote files into sync.
- **vcopy** [ğŸ“](./vcopy) [ğŸŒ](https://github.com/GerHobbelt/vcopy) -- tool to safely copy files across various (local) hardware under circumstances where there may be another file writer active at the same time and/or the (USB?) connection is sometimes flakey or system I/O drivers buggered.
- **zsync2** [ğŸ“](./zsync2) [ğŸŒ](https://github.com/GerHobbelt/zsync2) -- the advanced file download/sync tool zsync. zsync is a well known tool for downloading and updating local files from HTTP servers using the well known algorithms rsync used for diffing binary files. Therefore, it becomes possible to synchronize modifications by exchanging the changed blocks locally using `Range:` requests. The system is based on meta files called `.zsync` files. They contain hash sums for every block of data. The file is generated from and stored along with the actual file it refers to. Due to how system works, nothing but a "dumb" HTTP server is required to make use of zsync2. This makes it easy to integrate zsync2 into existing systems.











## OCR: hOCR output format, other output formats? (dedicated binary?)

- **archive-hocr-tools** [ğŸ“](./archive-hocr-tools) [ğŸŒ](https://github.com/GerHobbelt/archive-hocr-tools) -- a python package to ease hOCR parsing in a streaming manner.
- **hocr-fileformat** [ğŸ“](./hocr-fileformat) [ğŸŒ](https://github.com/GerHobbelt/ocr-fileformat) -- tools to alidate and transform between OCR file formats (hOCR, ALTO, PAGE, FineReader)
- **hocr-spec** [ğŸ“](./hocr-spec) [ğŸŒ](https://github.com/GerHobbelt/hocr-spec) -- the [hOCR](https://en.wikipedia.org/wiki/HOCR) Embedded OCR Workflow and Output Format specification originally written by [Thomas Breuel](https://github.com/tmbdev).
- **hocr-tools** [ğŸ“](./hocr-tools) [ğŸŒ](https://github.com/GerHobbelt/hocr-tools) -- a [Public Specification](http://hocr.info) and tools for the hOCR Format.
  
  hOCR is a format for representing OCR output, including layout information, character confidences, bounding boxes, and style information. It embeds this information invisibly in standard HTML. By building on standard HTML, it automatically inherits well-defined support for most scripts, languages, and common layout options. Furthermore, unlike previous OCR formats, the recognized text and OCR-related information co-exist in the same file and survives editing and manipulation. hOCR markup is independent of the presentation.












## Pattern Recognition

"A.I." for cover pages, image/page *segmentation*, including abstract & summary demarcation, "figure" and "table" detection & extraction from documents, ...











### BLAS, LAPACK, ...

- **amd-fftw** [ğŸ“](./amd-fftw) [ğŸŒ](https://github.com/GerHobbelt/amd-fftw) -- AOCL-FFTW is AMD optimized version of FFTW implementation targeted for AMD EPYC CPUs. It is developed on top of FFTW (version fftw-3.3.10). AOCL-FFTW achieves high performance as a result of its various optimizations involving improved SIMD Kernel functions, improved copy functions (cpy2d and cpy2d_pair used in rank-0 transform and buffering plan), improved 256-bit kernels selection by Planner and an optional in-place transpose for large problem sizes. AOCL-FFTW improves the performance of in-place MPI FFTs by employing a faster in-place MPI transpose function.
- **armadillo** [ğŸ“](./armadillo) [ğŸŒ](https://github.com/GerHobbelt/armadillo-code) -- C++ library for linear algebra & scientific computing
- **autodiff** [ğŸ“](./autodiff) [ğŸŒ](https://github.com/GerHobbelt/autodiff) -- a C++17 library that uses modern and advanced programming techniques to enable automatic computation of derivatives in an efficient, easy, and intuitive way.
- **BaseMatrixOps** [ğŸ“](./BaseMatrixOps) [ğŸŒ](https://github.com/GerHobbelt/BaseMatrixOps) -- wrappers to C++ linear algebra libraries. No guarantees made about APIs or functionality.
- **blis** [ğŸ“](./blis) [ğŸŒ](https://github.com/GerHobbelt/blis) -- BLIS is an award-winning portable software framework for instantiating high-performance BLAS-like dense linear algebra libraries. The framework was designed to isolate essential kernels of computation that, when optimized, immediately enable optimized implementations of most of its commonly used and computationally intensive operations. BLIS is written in [ISO C99](http://en.wikipedia.org/wiki/C99) and available under a [new/modified/3-clause BSD license](http://opensource.org/licenses/BSD-3-Clause). While BLIS exports a [new BLAS-like API](docs/BLISTypedAPI.md), it also includes a BLAS compatibility layer which gives application developers access to BLIS implementations via traditional [BLAS routine calls](http://www.netlib.org/lapack/lug/node145.html). An [object-based API](docs/BLISObjectAPI.md) unique to BLIS is also available.
- **clBLAS** [ğŸ“](./clBLAS) [ğŸŒ](https://github.com/GerHobbelt/clBLAS) -- the OpenCLâ„¢ BLAS portion of OpenCL's `clMath`. The complete set of BLAS level 1, 2 & 3 routines is implemented. In addition to GPU devices, the library also supports running on CPU devices to facilitate debugging and multicore programming. The primary goal of `clBLAS` is to make it easier for developers to utilize the inherent performance and power efficiency benefits of heterogeneous computing. `clBLAS` interfaces do not hide nor wrap OpenCL interfaces, but rather leaves OpenCL state management to the control of the user to allow for maximum performance and flexibility. The clBLAS library does generate and enqueue optimized OpenCL kernels, relieving the user from the task of writing, optimizing and maintaining kernel code themselves.
- **CLBlast** [ğŸ“](./CLBlast) [ğŸŒ](https://github.com/GerHobbelt/CLBlast) -- the tuned OpenCL BLAS library. CLBlast is a modern, lightweight, performant and tunable OpenCL BLAS library written in C++11. It is designed to leverage the full performance potential of a wide variety of OpenCL devices from different vendors, including desktop and laptop GPUs, embedded GPUs, and other accelerators. CLBlast implements BLAS routines: basic linear algebra subprograms operating on vectors and matrices.
- **CLBlast-database** [ğŸ“](./CLBlast-database) [ğŸŒ](https://github.com/GerHobbelt/CLBlast-database) -- the full database of tuning results for the [CLBlast OpenCL BLAS library](https://github.com/CNugteren/CLBlast). Tuning results are obtained using CLBlast and the [CLTune auto-tuner](https://github.com/CNugteren/CLTune).
- **CLTune** [ğŸ“](./CLTune) [ğŸŒ](https://github.com/GerHobbelt/CLTune) -- automatic OpenCL kernel tuning for CLBlast: CLTune is a C++ library which can be used to automatically tune your OpenCL and CUDA kernels. The only thing you'll need to provide is a tuneable kernel and a list of allowed parameters and values.
- **Cmathtuts** [ğŸ“](./Cmathtuts) [ğŸŒ](https://github.com/GerHobbelt/Cmathtuts) -- a collection of linear algebra math tutorials in C for BLAS, LAPACK and other fundamental APIs. These include samples for BLAS, LAPACK, CLAPACK, LAPACKE, ATLAS, OpenBLAS ...
- **efftw** [ğŸ“](./efftw) [ğŸŒ](https://github.com/GerHobbelt/efftw) -- Eigen-FFTW is a modern C++20 wrapper library around [FFTW](http://www.fftw.org) for [Eigen](https://eigen.tuxfamily.org/index.php?title=Main_Page).
- **ensmallen** [ğŸ“](./ensmallen) [ğŸŒ](https://github.com/GerHobbelt/ensmallen) -- a high-quality C++ library for non-linear numerical optimization. `ensmallen` provides many types of optimizers that can be used for virtually any numerical optimization task. This includes gradient descent techniques, gradient-free optimizers, and constrained optimization. Examples include L-BFGS, SGD, CMAES and Simulated Annealing.
- **exprtk** [ğŸ“](./exprtk) [ğŸŒ](https://github.com/GerHobbelt/exprtk) -- C++ Mathematical Expression Toolkit Library is a simple to use, easy to integrate and extremely efficient run-time mathematical expression parsing and evaluation engine. The parsing engine supports numerous forms of functional and logic processing semantics and is easily extensible.
- **fastapprox** [ğŸ“](./fastapprox) [ğŸŒ](https://github.com/GerHobbelt/fastapprox) -- approximate and vectorized versions of common mathematical functions (e.g. exponential, logarithm, and power, lgamma and digamma, cosh, sinh, tanh, cos, sin, tan, sigmoid and erf, Lambert W)
- **fastrange** [ğŸ“](./fastrange) [ğŸŒ](https://github.com/GerHobbelt/fastrange) -- a fast alternative to the modulo reduction. [It has accelerated some operations in Google's Tensorflow by 10% to 20%](https://github.com/tensorflow/tensorflow/commit/a47a300185026fe7829990def9113bf3a5109fed). Further reading : http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/ See also: Daniel Lemire, [Fast Random Integer Generation in an Interval](https://arxiv.org/abs/1805.10941), ACM Transactions on Modeling and Computer Simulation, January 2019 Article No. 3 https://doi.org/10.1145/3230636
- **ffts** [ğŸ“](./ffts) [ğŸŒ](https://github.com/GerHobbelt/ffts) -- FFTS -- The Fastest Fourier Transform in the South.
- **gcem** [ğŸ“](./gcem) [ğŸŒ](https://github.com/GerHobbelt/gcem) -- GCE-Math (**G**eneralized **C**onstant **E**xpression Math) is a templated C++ library enabling compile-time computation of mathematical functions.
- **GraphBLAS** [ğŸ“](./GraphBLAS) [ğŸŒ](https://github.com/GerHobbelt/GraphBLAS) -- SuiteSparse:GraphBLAS is a complete implementation of the GraphBLAS standard, which defines a set of sparse matrix operations on an extended algebra of semirings using an almost unlimited variety of operators and types.  When applied to sparse adjacency matrices, these algebraic operations are equivalent to computations on graphs.  GraphBLAS provides a powerful and expressive framework for creating graph algorithms based on the elegant mathematics of sparse matrix operations on a semiring.
- **h5cpp** [ğŸ“](./h5cpp) [ğŸŒ](https://github.com/GerHobbelt/h5cpp) -- easy to use HDF5 C++ templates for Serial and Paralel HDF5. Hierarchical Data Format HDF5 is prevalent in high performance scientific computing, sits directly on top of sequential or parallel file systems, providing block and stream operations on standardized or custom binary/text objects. Scientific computing platforms come with the necessary libraries to read write HDF5 dataset. H5CPP simplifies interactions with popular linear algebra libraries, provides compiler assisted seamless object persistence, Standard Template Library support and comes equipped with a novel error handling architecture.
- **Imath** [ğŸ“](./Imath) [ğŸŒ](https://github.com/GerHobbelt/Imath) -- a basic, light-weight, and efficient C++ representation of 2D and 3D vectors and matrices and other simple but useful mathematical objects, functions, and data types common in computer graphics applications, including the â€œhalfâ€ 16-bit floating-point type.
- **itpp** [ğŸ“](./itpp) [ğŸŒ](https://github.com/GerHobbelt/itpp) -- IT++ is a C++ library of mathematical, signal processing and communication classes and functions. Its main use is in simulation of communication systems and for performing research in the area of communications. The kernel of the library consists of generic vector and matrix classes, and a set of accompanying routines. Such a kernel makes IT++ similar to MATLAB or GNU Octave. The IT++ library originates from the former department of Information Theory at the Chalmers University of Technology, Gothenburg, Sweden.
- **kalman-cpp** [ğŸ“](./kalman-cpp) [ğŸŒ](https://github.com/GerHobbelt/kalman-cpp) -- Kalman filter and extended Kalman filter implementation in C++. Implements Kalman, Extended Kalman, Second-order extended Kalman and Unscented Kalman filters.
- **kissfft** [ğŸ“](./kissfft) [ğŸŒ](https://github.com/GerHobbelt/kissfft) -- KISS FFT - a mixed-radix Fast Fourier Transform based up on the principle, "Keep It Simple, Stupid."
- **lapack** [ğŸ“](./lapack) [ğŸŒ](https://github.com/GerHobbelt/lapack) -- [CBLAS](http://www.netlib.org/blas/) + [LAPACK](http://www.netlib.org/lapack/index.html) optimized linear algebra libs
- **libalg** [ğŸ“](./libalg) [ğŸŒ](https://github.com/GerHobbelt/alglib) -- the mathematical *ALGLIB* library for C++.
- **libbf** [ğŸ“](./libbf) [ğŸŒ](https://github.com/GerHobbelt/libbf) -- a small library to handle arbitrary precision binary or decimal floating point numbers
- **libcnl** [ğŸ“](./libcnl) [ğŸŒ](https://github.com/GerHobbelt/cnl) -- The Compositional Numeric Library (CNL) is a C++ library of fixed-precision numeric classes which enhance integers to deliver safer, simpler, cheaper arithmetic types. CNL is particularly well-suited to: (1) compute on energy-constrained environments where FPUs are absent or costly; (2) compute on energy-intensive environments where arithmetic is the bottleneck such as simulations, machine learning applications and DSPs; and (3) domains such as finance where precision is essential.
- **libeigen** [ğŸ“](./libeigen) [ğŸŒ](https://github.com/GerHobbelt/eigen-git-mirror) -- a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.
- **math-atlas** [ğŸ“](./math-atlas) [ğŸŒ](https://github.com/GerHobbelt/math-atlas) -- The ATLAS (Automatically Tuned Linear Algebra Software) project is an ongoing research effort focusing on applying empirical techniques in order to provide portable performance, delivering an efficient BLAS implementation, as well as a few routines from LAPACK.
- **mipp** [ğŸ“](./mipp) [ğŸŒ](https://github.com/GerHobbelt/MIPP) -- MyIntrinsics++ (MIPP): a portable wrapper for vector intrinsic functions (SIMD) written in C++11. It works for SSE, AVX, AVX-512 and ARM NEON (32-bit and 64-bit) instructions. MIPP wrapper supports simple/double precision floating-point numbers and also signed integer arithmetic (64-bit, 32-bit, 16-bit and 8-bit). With the MIPP wrapper you do not need to write a specific intrinsic code anymore. Just use provided functions and the wrapper will automatically generate the right intrisic calls for your specific architecture.
- **mlpack** [ğŸ“](./mlpack) [ğŸŒ](https://github.com/GerHobbelt/mlpack) -- an intuitive, fast, and flexible C++ machine learning library, meant to be a machine learning analog to LAPACK, aiming to implement a wide array of machine learning methods and functions as a "swiss army knife" for machine learning researchers.
- **nfft** [ğŸ“](./nfft) [ğŸŒ](https://github.com/GerHobbelt/nfft) -- Nonequispaced FFT (NFFT) is a software library, written in C, for computing non-equispaced fast Fourier transforms and related variations.
- **OpenBLAS** [ğŸ“](./OpenBLAS) [ğŸŒ](https://github.com/GerHobbelt/OpenBLAS) -- an optimized BLAS (Basic Linear Algebra Subprograms) library based on GotoBLAS2 1.13 BSD version.
- **OpenCL-CTS** [ğŸ“](./OpenCL-CTS) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-CTS) -- the OpenCL Conformance Test Suite (CTS) for all versions of the Khronos [OpenCL](https://www.khronos.org/opencl/) standard.
- **OpenCL-Headers** [ğŸ“](./OpenCL-Headers) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-Headers) -- C language headers for the OpenCL API.
- **OpenCL-SDK** [ğŸ“](./OpenCL-SDK) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-SDK) -- the Khronos OpenCL SDK. It brings together all the components needed to develop OpenCL applications.
- **optim** [ğŸ“](./optim) [ğŸŒ](https://github.com/GerHobbelt/optim) -- OptimLib is a lightweight C++ library of numerical optimization methods for nonlinear functions. Features a C++11/14/17 library of local and global optimization algorithms, as well as root finding techniques, derivative-free optimization using advanced, parallelized metaheuristic methods and constrained optimization routines to handle simple box constraints, as well as systems of nonlinear constraints.
- **QuantLib** [ğŸ“](./QuantLib) [ğŸŒ](https://github.com/GerHobbelt/QuantLib) -- the free/open-source library for quantitative finance, providing a comprehensive software framework for quantitative finance. QuantLib is a free/open-source library for modeling, trading, and risk management in real-life.
- **sdsl-lite** [ğŸ“](./sdsl-lite) [ğŸŒ](https://github.com/GerHobbelt/sdsl-lite) -- The Succinct Data Structure Library (SDSL) is a powerful and flexible C++11 library implementing succinct data structures. In total, the library contains the highlights of 40 [research publications][SDSLLIT]. Succinct data structures can represent an object (such as a bitvector or a tree) in space close to the information-theoretic lower bound of the object while supporting operations of the original object efficiently. The theoretical time complexity of an operation performed on the classical data structure and the equivalent succinct data structure are (most of the time) identical.
- **stan-math** [ğŸ“](./stan-math) [ğŸŒ](https://github.com/GerHobbelt/stan-math) -- the Stan Math Library is a C++, reverse-mode automatic differentiation library designed to be usable, extensive and extensible, efficient, scalable, stable, portable, and redistributable in order to facilitate the construction and utilization of algorithms that utilize derivatives.
- **stats** [ğŸ“](./stats) [ğŸŒ](https://github.com/GerHobbelt/stats) -- StatsLib is a templated C++ library of statistical distribution functions, featuring unique compile-time computing capabilities and seamless integration with several popular linear algebra libraries. Features a header-only library of probability density functions, cumulative distribution functions, quantile functions, and random sampling methods. Functions are written in C++11 `constexpr` format, enabling the library to operate as both a compile-time and run-time computation engine. Provides functions to compute the cdf, pdf, quantile, as well as random sampling methods, are available for the following distributions: Bernoulli, Beta, Binomial, Cauchy, Chi-squared, Exponential, F, Gamma, Inverse-Gamma, Inverse-Gaussian, Laplace, Logistic, Log-Normal, Normal (Gaussian), Poisson, Rademacher, Student's t, Uniform and Weibull. In addition, pdf and random sampling functions are available for several multivariate distributions: inverse-Wishart, Multivariate Normal and Wishart.
- **SuiteSparse** [ğŸ“](./SuiteSparse) [ğŸŒ](https://github.com/GerHobbelt/SuiteSparse) -- a set of sparse-matrix-related packages written or co-authored by Tim Davis, available at https://github.com/DrTimothyAldenDavis/SuiteSparse . Packages:
  
  * `AMD` - approximate minimum degree ordering.  This is the built-in AMD function in MATLAB.
  * `BTF` - permutation to block triangular form
  * `CAMD` - constrained approximate minimum degree ordering
  * `CCOLAMD` - constrained column approximate minimum degree ordering
  * `CHOLMOD` - sparse Cholesky factorization.  Requires AMD, COLAMD, CCOLAMD, the BLAS, and LAPACK.  Optionally uses METIS.  This is `chol` and `x=A\b` in MATLAB.
  * `COLAMD` - column approximate minimum degree ordering.  This is the built-in COLAMD function in MATLAB.
  * `CSparse` - a concise sparse matrix package, developed for my book, "Direct Methods for Sparse Linear Systems", published by SIAM.  Intended primarily for teaching. For production, use `CXSparse` instead.
  * `CXSparse` - CSparse Extended.  Includes support for complex matrices and both int or long integers.  Use this instead of CSparse for production use; it creates a libcsparse.so (or dylib on the Mac) with the same name as CSparse.  It is a superset of CSparse.
  * `GraphBLAS` - graph algorithms in the language of linear algebra. https://graphblas.org
  * `KLU` - sparse LU factorization, primarily for circuit simulation.  Requires AMD, COLAMD, and BTF.  Optionally uses CHOLMOD, CAMD, CCOLAMD, and METIS.
  * `LAGraph` - a graph algorithms library based on GraphBLAS.  See also https://github.com/GraphBLAS/LAGraph
  * `LDL` - a very concise LDL' factorization package

- **tinyexpr** [ğŸ“](./tinyexpr) [ğŸŒ](https://github.com/GerHobbelt/tinyexpr) -- a very small recursive descent parser and evaluation engine for math expressions.
- **universal-numbers** [ğŸ“](./universal-numbers) [ğŸŒ](https://github.com/GerHobbelt/universal) -- a header-only C++ template library for universal number arithmetic. The goal of the Universal Numbers Library is to offer applications alternatives to IEEE floating-point that are more efficient and mathematically robust. The Universal library is a ready-to-use header-only library that provides plug-in replacement for native types, and provides a low-friction environment to start exploring alternatives to IEEE floating-point in your own algorithms.
- **xsimd** [ğŸ“](./xsimd) [ğŸŒ](https://github.com/GerHobbelt/xsimd) -- SIMD (Single Instruction, Multiple Data) instructions differ between microprocessor vendors and compilers. `xsimd` provides a unified means for using these features for library authors. It enables manipulation of batches of numbers with the same arithmetic operators as for single values. It also provides accelerated implementation of common mathematical functions operating on batches.











### _delta features_ & other feature extraction (see Qiqqa research notes)

- **diffutils** [ğŸ“](./diffutils) [ğŸŒ](https://github.com/GerHobbelt/diffutils) -- the GNU diff, diff3, sdiff, and cmp utilities. Their features are a superset of the Unix features and they are significantly faster.
- **dtl-diff-template-library** [ğŸ“](./dtl-diff-template-library) [ğŸŒ](https://github.com/GerHobbelt/dtl) -- `dtl` is the diff template library written in C++.
- **google-diff-match-patch** [ğŸ“](./google-diff-match-patch) [ğŸŒ](https://github.com/GerHobbelt/diff-match-patch) -- Diff, Match and Patch offers robust algorithms to perform the operations required for synchronizing plain text.
  
  1. Diff:
     * Compare two blocks of plain text and efficiently return a list of differences.
  2. Match:
     * Given a search string, find its best fuzzy match in a block of plain text. Weighted for both accuracy and location.
  3. Patch:
     * Apply a list of patches onto plain text. Use best-effort to apply patch even when the underlying text doesn't match.
  
  Originally built in 2006 to power Google Docs.

- **HDiffPatch** [ğŸ“](./HDiffPatch) [ğŸŒ](https://github.com/GerHobbelt/HDiffPatch) -- a library and command-line tools for Diff & Patch between binary files or directories(folders); cross-platform; runs fast; create small delta/differential; support large files and limit memory requires when diff & patch.
- **libdist** [ğŸ“](./libdist) [ğŸŒ](https://github.com/GerHobbelt/distlib) -- string distance related functions (Damerau-Levenshtein, Jaro-Winkler, longest common substring & subsequence) implemented as SQLite run-time loadable extension, with UTF-8 support.
- **libharry** [ğŸ“](./libharry) [ğŸŒ](https://github.com/GerHobbelt/harry) -- Harry - A Tool for Measuring String Similarity. The tool supports several common distance and kernel functions for strings as well as some excotic similarity measures.  The focus of Harry lies on implicit similarity measures, that is, comparison functions that do not give rise to an explicit vector space.  Examples of such similarity measures are the Levenshtein distance, the Jaro-Winkler distance or the spectrum kernel.
- **open-vcdiff** [ğŸ“](./open-vcdiff) [ğŸŒ](https://github.com/GerHobbelt/open-vcdiff) -- an encoder and decoder for the VCDIFF format, as described in [RFC 3284](http://www.ietf.org/rfc/rfc3284.txt): The VCDIFF Generic Differencing and Compression Data Format.
- **rollinghashcpp** [ğŸ“](./rollinghashcpp) [ğŸŒ](https://github.com/GerHobbelt/rollinghashcpp) -- randomized rolling hash functions in C++. This is a set of C++ classes implementing various recursive n-gram hashing techniques, also called rolling hashing (http://en.wikipedia.org/wiki/Rolling_hash), including Randomized Karp-Rabin (sometimes called Rabin-Karp), Hashing by Cyclic Polynomials (also known as Buzhash) and Hashing by Irreducible Polynomials.
- **ssdeep** [ğŸ“](./ssdeep) [ğŸŒ](https://github.com/GerHobbelt/ssdeep) -- fuzzy hashing library, can be used to assist with identifying almost identical files using context triggered piecewise hashing.
- **xdelta** [ğŸ“](./xdelta) [ğŸŒ](https://github.com/GerHobbelt/xdelta) -- a C library and command-line tool for delta compression using VCDIFF/RFC 3284 streams.
- **yara-pattern-matcher** [ğŸ“](./yara-pattern-matcher) [ğŸŒ](https://github.com/GerHobbelt/yara) -- for automated and user-specified pattern recognition in custom document & metadata *cleaning* / processing tasks











### fuzzy matching

- **FM-fast-match** [ğŸ“](./FM-fast-match) [ğŸŒ](https://github.com/GerHobbelt/FAsT-Match) -- FAsT-Match: a port of the Fast Affine Template Matching algorithm (Simon Korman, Daniel Reichman, Gilad Tsur, Shai Avidan, CVPR 2013, Portland)
- **fuzzy-match** [ğŸ“](./fuzzy-match) [ğŸŒ](https://github.com/GerHobbelt/fuzzy-match) -- `FuzzyMatch-cli` is a commandline utility allowing to compile FuzzyMatch indexes and use them to lookup fuzzy matches. Okapi BM25 prefiltering is available on branch [`bm25`](https://github.com/SYSTRAN/fuzzy-match/tree/bm25).
- **libdist** [ğŸ“](./libdist) [ğŸŒ](https://github.com/GerHobbelt/distlib) -- string distance related functions (Damerau-Levenshtein, Jaro-Winkler, longest common substring & subsequence) implemented as SQLite run-time loadable extension, with UTF-8 support.
- **lshbox** [ğŸ“](./lshbox) [ğŸŒ](https://github.com/GerHobbelt/LSHBOX) -- a C++ Toolbox of Locality-Sensitive Hashing for Large Scale Image Retrieval. Locality-Sensitive Hashing (LSH) is an efficient method for large scale image retrieval, and it achieves great performance in approximate nearest neighborhood searching.
  
  LSHBOX is a simple but robust C++ toolbox that provides several LSH algrithms, in addition, it can be integrated into Python and MATLAB languages. The following LSH algrithms have been implemented in LSHBOX, they are:
  
  * LSH Based on Random Bits Sampling
  * Random Hyperplane Hashing
  * LSH Based on Thresholding
  * LSH Based on p-Stable Distributions
  * [Spectral Hashing](http://www.cs.huji.ac.il/~yweiss/SpectralHashing/) (SH)
  * [Iterative Quantization](http://www.unc.edu/~yunchao/itq.htm) (ITQ)
  * Double-Bit Quantization Hashing (DBQ)
  * K-means Based Double-Bit Quantization Hashing (KDBQ)

- **pdiff** [ğŸ“](./pdiff) [ğŸŒ](https://github.com/GerHobbelt/pdiff) -- perceptualdiff (pdiff): a program that compares two images using a perceptually based image metric.
- **rollinghashcpp** [ğŸ“](./rollinghashcpp) [ğŸŒ](https://github.com/GerHobbelt/rollinghashcpp) -- randomized rolling hash functions in C++. This is a set of C++ classes implementing various recursive n-gram hashing techniques, also called rolling hashing (http://en.wikipedia.org/wiki/Rolling_hash), including Randomized Karp-Rabin (sometimes called Rabin-Karp), Hashing by Cyclic Polynomials (also known as Buzhash) and Hashing by Irreducible Polynomials.
- **sdhash** [ğŸ“](./sdhash) [ğŸŒ](https://github.com/GerHobbelt/sdhash) -- a tool which allows two arbitrary blobs of data to be compared for similarity based on common strings of binary data. It is designed to provide quick results during triage and initial investigation phases.
- **ssdeep** [ğŸ“](./ssdeep) [ğŸŒ](https://github.com/GerHobbelt/ssdeep) -- fuzzy hashing library, can be used to assist with identifying almost identical files using context triggered piecewise hashing.
- **ssimulacra2** [ğŸ“](./ssimulacra2) [ğŸŒ](https://github.com/GerHobbelt/ssimulacra2) -- Structural SIMilarity Unveiling Local And Compression Related Artifacts metric developed by Jon Sneyers. SSIMULACRA 2 is based on the concept of the multi-scale structural similarity index measure (MS-SSIM), computed in a perceptually relevant color space, adding two other (asymmetric) error maps, and aggregating using two different norms.
- **VQMT** [ğŸ“](./VQMT) [ğŸŒ](https://github.com/GerHobbelt/VQMT) -- VQMT (Video Quality Measurement Tool) provides fast implementations of the following objective metrics:
  
  - **MS-SSIM**: Multi-Scale Structural Similarity,
  - **PSNR**: Peak Signal-to-Noise Ratio,
  - **PSNR-HVS**: Peak Signal-to-Noise Ratio taking into account Contrast Sensitivity Function (CSF),
  - **PSNR-HVS-M**: Peak Signal-to-Noise Ratio taking into account Contrast Sensitivity Function (CSF) and between-coefficient contrast masking of DCT basis functions.
  - **SSIM**: Structural Similarity,
  - **VIFp**: Visual Information Fidelity, pixel domain version
  
  The above metrics are implemented in C++ with the help of OpenCV and are based on the original Matlab implementations provided by their developers.

- **xor-and-binary-fuse-filter** [ğŸ“](./xor-and-binary-fuse-filter) [ğŸŒ](https://github.com/GerHobbelt/xor_singleheader) -- XOR and Binary Fuse Filter library: Bloom filters are used to quickly check whether an element is part of a set. Xor filters and binary fuse filters are faster and more concise alternative to Bloom filters. They are also smaller than cuckoo filters. They are used in [production systems](https://github.com/datafuselabs/databend).











### decision trees

- **catboost** [ğŸ“](./catboost) [ğŸŒ](https://github.com/GerHobbelt/catboost) -- a fast, scalable, high performance Gradient Boosting on Decision Trees library, used for ranking, classification, regression and other machine learning tasks. Supports computation on CPU and GPU.
- **decision-tree** [ğŸ“](./decision-tree) [ğŸŒ](https://github.com/GerHobbelt/decision-tree) -- a decision tree classifier. Decision trees are a simple machine learning algorithm that use a series of features of an observation to create a prediction of a target outcome class.
- **random-forest** [ğŸ“](./random-forest) [ğŸŒ](https://github.com/GerHobbelt/random-forest) -- a Fast C++ Implementation of Random Forests as described in: Leo Breiman. Random Forests. Machine Learning 45(1):5-32, 2001.
- **Sherwood** [ğŸ“](./Sherwood) [ğŸŒ](https://github.com/GerHobbelt/Sherwood) -- Sherwood: a library for decision forest inference, which was written by Duncan Robertson (duncan.robertson@redimension.co.uk) to accompany the book "A. Criminisi and J. Shotton. Decision Forests: for Computer Vision and Medical Image Analysis. Springer,  2013." The Sherwood library comprises a general purpose, object-oriented software framework for applying decision forests to a wide range of inference problems.
- **treelite** [ğŸ“](./treelite) [ğŸŒ](https://github.com/GerHobbelt/treelite) -- **Treelite** is a universal model exchange and serialization format for decision tree forests. Treelite aims to be a small library that enables other C++ applications to exchange and store decision trees on the disk as well as the network.
- **yggdrasil-decision-forests** [ğŸ“](./yggdrasil-decision-forests) [ğŸŒ](https://github.com/GerHobbelt/yggdrasil-decision-forests) -- Yggdrasil Decision Forests (YDF) is a production-grade collection of algorithms for the training, serving, and interpretation of decision forest models. YDF is open-source and is available in C++, command-line interface (CLI), TensorFlow (under the name [TensorFlow Decision Forests](https://github.com/tensorflow/decision-forests); TF-DF), JavaScript (inference only), and Go (inference only).











### GMM/HMM/kM

Fit patterns, e.g. match & transform a point cloud or image onto a template --> help matching pages against banner templates, etc. as part of the OCR/recognition task.

- **GMM-HMM-kMeans** [ğŸ“](./GMM-HMM-kMeans) [ğŸŒ](https://github.com/GerHobbelt/KMeans-GMM-HMM) -- HMM based on KMeans and GMM
- **GMMreg** [ğŸ“](./GMMreg) [ğŸŒ](https://github.com/GerHobbelt/Project_gmmreg) -- implementations of the robust point set registration framework described in the paper "[Robust Point Set Registration Using Gaussian Mixture Models](https://github.com/bing-jian/gmmreg/blob/master/gmmreg_PAMI_preprint.pdf)", Bing Jian and Baba C. Vemuri, IEEE Transactions on Pattern Analysis and Machine Intelligence, 2011, 33(8), pp. 1633-1645. An earlier conference version of this work, "A Robust Algorithm for Point Set Registration Using Mixture of Gaussians, Bing Jian and Baba C. Vemuri.", appeared in the proceedings of ICCV'05.
- **hmm-scalable** [ğŸ“](./hmm-scalable) [ğŸŒ](https://github.com/GerHobbelt/hmm-scalable) -- a Tool for fitting Hidden Markov Models models at scale. In particular, it is targeting a specific kind of HMM used in education called Bayesian Knowledge Tracing (BKT) model.
- **hmm-stoch** [ğŸ“](./hmm-stoch) [ğŸŒ](https://github.com/GerHobbelt/StochHMM) -- StochHMM - A Flexible hidden Markov model application and C++ library that implements HMM from simple text files.   It implements traditional HMM algorithms in addition to providing additional flexibility.  The additional flexibility is achieved by allowing researchers to integrate additional data sources and application code into the HMM framework.
- **liblinear** [ğŸ“](./liblinear) [ğŸŒ](https://github.com/GerHobbelt/liblinear) -- a simple package for solving large-scale regularized linear classification, regression and outlier detection.











### graph analysis, graph databases

- **arangodb** [ğŸ“](./arangodb) [ğŸŒ](https://github.com/GerHobbelt/arangodb) -- a scalable open-source multi-model database natively supporting graph, document and search. All supported data models & access patterns can be combined in queries allowing for maximal flexibility.
- **g2o** [ğŸ“](./g2o) [ğŸŒ](https://github.com/GerHobbelt/g2o) -- General Graph Optimization (G2O)is a C++ framework for optimizing graph-based nonlinear error functions. g2o has been designed to be easily extensible to a wide range of problems and a new problem typically can be specified in a few lines of code. The current implementation provides solutions to several variants of SLAM and BA.
- **GraphBLAS** [ğŸ“](./GraphBLAS) [ğŸŒ](https://github.com/GerHobbelt/GraphBLAS) -- SuiteSparse:GraphBLAS is a complete implementation of the GraphBLAS standard, which defines a set of sparse matrix operations on an extended algebra of semirings using an almost unlimited variety of operators and types.  When applied to sparse adjacency matrices, these algebraic operations are equivalent to computations on graphs.  GraphBLAS provides a powerful and expressive framework for creating graph algorithms based on the elegant mathematics of sparse matrix operations on a semiring.
- **graph-coloring** [ğŸ“](./graph-coloring) [ğŸŒ](https://github.com/GerHobbelt/graph-coloring) -- a C++ Graph Coloring Package. This project has two primary uses:
  
  * As an executable for finding the chromatic number for an input graph (in edge list or edge matrix format)
  * As a library for finding the particular coloring of an input graph (represented as a `map<string,vector<string>>` edge list)

- **graphit** [ğŸ“](./graphit) [ğŸŒ](https://github.com/GerHobbelt/graphit) -- a High-Performance Domain Specific Language for Graph Analytics.
- **kahypar** [ğŸ“](./kahypar) [ğŸŒ](https://github.com/GerHobbelt/kahypar) -- KaHyPar (Karlsruhe Hypergraph Partitioning) is a multilevel hypergraph partitioning framework providing direct k-way and recursive bisection based partitioning algorithms that compute solutions of very high quality.
- **libgrape-lite** [ğŸ“](./libgrape-lite) [ğŸŒ](https://github.com/GerHobbelt/libgrape-lite) -- a C++ library from Alibaba for parallel graph processing (GRAPE). It differs from prior systems in its ability to parallelize sequential graph algorithms as a whole by following the PIE programming model from GRAPE. Sequential algorithms can be easily "plugged into" `libgrape-lite` with only minor changes and get parallelized to handle large graphs efficiently. `libgrape-lite` is designed to be highly efficient and flexible, to cope with the scale, variety and complexity of real-life graph applications.
- **midas** [ğŸ“](./midas) [ğŸŒ](https://github.com/GerHobbelt/MIDAS) -- C++ implementation of:
  
  - [MIDAS: Microcluster-Based Detector of Anomalies in Edge Streams](https://arxiv.org/pdf/1911.04464.pdf). *Siddharth Bhatia, Bryan Hooi, Minji Yoon, Kijung Shin, Christos Faloutsos*. AAAI 2020.
  - [Real-time Streaming Anomaly Detection in Dynamic Graphs](https://arxiv.org/pdf/2009.08452.pdf). *Siddharth Bhatia, Rui Liu, Bryan Hooi, Minji Yoon, Kijung Shin, Christos Faloutsos*. TKDD 2022.

- **ogdf** [ğŸ“](./ogdf) [ğŸŒ](https://github.com/GerHobbelt/ogdf) -- OGDF stands both for **O**pen **G**raph **D**rawing **F**ramework (the original name) and **O**pen **G**raph algorithms and **D**ata structures **F**ramework. OGDF is a self-contained C++ library for graph algorithms, in particular for (but not restricted to) automatic graph drawing. It offers sophisticated algorithms and data structures to use within your own applications or scientific projects.
- **snap** [ğŸ“](./snap) [ğŸŒ](https://github.com/GerHobbelt/snap) -- Stanford Network Analysis Platform (SNAP) is a general purpose, high performance system for analysis and manipulation of large networks. SNAP scales to massive graphs with hundreds of millions of nodes and billions of edges.











### NN, ...

- **aho_corasick** [ğŸ“](./aho_corasick) [ğŸŒ](https://github.com/GerHobbelt/aho_corasick) -- a header only implementation of the Aho-Corasick pattern search algorithm invented by Alfred V. Aho and Margaret J. Corasick. It is a very efficient dictionary matching algorithm that can locate all search patterns against in input text simultaneously in O(n + m), with space complexity O(m) (where n is the length of the input text, and m is the combined length of the search patterns).
- **A-MNS_TemplateMatching** [ğŸ“](./A-MNS_TemplateMatching) [ğŸŒ](https://github.com/GerHobbelt/A-MNS_TemplateMatching) -- the official code for the PatternRecognition2020 paper: Fast and robust template matching with majority neighbour similarity and annulus projection transformation.
- **arrayfire** [ğŸ“](./arrayfire) [ğŸŒ](https://github.com/GerHobbelt/arrayfire) -- a general-purpose tensor library that simplifies the process of software development for the parallel architectures found in CPUs, GPUs, and other hardware acceleration devices. The library serves users in every technical computing market.
- **Awesome-Document-Image-Rectification** [ğŸ“](./Awesome-Document-Image-Rectification) [ğŸŒ](https://github.com/GerHobbelt/Awesome-Document-Image-Rectification) -- a comprehensive list of awesome document image rectification methods based on deep learning.
- **BehaviorTree.CPP** [ğŸ“](./BehaviorTree.CPP) [ğŸŒ](https://github.com/GerHobbelt/BehaviorTree.CPP) -- this C++/17 library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use, reactive and fast. Even if our main use-case is __robotics__, you can use this library to build __AI for games__, or to replace Finite State Machines. BehaviorTree.CPP features asynchronous Actions, reactive behaviors, execute multiple Actions concurrently (orthogonality), XML-based DSL scripts which can be loaded at run-time, i.e. the morphology of the Trees is _not_ hard-coded.
- **bhtsne--Barnes-Hut-t-SNE** [ğŸ“](./bhtsne--Barnes-Hut-t-SNE) [ğŸŒ](https://github.com/GerHobbelt/bhtsne) -- Barnes-Hut t-SNE
- **blis** [ğŸ“](./blis) [ğŸŒ](https://github.com/GerHobbelt/blis) -- BLIS is an award-winning portable software framework for instantiating high-performance BLAS-like dense linear algebra libraries. The framework was designed to isolate essential kernels of computation that, when optimized, immediately enable optimized implementations of most of its commonly used and computationally intensive operations. BLIS is written in [ISO C99](http://en.wikipedia.org/wiki/C99) and available under a [new/modified/3-clause BSD license](http://opensource.org/licenses/BSD-3-Clause). While BLIS exports a [new BLAS-like API](docs/BLISTypedAPI.md), it also includes a BLAS compatibility layer which gives application developers access to BLIS implementations via traditional [BLAS routine calls](http://www.netlib.org/lapack/lug/node145.html). An [object-based API](docs/BLISObjectAPI.md) unique to BLIS is also available.
- **bolt** [ğŸ“](./bolt) [ğŸŒ](https://github.com/GerHobbelt/bolt) -- a deep learning library with high performance and heterogeneous flexibility.
- **brown-cluster** [ğŸ“](./brown-cluster) [ğŸŒ](https://github.com/GerHobbelt/brown-cluster) -- the Brown hierarchical word clustering algorithm. Runs in $O(N C^2)$, where $N$ is the number of word types and $C$ is the number of clusters. Algorithm by Brown, et al.: Class-Based n-gram Models of Natural Language, http://acl.ldc.upenn.edu/J/J92/J92-4003.pdf
- **caffe** [ğŸ“](./caffe) [ğŸŒ](https://github.com/GerHobbelt/caffe) -- a fast deep learning framework made with expression and modularity in mind, developed by Berkeley AI Research (BAIR)/The Berkeley Vision and Learning Center (BVLC).
  
  - **ho-hum**; reason: uses google protobuffers, CUDA SDK for the GPU access (at least that's how it looks from the header files reported missing by my compiler). Needs more effort before this can be used in the monolithic production builds.

- **catboost** [ğŸ“](./catboost) [ğŸŒ](https://github.com/GerHobbelt/catboost) -- a fast, scalable, high performance Gradient Boosting on Decision Trees library, used for ranking, classification, regression and other machine learning tasks. Supports computation on CPU and GPU.
- **CNTK** [ğŸ“](./CNTK) [ğŸŒ](https://github.com/GerHobbelt/CNTK) -- the Microsoft Cognitive Toolkit (https://cntk.ai) is a unified deep learning toolkit that describes neural networks as a series of computational steps via a directed graph. In this directed graph, leaf nodes represent input values or network parameters, while other nodes represent matrix operations upon their inputs. CNTK allows users to easily realize and combine popular model types such as feed-forward DNNs, convolutional nets (CNNs), and recurrent networks (RNNs/LSTMs). It implements stochastic gradient descent (SGD, error backpropagation) learning with automatic differentiation and parallelization across multiple GPUs and servers. CNTK has been available under an open-source license since April 2015. It is our hope that the community will take advantage of CNTK to share ideas more quickly through the exchange of open source working code.
- **cppflow** [ğŸ“](./cppflow) [ğŸŒ](https://github.com/GerHobbelt/cppflow) -- run TensorFlow models in c++ without Bazel, without TensorFlow installation and without compiling Tensorflow.
- **CRFpp** [ğŸ“](./CRFpp) [ğŸŒ](https://github.com/GerHobbelt/crfpp) -- CRF++ is a simple, customizable, and open source implementation of <a href="http://www.cis.upenn.edu/~pereira/papers/crf.pdf">Conditional Random Fields (CRFs)</a> for segmenting/labeling sequential data. CRF++ is designed for generic purpose and will be applied to a variety of NLP tasks, such as Named Entity Recognition, Information Extraction and Text Chunking.
- **crfsuite** [ğŸ“](./crfsuite) [ğŸŒ](https://github.com/GerHobbelt/crfsuite) -- an implementation of Conditional Random Fields (CRFs) for labeling sequential data.
- **CRFsuite-extended** [ğŸ“](./CRFsuite-extended) [ğŸŒ](https://github.com/GerHobbelt/CRFSuiteEx) -- a fork of [Naoaki Okazaki's](http://www.chokkan.org/) implementation of conditional random fields (CRFs).
- **CurvatureFilter** [ğŸ“](./CurvatureFilter) [ğŸŒ](https://github.com/GerHobbelt/CurvatureFilter) -- Curvature filters are efficient solvers for variational models. Traditional solvers, such as gradient descent or Euler Lagrange Equation, start at the total energy and use diffusion scheme to carry out the minimization. When the initial condition is the original image, the data fitting energy always increases while the regularization energy always reduces during the optimization, as illustrated in the below figure. Thus, regularization energy must be the dominant part since the total energy has to decrease. Therefore, **Curvature filters focus on minimizing the regularization term,** whose minimizers are already known. For example, if the regularization is Gaussian curvature, the developable surfaces minimize this energy. Therefore, in curvature filter, developable surfaces are used to approximate the data. **As long as the decreased amount in the regularization part is larger than the increased amount in the data fitting energy, the total energy is reduced.**
- **darknet** [ğŸ“](./darknet) [ğŸŒ](https://github.com/GerHobbelt/darknet) -- Darknet is an open source neural network framework written in C and CUDA. It is fast, easy to install, and supports CPU and GPU computation.
- **DBoW2** [ğŸ“](./DBoW2) [ğŸŒ](https://github.com/GerHobbelt/DBoW2) -- a C++ library for indexing and converting images into a bag-of-word representation. It implements a hierarchical tree for approximating nearest neighbours in the image feature space and creating a visual vocabulary. DBoW2 also implements an image database with inverted and direct files to index images and enabling quick queries and feature comparisons.
- **DBow3** [ğŸ“](./DBow3) [ğŸŒ](https://github.com/GerHobbelt/DBow3) -- DBoW3 is an improved version of the DBow2 library, an open source C++ library for indexing and converting images into a bag-of-word representation. It implements a hierarchical tree for approximating nearest neighbours in the image feature space and creating a visual vocabulary. DBoW3 also implements an image database with inverted and direct files to index images and enabling quick queries and feature comparisons.
- **deepdetect** [ğŸ“](./deepdetect) [ğŸŒ](https://github.com/GerHobbelt/deepdetect) -- DeepDetect (https://www.deepdetect.com/) is a machine learning API and server written in C++11. It makes state of the art machine learning easy to work with and integrate into existing applications. It has support for both training and inference, with automatic conversion to embedded platforms with TensorRT (NVidia GPU) and NCNN (ARM CPU). It implements support for supervised and unsupervised deep learning of images, text, time series and other data, with focus on simplicity and ease of use, test and connection into existing applications. It supports classification, object detection, segmentation, regression, autoencoders, ... and it relies on external machine learning libraries through a very generic and flexible API.
- **DGM-CRF** [ğŸ“](./DGM-CRF) [ğŸŒ](https://github.com/GerHobbelt/DGM) -- DGM (Direct Graphical Models) is a cross-platform C++ library implementing various tasks in probabilistic graphical models with pairwise and complete (dense) dependencies. The library aims to be used for the Markov and Conditional Random Fields (MRF / CRF), Markov Chains, Bayesian Networks, _etc_.
- **DiskANN** [ğŸ“](./DiskANN) [ğŸŒ](https://github.com/GerHobbelt/DiskANN) -- DiskANN is a suite of scalable, accurate and cost-effective approximate nearest neighbor search algorithms for large-scale vector search that support real-time changes and simple filters.
- **dkm** [ğŸ“](./dkm) [ğŸŒ](https://github.com/GerHobbelt/dkm) -- a generic C++11 k-means clustering implementation. The algorithm is based on [Lloyds Algorithm](https://en.wikipedia.org/wiki/Lloyd%27s_algorithm) and uses the [kmeans++](https://en.wikipedia.org/wiki/K-means%2B%2B) initialization method.
- **dlib** [ğŸ“](./dlib) [ğŸŒ](https://github.com/GerHobbelt/dlib) -- machine learning algorithms
- **DP_means** [ğŸ“](./DP_means) [ğŸŒ](https://github.com/GerHobbelt/DP_means) -- Dirichlet Process K-means is a bayesian non-parametric extension of the K-means algorithm based on small variance assymptotics (SVA) approximation of the Dirichlet Process Mixture Model.  B. Kulis and M. Jordan, "Revisiting k-means: New Algorithms via Bayesian Nonparametrics"
- **dynet** [ğŸ“](./dynet) [ğŸŒ](https://github.com/GerHobbelt/dynet) -- The Dynamic Neural Network Toolkit. DyNet is a neural network library developed by Carnegie Mellon University and many others. It is written in C++ (with bindings in Python) and is designed to be efficient when run on either CPU or GPU, and to work well with networks that have dynamic structures that change for every training instance. For example, these kinds of networks are particularly important in natural language processing tasks, and DyNet has been used to build state-of-the-art systems for syntactic parsing, machine translation, morphological inflection, and many other application areas.
- **falconn** [ğŸ“](./falconn) [ğŸŒ](https://github.com/GerHobbelt/FALCONN) -- FALCONN (FAst Lookups of Cosine and Other Nearest Neighbors) is a library with algorithms for the nearest neighbor search problem. The algorithms in FALCONN are based on [Locality-Sensitive Hashing](https://en.wikipedia.org/wiki/Locality-sensitive_hashing) (LSH), which is a popular class of methods for nearest neighbor search in high-dimensional spaces. The goal of FALCONN is to provide very efficient and well-tested implementations of LSH-based data structures.  Currently, FALCONN supports two LSH families for the [cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity): hyperplane LSH and cross polytope LSH. Both hash families are implemented with multi-probe LSH in order to minimize memory usage. Moreover, FALCONN is optimized for both dense and sparse data. Despite being designed for the cosine similarity, FALCONN can often be used for nearest neighbor search under the Euclidean distance or a maximum inner product search.
- **fast-kmeans** [ğŸ“](./fast-kmeans) [ğŸŒ](https://github.com/GerHobbelt/fast-kmeans) -- this Fast K-means Clustering Toolkit is a testbed for comparing variants of Lloyd's k-means clustering algorithm.  It includes implementations of several algorithms that accelerate the algorithm by avoiding unnecessary distance calculations.
- **fbow** [ğŸ“](./fbow) [ğŸŒ](https://github.com/GerHobbelt/fbow) -- FBOW (Fast Bag of Words) is an extremmely optimized version of the DBow2/DBow3 libraries. The library is highly optimized to speed up the Bag of Words creation using  AVX,SSE and MMX instructions. In loading a vocabulary, fbow is ~80x faster than DBOW2 (see tests directory and try). In transforming an image into a bag of words using on machines with AVX instructions, it is ~6.4x faster.
- **ffht** [ğŸ“](./ffht) [ğŸŒ](https://github.com/GerHobbelt/FFHT) -- FFHT (Fast Fast Hadamard Transform) is a library that provides a heavily optimized C99 implementation of the Fast Hadamard Transform. FFHT also provides a thin Python wrapper that allows to perform the Fast Hadamard Transform on one-dimensional [NumPy](http://www.numpy.org/) arrays. The Hadamard Transform is a linear orthogonal map defined on real vectors whose length is a _power of two_. For the precise definition, see the [Wikipedia entry](https://en.wikipedia.org/wiki/Hadamard_transform). The Hadamard Transform has been recently used a lot in various machine learning and numerical algorithms. FFHT uses [AVX](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions) to speed up the computation.
- **FFME** [ğŸ“](./FFME) [ğŸŒ](https://github.com/GerHobbelt/FFME) -- key points detection (OpenCV). This method is a SIFT-like one, but specifically designed for egomotion computation. The key idea is that it avoids some of the steps SIFT gives, so that it runs faster, at the cost of not being so robust against scaling. The good news is that in egomotion estimation the scaling is not so critical as in registration applications, where SIFT should be selected.
- **flann** [ğŸ“](./flann) [ğŸŒ](https://github.com/GerHobbelt/flann) -- FLANN (Fast Library for Approximate Nearest Neighbors) is a library for performing fast approximate nearest neighbor searches in high dimensional spaces. It contains a collection of algorithms we found to work best for nearest neighbor search and a system for automatically choosing the best algorithm and optimum parameters depending on the dataset.
- **flashlight** [ğŸ“](./flashlight) [ğŸŒ](https://github.com/GerHobbelt/flashlight) -- a fast, flexible machine learning library written entirely in C++ from the Facebook AI Research and the creators of Torch, TensorFlow, Eigen and Deep Speech, with an emphasis on efficiency and scale.
- **flinng** [ğŸ“](./flinng) [ğŸŒ](https://github.com/GerHobbelt/FLINNG) -- Filters to Identify Near-Neighbor Groups (FLINNG) is a near neighbor search algorithm outlined in the paper [Practical Near Neighbor Search via Group Testing](https://arxiv.org/pdf/2106.11565.pdf).
- **gtn** [ğŸ“](./gtn) [ğŸŒ](https://github.com/GerHobbelt/gtn) -- GTN (Automatic Differentiation with WFSTs) is a framework for automatic differentiation with weighted finite-state transducers. The goal of GTN is to make adding and experimenting with structure in learning algorithms much simpler. This structure is encoded as weighted automata, either acceptors (WFSAs) or transducers (WFSTs). With `gtn` you can dynamically construct complex graphs from operations on simpler graphs. Automatic differentiation gives gradients with respect to any input or intermediate graph with a single call to `gtn.backward`.
- **ikd-Tree** [ğŸ“](./ikd-Tree) [ğŸŒ](https://github.com/GerHobbelt/ikd-Tree) -- an incremental k-d tree designed for robotic applications. The ikd-Tree incrementally updates a k-d tree with new coming points only, leading to much lower computation time than existing static k-d trees. Besides point-wise operations, the ikd-Tree supports several features such as box-wise operations and down-sampling that are practically useful in robotic applications.
- **InferenceHelper** [ğŸ“](./InferenceHelper) [ğŸŒ](https://github.com/GerHobbelt/InferenceHelper) -- a wrapper of deep learning frameworks especially for inference. This class provides a common interface to use various deep learnig frameworks, so that you can use the same application code.
- **InversePerspectiveMapping** [ğŸ“](./InversePerspectiveMapping) [ğŸŒ](https://github.com/GerHobbelt/InversePerspectiveMapping) -- C++ class for the computation of plane-to-plane homographies, aka bird's-eye view or IPM, particularly relevant in the field of Advanced Driver Assistance Systems.
- **jpeg2dct** [ğŸ“](./jpeg2dct) [ğŸŒ](https://github.com/GerHobbelt/jpeg2dct) -- Faster Neural Networks Straight from JPEG: jpeg2dct subroutines -- this module is useful for reproducing results presented in the paper [Faster Neural Networks Straight from JPEG](https://openreview.net/forum?id=S1ry6Y1vG) (ICLR workshop 2018).
- **kann** [ğŸ“](./kann) [ğŸŒ](https://github.com/GerHobbelt/kann) -- KANN is a standalone and lightweight library in C for constructing and training small to medium artificial neural networks such as multi-layer perceptrons (MLP), convolutional neural networks (CNN) and recurrent neural networks (RNN), including LSTM and GRU. It implements graph-based reverse-mode automatic differentiation and allows to build topologically complex neural networks with recurrence, shared weights and multiple inputs/outputs/costs. In comparison to mainstream deep learning frameworks such as TensorFlow, KANN is not as scalable, but it is close in flexibility, has a much smaller code base and only depends on the standard C library. In comparison to other lightweight frameworks such as tiny-dnn, KANN is still smaller, times faster and much more versatile, supporting RNN, VAE and non-standard neural networks that may fail these lightweight frameworks. KANN could be potentially useful when you want to experiment small to medium neural networks in C/C++, to deploy no-so-large models without worrying about dependency hell, or to learn the internals of deep learning libraries.
- **K-Medoids-Clustering** [ğŸ“](./K-Medoids-Clustering) [ğŸŒ](https://github.com/GerHobbelt/K-Medoids-Clustering) -- K-medoids is a clustering algorithm related to K-means. In contrast to the K-means algorithm, K-medoids chooses datapoints as centers of the clusters. There are eight combinations of Initialization, Assignment and Update algorithms to achieve the best results in the given dataset. Also Clara algorithm approach is implemented.
- **lapack** [ğŸ“](./lapack) [ğŸŒ](https://github.com/GerHobbelt/lapack) -- [CBLAS](http://www.netlib.org/blas/) + [LAPACK](http://www.netlib.org/lapack/index.html) optimized linear algebra libs
- **libahocorasick** [ğŸ“](./libahocorasick) [ğŸŒ](https://github.com/GerHobbelt/pyahocorasick) -- a fast and memory efficient library for exact or approximate multi-pattern string search meaning that you can find multiple key strings occurrences at once in some input text.  The strings "index" can be built ahead of time and saved (as a pickle) to disk to reload and reuse later.  The library provides an `ahocorasick` Python module that you can use as a plain dict-like Trie or convert a Trie to an automaton for efficient Aho-Corasick search.
- **libcluster** [ğŸ“](./libcluster) [ğŸŒ](https://github.com/GerHobbelt/libcluster) -- implements various algorithms with variational Bayes learning procedures and efficient cluster splitting heuristics, including the Variational Dirichlet Process (VDP), the Bayesian Gaussian Mixture Model, the Grouped Mixtures Clustering (GMC) model and more clustering algorithms based on diagonal Gaussian, and Exponential distributions.
- **libdivsufsort** [ğŸ“](./libdivsufsort) [ğŸŒ](https://github.com/GerHobbelt/libdivsufsort) -- a software library that implements a lightweight suffix array construction algorithm.
- **libfann** [ğŸ“](./libfann) [ğŸŒ](https://github.com/GerHobbelt/fann) -- FANN: Fast Artificial Neural Network Library, a free open source neural network library, which implements multilayer artificial neural networks in C with support for both fully connected and sparsely connected networks. Cross-platform execution in both fixed and floating point are supported. It includes a framework for easy handling of training data sets. It is easy to use, versatile, well documented, and fast.
- **libirwls** [ğŸ“](./libirwls) [ğŸŒ](https://github.com/GerHobbelt/LIBIRWLS) -- LIBIRWLS is an integrated library that incorporates a parallel implementation of the Iterative Re-Weighted Least Squares (IRWLS) procedure, an alternative to quadratic programming (QP), for training of Support Vector Machines (SVMs). Although there are several methods for SVM training, the number of parallel libraries is very reduced. In particular, this library contains solutions to solve either full or budgeted SVMs making use of shared memory parallelization techniques: (1) a parallel SVM training procedure based on the IRWLS algorithm, (2) a parallel budgeted SVMs solver based on the IRWLS algorithm.
- **libkdtree** [ğŸ“](./libkdtree) [ğŸŒ](https://github.com/GerHobbelt/libkdtree) -- libkdtree++ is a C++ template container implementation of k-dimensional space sorting, using a kd-tree.
- **libmlpp** [ğŸ“](./libmlpp) [ğŸŒ](https://github.com/GerHobbelt/MLPP) -- ML++ :: The intent with this machine-learning library is for it to act as a crossroad between low-level developers and machine learning engineers.
- **libsvm** [ğŸ“](./libsvm) [ğŸŒ](https://github.com/GerHobbelt/libsvm) -- a simple, easy-to-use, and efficient software for SVM classification and regression. It solves C-SVM classification, nu-SVM classification, one-class-SVM, epsilon-SVM regression, and nu-SVM regression. It also provides an automatic model selection tool for C-SVM classification.
- **LightGBM** [ğŸ“](./LightGBM) [ğŸŒ](https://github.com/GerHobbelt/LightGBM) -- LightGBM (Light Gradient Boosting Machine) is a gradient boosting framework that uses tree based learning algorithms. It is designed to be distributed and efficient with the following advantages:
  
  - Better accuracy.
  - Capable of handling large-scale data.
  - Faster training speed and higher efficiency.
  - Lower memory usage.
  - Support of parallel, distributed, and GPU learning.

- **LMW-tree** [ğŸ“](./LMW-tree) [ğŸŒ](https://github.com/GerHobbelt/LMW-tree) -- LMW-tree: learning m-way tree is a generic template library written in C++ that implements several algorithms that use the m-way nearest neighbor tree structure to store their data. See the related [PhD thesis](http://eprints.qut.edu.au/75862/) for more details on m-way nn trees. The algorithms are primarily focussed on computationally efficient clustering. Clustering is an unsupervised machine learning process that finds interesting patterns in data. It places similar items into clusters and dissimilar items into different clusters. The data structures and algorithms can also be used for nearest neighbor search, supervised learning and other machine learning applications. The package includes EM-tree, K-tree, k-means, TSVQ, repeated k-means, clustering, random projections, random indexing, hashing, bit signatures. See the related [PhD thesis](http://eprints.qut.edu.au/75862/) for more details these algorithms and representations.
- **mace** [ğŸ“](./mace) [ğŸŒ](https://github.com/GerHobbelt/mace) -- **Mobile AI Compute Engine** (or **MACE** for short) is a deep learning inference framework optimized for mobile heterogeneous computing on Android, iOS, Linux and Windows devices. The design focuses on the following
- **mapreduce** [ğŸ“](./mapreduce) [ğŸŒ](https://github.com/GerHobbelt/mapreduce) -- the MapReduce-MPI (MR-MPI) library. MapReduce is the operation popularized by Google for computing on large distributed data sets.  See the Wikipedia entry on MapReduce for an overview of what a MapReduce is. The MR-MPI library is a simple, portable implementation of MapReduce that runs on any serial desktop machine or large parallel machine using MPI message passing.
- **marian** [ğŸ“](./marian) [ğŸŒ](https://github.com/GerHobbelt/marian) -- an efficient Neural Machine Translation framework written in pure C++ with minimal dependencies.
- **MegEngine** [ğŸ“](./MegEngine) [ğŸŒ](https://github.com/GerHobbelt/MegEngine) -- MegEngine is a fast, scalable, and user friendly deep learning framework with 3 key features: (1) Unified framework for both training and inference, (2) The lowest hardware requirements and (3) Inference efficiently on all platforms.
- **midas** [ğŸ“](./midas) [ğŸŒ](https://github.com/GerHobbelt/MIDAS) -- C++ implementation of:
  
  - [MIDAS: Microcluster-Based Detector of Anomalies in Edge Streams](https://arxiv.org/pdf/1911.04464.pdf). *Siddharth Bhatia, Bryan Hooi, Minji Yoon, Kijung Shin, Christos Faloutsos*. AAAI 2020.
  - [Real-time Streaming Anomaly Detection in Dynamic Graphs](https://arxiv.org/pdf/2009.08452.pdf). *Siddharth Bhatia, Rui Liu, Bryan Hooi, Minji Yoon, Kijung Shin, Christos Faloutsos*. TKDD 2022.

- **minhash_clustering** [ğŸ“](./minhash_clustering) [ğŸŒ](https://github.com/GerHobbelt/minhash_clustering) -- this program is for clustering protein conserved regions using MinWise Independent Hashing. The code uses MRMPI library for MapReduce in C/C++ and constitutes of two major parts.
- **MITIE-nlp** [ğŸ“](./MITIE-nlp) [ğŸŒ](https://github.com/GerHobbelt/MITIE) -- provides state-of-the-art information extraction tools. Includes tools for performing [named entity extraction](http://blog.dlib.net/2014/04/mitie-completely-free-and-state-of-art.html) and [binary relation detection](http://blog.dlib.net/2014/07/mitie-v02-released-now-includes-python.html) as well as tools for training custom extractors and relation detectors.  MITIE is built on top of [dlib](http://dlib.net), a high-performance machine-learning library, MITIE makes use of several state-of-the-art techniques including the use of distributional word embeddings and Structural Support Vector Machines.
- **MNN** [ğŸ“](./MNN) [ğŸŒ](https://github.com/GerHobbelt/MNN) -- a highly efficient and lightweight deep learning framework. It supports inference and training of deep learning models, and has industry leading performance for inference and training on-device. At present, MNN has been integrated in more than 30 apps of Alibaba Inc, such as Taobao, Tmall, Youku, Dingtalk, Xianyu and etc., covering more than 70 usage scenarios such as live broadcast, short video capture, search recommendation, product searching by image, interactive marketing, equity distribution, security risk control. In addition, MNN is also used on embedded devices, such as IoT. Inside Alibaba, [MNN](https://mp.weixin.qq.com/s/5I1ISpx8lQqvCS8tGd6EJw) works as the basic module of the compute container in the [Walle](https://mp.weixin.qq.com/s/qpeCETty0BqqNJV9CMJafA) System, the first end-to-end, general-purpose, and large-scale production system for device-cloud collaborative machine learning, which has been published in the top system conference OSDIâ€™22.
- **mrpt** [ğŸ“](./mrpt) [ğŸŒ](https://github.com/GerHobbelt/mrpt) -- MRPT is a lightweight and easy-to-use library for approximate nearest neighbor search with random projection. The index building has an integrated hyperparameter tuning algorithm, so the only hyperparameter required to construct the index is the target recall level! According to [our experiments](https://github.com/ejaasaari/mrpt-comparison/) MRPT is one of the fastest libraries for approximate nearest neighbor search.
  
  In the offline phase of the algorithm MRPT indexes the data with a collection of *random projection trees*. In the online phase the index structure allows us to answer queries in superior time. A detailed description of the algorithm with the time and space complexities, and the aforementioned comparisons can be found in [our article](https://www.cs.helsinki.fi/u/ttonteri/pub/bigdata2016.pdf) that was published in IEEE International Conference on Big Data 2016.
  
  The algorithm for automatic hyperparameter tuning is described in detail in our new article that will be presented in Pacific-Asia Conference on Knowledge Discovery and Data Mining 2019 ([arxiv preprint](https://arxiv.org/abs/1812.07484)).

- **Multicore-TSNE** [ğŸ“](./Multicore-TSNE) [ğŸŒ](https://github.com/GerHobbelt/Multicore-TSNE) -- Multicore t-SNE is a multicore modification of [Barnes-Hut t-SNE](https://github.com/lvdmaaten/bhtsne) by L. Van der Maaten with Python CFFI-based wrappers. This code also works **faster than sklearn.TSNE** on 1 core (as of version 0.18).
- **multiverso** [ğŸ“](./multiverso) [ğŸŒ](https://github.com/GerHobbelt/Multiverso) -- a parameter server based framework for training machine learning models on big data with numbers of machines. It is currently a standard C++ library and provides a series of friendly programming interfaces. Now machine learning researchers and practitioners do not need to worry about the system routine issues such as distributed model storage and operation, inter-process and inter-thread communication, multi-threading management, and so on. Instead, they are able to focus on the core machine learning logics: data, model, and training.
- **mxnet** [ğŸ“](./mxnet) [ğŸŒ](https://github.com/GerHobbelt/mxnet) -- Apache MXNet is a deep learning framework designed for both *efficiency* and *flexibility*. It allows you to ***mix*** [symbolic and imperative programming](https://mxnet.apache.org/api/architecture/program_model) to ***maximize*** efficiency and productivity.
- **nanoflann_dbscan** [ğŸ“](./nanoflann_dbscan) [ğŸŒ](https://github.com/GerHobbelt/nanoflann_dbscan) -- a fast C++ implementation of the Density-Based Spatial Clustering of Applications with Noise (DBSCAN) algorithm.
- **ncnn** [ğŸ“](./ncnn) [ğŸŒ](https://github.com/GerHobbelt/ncnn) -- high-performance neural network inference computing framework optimized for mobile platforms (i.e. small footprint)
- **NiuTrans.NMT** [ğŸ“](./NiuTrans.NMT) [ğŸŒ](https://github.com/GerHobbelt/NiuTrans.NMT) -- a lightweight and efficient Transformer-based neural machine translation system. Its main features are:
  
  - Few dependencies. It is implemented with pure C++, and all dependencies are optional.
  - Flexible running modes. The system can run with various systems and devices (Linux vs. Windows, CPUs vs. GPUs, and FP32 vs. FP16, etc.).
  - Framework agnostic. It supports various models trained with other tools, e.g., fairseq models.
  - High efficiency. It is heavily optimized for fast decoding, see [our WMT paper](https://arxiv.org/pdf/2109.08003.pdf) for more details.

- **oneDNN** [ğŸ“](./oneDNN) [ğŸŒ](https://github.com/GerHobbelt/oneDNN) -- oneAPI Deep Neural Network Library (oneDNN) is an open-source cross-platform performance library of basic building blocks for deep learning applications. oneDNN is intended for deep learning applications and framework developers interested in improving application performance on CPUs and GPUs.
- **onnxruntime** [ğŸ“](./onnxruntime) [ğŸŒ](https://github.com/GerHobbelt/onnxruntime) -- a cross-platform inference and training machine-learning accelerator. **ONNX Runtime inference** can enable faster customer experiences and lower costs, supporting models from deep learning frameworks such as PyTorch and TensorFlow/Keras as well as classical machine learning libraries such as scikit-learn, LightGBM, XGBoost, etc. ONNX Runtime is compatible with different hardware, drivers, and operating systems, and provides optimal performance by leveraging hardware accelerators where applicable alongside graph optimizations and transforms. [Learn more &rarr;](https://www.onnxruntime.ai/docs/#onnx-runtime-for-inferencing)
- **onnxruntime-extensions** [ğŸ“](./onnxruntime-extensions) [ğŸŒ](https://github.com/GerHobbelt/onnxruntime-extensions) -- a library that extends the capability of the ONNX models and inference with ONNX Runtime, via ONNX Runtime Custom Operator ABIs. It includes a set of [ONNX Runtime Custom Operator](https://onnxruntime.ai/docs/reference/operators/add-custom-op.html) to support the common pre- and post-processing operators for vision, text, and nlp models. The basic workflow is to enhance a ONNX model firstly and then do the model inference with ONNX Runtime and ONNXRuntime-Extensions package.
- **onnxruntime-genai** [ğŸ“](./onnxruntime-genai) [ğŸŒ](https://github.com/GerHobbelt/onnxruntime-genai) -- generative AI: run Llama, Phi, Gemma, Mistral with ONNX Runtime. This API gives you an easy, flexible and performant way of running LLMs on any device. It implements the generative AI loop for ONNX models, including pre and post processing, inference with ONNX Runtime, logits processing, search and sampling, and KV cache management.
- **OpenBLAS** [ğŸ“](./OpenBLAS) [ğŸŒ](https://github.com/GerHobbelt/OpenBLAS) -- an optimized BLAS (Basic Linear Algebra Subprograms) library based on GotoBLAS2 1.13 BSD version.
- **OpenCL-CTS** [ğŸ“](./OpenCL-CTS) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-CTS) -- the OpenCL Conformance Test Suite (CTS) for all versions of the Khronos [OpenCL](https://www.khronos.org/opencl/) standard.
- **OpenCL-Headers** [ğŸ“](./OpenCL-Headers) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-Headers) -- C language headers for the OpenCL API.
- **OpenCL-SDK** [ğŸ“](./OpenCL-SDK) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-SDK) -- the Khronos OpenCL SDK. It brings together all the components needed to develop OpenCL applications.
- **OpenFST** [ğŸ“](./OpenFST) [ğŸŒ](https://github.com/GerHobbelt/openfst) -- a library for constructing, combining, optimizing, and searching weighted finite-state transducers (FSTs). Weighted finite-state transducers are automata where each transition has an input label, an output label, and a weight. The more familiar finite-state acceptor is represented as a transducer with each transition's input and output label equal. Finite-state acceptors are used to represent sets of strings (specifically, regular or rational sets); finite-state transducers are used to represent binary relations between pairs of strings (specifically, rational transductions). The weights can be used to represent the cost of taking a particular transition. FSTs have key applications in speech recognition and synthesis, machine translation, optical character recognition, pattern matching, string processing, machine learning, information extraction and retrieval among others. Often a weighted transducer is used to represent a probabilistic model (e.g., an n-gram model, pronunciation model). FSTs can be optimized by determinization and minimization, models can be applied to hypothesis sets (also represented as automata) or cascaded by finite-state composition, and the best results can be selected by shortest-path algorithms.
- **OpenFST-utils** [ğŸ“](./OpenFST-utils) [ğŸŒ](https://github.com/GerHobbelt/openfst-utils) -- a set of useful programs for manipulating Finite State Transducer with the OpenFst library.
- **OpenNN** [ğŸ“](./OpenNN) [ğŸŒ](https://github.com/GerHobbelt/opennn) -- a software library written in C++ for advanced analytics. It implements neural networks, the most successful machine learning method. The main advantage of OpenNN is its high performance. This library outstands in terms of execution speed and memory allocation. It is constantly optimized and parallelized in order to maximize its efficiency.
- **openvino** [ğŸ“](./openvino) [ğŸŒ](https://github.com/GerHobbelt/openvino) -- OpenVINOâ„¢ is an open-source toolkit for optimizing and deploying AI inference, includind several components: namely [Model Optimizer], [OpenVINOâ„¢ Runtime], [Post-Training Optimization Tool], as well as CPU, GPU, GNA, multi device and heterogeneous plugins to accelerate deep learning inference on IntelÂ® CPUs and IntelÂ® Processor Graphics. It supports pre-trained models from [Open Model Zoo], along with 100+ open source and public models in popular formats such as TensorFlow, ONNX, PaddlePaddle, MXNet, Caffe, Kaldi.
- **OTB** [ğŸ“](./OTB) [ğŸŒ](https://github.com/GerHobbelt/OTB) -- Orfeo ToolBox (OTB) is an open-source project for state-of-the-art remote sensing. Built on the shoulders of the open-source geospatial community, it can process high resolution optical, multispectral and radar images at the terabyte scale. A wide variety of applications are available: from ortho-rectification or pansharpening, all the way to classification, SAR processing, and much more!
- **PaddleClas** [ğŸ“](./PaddleClas) [ğŸŒ](https://github.com/GerHobbelt/PaddleClas) -- an image classification and image recognition toolset for industry and academia, helping users train better computer vision models and apply them in real scenarios, based onÂ [PaddlePaddle](https://github.com/paddlepaddle/paddle).
- **PaddleDetection** [ğŸ“](./PaddleDetection) [ğŸŒ](https://github.com/GerHobbelt/PaddleDetection) -- a Highly Efficient Development Toolkit for Object Detection based onÂ [PaddlePaddle](https://github.com/paddlepaddle/paddle).
- **Paddle-Lite** [ğŸ“](./Paddle-Lite) [ğŸŒ](https://github.com/GerHobbelt/Paddle-Lite) -- an updated version of Paddle-Mobile, an open-open source deep learning framework designed to make it easy to perform inference on mobile, embeded, and IoT devices. It is compatible with PaddlePaddle and pre-trained models from other sources.
- **PaddleNLP** [ğŸ“](./PaddleNLP) [ğŸŒ](https://github.com/GerHobbelt/PaddleNLP) -- a NLP library that is both **easy to use** and **powerful**. It aggregates high-quality pretrained models in the industry and provides a **plug-and-play** development experience, covering a model library for various NLP scenarios. With practical examples from industry practices, PaddleNLP can meet the needs of developers who require **flexible customization**.
- **PaddleOCR** [ğŸ“](./PaddleOCR) [ğŸŒ](https://github.com/GerHobbelt/PaddleOCR) -- PaddleOCR aims to create multilingual, awesome, leading, and practical OCR tools that help users train better models and apply them into practice.
- **PaddlePaddle** [ğŸ“](./PaddlePaddle) [ğŸŒ](https://github.com/GerHobbelt/Paddle) -- the first independent R&D deep learning platform in China. It is an industrial platform with advanced technologies and rich features that cover core deep learning frameworks, basic model libraries, end-to-end development kits, tools & components as well as service platforms. PaddlePaddle is originated from industrial practices with dedication and commitments to industrialization. It has been widely adopted by a wide range of sectors including manufacturing, agriculture, enterprise service, and so on while serving more than 4.7 million developers, 180,000 companies and generating 560,000 models. With such advantages, PaddlePaddle has helped an increasing number of partners commercialize AI.
- **pagerank** [ğŸ“](./pagerank) [ğŸŒ](https://github.com/GerHobbelt/pagerank) -- a [pagerank](http://www.ams.org/samplings/feature-column/fcarc-pagerank) implementation in C++ able to handle very big graphs.
- **pecos** [ğŸ“](./pecos) [ğŸŒ](https://github.com/GerHobbelt/pecos) -- PECOS (Predictions for Enormous and Correlated Output Spaces) is a versatile and modular machine learning (ML) framework for fast learning and inference on problems with large output spaces, such as extreme multi-label ranking (XMR) and large-scale retrieval. PECOS' design is intentionally agnostic to the specific nature of the inputs and outputs as it is envisioned to be a general-purpose framework for multiple distinct applications. Given an input, PECOS identifies a small set (10-100) of relevant outputs from amongst an extremely large (~100MM) candidate set and ranks these outputs in terms of relevance.
- **PGM-index** [ğŸ“](./PGM-index) [ğŸŒ](https://github.com/GerHobbelt/PGM-index) -- the Piecewise Geometric Model index (PGM-index) is a data structure that enables fast lookup, predecessor, range searches and updates in arrays of billions of items using orders of magnitude less space than traditional indexes while providing the same worst-case query time guarantees.
- **pico_tree** [ğŸ“](./pico_tree) [ğŸŒ](https://github.com/GerHobbelt/pico_tree) -- a C++ header only library for fast nearest neighbor searches and range searches using a KdTree.
- **puffinn** [ğŸ“](./puffinn) [ğŸŒ](https://github.com/GerHobbelt/puffinn) -- PUFFINN - Parameterless and Universal Fast FInding of Nearest Neighbors - is an easily configurable library for finding the approximate nearest neighbors of arbitrary points. It also supports the identification of the closest pairs in the dataset. The only necessary parameters are the allowed space usage and the recall. Each near neighbor is guaranteed to be found with the probability given by the recall, regardless of the difficulty of the query.  Under the hood PUFFINN uses Locality Sensitive Hashing with an adaptive query mechanism. This means that the algorithm works for any similarity measure where a Locality Sensitive Hash family exists. Currently Cosine similarity is supported using SimHash or cross-polytope LSH and Jaccard similarity is supported using MinHash.
- **pyclustering** [ğŸ“](./pyclustering) [ğŸŒ](https://github.com/GerHobbelt/pyclustering) -- a Python, C++ data mining library (clustering algorithm, oscillatory networks, neural networks). The library provides Python and C++ implementations (C++ pyclustering library) of each algorithm or model.
- **pyglass** [ğŸ“](./pyglass) [ğŸŒ](https://github.com/GerHobbelt/pyglass) -- a library for fast inference of graph index for approximate similarity search.
  
  - It's high performant.
  - No third-party library dependencies, does not rely on OpenBLAS / MKL or any other computing framework.
  - Sophisticated memory management and data structure design, very low memory footprint.
  - Supports multiple graph algorithms, like [**HNSW**](https://github.com/nmslib/hnswlib) and [**NSG**](https://github.com/ZJULearning/nsg).
  - Supports multiple hardware platforms, like **X86** and **ARM**. Support for **GPU** is on the way

- **pytorch** [ğŸ“](./pytorch) [ğŸŒ](https://github.com/GerHobbelt/pytorch) -- PyTorch library in C++
- **pytorch_cluster** [ğŸ“](./pytorch_cluster) [ğŸŒ](https://github.com/GerHobbelt/pytorch_cluster) -- a small extension library of highly optimized graph cluster algorithms for the use in [PyTorch](http://pytorch.org/), supporting: 
  
  * **Graclus** from Dhillon *et al.*: [Weighted Graph Cuts without Eigenvectors: A Multilevel Approach](http://www.cs.utexas.edu/users/inderjit/public_papers/multilevel_pami.pdf) (PAMI 2007)
  * **Voxel Grid Pooling** from, *e.g.*, Simonovsky and Komodakis: [Dynamic Edge-Conditioned Filters in Convolutional Neural Networks on Graphs](https://arxiv.org/abs/1704.02901) (CVPR 2017)
  * **Iterative Farthest Point Sampling** from, *e.g.* Qi *et al.*: [PointNet++: Deep Hierarchical Feature Learning on Point Sets in a Metric Space](https://arxiv.org/abs/1706.02413) (NIPS 2017)
  * **k-NN** and **Radius** graph generation
  * Clustering based on **Nearest** points
  * **Random Walk Sampling** from, *e.g.*, Grover and Leskovec: [node2vec: Scalable Feature Learning for Networks](https://arxiv.org/abs/1607.00653) (KDD 2016)

- **pytorch_cpp_demo** [ğŸ“](./pytorch_cpp_demo) [ğŸŒ](https://github.com/GerHobbelt/pytorch_cpp) -- Deep Learning sample programs of PyTorch written in C++.
- **spherical-k-means** [ğŸ“](./spherical-k-means) [ğŸŒ](https://github.com/GerHobbelt/spherical-k-means) -- the spherical K-means algorithm in Matlab and C++. The C++ version emphasizes a multithreaded implementation and features three ways of running the algorithm. It can be executed with a single-thread (same as the Matlab implementation), or using OpenMP or Galois (http://iss.ices.utexas.edu/?p=projects/galois). The purpose of this code is to optimize and compare the different parallel paradigms to maximize the efficiency of the algorithm.
- **ssdeep** [ğŸ“](./ssdeep) [ğŸŒ](https://github.com/GerHobbelt/ssdeep) -- fuzzy hashing library, can be used to assist with identifying almost identical files using context triggered piecewise hashing.
- **ssimulacra2** [ğŸ“](./ssimulacra2) [ğŸŒ](https://github.com/GerHobbelt/ssimulacra2) -- Structural SIMilarity Unveiling Local And Compression Related Artifacts metric developed by Jon Sneyers. SSIMULACRA 2 is based on the concept of the multi-scale structural similarity index measure (MS-SSIM), computed in a perceptually relevant color space, adding two other (asymmetric) error maps, and aggregating using two different norms.
- **stan** [ğŸ“](./stan) [ğŸŒ](https://github.com/GerHobbelt/stan) -- Stan is a C++ package providing (1) full Bayesian inference using the No-U-Turn sampler (NUTS), a variant of Hamiltonian Monte Carlo (HMC), (2) approximate Bayesian inference using automatic differentiation variational inference (ADVI), and (3) penalized maximum likelihood estimation (MLE) using L-BFGS optimization. It is built on top of the [Stan Math library](https://github.com/stan-dev/math).
- **stan-math** [ğŸ“](./stan-math) [ğŸŒ](https://github.com/GerHobbelt/stan-math) -- the Stan Math Library is a C++, reverse-mode automatic differentiation library designed to be usable, extensive and extensible, efficient, scalable, stable, portable, and redistributable in order to facilitate the construction and utilization of algorithms that utilize derivatives.
- **StarSpace** [ğŸ“](./StarSpace) [ğŸŒ](https://github.com/GerHobbelt/StarSpace) -- a general-purpose neural model for efficient learning of entity embeddings for solving a wide variety of problems.
- **tapkee** [ğŸ“](./tapkee) [ğŸŒ](https://github.com/GerHobbelt/tapkee) -- a C++ template library for dimensionality reduction with some bias on spectral methods. The Tapkee origins from the code developed during [GSoC 2011](http://www.google-melange.com/gsoc/homepage/google/gsoc2011) as the part of the [Shogun machine learning toolbox](https://github.com/shogun-toolbox/shogun). The project aim is to provide efficient and flexible standalone library for dimensionality reduction which can be easily integrated to existing codebases. Tapkee leverages capabilities of effective [Eigen3 linear algebra library](http://eigen.tuxfamily.org) and optionally makes use of the [ARPACK eigensolver](http://www.caam.rice.edu/software/ARPACK/). The library uses CoverTree and VP-tree data structures to compute nearest neighbors. To achieve greater flexibility we provide a callback interface which decouples dimension reduction algorithms from the data representation and storage schemes.
- **tensorflow** [ğŸ“](./tensorflow) [ğŸŒ](https://github.com/GerHobbelt/tensorflow) -- an end-to-end open source platform for machine learning.
- **tensorflow-docs** [ğŸ“](./tensorflow-docs) [ğŸŒ](https://github.com/GerHobbelt/tensorflow-docs) -- TensorFlow documentation
- **tensorflow-io** [ğŸ“](./tensorflow-io) [ğŸŒ](https://github.com/GerHobbelt/tensorflow-io) -- TensorFlow I/O is a collection of file systems and file formats that are not available in TensorFlow's built-in support. A full list of supported file systems and file formats by TensorFlow I/O can be found [here](https://www.tensorflow.org/io/api_docs/python/tfio).
- **tensorflow-text** [ğŸ“](./tensorflow-text) [ğŸŒ](https://github.com/GerHobbelt/tensorflow-text) -- TensorFlow Text provides a collection of text related classes and ops ready to use with TensorFlow 2.0. The library can perform the preprocessing regularly required by text-based models, and includes other features useful for sequence modeling not provided by core TensorFlow.
- **tensorstore** [ğŸ“](./tensorstore) [ğŸŒ](https://github.com/GerHobbelt/tensorstore) -- TensorStore is an open-source C++ and Python software library designed for storage and manipulation of large multi-dimensional arrays.
- **thunderSVM** [ğŸ“](./thunderSVM) [ğŸŒ](https://github.com/GerHobbelt/thundersvm) -- ThunderSVM exploits GPUs and multi-core CPUs to achieve high efficiency, supporting all functionalities of LibSVM such as one-class SVMs, SVC, SVR and probabilistic SVMs.
- **tinn** [ğŸ“](./tinn) [ğŸŒ](https://github.com/GerHobbelt/tinn) -- Tinn (Tiny Neural Network) is a 200 line dependency free neural network library written in C99.
- **tiny-dnn** [ğŸ“](./tiny-dnn) [ğŸŒ](https://github.com/GerHobbelt/tiny-dnn) -- a C++14 implementation of deep learning. It is suitable for deep learning on limited computational resource, embedded systems and IoT devices.
- **TNN** [ğŸ“](./TNN) [ğŸŒ](https://github.com/GerHobbelt/TNN) -- a high-performance, lightweight neural network inference framework open sourced by Tencent Youtu Lab. It also has many outstanding advantages such as cross-platform, high performance, model compression, and code tailoring. The TNN framework further strengthens the support and performance optimization of mobile devices on the basis of the original Rapidnet and ncnn frameworks. At the same time, it refers to the high performance and good scalability characteristics of the industry's mainstream open source frameworks, and expands the support for X86 and NV GPUs. On the mobile phone, TNN has been used by many applications such as mobile QQ, weishi, and Pitu. As a basic acceleration framework for Tencent Cloud AI, TNN has provided acceleration support for the implementation of many businesses. Everyone is welcome to participate in the collaborative construction to promote the further improvement of the TNN inference framework.
- **vxl** [ğŸ“](./vxl) [ğŸŒ](https://github.com/GerHobbelt/vxl) -- VXL (the Vision-something-Libraries) is a collection of C++ libraries designed for computer vision research and implementation. It was created from TargetJr and the IUE with the aim of making a light, fast and consistent system.
- **waifu2x-ncnn-vulkan** [ğŸ“](./waifu2x-ncnn-vulkan) [ğŸŒ](https://github.com/GerHobbelt/waifu2x-ncnn-vulkan) -- waifu2x ncnn Vulkan: an [ncnn project](https://github.com/Tencent/ncnn) implementation of the waifu2x converter. Runs fast on Intel / AMD / Nvidia / Apple-Silicon with Vulkan API.
- **warp-ctc** [ğŸ“](./warp-ctc) [ğŸŒ](https://github.com/GerHobbelt/warp-ctc) -- A fast parallel implementation of CTC, on both CPU and GPU. Connectionist Temporal Classification (CTC) is a loss function useful for performing supervised learning on sequence data, without needing an alignment between input data and labels. For example, CTC can be used to train end-to-end systems for speech recognition.
- **xnnpack** [ğŸ“](./xnnpack) [ğŸŒ](https://github.com/GerHobbelt/XNNPACK) -- a highly optimized library of floating-point neural network inference operators for ARM, WebAssembly, and x86 platforms. XNNPACK is not intended for direct use by deep learning practitioners and researchers; instead it provides low-level performance primitives for accelerating high-level machine learning frameworks, such as TensorFlow Lite, TensorFlow.js, PyTorch, and MediaPipe.
- **xtensor** [ğŸ“](./xtensor) [ğŸŒ](https://github.com/GerHobbelt/xtensor) -- C++ tensors with broadcasting and lazy computing. `xtensor` is a C++ library meant for numerical analysis with multi-dimensional array expressions.
- **xtensor-blas** [ğŸ“](./xtensor-blas) [ğŸŒ](https://github.com/GerHobbelt/xtensor-blas) -- an extension to the `xtensor` library, offering bindings to BLAS and LAPACK libraries through `cxxblas` and `cxxlapack`.
- **xtensor-io** [ğŸ“](./xtensor-io) [ğŸŒ](https://github.com/GerHobbelt/xtensor-io) -- a `xtensor` plugin to read and write images, audio files, NumPy (compressed) NPZ and HDF5 files.
- **xtl** [ğŸ“](./xtl) [ğŸŒ](https://github.com/GerHobbelt/xtl) -- xtensor core library
- **yara-pattern-matcher** [ğŸ“](./yara-pattern-matcher) [ğŸŒ](https://github.com/GerHobbelt/yara) -- for automated and user-specified pattern recognition in custom document & metadata *cleaning* / processing tasks
- **ZQCNN** [ğŸ“](./ZQCNN) [ğŸŒ](https://github.com/GerHobbelt/ZQCNN) -- ZQCNN is an inference framework that can run under windows, linux and arm-linux. At the same time, there are some demos related to face detection and recognition.











### similarity search

- **aho_corasick** [ğŸ“](./aho_corasick) [ğŸŒ](https://github.com/GerHobbelt/aho_corasick) -- a header only implementation of the Aho-Corasick pattern search algorithm invented by Alfred V. Aho and Margaret J. Corasick. It is a very efficient dictionary matching algorithm that can locate all search patterns against in input text simultaneously in O(n + m), with space complexity O(m) (where n is the length of the input text, and m is the combined length of the search patterns).
- **annoy** [ğŸ“](./annoy) [ğŸŒ](https://github.com/GerHobbelt/annoy) -- ANNOY (<b>A</b>pproximate <b>N</b>earest <b>N</b>eighbors <b>O</b>h <b>Y</b>eah) is a C++ library to search for points in space that are close to a given query point. It also creates large read-only file-based data structures that are `mmap`-ped into memory so that many processes may share the same data. ANNOY is almost as fast as the fastest libraries, but what really sets Annoy apart is: it has the ability to use static files as indexes, enabling you to share an index across processes. ANNOY also decouples creating indexes from loading them, so you can pass around indexes as files and map them into memory quickly. ANNOY tries to minimize its memory footprint: the indexes are quite small. This is useful when you want to find nearest neighbors using multiple CPU's. Spotify uses ANNOY for music recommendations.
- **brown-cluster** [ğŸ“](./brown-cluster) [ğŸŒ](https://github.com/GerHobbelt/brown-cluster) -- the Brown hierarchical word clustering algorithm. Runs in $O(N C^2)$, where $N$ is the number of word types and $C$ is the number of clusters. Algorithm by Brown, et al.: Class-Based n-gram Models of Natural Language, http://acl.ldc.upenn.edu/J/J92/J92-4003.pdf
- **cppsimhash** [ğŸ“](./cppsimhash) [ğŸŒ](https://github.com/GerHobbelt/cppsimhash) -- C++ simhash implementation for documents and an additional (prototype) simhash index for text documents. Simhash is a hashing technique that belongs to the LSH (Local Sensitive Hashing) algorithmic family. It was initially developed by Moses S. Charikar in 2002 and is described in detail in his [paper](http://www.cs.princeton.edu/courses/archive/spring04/cos598B/bib/CharikarEstim.pdf).
- **CTCWordBeamSearch** [ğŸ“](./CTCWordBeamSearch) [ğŸŒ](https://github.com/GerHobbelt/CTCWordBeamSearch) -- Connectionist Temporal Classification (CTC) decoder with dictionary and Language Model (LM).
- **DiskANN** [ğŸ“](./DiskANN) [ğŸŒ](https://github.com/GerHobbelt/DiskANN) -- DiskANN is a suite of scalable, accurate and cost-effective approximate nearest neighbor search algorithms for large-scale vector search that support real-time changes and simple filters.
- **DP_means** [ğŸ“](./DP_means) [ğŸŒ](https://github.com/GerHobbelt/DP_means) -- Dirichlet Process K-means is a bayesian non-parametric extension of the K-means algorithm based on small variance assymptotics (SVA) approximation of the Dirichlet Process Mixture Model.  B. Kulis and M. Jordan, "Revisiting k-means: New Algorithms via Bayesian Nonparametrics"
- **faiss** [ğŸ“](./faiss) [ğŸŒ](https://github.com/GerHobbelt/faiss) -- a library for efficient similarity search and clustering of dense vectors. It contains algorithms that search in sets of vectors of any size, up to ones that possibly do not fit in RAM. It also contains supporting code for evaluation and parameter tuning. Faiss is written in C++ with complete wrappers for Python/numpy. Some of the most useful algorithms are implemented on the GPU. It is developed primarily at Facebook AI Research.
- **falconn** [ğŸ“](./falconn) [ğŸŒ](https://github.com/GerHobbelt/FALCONN) -- FALCONN (FAst Lookups of Cosine and Other Nearest Neighbors) is a library with algorithms for the nearest neighbor search problem. The algorithms in FALCONN are based on [Locality-Sensitive Hashing](https://en.wikipedia.org/wiki/Locality-sensitive_hashing) (LSH), which is a popular class of methods for nearest neighbor search in high-dimensional spaces. The goal of FALCONN is to provide very efficient and well-tested implementations of LSH-based data structures.  Currently, FALCONN supports two LSH families for the [cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity): hyperplane LSH and cross polytope LSH. Both hash families are implemented with multi-probe LSH in order to minimize memory usage. Moreover, FALCONN is optimized for both dense and sparse data. Despite being designed for the cosine similarity, FALCONN can often be used for nearest neighbor search under the Euclidean distance or a maximum inner product search.
- **flann** [ğŸ“](./flann) [ğŸŒ](https://github.com/GerHobbelt/flann) -- FLANN (Fast Library for Approximate Nearest Neighbors) is a library for performing fast approximate nearest neighbor searches in high dimensional spaces. It contains a collection of algorithms we found to work best for nearest neighbor search and a system for automatically choosing the best algorithm and optimum parameters depending on the dataset.
- **flinng** [ğŸ“](./flinng) [ğŸŒ](https://github.com/GerHobbelt/FLINNG) -- Filters to Identify Near-Neighbor Groups (FLINNG) is a near neighbor search algorithm outlined in the paper [Practical Near Neighbor Search via Group Testing](https://arxiv.org/pdf/2106.11565.pdf).
- **FM-fast-match** [ğŸ“](./FM-fast-match) [ğŸŒ](https://github.com/GerHobbelt/FAsT-Match) -- FAsT-Match: a port of the Fast Affine Template Matching algorithm (Simon Korman, Daniel Reichman, Gilad Tsur, Shai Avidan, CVPR 2013, Portland)
- **fuzzy-match** [ğŸ“](./fuzzy-match) [ğŸŒ](https://github.com/GerHobbelt/fuzzy-match) -- `FuzzyMatch-cli` is a commandline utility allowing to compile FuzzyMatch indexes and use them to lookup fuzzy matches. Okapi BM25 prefiltering is available on branch [`bm25`](https://github.com/SYSTRAN/fuzzy-match/tree/bm25).
- **hnswlib** [ğŸ“](./hnswlib) [ğŸŒ](https://github.com/GerHobbelt/hnswlib) -- fast approximate nearest neighbor search. Header-only C++ HNSW implementation with python bindings.
- **ikd-Tree** [ğŸ“](./ikd-Tree) [ğŸŒ](https://github.com/GerHobbelt/ikd-Tree) -- an incremental k-d tree designed for robotic applications. The ikd-Tree incrementally updates a k-d tree with new coming points only, leading to much lower computation time than existing static k-d trees. Besides point-wise operations, the ikd-Tree supports several features such as box-wise operations and down-sampling that are practically useful in robotic applications.
- **imagehash** [ğŸ“](./imagehash) [ğŸŒ](https://github.com/GerHobbelt/imagehash) -- an image hashing library written in Python. ImageHash supports Average hashing, Perceptual hashing, Difference hashing, Wavelet hashing, HSV color hashing (colorhash) and Crop-resistant hashing. The image hash algorithms (average, perceptual, difference, wavelet) analyse the image structure on luminance (without color information). The color hash algorithm analyses the color distribution and black & gray fractions (without position information).
- **ivf-hnsw** [ğŸ“](./ivf-hnsw) [ğŸŒ](https://github.com/GerHobbelt/ivf-hnsw) -- Revisiting the Inverted Indices for Billion-Scale Approximate Nearest Neighbors. This is the code for the current state-of-the-art billion-scale nearest neighbor search system presented in the paper: [Revisiting the Inverted Indices for Billion-Scale Approximate Nearest Neighbors](http://openaccess.thecvf.com/content_ECCV_2018/html/Dmitry_Baranchuk_Revisiting_the_Inverted_ECCV_2018_paper.html) (Dmitry Baranchuk, Artem Babenko, Yury Malkov).
- **kgraph** [ğŸ“](./kgraph) [ğŸŒ](https://github.com/GerHobbelt/kgraph) -- a library for k-nearest neighbor (k-NN) graph construction and online k-NN search using a k-NN Graph as index. KGraph implements heuristic algorithms that are extremely generic and fast. KGraph works on abstract objects. The only assumption it makes is that a similarity score can be computed on any pair of objects, with a user-provided function.
- **K-Medoids-Clustering** [ğŸ“](./K-Medoids-Clustering) [ğŸŒ](https://github.com/GerHobbelt/K-Medoids-Clustering) -- K-medoids is a clustering algorithm related to K-means. In contrast to the K-means algorithm, K-medoids chooses datapoints as centers of the clusters. There are eight combinations of Initialization, Assignment and Update algorithms to achieve the best results in the given dataset. Also Clara algorithm approach is implemented.
- **libahocorasick** [ğŸ“](./libahocorasick) [ğŸŒ](https://github.com/GerHobbelt/pyahocorasick) -- a fast and memory efficient library for exact or approximate multi-pattern string search meaning that you can find multiple key strings occurrences at once in some input text.  The strings "index" can be built ahead of time and saved (as a pickle) to disk to reload and reuse later.  The library provides an `ahocorasick` Python module that you can use as a plain dict-like Trie or convert a Trie to an automaton for efficient Aho-Corasick search.
- **libharry** [ğŸ“](./libharry) [ğŸŒ](https://github.com/GerHobbelt/harry) -- Harry - A Tool for Measuring String Similarity. The tool supports several common distance and kernel functions for strings as well as some excotic similarity measures.  The focus of Harry lies on implicit similarity measures, that is, comparison functions that do not give rise to an explicit vector space.  Examples of such similarity measures are the Levenshtein distance, the Jaro-Winkler distance or the spectrum kernel.
- **libkdtree** [ğŸ“](./libkdtree) [ğŸŒ](https://github.com/GerHobbelt/libkdtree) -- libkdtree++ is a C++ template container implementation of k-dimensional space sorting, using a kd-tree.
- **libngt-ann** [ğŸ“](./libngt-ann) [ğŸŒ](https://github.com/GerHobbelt/NGT) -- Yahoo's Neighborhood Graph and Tree for Indexing High-dimensional Data. NGT provides commands and a library for performing high-speed approximate nearest neighbor searches against a large volume of data (several million to several 10 million items of data) in high dimensional vector data space (several ten to several thousand dimensions).
- **libsptag** [ğŸ“](./libsptag) [ğŸŒ](https://github.com/GerHobbelt/SPTAG) -- a library for fast approximate nearest neighbor search.  SPTAG (Space Partition Tree And Graph) is a library for large scale vector approximate nearest neighbor search scenario released by [Microsoft Research (MSR)](https://www.msra.cn/) and [Microsoft Bing](http://bing.com).
- **LMW-tree** [ğŸ“](./LMW-tree) [ğŸŒ](https://github.com/GerHobbelt/LMW-tree) -- LMW-tree: learning m-way tree is a generic template library written in C++ that implements several algorithms that use the m-way nearest neighbor tree structure to store their data. See the related [PhD thesis](http://eprints.qut.edu.au/75862/) for more details on m-way nn trees. The algorithms are primarily focussed on computationally efficient clustering. Clustering is an unsupervised machine learning process that finds interesting patterns in data. It places similar items into clusters and dissimilar items into different clusters. The data structures and algorithms can also be used for nearest neighbor search, supervised learning and other machine learning applications. The package includes EM-tree, K-tree, k-means, TSVQ, repeated k-means, clustering, random projections, random indexing, hashing, bit signatures. See the related [PhD thesis](http://eprints.qut.edu.au/75862/) for more details these algorithms and representations.
- **lshbox** [ğŸ“](./lshbox) [ğŸŒ](https://github.com/GerHobbelt/LSHBOX) -- a C++ Toolbox of Locality-Sensitive Hashing for Large Scale Image Retrieval. Locality-Sensitive Hashing (LSH) is an efficient method for large scale image retrieval, and it achieves great performance in approximate nearest neighborhood searching.
  
  LSHBOX is a simple but robust C++ toolbox that provides several LSH algrithms, in addition, it can be integrated into Python and MATLAB languages. The following LSH algrithms have been implemented in LSHBOX, they are:
  
  * LSH Based on Random Bits Sampling
  * Random Hyperplane Hashing
  * LSH Based on Thresholding
  * LSH Based on p-Stable Distributions
  * [Spectral Hashing](http://www.cs.huji.ac.il/~yweiss/SpectralHashing/) (SH)
  * [Iterative Quantization](http://www.unc.edu/~yunchao/itq.htm) (ITQ)
  * Double-Bit Quantization Hashing (DBQ)
  * K-means Based Double-Bit Quantization Hashing (KDBQ)

- **mrpt** [ğŸ“](./mrpt) [ğŸŒ](https://github.com/GerHobbelt/mrpt) -- MRPT is a lightweight and easy-to-use library for approximate nearest neighbor search with random projection. The index building has an integrated hyperparameter tuning algorithm, so the only hyperparameter required to construct the index is the target recall level! According to [our experiments](https://github.com/ejaasaari/mrpt-comparison/) MRPT is one of the fastest libraries for approximate nearest neighbor search.
  
  In the offline phase of the algorithm MRPT indexes the data with a collection of *random projection trees*. In the online phase the index structure allows us to answer queries in superior time. A detailed description of the algorithm with the time and space complexities, and the aforementioned comparisons can be found in [our article](https://www.cs.helsinki.fi/u/ttonteri/pub/bigdata2016.pdf) that was published in IEEE International Conference on Big Data 2016.
  
  The algorithm for automatic hyperparameter tuning is described in detail in our new article that will be presented in Pacific-Asia Conference on Knowledge Discovery and Data Mining 2019 ([arxiv preprint](https://arxiv.org/abs/1812.07484)).

- **n2-kNN** [ğŸ“](./n2-kNN) [ğŸŒ](https://github.com/GerHobbelt/n2) -- N2: Lightweight approximate **N**\ earest **N**\ eighbor algorithm library. N2 stands for two N's, which comes from \'Approximate ``N``\ earest ``N``\ eighbor Algorithm\'. Before N2, there has been other great approximate nearest neighbor libraries such as `Annoy` and `NMSLIB`. However, each of them had different strengths and weaknesses regarding usability, performance, etc. N2 has been developed aiming to bring the strengths of existing aKNN libraries and supplement their weaknesses.
- **nanoflann** [ğŸ“](./nanoflann) [ğŸŒ](https://github.com/GerHobbelt/nanoflann) -- a C++11 header-only library for building KD-Trees of datasets with different topologies: R^2, R^3 (point clouds), SO(2) and SO(3) (2D and 3D rotation groups). No support for approximate NN is provided. This library is a fork of the `flann` library by Marius Muja and David G. Lowe, and born as a child project of `MRPT`.
- **nanoflann_dbscan** [ğŸ“](./nanoflann_dbscan) [ğŸŒ](https://github.com/GerHobbelt/nanoflann_dbscan) -- a fast C++ implementation of the Density-Based Spatial Clustering of Applications with Noise (DBSCAN) algorithm.
- **nmslib** [ğŸ“](./nmslib) [ğŸŒ](https://github.com/GerHobbelt/nmslib) -- Non-Metric Space Library (NMSLIB) is an efficient cross-platform similarity search library and a toolkit for evaluation of similarity search methods. The core-library does not have any third-party dependencies. It has been gaining popularity recently. In particular, it has become a part of Amazon Elasticsearch Service. The goal of the project is to create an effective and comprehensive toolkit for searching in generic and non-metric spaces. Even though the library contains a variety of metric-space access methods, our main focus is on generic and approximate search methods, in particular, on methods for non-metric spaces. NMSLIB is possibly the first library with a principled support for non-metric space searching.
- **online-hnsw** [ğŸ“](./online-hnsw) [ğŸŒ](https://github.com/GerHobbelt/online-hnsw) -- Online HNSW: an implementation of the HNSW index for approximate nearest neighbors search for C++14, that supports incremental insertion and removal of elements.
- **pagerank** [ğŸ“](./pagerank) [ğŸŒ](https://github.com/GerHobbelt/pagerank) -- a [pagerank](http://www.ams.org/samplings/feature-column/fcarc-pagerank) implementation in C++ able to handle very big graphs.
- **pHash** [ğŸ“](./pHash) [ğŸŒ](https://github.com/GerHobbelt/pHash) -- the open source perceptual hash library. Potential applications include copyright protection, similarity search for media files, or even digital forensics. For example, YouTube could maintain a database of hashes that have been submitted by the major movie producers of movies to which they hold the copyright. If a user then uploads the same video to YouTube, the hash will be almost identical, and it can be flagged as a possible copyright violation. The audio hash could be used to automatically tag MP3 files with proper ID3 information, while the text hash could be used for plagiarism detection.
- **phash-gpl** [ğŸ“](./phash-gpl) [ğŸŒ](https://github.com/GerHobbelt/phash-gpl) -- pHash&trade; Perceptual Hashing Library is a collection of perceptual hashing algorithms for image, audo, video and text media.
- **pico_tree** [ğŸ“](./pico_tree) [ğŸŒ](https://github.com/GerHobbelt/pico_tree) -- a C++ header only library for fast nearest neighbor searches and range searches using a KdTree.
- **probminhash** [ğŸ“](./probminhash) [ğŸŒ](https://github.com/GerHobbelt/probminhash) -- a class of Locality-Sensitive Hash Algorithms for the (Probability) Jaccard Similarity
- **pyglass** [ğŸ“](./pyglass) [ğŸŒ](https://github.com/GerHobbelt/pyglass) -- a library for fast inference of graph index for approximate similarity search.
  
  - It's high performant.
  - No third-party library dependencies, does not rely on OpenBLAS / MKL or any other computing framework.
  - Sophisticated memory management and data structure design, very low memory footprint.
  - Supports multiple graph algorithms, like [**HNSW**](https://github.com/nmslib/hnswlib) and [**NSG**](https://github.com/ZJULearning/nsg).
  - Supports multiple hardware platforms, like **X86** and **ARM**. Support for **GPU** is on the way

- **sdhash** [ğŸ“](./sdhash) [ğŸŒ](https://github.com/GerHobbelt/sdhash) -- a tool which allows two arbitrary blobs of data to be compared for similarity based on common strings of binary data. It is designed to provide quick results during triage and initial investigation phases.
- **Shifted-Hamming-Distance** [ğŸ“](./Shifted-Hamming-Distance) [ğŸŒ](https://github.com/GerHobbelt/Shifted-Hamming-Distance) -- Shifted Hamming Distance (SHD) is an edit-distance based filter that can quickly check whether the minimum number of edits (including insertions, deletions and substitutions) between two strings is smaller than a user defined threshold **T** (the number of allowed edits between the two strings).  Testing if two stings differs by a small amount is a prevalent function that is used in many applications. One of its biggest usage, perhaps, is in DNA or protein mapping, where a short DNA or protein string is compared against an enormous database, in order to find similar matches. In such applications, a query string is usually compared against multiple candidate strings in the database. Only candidates that are similar to the query are considered **matches** and recorded.  SHD expands the basic Hamming distance computation, which only detects substitutions, into a full-fledged edit-distance filter, which counts not only substitutions but **insertions and deletions** as well.
- **simhash-cpp** [ğŸ“](./simhash-cpp) [ğŸŒ](https://github.com/GerHobbelt/simhash-cpp) -- Simhash Near-Duplicate Detection enables the identification of all fingerprints that are nearly identical to a query fingerprint. In this context, a fingerprint is an unsigned 64-bit integer. It also comes with an auxillary function designed to generate a fingerprint given a `char*` and a length. This fingeprint is generated with a tokenizer and a hash function (both of which may be provided as template parameters). Using a cyclic hash function, it then performs simhash on a moving window of tokens (as defined by the tokenizer).
- **spherical-k-means** [ğŸ“](./spherical-k-means) [ğŸŒ](https://github.com/GerHobbelt/spherical-k-means) -- the spherical K-means algorithm in Matlab and C++. The C++ version emphasizes a multithreaded implementation and features three ways of running the algorithm. It can be executed with a single-thread (same as the Matlab implementation), or using OpenMP or Galois (http://iss.ices.utexas.edu/?p=projects/galois). The purpose of this code is to optimize and compare the different parallel paradigms to maximize the efficiency of the algorithm.
- **ssdeep** [ğŸ“](./ssdeep) [ğŸŒ](https://github.com/GerHobbelt/ssdeep) -- fuzzy hashing library, can be used to assist with identifying almost identical files using context triggered piecewise hashing.
- **ssimulacra2** [ğŸ“](./ssimulacra2) [ğŸŒ](https://github.com/GerHobbelt/ssimulacra2) -- Structural SIMilarity Unveiling Local And Compression Related Artifacts metric developed by Jon Sneyers. SSIMULACRA 2 is based on the concept of the multi-scale structural similarity index measure (MS-SSIM), computed in a perceptually relevant color space, adding two other (asymmetric) error maps, and aggregating using two different norms.
- **tiny-dnn** [ğŸ“](./tiny-dnn) [ğŸŒ](https://github.com/GerHobbelt/tiny-dnn) -- a C++14 implementation of deep learning. It is suitable for deep learning on limited computational resource, embedded systems and IoT devices.
- **tlsh** [ğŸ“](./tlsh) [ğŸŒ](https://github.com/GerHobbelt/tlsh) -- TLSH - Trend Micro Locality Sensitive Hash - is a fuzzy matching library. Given a byte stream with a minimum length of 50 bytes TLSH generates a hash value which can be used for similarity comparisons. Similar objects will have similar hash values which allows for the detection of similar objects by comparing their hash values.  Note that the byte stream should have a sufficient amount of complexity.  For example, a byte stream of identical bytes will not generate a hash value.
- **usearch** [ğŸ“](./usearch) [ğŸŒ](https://github.com/GerHobbelt/usearch) -- smaller & faster Single-File Similarity Search Engine for vectors & texts.
- **VQMT** [ğŸ“](./VQMT) [ğŸŒ](https://github.com/GerHobbelt/VQMT) -- VQMT (Video Quality Measurement Tool) provides fast implementations of the following objective metrics:
  
  - **MS-SSIM**: Multi-Scale Structural Similarity,
  - **PSNR**: Peak Signal-to-Noise Ratio,
  - **PSNR-HVS**: Peak Signal-to-Noise Ratio taking into account Contrast Sensitivity Function (CSF),
  - **PSNR-HVS-M**: Peak Signal-to-Noise Ratio taking into account Contrast Sensitivity Function (CSF) and between-coefficient contrast masking of DCT basis functions.
  - **SSIM**: Structural Similarity,
  - **VIFp**: Visual Information Fidelity, pixel domain version
  
  The above metrics are implemented in C++ with the help of OpenCV and are based on the original Matlab implementations provided by their developers.

- **xgboost** [ğŸ“](./xgboost) [ğŸŒ](https://github.com/GerHobbelt/xgboost) -- an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable. It implements machine learning algorithms under the Gradient Boosting framework. XGBoost provides a parallel tree boosting (also known as GBDT, GBM) that solve many data science problems in a fast and accurate way. The same code runs on major distributed environment (Kubernetes, Hadoop, SGE, MPI, Dask) and can solve problems beyond billions of examples.











### text tokenization (as a preprocessing step for LDA et al):

i.e. breaking text into words when you _receive a textstream without spaces_. Also useful for Asian languages, which don't do spaces, e.g. Chinese.

- **Bi-Sent2Vec** [ğŸ“](./Bi-Sent2Vec) [ğŸŒ](https://github.com/GerHobbelt/Bi-Sent2Vec) -- provides cross-lingual numerical representations (features) for words, short texts, or sentences, which can be used as input to any machine learning task with applications geared towards cross-lingual word translation, cross-lingual sentence retrieval as well as cross-lingual downstream NLP tasks. The library is a cross-lingual extension of [Sent2Vec](https://github.com/epfml/sent2vec). Bi-Sent2Vec vectors are also well suited to monolingual tasks as indicated by a marked improvement in the monolingual quality of the word embeddings. (For more details, see [paper](https://arxiv.org/abs/1912.12481))
- **BlingFire** [ğŸ“](./BlingFire) [ğŸŒ](https://github.com/GerHobbelt/BlingFire) -- we are a team at Microsoft called Bling (Beyond Language Understanding), sharing our [FInite State machine and REgular expression manipulation library](https://github.com/microsoft/BlingFire) (FIRE). We use Fire for many linguistic operations inside Bing such as Tokenization, Multi-word expression matching, Unknown word-guessing, Stemming / Lemmatization just to mention a few.
  
  Fire can also be used to improve FastText: see [here](https://github.com/microsoft/BlingFire#8-example-of-reaching-99-accuracy-for-language-detection).
  
  Bling Fire Tokenizer provides state of the art performance for Natural Language text tokenization.

- **chewing_text_cud** [ğŸ“](./chewing_text_cud) [ğŸŒ](https://github.com/GerHobbelt/chewing_text_cud) -- a text processing / filtering library for use in NLP/search/content analysis research pipelines.
- **cppjieba** [ğŸ“](./cppjieba) [ğŸŒ](https://github.com/GerHobbelt/cppjieba) -- the C++ version of the Chinese "Jieba" project:
  
  - Supports loading a custom user dictionary, using the '|' separator when multipathing or the ';' separator for separate, multiple, dictionaries.
  - Supports 'utf8' encoding.
  - The project comes with a relatively complete unit test, and the stability of the core function Chinese word segmentation (utf8) has been tested by the online environment.

- **fastBPE** [ğŸ“](./fastBPE) [ğŸŒ](https://github.com/GerHobbelt/fastBPE) -- text tokenization / ngrams
- **fastText** [ğŸ“](./fastText) [ğŸŒ](https://github.com/GerHobbelt/fastText) -- [fastText](https://fasttext.cc/) is a library for efficient learning of word representations and sentence classification. Includes language detection feeatures.
- **fribidi** [ğŸ“](./fribidi) [ğŸŒ](https://github.com/GerHobbelt/fribidi) -- GNU FriBidi: the Free Implementation of the [Unicode Bidirectional Algorithm]. One of the missing links stopping the penetration of free software in Middle East is the lack of support for the Arabic and Hebrew alphabets. In order to have proper Arabic and Hebrew support, the bidi algorithm needs to be implemented. It is our hope that this library will stimulate more free software in the Middle Eastern countries.
- **friso** [ğŸ“](./friso) [ğŸŒ](https://github.com/GerHobbelt/friso) -- high performance Chinese tokenizer with both GBK and UTF-8 charset support based on MMSEG algorithm.
- **fxt** [ğŸ“](./fxt) [ğŸŒ](https://github.com/GerHobbelt/fxt) -- a large scale feature extraction tool for text-based machine learning.
- **koan** [ğŸ“](./koan) [ğŸŒ](https://github.com/GerHobbelt/koan) -- a `word2vec` negative sampling implementation with correct CBOW update. kÅan only depends on Eigen.
  
  Although continuous bag of word (CBOW) embeddings can be trained more quickly than skipgram (SG) embeddings, it is a common belief that SG embeddings tend to perform better in practice. This was observed by the original authors of Word2Vec [1] and also in subsequent work [2].  However, we found that popular implementations of word2vec with negative sampling such as [word2vec](https://github.com/tmikolov/word2vec/) and [gensim](https://github.com/RaRe-Technologies/gensim/) do not implement the CBOW update correctly, thus potentially leading to misconceptions about the performance of CBOW embeddings when trained correctly.

- **libchopshop** [ğŸ“](./libchopshop) [ğŸŒ](https://github.com/GerHobbelt/libchopshop) -- NLP/text processing with automated stop word detection and stemmer-based filtering. This library / toolkit is engineered to be able to provide **both** of the (often more or less disparate) n-gram token streams / vectors required for (1) initializing / training FTS databases, neural nets, etc. and (2) executing effective queries / matches on these engines.
- **libcppjieba** [ğŸ“](./libcppjieba) [ğŸŒ](https://github.com/GerHobbelt/libcppjieba) -- source code extracted from the [CppJieba] project to form a separate project, making it easier to understand and use.
- **libdtm** [ğŸ“](./libdtm) [ğŸŒ](https://github.com/GerHobbelt/dtm) -- LibDTM (Dynamic Topic Models and the Document Influence Model) implements topics that change over time (Dynamic Topic Models) and a model of how individual documents predict that change. This code is the result of work by David M. Blei and Sean M. Gerrish.
- **libpostal** [ğŸ“](./libpostal) [ğŸŒ](https://github.com/GerHobbelt/libpostal) -- a C library for parsing/normalizing street addresses around the world using statistical NLP and open data. The goal of this project is to understand location-based strings in every language, everywhere.
- **libtextcat** [ğŸ“](./libtextcat) [ğŸŒ](https://github.com/GerHobbelt/libtextcat) -- text language detection
- **many-stop-words** [ğŸ“](./many-stop-words) [ğŸŒ](https://github.com/GerHobbelt/many-stop-words) -- Many Stop Words is a simple Python package that provides a single function for loading sets of stop words for different languages.
- **mecab** [ğŸ“](./mecab) [ğŸŒ](https://github.com/GerHobbelt/mecab) -- MeCab (Yet Another Part-of-Speech and Morphological Analyzer) is a high-performance morphological analysis engine, designed to be independent of languages, dictionaries, and corpora, using Conditional Random Fields ((CRF)[http://www.cis.upenn.edu/~pereira/papers/crf.pdf]) to estimate the parameters.
- **ngrams-weighted** [ğŸ“](./ngrams-weighted) [ğŸŒ](https://github.com/GerHobbelt/ngweight) -- implements the method to compute N-gram IDF weights for all valid word N-grams in the given corpus (document set).
- **sally** [ğŸ“](./sally) [ğŸŒ](https://github.com/GerHobbelt/sally) -- a Tool for Embedding Strings in Vector Spaces. This mapping is referred to as embedding and allows for applying techniques of machine learning and data mining for analysis of string data.  Sally can be applied to several types of strings, such as text documents, DNA sequences or log files, where it can handle common formats such as directories, archives and text files of string data. Sally implements a standard technique for mapping strings to a vector space that can be referred to as generalized bag-of-words model.  The strings are characterized by a set of features, where each feature is associated with one dimension of the vector space.  The following types of features are supported by Sally: bytes, tokens (words), n-grams of bytes and n-grams of tokens.
- **scws-chinese-word-segmentation** [ğŸ“](./scws-chinese-word-segmentation) [ğŸŒ](https://github.com/GerHobbelt/scws) -- SCWS (Simple Chinese Word Segmentation) (i.e.: Simple Chinese Word Segmentation System). This is a mechanical Chinese word segmentation engine based on word frequency dictionary, which can basically correctly segment a whole paragraph of Chinese text into words. A word is the smallest morpheme unit in Chinese, but when writing, it does not separate words with spaces like English, so how to segment words accurately and quickly has always been a difficult problem in Chinese word segmentation. SCWS supports Chinese encoding includes `GBK`, `UTF-8`, etc.
  
  There are not many innovative elements in the word segmentation algorithm. It uses a word frequency dictionary collected by itself, supplemented by certain proper names, names of people, and place names. Basic word segmentation is achieved by identifying rules such as digital age. After small-scale testing, the accuracy is between 90% and 95%, which can basically satisfy some use in small search engines, keyword extraction and other occasions. The first prototype version was released in late 2005.

- **sent2vec** [ğŸ“](./sent2vec) [ğŸŒ](https://github.com/GerHobbelt/sent2vec) -- a tool and pre-trained models related to the [Bi-Sent2vec](https://arxiv.org/abs/1912.12481). The cross-lingual extension of Sent2Vec can be found [here](https://github.com/epfml/Bi-sent2vec). This library provides numerical representations (features) for words, short texts, or sentences, which can be used as input to any machine learning task.
- **sentencepiece** [ğŸ“](./sentencepiece) [ğŸŒ](https://github.com/GerHobbelt/sentencepiece) -- text tokenization
- **sentence-tokenizer** [ğŸ“](./sentence-tokenizer) [ğŸŒ](https://github.com/GerHobbelt/Tokenizer) -- text tokenization
- **SheenBidi** [ğŸ“](./SheenBidi) [ğŸŒ](https://github.com/GerHobbelt/SheenBidi) -- implements Unicode Bidirectional Algorithm available at http://www.unicode.org/reports/tr9. It is a sophisticated implementation which provides the developers an easy way to use UBA in their applications.
- **stopwords** [ğŸ“](./stopwords) [ğŸŒ](https://github.com/GerHobbelt/stopwords) -- default English stop words from different sources.
- **ucto** [ğŸ“](./ucto) [ğŸŒ](https://github.com/GerHobbelt/ucto) -- text tokenization
  
  - **libfolia** [ğŸ“](./libfolia) [ğŸŒ](https://github.com/GerHobbelt/libfolia) -- working with the Format for Linguistic Annotation (FoLiA). Provides a high-level API to read, manipulate, and create FoLiA documents.
  - **uctodata** [ğŸ“](./uctodata) [ğŸŒ](https://github.com/GerHobbelt/uctodata) -- data for `ucto` library

- **word2vec** [ğŸ“](./word2vec) [ğŸŒ](https://github.com/GerHobbelt/word2vec) -- Word2Vec in C++ 11.
- **word2vec-GloVe** [ğŸ“](./word2vec-GloVe) [ğŸŒ](https://github.com/GerHobbelt/GloVe) -- an implementation of the GloVe (*Global Vectors for Word Representation*) model for learning word representations.
- **worde_butcher** [ğŸ“](./worde_butcher) [ğŸŒ](https://github.com/GerHobbelt/worde_butcher) -- a tool for text segmentation, keyword extraction and speech tagging. Butchers any text into prime word / phrase cuts, deboning all incoming based on our definitive set of stopwords for all languages.
- **wordfreq** [ğŸ“](./wordfreq) [ğŸŒ](https://github.com/GerHobbelt/wordfreq) -- wordfreq is a Python library for looking up the frequencies of words in many languages, based on many sources of data.
- **wordfrequency** [ğŸ“](./wordfrequency) [ğŸŒ](https://github.com/GerHobbelt/FrequencyWords) -- FrequencyWords: Frequency Word List Generator and processed files.
- **you-token-to-me** [ğŸ“](./you-token-to-me) [ğŸŒ](https://github.com/GerHobbelt/YouTokenToMe) -- text tokenization











### regex matchers (manual edit - pattern recognition)

- **hyperscan** [ğŸ“](./hyperscan) [ğŸŒ](https://github.com/GerHobbelt/hyperscan) -- Hyperscan is a high-performance multiple regex matching library.
- **libgnurx** [ğŸ“](./libgnurx) [ğŸŒ](https://github.com/GerHobbelt/libgnurx) -- the POSIX regex functionality from glibc extracted into a separate library, for Win32.
- **libwildmatch** [ğŸ“](./libwildmatch) [ğŸŒ](https://github.com/GerHobbelt/wildmatch) -- wildmatch is a BSD-licensed C/C++ library for git/rsync-style pattern matching.
- **pcre** [ğŸ“](./pcre) [ğŸŒ](https://github.com/GerHobbelt/pcre) -- PCRE2 : Perl-Compatible Regular Expressions. The PCRE2 library is a set of C functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5. PCRE2 has its own native API, as well as a set of wrapper functions that correspond to the POSIX regular expression API. It comes in three forms, for processing 8-bit, 16-bit, or 32-bit code units, in either literal or UTF encoding.
- **pdfgrep** [ğŸ“](./pdfgrep) [ğŸŒ](https://github.com/GerHobbelt/pdfgrep) -- a tool to search text in PDF files. It works similarly to *grep*.
- **ragel** [ğŸ“](./ragel) [ğŸŒ](https://github.com/GerHobbelt/ragel) -- State Machine Compiler
- **re2** [ğŸ“](./re2) [ğŸŒ](https://github.com/GerHobbelt/re2) -- RE2, a regular expression library.
- **re2c** [ğŸ“](./re2c) [ğŸŒ](https://github.com/GerHobbelt/re2c) -- a lexer generator for C/C++, Go and Rust. Its main goal is generating fast lexers: at least as fast as their reasonably optimized hand-coded counterparts. Instead of using traditional table-driven approach, re2c encodes the generated finite state automata directly in the form of conditional jumps and comparisons. The resulting programs are faster and often smaller than their table-driven analogues, and they are much easier to debug and understand. re2c applies quite a few optimizations in order to speed up and compress the generated code.  Another distinctive feature is its flexible interface: instead of assuming a fixed program template, re2c lets the programmer write most of the interface code and adapt the generated lexer to any particular environment.
- **RE-flex** [ğŸ“](./RE-flex) [ğŸŒ](https://github.com/GerHobbelt/RE-flex) -- the regex-centric, fast lexical analyzer generator for C++ with full Unicode support. Faster than Flex. Accepts Flex specifications. Generates reusable source code that is easy to understand. Introduces indent/dedent anchors, lazy quantifiers, functions for lex/syntax error reporting and more. Seamlessly integrates with Bison and other parsers.
  
  The RE/flex matcher tracks line numbers, column numbers, and indentations, whereas Flex does not (option `noyylineno`) and neither do the other regex matchers (except PCRE2 and Boost.Regex when used with RE/flex).
  Tracking this information incurs some overhead. RE/flex also automatically decodes UTF-8/16/32 input and accepts `std::istream`, strings, and wide strings as input.
  
  RE/flex runs equally fast or slightly faster than the best times of Flex.

- **tre** [ğŸ“](./tre) [ğŸŒ](https://github.com/GerHobbelt/tre) -- TRE is a lightweight, robust, and efficient POSIX compliant regexp matching library with some exciting features such as approximate (fuzzy) matching. The matching algorithm used in TRE uses linear worst-case time in the length of the text being searched, and quadratic worst-case time in the length of the used regular expression.
- **ugrep** [ğŸ“](./ugrep) [ğŸŒ](https://github.com/GerHobbelt/ugrep) -- search for anything in everything... ultra fast. "*`grep` for arbitrary binary files*."
- **yara-pattern-matcher** [ğŸ“](./yara-pattern-matcher) [ğŸŒ](https://github.com/GerHobbelt/yara) -- for automated and user-specified pattern recognition in custom document & metadata *cleaning* / processing tasks











### OCR: quality improvements, language detect, ...

- **Awesome-Document-Image-Rectification** [ğŸ“](./Awesome-Document-Image-Rectification) [ğŸŒ](https://github.com/GerHobbelt/Awesome-Document-Image-Rectification) -- a comprehensive list of awesome document image rectification methods based on deep learning.
- **Awesome-Image-Quality-Assessment** [ğŸ“](./Awesome-Image-Quality-Assessment) [ğŸŒ](https://github.com/GerHobbelt/Awesome-Image-Quality-Assessment) -- a comprehensive collection of IQA papers, datasets and codes. We also provide PyTorch implementations of mainstream metrics in [IQA-PyTorch](https://github.com/chaofengc/IQA-PyTorch)
- **Capture2Text** [ğŸ“](./Capture2Text) [ğŸŒ](https://github.com/GerHobbelt/Capture2Text) -- Linux CLI port of Capture2Text v4.5.1 (Ubuntu) - the OCR results from Capture2Text were generally better than standard Tesseract, so it seemed ideal to make this run on Linux.
- **chewing_text_cud** [ğŸ“](./chewing_text_cud) [ğŸŒ](https://github.com/GerHobbelt/chewing_text_cud) -- a text processing / filtering library for use in NLP/search/content analysis research pipelines.
- **EasyOCR** [ğŸ“](./EasyOCR) [ğŸŒ](https://github.com/GerHobbelt/EasyOCR) -- ready-to-use OCR with 80+ [supported languages](https://www.jaided.ai/easyocr) and all popular writing scripts including: Latin, Chinese, Arabic, Devanagari, Cyrillic, etc.
- **EasyOCR-cpp** [ğŸ“](./EasyOCR-cpp) [ğŸŒ](https://github.com/GerHobbelt/EasyOCR-cpp) -- custom C++ implementation of [EasyOCR](https://github.com/JaidedAI/EasyOCR). This C++ project implements the pre/post processing to run a OCR pipeline consisting of a text detector [CRAFT](https://arxiv.org/abs/1904.01941), and a CRNN based text recognizer. Unlike the EasyOCR python which is API based, this repo provides a set of classes to show how you can integrate OCR in any C++ program for maximum flexibility.
- **fastText** [ğŸ“](./fastText) [ğŸŒ](https://github.com/GerHobbelt/fastText) -- [fastText](https://fasttext.cc/) is a library for efficient learning of word representations and sentence classification. Includes language detection feeatures.
- **fribidi** [ğŸ“](./fribidi) [ğŸŒ](https://github.com/GerHobbelt/fribidi) -- GNU FriBidi: the Free Implementation of the [Unicode Bidirectional Algorithm]. One of the missing links stopping the penetration of free software in Middle East is the lack of support for the Arabic and Hebrew alphabets. In order to have proper Arabic and Hebrew support, the bidi algorithm needs to be implemented. It is our hope that this library will stimulate more free software in the Middle Eastern countries.
- **hunspell** [ğŸ“](./hunspell) [ğŸŒ](https://github.com/GerHobbelt/hunspell) -- a free spell checker and morphological analyzer library and command-line tool, designed for quick and high quality spell checking and correcting for languages with word-level writing system, including languages with rich morphology, complex word compounding and character encoding.
- **hunspell-dictionaries** [ğŸ“](./hunspell-dictionaries) [ğŸŒ](https://github.com/GerHobbelt/dictionaries) -- Collection of normalized and installable [hunspell][] dictionaries.
- **hunspell-hyphen** [ğŸ“](./hunspell-hyphen) [ğŸŒ](https://github.com/GerHobbelt/hyphen) -- hyphenation library to use converted TeX hyphenation patterns with hunspell.
- **IMGUR5K-Handwriting-Dataset** [ğŸ“](./IMGUR5K-Handwriting-Dataset) [ğŸŒ](https://github.com/GerHobbelt/IMGUR5K-Handwriting-Dataset) -- the IMGUR5K Handwriting Dataset for OCR/image preprocessing benchmarks.
- **InversePerspectiveMapping** [ğŸ“](./InversePerspectiveMapping) [ğŸŒ](https://github.com/GerHobbelt/InversePerspectiveMapping) -- C++ class for the computation of plane-to-plane homographies, aka bird's-eye view or IPM, particularly relevant in the field of Advanced Driver Assistance Systems.
- **ipa-dict** [ğŸ“](./ipa-dict) [ğŸŒ](https://github.com/GerHobbelt/ipa-dict) -- Monolingual wordlists with pronunciation information in IPA aims to provide a series of dictionaries consisting of wordlists with accompanying phonemic pronunciation information in International Phonetic Alphabet (IPA) transcription for as many words as possible in as many languages / dialects / variants as possible. The dictionary data is available in a number of human- and machine-readable formats, in order to make it as useful as possible for various other applications.
- **JamSpell** [ğŸ“](./JamSpell) [ğŸŒ](https://github.com/GerHobbelt/JamSpell) -- a spell checking library, which considers words surroundings (context) for better correction (**accuracy**) and is **fast** (near 5K words per second)
- **libpinyin** [ğŸ“](./libpinyin) [ğŸŒ](https://github.com/GerHobbelt/libpinyin) -- the libpinyin project aims to provide the algorithms core for intelligent sentence-based Chinese pinyin input methods.
- **libpostal** [ğŸ“](./libpostal) [ğŸŒ](https://github.com/GerHobbelt/libpostal) -- a C library for parsing/normalizing street addresses around the world using statistical NLP and open data. The goal of this project is to understand location-based strings in every language, everywhere.
- **libtextcat** [ğŸ“](./libtextcat) [ğŸŒ](https://github.com/GerHobbelt/libtextcat) -- text language detection
- **LSWMS** [ğŸ“](./LSWMS) [ğŸŒ](https://github.com/GerHobbelt/LSWMS) -- LSWMS  (Line Segment detection using Weighted Mean-Shift): line segment detection with OpenCV, originally published by Marcos Nieto Doncel.
- **marian** [ğŸ“](./marian) [ğŸŒ](https://github.com/GerHobbelt/marian) -- an efficient Neural Machine Translation framework written in pure C++ with minimal dependencies.
- **nuspell** [ğŸ“](./nuspell) [ğŸŒ](https://github.com/GerHobbelt/nuspell) -- a fast and safe spelling checker software program. It is designed for languages with rich morphology and complex word compounding. Nuspell is written in modern C++ and it supports Hunspell dictionaries.
- **ocreval** [ğŸ“](./ocreval) [ğŸŒ](https://github.com/GerHobbelt/ocreval) -- `ocreval` contains 17 tools for measuring the performance of and experimenting with OCR output. `ocreval` is a modern port of the [ISRI Analytic Tools for OCR Evaluation](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.216.9427&rep=rep1&type=pdf), with UTF-8 support and other improvements.
- **OTB** [ğŸ“](./OTB) [ğŸŒ](https://github.com/GerHobbelt/OTB) -- Orfeo ToolBox (OTB) is an open-source project for state-of-the-art remote sensing. Built on the shoulders of the open-source geospatial community, it can process high resolution optical, multispectral and radar images at the terabyte scale. A wide variety of applications are available: from ortho-rectification or pansharpening, all the way to classification, SAR processing, and much more!
- **pinyin** [ğŸ“](./pinyin) [ğŸŒ](https://github.com/GerHobbelt/pinyin) -- pÄ«nyÄ«n is a tool for converting Chinese characters to *pinyin*. It can be used for Chinese phonetic notation, sorting, and retrieval.
- **retinex** [ğŸ“](./retinex) [ğŸŒ](https://github.com/GerHobbelt/retinex) -- the Retinex algorithm for intrinsic image decomposition. The provided code computes image gradients, and assembles a sparse linear "Ax = b" system. The system is solved using Eigen.
- **scws-chinese-word-segmentation** [ğŸ“](./scws-chinese-word-segmentation) [ğŸŒ](https://github.com/GerHobbelt/scws) -- SCWS (Simple Chinese Word Segmentation) (i.e.: Simple Chinese Word Segmentation System). This is a mechanical Chinese word segmentation engine based on word frequency dictionary, which can basically correctly segment a whole paragraph of Chinese text into words. A word is the smallest morpheme unit in Chinese, but when writing, it does not separate words with spaces like English, so how to segment words accurately and quickly has always been a difficult problem in Chinese word segmentation. SCWS supports Chinese encoding includes `GBK`, `UTF-8`, etc.
  
  There are not many innovative elements in the word segmentation algorithm. It uses a word frequency dictionary collected by itself, supplemented by certain proper names, names of people, and place names. Basic word segmentation is achieved by identifying rules such as digital age. After small-scale testing, the accuracy is between 90% and 95%, which can basically satisfy some use in small search engines, keyword extraction and other occasions. The first prototype version was released in late 2005.

- **SheenBidi** [ğŸ“](./SheenBidi) [ğŸŒ](https://github.com/GerHobbelt/SheenBidi) -- implements Unicode Bidirectional Algorithm available at http://www.unicode.org/reports/tr9. It is a sophisticated implementation which provides the developers an easy way to use UBA in their applications.
- **SymSpell** [ğŸ“](./SymSpell) [ğŸŒ](https://github.com/GerHobbelt/SymSpell) -- spelling correction & fuzzy search: **1 million times faster** through Symmetric Delete spelling correction algorithm. The Symmetric Delete spelling correction algorithm reduces the complexity of edit candidate generation and dictionary lookup for a given Damerau-Levenshtein distance. It is six orders of magnitude faster ([than the standard approach with deletes + transposes + replaces + inserts](http://norvig.com/spell-correct.html)) and language independent.
- **SymspellCPP** [ğŸ“](./SymspellCPP) [ğŸŒ](https://github.com/GerHobbelt/SymspellCPP) -- a C++ port from https://github.com/wolfgarbe/SymSpell v6.5
- **tesslinesplit** [ğŸ“](./tesslinesplit) [ğŸŒ](https://github.com/GerHobbelt/tesslinesplit) -- a standalone program for using Tesseract's line segmentation algorithm to split up document images.
- **unpaper** [ğŸ“](./unpaper) [ğŸŒ](https://github.com/GerHobbelt/unpaper) -- a post-processing tool for scanned sheets of paper, especially for book pages that have been scanned from previously created photocopies.  The main purpose is to make scanned book pages better readable on screen after conversion to PDF. The program also tries to detect misaligned centering and rotation of ages and will automatically straighten each page by rotating it to the correct angle (a.k.a. deskewing).











### OCR page image preprocessing, \[scanner] tooling: getting the pages to the OCR engine

- **Awesome-Document-Image-Rectification** [ğŸ“](./Awesome-Document-Image-Rectification) [ğŸŒ](https://github.com/GerHobbelt/Awesome-Document-Image-Rectification) -- a comprehensive list of awesome document image rectification methods based on deep learning.
- **Awesome-Image-Quality-Assessment** [ğŸ“](./Awesome-Image-Quality-Assessment) [ğŸŒ](https://github.com/GerHobbelt/Awesome-Image-Quality-Assessment) -- a comprehensive collection of IQA papers, datasets and codes. We also provide PyTorch implementations of mainstream metrics in [IQA-PyTorch](https://github.com/chaofengc/IQA-PyTorch)
- **butteraugli** [ğŸ“](./butteraugli) [ğŸŒ](https://github.com/GerHobbelt/butteraugli) -- a tool for measuring perceived differences between images. Butteraugli is a project that estimates the psychovisual similarity of two images. It gives a score for the images that is reliable in the domain of barely noticeable differences. Butteraugli not only gives a scalar score, but also computes a spatial map of the level of differences. One of the main motivations for this project is the statistical differences in location and density of different color receptors, particularly the low density of blue cones in the fovea. Another motivation comes from more accurate modeling of ganglion cells, particularly the frequency space inhibition.
- **Capture2Text** [ğŸ“](./Capture2Text) [ğŸŒ](https://github.com/GerHobbelt/Capture2Text) -- Linux CLI port of Capture2Text v4.5.1 (Ubuntu) - the OCR results from Capture2Text were generally better than standard Tesseract, so it seemed ideal to make this run on Linux.
- **ccv-nnc** [ğŸ“](./ccv-nnc) [ğŸŒ](https://github.com/GerHobbelt/ccv) -- C-based/Cached/Core Computer Vision Library. A Modern Computer Vision Library.
- **CImg** [ğŸ“](./CImg) [ğŸŒ](https://github.com/GerHobbelt/CImg) -- a **small** C++ toolkit for **image processing**.
- **colorm** [ğŸ“](./colorm) [ğŸŒ](https://github.com/GerHobbelt/colorm) -- ColorM is a C++11 header-only color conversion and manipulation library for [CSS colors](https://www.w3.org/TR/css-color-4/) with an API similar to [chroma.js](https://github.com/gka/chroma.js/)'s API.
- **ColorSpace** [ğŸ“](./ColorSpace) [ğŸŒ](https://github.com/GerHobbelt/ColorSpace) -- library for converting between color spaces and comparing colors.
- **color-util** [ğŸ“](./color-util) [ğŸŒ](https://github.com/GerHobbelt/color-util) -- a header-only C++11 library for handling colors, including color space converters between RGB, XYZ, Lab, etc. and color difference calculators such as CIEDE2000.
- **DocLayNet** [ğŸ“](./DocLayNet) [ğŸŒ](https://github.com/GerHobbelt/DocLayNet) -- DocLayNet provides page-by-page layout segmentation ground-truth using bounding-boxes for 11 distinct class labels on 80863 unique pages from 6 document categories. It provides several unique features compared to related work such as PubLayNet or DocBank, e.g. *Human Annotation*: DocLayNet is hand-annotated by well-trained experts, providing a gold-standard in layout segmentation through human recognition and interpretation of each page layout.
- **doxa** [ğŸ“](./doxa) [ğŸŒ](https://github.com/GerHobbelt/Doxa) -- Î”oxa Binarization Framework (Î”BF) is an image binarization framework which focuses primarily on local adaptive thresholding algorithms, aimed at providing the building blocks one might use to advance the state of handwritten manuscript binarization.
  
  Supported Algorithms:
  
  * Otsu - "A threshold selection method from gray-level histograms", 1979.
  * Bernsen - "Dynamic thresholding of gray-level images", 1986.
  * Niblack - "An Introduction to Digital Image Processing", 1986.
  * Sauvola - "Adaptive document image binarization", 1999.
  * Wolf - "Extraction and Recognition of Artificial Text in Multimedia Documents", 2003.
  * Gatos - "Adaptive degraded document image binarization", 2005. (Partial)
  * NICK - "Comparison of Niblack inspired Binarization methods for ancient documents", 2009.
  * Su - "Binarization of Historical Document Images Using the Local Maximum and Minimum", 2010.
  * T.R. Singh - "A New local Adaptive Thresholding Technique in Binarization", 2011.
  * Bataineh - "An adaptive local binarization method for document images based on a novel thresholding method and dynamic windows", 2011. (unreproducible)
  * ISauvola - "ISauvola: Improved Sauvolaâ€™s Algorithm for Document Image Binarization", 2016.
  * WAN - "Binarization of Document Image Using Optimum Threshold Modification", 2018.
  
  Optimizations:
  
  * Shafait - "Efficient Implementation of Local Adaptive Thresholding Techniques Using Integral Images", 2008.
  * Petty - An algorithm for efficiently calculating the min and max of a local window.  Unpublished, 2019.
  * Chan - "Memory-efficient and fast implementation of local adaptive binarization methods", 2019.
  
  Performance Metrics:
  
  * Overall Accuracy
  * F-Measure
  * Peak Signal-To-Noise Ratio (PSNR)
  * Negative Rate Metric (NRM)
  * Matthews Correlation Coefficient (MCC)
  * Distance-Reciprocal Distortion Measure (DRDM) - "An Objective Distortion Measure for Binary Document Images Based on Human Visual Perception", 2002.
  
  Native Image Support:
  
  * Portable Any-Map: PBM (P4), 8-bit PGM (P5), PPM (P6), PAM (P7)

- **EasyOCR** [ğŸ“](./EasyOCR) [ğŸŒ](https://github.com/GerHobbelt/EasyOCR) -- ready-to-use OCR with 80+ [supported languages](https://www.jaided.ai/easyocr) and all popular writing scripts including: Latin, Chinese, Arabic, Devanagari, Cyrillic, etc.
- **EasyOCR-cpp** [ğŸ“](./EasyOCR-cpp) [ğŸŒ](https://github.com/GerHobbelt/EasyOCR-cpp) -- custom C++ implementation of [EasyOCR](https://github.com/JaidedAI/EasyOCR). This C++ project implements the pre/post processing to run a OCR pipeline consisting of a text detector [CRAFT](https://arxiv.org/abs/1904.01941), and a CRNN based text recognizer. Unlike the EasyOCR python which is API based, this repo provides a set of classes to show how you can integrate OCR in any C++ program for maximum flexibility.
- **farver-OKlab** [ğŸ“](./farver-OKlab) [ğŸŒ](https://github.com/GerHobbelt/farver) -- provides very fast, vectorised functions for conversion of colours between different colour spaces, colour comparisons (distance between colours), encoding/decoding, and channel manipulation in colour strings.
- **fCWT** [ğŸ“](./fCWT) [ğŸŒ](https://github.com/GerHobbelt/fCWT) -- the fast Continuous Wavelet Transform (fCWT) is a highly optimized C++ library for very fast calculation of the CWT in C++, Matlab, and Python. **fCWT has been featured on the January 2022 cover of NATURE Computational Science**. In this article, fCWT is compared against eight competitor algorithms, tested on noise resistance and validated on synthetic electroencephalography and in vivo extracellular local field potential data.
- **FFmpeg** [ğŸ“](./FFmpeg) [ğŸŒ](https://github.com/GerHobbelt/FFmpeg) -- a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata.
- **gegl** [ğŸ“](./gegl) [ğŸŒ](https://github.com/GerHobbelt/gegl) -- *GEGL* (Generic Graphics Library) is a data flow based image processing framework, providing floating point processing and non-destructive image processing capabilities to [GNU Image Manipulation Program](http://www.gimp.org/) and other projects. With GEGL you chain together processing operations to represent the desired image processing pipeline. GEGL provides operations for image loading and storing, color adjustments, GIMPs artistic filters and more forms of image processing GEGL can be used on the command-line with the same syntax that can be used for creating processing flows interactively with text from GIMP using gegl-graph.
- **gmic** [ğŸ“](./gmic) [ğŸŒ](https://github.com/GerHobbelt/gmic) -- a Full-Featured Open-Source Framework for Image Processing. It provides several different **[user interfaces](https://en.wikipedia.org/wiki/User_interface)** to convert/manipulate/filter/visualize **generic image datasets**, ranging from _1d scalar signals_ to _3d+t sequences of multi-spectral volumetric images_, hence including _2d color images_.
- **gmic-community** [ğŸ“](./gmic-community) [ğŸŒ](https://github.com/GerHobbelt/gmic-community) -- community contributions for the GMIC Full-Featured Open-Source Framework for Image Processing. It provides several different **[user interfaces](https://en.wikipedia.org/wiki/User_interface)** to convert/manipulate/filter/visualize **generic image datasets**, ranging from _1d scalar signals_ to _3d+t sequences of multi-spectral volumetric images_, hence including _2d color images_.
- **graph-coloring** [ğŸ“](./graph-coloring) [ğŸŒ](https://github.com/GerHobbelt/graph-coloring) -- a C++ Graph Coloring Package. This project has two primary uses:
  
  * As an executable for finding the chromatic number for an input graph (in edge list or edge matrix format)
  * As a library for finding the particular coloring of an input graph (represented as a `map<string,vector<string>>` edge list)

- **GraphicsMagick** [ğŸ“](./GraphicsMagick) [ğŸŒ](https://github.com/GerHobbelt/graphicsmagick) -- provides a comprehensive collection of utilities, programming interfaces, and GUIs, to support file format conversion, image processing, and 2D vector rendering. GraphicsMagick is originally based on ImageMagick from ImageMagick Studio (which was originally written by John Cristy at Dupont). The goal of GraphicsMagick is to provide the highest quality product possible while encouraging open and active participation from all interested developers.
- **gtsam** [ğŸ“](./gtsam) [ğŸŒ](https://github.com/GerHobbelt/gtsam) -- Georgia Tech Smoothing and Mapping Library (GTSAM) is a C++ library that implements smoothing and mapping (SAM) in robotics and vision, using Factor Graphs and Bayes Networks as the underlying computing paradigm rather than sparse matrices.
- **guetzli** [ğŸ“](./guetzli) [ğŸŒ](https://github.com/GerHobbelt/guetzli) -- a JPEG encoder that aims for excellent compression density at high visual quality. Guetzli-generated images are typically 20-30% smaller than images of equivalent quality generated by libjpeg. Guetzli generates only sequential (nonprogressive) JPEGs due to faster decompression speeds they offer.
- **hsluv-c** [ğŸ“](./hsluv-c) [ğŸŒ](https://github.com/GerHobbelt/hsluv-c) -- HSLuv (revision 4) is a human-friendly alternative to HSL. HSLuv is very similar to CIELUV, a color space designed for perceptual uniformity based on human experiments. When accessed by polar coordinates, it becomes functionally similar to HSL with a single problem: its chroma component doesn't fit into a specific range. HSLuv extends CIELUV with a new saturation component that allows you to span all the available chroma as a neat percentage.
- **ImageMagick** [ğŸ“](./ImageMagick) [ğŸŒ](https://github.com/GerHobbelt/ImageMagick) -- [ImageMagickÂ®](https://imagemagick.org/) can create, edit, compose, or convert digital images. It can read and write images in a variety of formats (over 200) including PNG, JPEG, GIF, WebP, HEIC, SVG, PDF, DPX, EXR, and TIFF. ImageMagick can resize, flip, mirror, rotate, distort, shear and transform images, adjust image colors, apply various special effects, or draw text, lines, polygons, ellipses, and BÃ©zier curves.
- **IMGUR5K-Handwriting-Dataset** [ğŸ“](./IMGUR5K-Handwriting-Dataset) [ğŸŒ](https://github.com/GerHobbelt/IMGUR5K-Handwriting-Dataset) -- the IMGUR5K Handwriting Dataset for OCR/image preprocessing benchmarks.
- **InversePerspectiveMapping** [ğŸ“](./InversePerspectiveMapping) [ğŸŒ](https://github.com/GerHobbelt/InversePerspectiveMapping) -- C++ class for the computation of plane-to-plane homographies, aka bird's-eye view or IPM, particularly relevant in the field of Advanced Driver Assistance Systems.
- **ITK** [ğŸ“](./ITK) [ğŸŒ](https://github.com/GerHobbelt/ITK) -- The Insight Toolkit (ITK) is an open-source, cross-platform toolkit for N-dimensional scientific image processing, segmentation, and registration. Segmentation is the process of identifying and classifying data found in a digitally sampled representation. Typically the sampled representation is an image acquired from such medical instrumentation as CT or MRI scanners. Registration is the task of aligning or developing correspondences between data. For example, in the medical environment, a CT scan may be aligned with a MRI scan in order to combine the information contained in both.
- **jasper** [ğŸ“](./jasper) [ğŸŒ](https://github.com/GerHobbelt/jasper) -- JasPer Image Processing/Coding Tool Kit
- **jpeg2dct** [ğŸ“](./jpeg2dct) [ğŸŒ](https://github.com/GerHobbelt/jpeg2dct) -- Faster Neural Networks Straight from JPEG: jpeg2dct subroutines -- this module is useful for reproducing results presented in the paper [Faster Neural Networks Straight from JPEG](https://openreview.net/forum?id=S1ry6Y1vG) (ICLR workshop 2018).
- **lcms2** [ğŸ“](../../thirdparty/lcms2) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-lcms2) -- `lcms2mt` is a thread-safe fork of `lcms` (a.k.a. Little CMS). Little CMS intends to be a small-footprint color management engine, with special focus on accuracy and performance. It uses the International Color Consortium standard (ICC), which is the modern standard when regarding to color management. The ICC specification is widely used and is referred to in many International and other de-facto standards. It was approved as an International Standard, ISO 15076-1, in 2005. Little CMS is a **full implementation** of ICC specification 4.3, it fully supports all kind of V2 and V4 profiles, including abstract, devicelink and named color profiles.
- **leptonica** [ğŸ“](../../thirdparty/leptonica) [ğŸŒ](https://github.com/GerHobbelt/leptonica) -- supports many operations that are useful on images.
  
  Features:
  
  * Rasterop (aka bitblt)
  * Affine transforms (scaling, translation, rotation, shear) on images of arbitrary pixel depth
  * Projective and bilinear transforms
  * Binary and grayscale morphology, rank order filters, and convolution
  * Seedfill and connected components
  * Image transformations with changes in pixel depth, both at the same scale and with scale change
  * Pixelwise masking, blending, enhancement, arithmetic ops, etc.
  
  Documentation:
  
  - **LeptonicaDocsSite** [ğŸ“](./LeptonicaDocsSite) [ğŸŒ](https://github.com/GerHobbelt/LeptonicaDocsSite) -- unofficial Reference Documentation for the Leptonica image processing library ([www.leptonica.org](http://www.leptonica.org)).
  - **UnofficialLeptDocs** [ğŸ“](./UnofficialLeptDocs) [ğŸŒ](https://github.com/GerHobbelt/UnofficialLeptDocs) -- unofficial Sphinx-generated documentation for the Leptonica image processing library.

- **libchiaroscuramente** [ğŸ“](./libchiaroscuramente) [ğŸŒ](https://github.com/GerHobbelt/libchiaroscuramente) -- a collection of C/C++ functions (components) to help improving / enhancing your images for various purposes (e.g. helping an OCR engine detect and recognize the text in the page scan image)
- **libdip** [ğŸ“](./libdip) [ğŸŒ](https://github.com/GerHobbelt/diplib) -- **[*DIPlib*](https://diplib.org/diplib-docs/)** is a C++ library for quantitative image analysis.
- **libimagequant** [ğŸ“](./libimagequant) [ğŸŒ](https://github.com/GerHobbelt/libimagequant) -- Palette quantization library that powers `pngquant` and other PNG optimizers. `libimagequant` converts RGBA images to palette-based 8-bit indexed images, including alpha component. It's ideal for generating tiny PNG images and nice-looking GIFs. Image encoding/decoding isn't handled by the library itself, bring your own encoder.
- **libinsane** [ğŸ“](./libinsane) [ğŸŒ](https://github.com/GerHobbelt/libinsane) -- *the* library to access scanners on both Linux and Windows.
- **libjpegqs** [ğŸ“](./libjpegqs) [ğŸŒ](https://github.com/GerHobbelt/libjpegqs) -- JPEG Quant Smooth tries to recreate lost precision of DCT coefficients based on quantization table from jpeg image. You may not notice jpeg artifacts on the screen without zooming in, but you may notice them after printing. Also, when editing compressed images, artifacts can accumulate, but if you use this program before editing - the result will be better.
- **libpano13** [ğŸ“](./libpano13) [ğŸŒ](https://github.com/GerHobbelt/libpano13) -- the pano13 library, part of the Panorama Tools by Helmut Dersch of the University of Applied Sciences Furtwangen.
- **libpillowfight** [ğŸ“](./libpillowfight) [ğŸŒ](https://github.com/GerHobbelt/libpillowfight) -- simple C Library containing various image processing algorithms. 
  
  Available algorithms:
  
  - ACE (Automatic Color Equalization; Parallelized implementation)
  - Canny edge detection
  - Compare: Compare two images (grayscale) and makes the pixels that are different really visible (red).
  - Gaussian blur
  - Scan borders: Tries to detect the borders of a page in an image coming from a scanner.
  - Sobel operator
  - SWT (Stroke Width Transformation)
  - [Unpaper](https://github.com/Flameeyes/unpaper)'s algorithms
    
    - Blackfilter
    - Blurfilter
    - Border
    - Grayfilter
    - Masks
    - Noisefilter

- **libprecog** [ğŸ“](./libprecog) [ğŸŒ](https://github.com/GerHobbelt/PRLib) -- PRLib - Pre-Recognition Library. The main aim of the library is to prepare images for OCR (text recogntion). Image processing can really help to improve recognition quality.
- **libprecog-data** [ğŸ“](./libprecog-data) [ğŸŒ](https://github.com/GerHobbelt/libprecog-data) -- `PRLib` (a.k.a. `libprecog`) test data.
- **libprecog-manuals** [ğŸ“](./libprecog-manuals) [ğŸŒ](https://github.com/GerHobbelt/libprecog-manuals) -- `PRLib` (a.k.a. `libprecog`) related papers.
- **libraqm** [ğŸ“](./libraqm) [ğŸŒ](https://github.com/GerHobbelt/libraqm) -- a small library that encapsulates the logic for complex text layout and provides a convenient API.
- **libvips** [ğŸ“](./libvips) [ğŸŒ](https://github.com/GerHobbelt/libvips) -- a demand-driven, horizontally threaded image processing library which has around 300 operations covering arithmetic, histograms, convolution, morphological operations, frequency filtering, colour, resampling, statistics and others. It supports a large range of numeric types, from 8-bit int to 128-bit complex. Images can have any number of bands. It supports a good range of image formats, including JPEG, JPEG2000, JPEG-XL, TIFF, PNG, WebP, HEIC, AVIF, FITS, Matlab, OpenEXR, PDF, SVG, HDR, PPM / PGM / PFM, CSV, GIF, Analyze, NIfTI, DeepZoom, and OpenSlide. It can also load images via ImageMagick or GraphicsMagick, letting it work with formats like DICOM.
- **libxbr-standalone** [ğŸ“](./libxbr-standalone) [ğŸŒ](https://github.com/GerHobbelt/libxbr-standalone) -- this standalone XBR/hqx Library implements the xBR pixel art scaling filter developed by Hyllian, and now also the hqx filter developed by Maxim Stepin. Original source for the xBR implementation: http://git.videolan.org/gitweb.cgi/ffmpeg.git/?p=ffmpeg.git;a=blob;f=libavfilter/vf_xbr.c;h=5c14565b3a03f66f1e0296623dc91373aeac1ed0;hb=HEAD
- **local_adaptive_binarization** [ğŸ“](./local_adaptive_binarization) [ğŸŒ](https://github.com/GerHobbelt/local_adaptive_binarization) -- uses an improved contrast maximization version of Niblack/Sauvola et al's method to binarize document images. It is also able to perform the more classical Niblack as well as Sauvola et al. methods. Details can be found in the [ICPR 2002 paper](file:///Users/chris/www/prof/publications/index.html#icpr2002v).
- **LSWMS** [ğŸ“](./LSWMS) [ğŸŒ](https://github.com/GerHobbelt/LSWMS) -- LSWMS  (Line Segment detection using Weighted Mean-Shift): line segment detection with OpenCV, originally published by Marcos Nieto Doncel.
- **magsac** [ğŸ“](./magsac) [ğŸŒ](https://github.com/GerHobbelt/magsac) -- (MAGSAC++ had been included in OpenCV) the MAGSAC and MAGSAC++ algorithms for robust model fitting without using a single inlier-outlier threshold.
- **oidn-OpenImageDenoise** [ğŸ“](./oidn-OpenImageDenoise) [ğŸŒ](https://github.com/GerHobbelt/oidn) -- IntelÂ® Open Image Denoise is an open source library of high-performance, high-quality denoising filters for images rendered with ray tracing.
- **olena** [ğŸ“](./olena) [ğŸŒ](https://github.com/GerHobbelt/olena) -- a platform dedicated to image processing.  At the moment it is mainly composed of a C++ library: Milena.  This library features many tools to easily perform image processing tasks.  Its main characteristic is its genericity: it allows to write an algorithm once and run it over many kinds of images (gray scale, color, 1D, 2D, 3D, ...).
- **OpenColorIO** [ğŸ“](./OpenColorIO) [ğŸŒ](https://github.com/GerHobbelt/OpenColorIO) -- OpenColorIO (OCIO) is a complete color management solution geared towards motion picture production with an emphasis on visual effects and computer animation. OCIO provides a straightforward and consistent user experience across all supporting applications while allowing for sophisticated back-end configuration options suitable for high-end production usage. OCIO is compatible with the Academy Color Encoding Specification (ACES) and is LUT-format agnostic, supporting many popular formats.
- **OpenCP** [ğŸ“](./OpenCP) [ğŸŒ](https://github.com/GerHobbelt/OpenCP) -- a library for computational photography.
- **opencv** [ğŸ“](./opencv) [ğŸŒ](https://github.com/GerHobbelt/opencv) -- OpenCV: Open Source Computer Vision Library
- **opencv_contrib** [ğŸ“](./opencv_contrib) [ğŸŒ](https://github.com/GerHobbelt/opencv_contrib) -- OpenCV's extra modules. This is where you'll find new, bleeding edge OpenCV module development.
- **opencv_extra** [ğŸ“](./opencv_extra) [ğŸŒ](https://github.com/GerHobbelt/opencv_extra) -- extra data for OpenCV: Open Source Computer Vision Library
- **OTB** [ğŸ“](./OTB) [ğŸŒ](https://github.com/GerHobbelt/OTB) -- Orfeo ToolBox (OTB) is an open-source project for state-of-the-art remote sensing. Built on the shoulders of the open-source geospatial community, it can process high resolution optical, multispectral and radar images at the terabyte scale. A wide variety of applications are available: from ortho-rectification or pansharpening, all the way to classification, SAR processing, and much more!
- **pdiff** [ğŸ“](./pdiff) [ğŸŒ](https://github.com/GerHobbelt/pdiff) -- perceptualdiff (pdiff): a program that compares two images using a perceptually based image metric.
- **Pillow** [ğŸ“](./Pillow) [ğŸŒ](https://github.com/GerHobbelt/Pillow) -- the friendly PIL (Python Imaging Library) fork by [Jeffrey A. Clark (Alex) and contributors](https://github.com/python-pillow/Pillow/graphs/contributors). PIL is the Python Imaging Library by Fredrik Lundh and Contributors. This library provides extensive file format support, an efficient internal representation, and fairly powerful image processing capabilities.
- **pillow-resize** [ğŸ“](./pillow-resize) [ğŸŒ](https://github.com/GerHobbelt/pillow-resize) -- a C++ porting of the resize method from the [Pillow](https://github.com/python-pillow/Pillow) python library. It is written in C++ using [OpenCV](https://opencv.org/) for matrix support. The main difference with respect to the [`resize`](https://docs.opencv.org/4.5.2/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d) method of OpenCV is the use of an anti aliasing filter, that is missing in OpenCV and could introduce some artifacts, in particular with strong down-sampling.
- **pixman** [ğŸ“](./pixman) [ğŸŒ](https://github.com/GerHobbelt/pixman) -- a library that provides low-level pixel manipulation features such as image compositing and trapezoid rasterization.
- **poisson_blend** [ğŸ“](./poisson_blend) [ğŸŒ](https://github.com/GerHobbelt/poisson_blend) -- a simple, readable implementation of Poisson Blending, that demonstrates the concepts explained in [my article](https://erkaman.github.io/posts/poisson_blending.html), seamlessly blending a source image and a target image, at some specified pixel location.
- **pylene** [ğŸ“](./pylene) [ğŸŒ](https://github.com/GerHobbelt/pylene) -- Pylene is a fork of [Olena/Milena](http://www.lrde.epita.fr/olena), an image processing library targeting genericity and efficiency. It provided mostly Mathematical Morphology building blocs for image processing pipelines.
- **radon-tf** [ğŸ“](./radon-tf) [ğŸŒ](https://github.com/GerHobbelt/radon-tf) -- simple implementation of the radon transform. Faster when using more than one thread to execute it. No inverse function is provided. CPU implementation only.
- **RandomizedRedundantDCTDenoising** [ğŸ“](./RandomizedRedundantDCTDenoising) [ğŸŒ](https://github.com/GerHobbelt/RandomizedRedundantDCTDenoising) -- demonstrates the paper S. Fujita, N. Fukushima, M. Kimura, and Y. Ishibashi, "Randomized redundant DCT: Efficient denoising by using random subsampling of DCT patches," Proc. Siggraph Asia, Technical Brief, Nov. 2015. In this paper, the DCT-based denoising is accelerated by using a randomized algorithm. The DCT is based on the fastest algorithm and is SIMD vectorized by using SSE. Some modifications improve denoising performance in term of PSNR. The code is 100x faster than the OpenCV's implementation (cv::xphoto::dctDenoising) for the paper. Optionally, we can use DHT (discrete Walshâ€“Hadamard transform) for fast computation instead of using DCT.
- **retinex** [ğŸ“](./retinex) [ğŸŒ](https://github.com/GerHobbelt/retinex) -- the Retinex algorithm for intrinsic image decomposition. The provided code computes image gradients, and assembles a sparse linear "Ax = b" system. The system is solved using Eigen.
- **rotate** [ğŸ“](./rotate) [ğŸŒ](https://github.com/GerHobbelt/rotate) -- provides several classic, commonly used and novel rotation algorithms (aka block swaps), which were documented since around 1981 up to 2021: three novel rotation algorithms were introduced in 2021, notably the [trinity rotation](https://github.com/scandum/rotate#Trinity-Rotation).
- **rotate_detection** [ğŸ“](./rotate_detection) [ğŸŒ](https://github.com/GerHobbelt/rotate_detection) -- angle rotation detection on scanned documents. Designed for embedding in systems using tesseract OCR. The detection algorithm based on [RÃ©nyi entropy](https://en.wikipedia.org/wiki/R%C3%A9nyi_entropy).
- **scantailor** [ğŸ“](./scantailor) [ğŸŒ](https://github.com/GerHobbelt/scantailor-advanced) -- [scantailor_advanced](https://github.com/4lex4/scantailor-advanced) is the [ScanTailor](https://github.com/scantailor/scantailor) version that merges the features of the *ScanTailor Featured* and *ScanTailor Enhanced* versions, brings new ones and fixes. ScanTailor is an interactive post-processing tool for scanned pages. It performs operations such as page splitting, deskewing, adding/removing borders, selecting content, ... and many others.
- **scilab** [ğŸ“](./scilab) [ğŸŒ](https://github.com/GerHobbelt/scilab) -- Scilab includes hundreds of mathematical functions. It has a high-level programming language allowing access to advanced data structures, 2-D and 3-D graphical functions.
- **simd-imgproc** [ğŸ“](./simd-imgproc) [ğŸŒ](https://github.com/GerHobbelt/Simd) -- the Simd Library is an image processing and machine learning library designed for C and C++ programmers. It provides many useful high performance algorithms for image processing such as: pixel format conversion, image scaling and filtration, extraction of statistic information from images, motion detection, object detection (HAAR and LBP classifier cascades) and classification, neural network.
  
  The algorithms are optimized, using different SIMD CPU extensions where available. The library supports following CPU extensions: SSE, AVX, AVX-512 and AMX for x86/x64, VMX(Altivec) and VSX(Power7) for PowerPC (big-endian), NEON for ARM.

- **tesslinesplit** [ğŸ“](./tesslinesplit) [ğŸŒ](https://github.com/GerHobbelt/tesslinesplit) -- a standalone program for using Tesseract's line segmentation algorithm to split up document images.
- **twain_library** [ğŸ“](./twain_library) [ğŸŒ](https://github.com/GerHobbelt/twain_library) -- the DTWAIN Library, **Version 5.x**, from Dynarithmic Software.  DTWAIN is an open source programmer's library that will allow applications to acquire images from TWAIN-enabled devices using a simple Application Programmer's Interface (API).
- **unblending** [ğŸ“](./unblending) [ğŸŒ](https://github.com/GerHobbelt/unblending) -- a C++ library for decomposing a target image into a set of semi-transparent layers associated with *advanced color-blend modes* (e.g., "multiply" and "color-dodge"). Output layers can be imported to Adobe Photoshop, Adobe After Effects, GIMP, Krita, etc. and are useful for performing complex edits that are otherwise difficult.
- **unpaper** [ğŸ“](./unpaper) [ğŸŒ](https://github.com/GerHobbelt/unpaper) -- a post-processing tool for scanned sheets of paper, especially for book pages that have been scanned from previously created photocopies.  The main purpose is to make scanned book pages better readable on screen after conversion to PDF. The program also tries to detect misaligned centering and rotation of ages and will automatically straighten each page by rotating it to the correct angle (a.k.a. deskewing).
- **VQMT** [ğŸ“](./VQMT) [ğŸŒ](https://github.com/GerHobbelt/VQMT) -- VQMT (Video Quality Measurement Tool) provides fast implementations of the following objective metrics:
  
  - **MS-SSIM**: Multi-Scale Structural Similarity,
  - **PSNR**: Peak Signal-to-Noise Ratio,
  - **PSNR-HVS**: Peak Signal-to-Noise Ratio taking into account Contrast Sensitivity Function (CSF),
  - **PSNR-HVS-M**: Peak Signal-to-Noise Ratio taking into account Contrast Sensitivity Function (CSF) and between-coefficient contrast masking of DCT basis functions.
  - **SSIM**: Structural Similarity,
  - **VIFp**: Visual Information Fidelity, pixel domain version
  
  The above metrics are implemented in C++ with the help of OpenCV and are based on the original Matlab implementations provided by their developers.

- **wavelib** [ğŸ“](./wavelib) [ğŸŒ](https://github.com/GerHobbelt/wavelib) -- C implementation of Discrete Wavelet Transform (DWT,SWT and MODWT), Continuous Wavelet transform (CWT) and Discrete Packet Transform ( Full Tree Decomposition and Best Basis DWPT).
- **wdenoise** [ğŸ“](./wdenoise) [ğŸŒ](https://github.com/GerHobbelt/wdenoise) -- Wavelet Denoising in ANSI C using empirical bayes thresholding and a host of other thresholding methods.
- **xbrzscale** [ğŸ“](./xbrzscale) [ğŸŒ](https://github.com/GerHobbelt/xbrzscale) -- xBRZ upscaling commandline tool. This tool allows you to scale your graphics with xBRZ algorithm, see https://en.wikipedia.org/wiki/Pixel-art_scaling_algorithms#xBR_family











### image export, image / \[scanned] document import

- **brunsli** [ğŸ“](./brunsli) [ğŸŒ](https://github.com/GerHobbelt/brunsli) -- a lossless JPEG repacking library. Brunsli allows for a 22% decrease in file size while allowing the original JPEG to be recovered byte-by-byte.
- **CImg** [ğŸ“](./CImg) [ğŸŒ](https://github.com/GerHobbelt/CImg) -- a **small** C++ toolkit for **image processing**.
- **CxImage** [ğŸ“](./CxImage) [ğŸŒ](https://github.com/GerHobbelt/CxImage) -- venerated library for reading and creating many image file formats.
- **FFmpeg** [ğŸ“](./FFmpeg) [ğŸŒ](https://github.com/GerHobbelt/FFmpeg) -- a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata.
- **fpng** [ğŸ“](./fpng) [ğŸŒ](https://github.com/GerHobbelt/fpng) -- a very fast C++ .PNG image reader/writer for 24/32bpp images. fpng was written to see just how fast you can write .PNG's without sacrificing too much compression. The files written by fpng conform to the [PNG standard](https://www.w3.org/TR/PNG/), are readable using any PNG decoder, and load or validate successfully using libpng, wuffs, lodepng, stb_image, and [pngcheck](http://www.libpng.org/pub/png/apps/pngcheck.html). PNG files written using fpng can also be read using fpng faster than other PNG libraries, due to its explicit use of [Length-Limited Prefix Codes](https://create.stephan-brumme.com/length-limited-prefix-codes/) and an [optimized decoder](https://fastcompression.blogspot.com/2015/10/huffman-revisited-part-4-multi-bytes.html) that exploits the properties of these codes.
- **giflib-turbo** [ğŸ“](./giflib-turbo) [ğŸŒ](https://github.com/GerHobbelt/giflib-turbo) -- GIFLIB-Turbo is a faster drop-in replacement for GIFLIB. The original GIF codecs were written for a much different world and took great pains to use as little memory as possible and to accommodate a slow and unreliable input stream of data. Those constraints are no longer a problem for the vast majority of users and they were hurting the performance. Another feature holding back the performance of the original GIFLIB was that the original codec was designed to work with image data a line at a time and used a separate LZW dictionary to manage the strings of repeating symbols. My codec uses the output image as the dictionary; this allows much faster 'unwinding' of the codes since they are all stored in the right direction to just be copied to the new location.
- **grok-jpeg2000** [ğŸ“](./grok-jpeg2000) [ğŸŒ](https://github.com/GerHobbelt/grok) -- World's Leading Open Source JPEG 2000 Codec
  
  Features:
  
  * support for new **High Throughput JPEG 2000 (HTJ2K)** standard
  * fast random-access sub-image decoding using `TLM` and `PLT` markers
  * full encode/decode support for `ICC` colour profiles
  * full encode/decode support for `XML`,`IPTC`, `XMP` and `EXIF` meta-data
  * full encode/decode support for `monochrome`, `sRGB`, `palette`, `YCC`, `extended YCC`, `CIELab` and `CMYK` colour spaces
  * full encode/decode support for `JPEG`,`PNG`,`BMP`,`TIFF`,`RAW`,`PNM` and `PAM` image formats
  * full encode/decode support for 1-16 bit precision images

- **guetzli** [ğŸ“](./guetzli) [ğŸŒ](https://github.com/GerHobbelt/guetzli) -- a JPEG encoder that aims for excellent compression density at high visual quality. Guetzli-generated images are typically 20-30% smaller than images of equivalent quality generated by libjpeg. Guetzli generates only sequential (nonprogressive) JPEGs due to faster decompression speeds they offer.
- **icer_compression** [ğŸ“](./icer_compression) [ğŸŒ](https://github.com/GerHobbelt/icer_compression) -- implements the NASA ICER image compression algorithm as a C library. Said compression algorithm is a progressive, wavelet-based image compression algorithm designed to be resistant to data loss, making it suitable for use as the image compression algorithm when encoding images to be transmitted over unreliable delivery channels, such as those in satellite radio communications.
- **jbig2dec** [ğŸ“](../../thirdparty/jbig2dec) [ğŸŒ](https://github.com/GerHobbelt/jbig2dec) -- a decoder library and example utility implementing the JBIG2 bi-level image compression spec. Also known as ITU T.88 and ISO IEC 14492, and included by reference in Adobe's PDF version 1.4 and later.
- **jbig2enc** [ğŸ“](./jbig2enc) [ğŸŒ](https://github.com/GerHobbelt/jbig2enc) -- an encoder for JBIG2. JBIG2 encodes bi-level (1 bpp) images using a number of clever tricks to get better compression than G4. This encoder can:
  
  * Generate JBIG2 files, or fragments for embedding in PDFs
  * Generic region encoding
  * Perform symbol extraction, classification and text region coding
  * Perform refinement coding and,
  * Compress multipage documents
  
  It uses the Leptonica library.

- **jpeginfo** [ğŸ“](../../thirdparty/jpeginfo) [ğŸŒ](https://github.com/GerHobbelt/jpeginfo) -- prints information and tests integrity of JPEG/JFIF files.
- **JPEG-XL** [ğŸ“](./jpeg-xl) [ğŸŒ](https://github.com/GerHobbelt/jpeg-xl) -- JPEG XL reference implementation (encoder and decoder), called `libjxl`. JPEG XL was standardized in 2022 as [ISO/IEC 18181](https://jpeg.org/jpegxl/workplan.html). The [core codestream](doc/format_overview.md#codestream-features) is specified in 18181-1, the [file format](doc/format_overview.md#file-format-features) in 18181-2. [Decoder conformance](https://github.com/libjxl/conformance) is defined in 18181-3, and 18181-4 is the [reference software](https://github.com/libjxl/libjxl).
- **knusperli** [ğŸ“](./knusperli) [ğŸŒ](https://github.com/GerHobbelt/knusperli) -- Knusperli reduces blocking artifacts in decoded JPEG images by interpreting quantized DCT coefficients in the image data as an interval, rather than a fixed value, and choosing the value from that interval that minimizes discontinuities at block boundaries.
- **lerc** [ğŸ“](./lerc) [ğŸŒ](https://github.com/GerHobbelt/lerc) -- LERC (Limited Error Raster Compression) is an open-source image or raster format which supports rapid encoding and decoding for any pixel type (not just RGB or Byte). Users set the maximum compression error per pixel while encoding, so the precision of the original input image is preserved (within user defined error bounds).
- **libaom** [ğŸ“](./libaom) [ğŸŒ](https://github.com/GerHobbelt/libaom) -- AV1 Codec Library
- **libavif** [ğŸ“](./libavif) [ğŸŒ](https://github.com/GerHobbelt/libavif) -- a friendly, portable C implementation of the AV1 Image File Format, as described here: <https://aomediacodec.github.io/av1-avif/>
- **libde265** [ğŸ“](./libde265) [ğŸŒ](https://github.com/GerHobbelt/libde265) -- libde265 is an open source implementation of the h.265 video codec. It is written from scratch and has a plain C API to enable a simple integration into other software. libde265 supports WPP and tile-based multithreading and includes SSE optimizations. The decoder includes all features of the Main profile and correctly decodes almost all conformance streams (see [[wiki page](https://github.com/strukturag/libde265/wiki/Decoder-conformance)]).
- **libgd** [ğŸ“](./libgd) [ğŸŒ](https://github.com/GerHobbelt/libgd) -- GD is a library for the dynamic creation of images by programmers. GD has support for: WebP, JPEG, PNG, AVIF, HEIF, TIFF, BMP, GIF, TGA, WBMP, XPM.
- **libgif** [ğŸ“](./libgif) [ğŸŒ](https://github.com/GerHobbelt/libgif) -- a library for manipulating GIF files.
- **libheif** [ğŸ“](./libheif) [ğŸŒ](https://github.com/GerHobbelt/heif) -- High Efficiency Image File Format (HEIF) :: a visual media container format standardized by the Moving Picture Experts Group (MPEG) for storage and sharing of images and image sequences. It is based on the well-known ISO Base Media File Format (ISOBMFF) standard. HEIF Reader/Writer Engine is an implementation of HEIF standard in order to demonstrate its powerful features and capabilities.
- **libheif-alt** [ğŸ“](./libheif-alt) [ğŸŒ](https://github.com/GerHobbelt/libheif) -- an ISO/IEC 23008-12:2017 HEIF and AVIF (AV1 Image File Format) file format decoder and encoder. HEIF and AVIF are new image file formats employing HEVC (h.265) or AV1 image coding, respectively, for the best compression ratios currently possible.
- **libjpeg** [ğŸ“](../../thirdparty/libjpeg) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-libjpeg) -- the Independent JPEG Group's JPEG software
- **libjpeg-turbo** [ğŸ“](./libjpeg-turbo) [ğŸŒ](https://github.com/GerHobbelt/libjpeg-turbo) -- a JPEG image codec that uses SIMD instructions to accelerate baseline JPEG compression and decompression on x86, x86-64, Arm, PowerPC, and MIPS systems, as well as progressive JPEG compression on x86, x86-64, and Arm systems.  On such systems, libjpeg-turbo is generally 2-6x as fast as libjpeg, all else being equal.  On other types of systems, libjpeg-turbo can still outperform libjpeg by a significant amount, by virtue of its highly-optimized Huffman coding routines.  In many cases, the performance of libjpeg-turbo rivals that of proprietary high-speed JPEG codecs.
- **libkra** [ğŸ“](./libkra) [ğŸŒ](https://github.com/GerHobbelt/libkra) -- a C++ library for importing Krita's KRA & KRZ formatted documents.
- **libpng** [ğŸ“](../../thirdparty/libpng) [ğŸŒ](https://github.com/GerHobbelt/libpng) -- LIBPNG: Portable Network Graphics support, official libpng repository.
- **libtiff** [ğŸ“](../../thirdparty/libtiff) [ğŸŒ](https://github.com/GerHobbelt/libtiff) -- TIFF Software Distribution
- **libwebp** [ğŸ“](./libwebp) [ğŸŒ](https://github.com/GerHobbelt/libwebp) -- a library to encode and decode images in WebP format.
- **mozjpeg** [ğŸ“](./mozjpeg) [ğŸŒ](https://github.com/GerHobbelt/mozjpeg) -- the Mozilla JPEG Encoder Project improves JPEG compression efficiency achieving higher visual quality and smaller file sizes at the same time. It is compatible with the JPEG standard, and the vast majority of the world's deployed JPEG decoders. MozJPEG is a patch for [libjpeg-turbo](https://github.com/libjpeg-turbo/libjpeg-turbo).
- **OpenEXR** [ğŸ“](./OpenEXR) [ğŸŒ](https://github.com/GerHobbelt/openexr) -- a high dynamic-range (HDR) image file format developed by Industrial Light & Magic (ILM) for use in computer imaging applications. OpenEXR is a lossless format for multi-layered images. Professional use. (I've used it before; nice file format.)
- **openexr-images** [ğŸ“](./openexr-images) [ğŸŒ](https://github.com/GerHobbelt/openexr-images) -- collection of images associated with the OpenEXR distribution.
- **OpenImageIO** [ğŸ“](./oiio) [ğŸŒ](https://github.com/GerHobbelt/oiio) -- Reading, writing, and processing images in a wide variety of file formats, using a format-agnostic API, aimed at VFX applications.
  
  Also includes:
  
  - an ImageCache class that transparently manages a cache so that it can access truly vast amounts of image data (tens of thousands of image files totaling multiple TB) very efficiently using only a tiny amount (tens of megabytes at most) of runtime memory.
  - ImageBuf and ImageBufAlgo functions, which constitute a simple class for storing and manipulating whole images in memory, plus a collection of the most useful computations you might want to do involving those images, including many image processing operations.
  
  The primary target audience for OIIO is VFX studios and developers of tools such as renderers, compositors, viewers, and other image-related software you'd find in a production pipeline.

- **openjpeg** [ğŸ“](../../thirdparty/openjpeg) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-openjpeg) -- OPENJPEG Library and Applications -- OpenJPEG is an open-source JPEG 2000 codec written in C language. It has been developed in order to promote the use of [JPEG 2000](http://www.jpeg.org/jpeg2000), a still-image compression standard from the Joint Photographic Experts Group ([JPEG](http://www.jpeg.org)).  Since April 2015, it is officially recognized by ISO/IEC and ITU-T as a [JPEG 2000 Reference Software](http://www.itu.int/rec/T-REC-T.804-201504-I!Amd2).
- **pdiff** [ğŸ“](./pdiff) [ğŸŒ](https://github.com/GerHobbelt/pdiff) -- perceptualdiff (pdiff): a program that compares two images using a perceptually based image metric.
- **pmt-png-tools** [ğŸ“](./pmt-png-tools) [ğŸŒ](https://github.com/GerHobbelt/pmt) -- pngcrush and other PNG and MNG tools
- **psd_sdk** [ğŸ“](./psd_sdk) [ğŸŒ](https://github.com/GerHobbelt/psd_sdk) -- a C++ library that directly reads Photoshop PSD files. The library supports:
  
  * Groups
  * Nested layers
  * Smart Objects
  * User and vector masks
  * Transparency masks and additional alpha channels
  * 8-bit, 16-bit, and 32-bit data in grayscale and RGB color mode
  * All compression types known to Photoshop
  
  Additionally, limited export functionality is also supported.

- **qoi** [ğŸ“](./qoi) [ğŸŒ](https://github.com/GerHobbelt/qoi) -- QOI: the â€œQuite OK Image Formatâ€ for fast, lossless image compression, single-file MIT licensed library for C/C++. Compared to stb_image and stb_image_write QOI offers 20x-50x faster encoding, 3x-4x faster decoding and 20% better compression. It's also stupidly simple and fits in about 300 lines of C.
- **tinyexr** [ğŸ“](./tinyexr) [ğŸŒ](https://github.com/GerHobbelt/tinyexr) -- Tiny OpenEXR: `tinyexr` is a small, single header-only library to load and save OpenEXR (.exr) images.
- **twain_library** [ğŸ“](./twain_library) [ğŸŒ](https://github.com/GerHobbelt/twain_library) -- the DTWAIN Library, **Version 5.x**, from Dynarithmic Software.  DTWAIN is an open source programmer's library that will allow applications to acquire images from TWAIN-enabled devices using a simple Application Programmer's Interface (API).
- **Imath** [ğŸŒ](https://github.com/AcademySoftwareFoundation/Imath) -- float16 support lib for OpenEXR format
  
  - **optional**; reason: considered *overkill* for the projects I'm currently involved in, including Qiqqa. Those can use [Apache Tika](https://tika.apache.org/), [ImageMagick](https://imagemagick.org/) or other thirdparty pipelines to convert to & from supported formats.

- **OpenImageIO** [ğŸŒ](https://github.com/OpenImageIO/oiio) -- a library for reading, writing, and processing images in a wide variety of file formats, using a format-agnostic API, aimed at VFX applications.
  
  - **tentative/pending**; reason: considered nice & cool but still *overkill*. Qiqqa tooling can use [Apache Tika](https://tika.apache.org/), [ImageMagick](https://imagemagick.org/) or other thirdparty pipelines to convert to & from supported formats.

- ~~**cgohlke::imagecodecs** [ğŸŒ](https://github.com/cgohlke/imagecodecs) (*not included; see also DICOM slot above*)~~
- ~~[DICOM to NIfTI](https://github.com/rordenlab/dcm2niix) (*not included; see also DICOM slot above*)~~
- ~~**GDCM-Grassroots-DICOM** [ğŸŒ](https://github.com/malaterre/GDCM)~~
  
  - **removed**; reason: not a frequently used format; the filter codes can be found in other libraries. *Overkill*. Qiqqa tooling can use [Apache Tika](https://tika.apache.org/), [ImageMagick](https://imagemagick.org/) or other thirdparty pipelines to convert to & from supported formats.












### Monte Carlo simulations, LDA, keyword inference/extraction, etc.

- **ceres-solver** [ğŸ“](./ceres-solver) [ğŸŒ](https://github.com/GerHobbelt/ceres-solver) -- a library for modeling and solving large, complicated optimization problems. It is a feature rich, mature and performant library which has been used in production at Google since 2010. Ceres Solver can solve two kinds of problems: (1) Non-linear Least Squares problems with bounds constraints, and (2) General unconstrained optimization problems.
- **gibbs-lda** [ğŸ“](./gibbs-lda) [ğŸŒ](https://github.com/GerHobbelt/gibbs-lda) -- modified GibbsLDA++: A C/C++ Implementation of Latent Dirichlet Allocation by by Xuan-Hieu Phan and Cam-Tu Nguyen.
- **lda** [ğŸ“](./lda) [ğŸŒ](https://github.com/GerHobbelt/lda-c) -- variational EM for latent Dirichlet allocation (LDA), David Blei et al
- **lda-3-variants** [ğŸ“](./lda-3-variants) [ğŸŒ](https://github.com/GerHobbelt/LDA) -- three modified open source versions of LDA with collapsed Gibbs Sampling: GibbsLDA++, ompi-lda and online_twitter_lda.
- **lda-bigartm** [ğŸ“](./lda-bigartm) [ğŸŒ](https://github.com/GerHobbelt/bigartm) -- BigARTM is a powerful tool for topic modeling based on a novel technique called Additive Regularization of Topic Models. This technique effectively builds multi-objective models by adding the weighted sums of regularizers to the optimization criterion. BigARTM is known to combine well very different objectives, including sparsing, smoothing, topics decorrelation and many others. Such combination of regularizers significantly improves several quality measures at once almost without any loss of the perplexity.
- **lda-Familia** [ğŸ“](./lda-Familia) [ğŸŒ](https://github.com/GerHobbelt/Familia) -- Familia: A Configurable Topic Modeling Framework for Industrial Text Engineering (Di Jiang and Yuanfeng Song and Rongzhong Lian and Siqi Bao and Jinhua Peng and Huang He and Hua Wu) (2018)
- **LightLDA** [ğŸ“](./LightLDA) [ğŸŒ](https://github.com/GerHobbelt/LightLDA) -- a distributed system for large scale topic modeling. It implements a distributed sampler that enables very large data sizes and models. LightLDA improves sampling throughput and convergence speed via a fast O(1) metropolis-Hastings algorithm, and allows small cluster to tackle very large data and model sizes through model scheduling and data parallelism architecture. LightLDA is implemented with C++ for performance consideration.
- **mcmc** [ğŸ“](./mcmc) [ğŸŒ](https://github.com/GerHobbelt/mcmc) -- Monte Carlo
- **mmc** [ğŸ“](./mmc) [ğŸŒ](https://github.com/GerHobbelt/mmc) -- Monte Carlo
- **multiverso** [ğŸ“](./multiverso) [ğŸŒ](https://github.com/GerHobbelt/Multiverso) -- a parameter server based framework for training machine learning models on big data with numbers of machines. It is currently a standard C++ library and provides a series of friendly programming interfaces. Now machine learning researchers and practitioners do not need to worry about the system routine issues such as distributed model storage and operation, inter-process and inter-thread communication, multi-threading management, and so on. Instead, they are able to focus on the core machine learning logics: data, model, and training.
- **ncnn** [ğŸ“](./ncnn) [ğŸŒ](https://github.com/GerHobbelt/ncnn) -- high-performance neural network inference computing framework optimized for mobile platforms (i.e. small footprint)
- **OptimizationTemplateLibrary** [ğŸ“](./OptimizationTemplateLibrary) [ğŸŒ](https://github.com/GerHobbelt/O-T-L) -- Optimization Template Library (OTL)
- **pke** [ğŸ“](./pke) [ğŸŒ](https://github.com/GerHobbelt/pke) -- python keyphrase extraction (PKE) is an open source python-based **keyphrase extraction** toolkit. It provides an end-to-end keyphrase extraction pipeline in which each component can be easily modified or extended to develop new models. `pke` also allows for easy benchmarking of state-of-the-art keyphrase extraction models, and ships with supervised models trained on the [SemEval-2010 dataset](http://aclweb.org/anthology/S10-1004).
- **RAKE** [ğŸ“](./RAKE) [ğŸŒ](https://github.com/GerHobbelt/RAKE) -- the Rapid Automatic Keyword Extraction (RAKE) algorithm as described in: Rose, S., Engel, D., Cramer, N., & Cowley, W. (2010). Automatic Keyword Extraction from Individual Documents. In M. W. Berry & J. Kogan (Eds.), Text Mining: Theory and Applications: John Wiley & Sons.
- **stan** [ğŸ“](./stan) [ğŸŒ](https://github.com/GerHobbelt/stan) -- Stan is a C++ package providing (1) full Bayesian inference using the No-U-Turn sampler (NUTS), a variant of Hamiltonian Monte Carlo (HMC), (2) approximate Bayesian inference using automatic differentiation variational inference (ADVI), and (3) penalized maximum likelihood estimation (MLE) using L-BFGS optimization. It is built on top of the [Stan Math library](https://github.com/stan-dev/math).
- **stateline** [ğŸ“](./stateline) [ğŸŒ](https://github.com/GerHobbelt/stateline) -- a framework for distributed Markov Chain Monte Carlo (MCMC) sampling written in C++. It implements random walk Metropolis-Hastings with parallel tempering to improve chain mixing, provides an adaptive proposal distribution to speed up convergence, and allows the user to factorise their likelihoods (eg. over sensors or data).
- **waifu2x-ncnn-vulkan** [ğŸ“](./waifu2x-ncnn-vulkan) [ğŸŒ](https://github.com/GerHobbelt/waifu2x-ncnn-vulkan) -- waifu2x ncnn Vulkan: an [ncnn project](https://github.com/Tencent/ncnn) implementation of the waifu2x converter. Runs fast on Intel / AMD / Nvidia / Apple-Silicon with Vulkan API.
- **warpLDA** [ğŸ“](./warpLDA) [ğŸŒ](https://github.com/GerHobbelt/warplda) -- a cache efficient implementation for Latent Dirichlet Allocation.
- **worde_butcher** [ğŸ“](./worde_butcher) [ğŸŒ](https://github.com/GerHobbelt/worde_butcher) -- a tool for text segmentation, keyword extraction and speech tagging. Butchers any text into prime word / phrase cuts, deboning all incoming based on our definitive set of stopwords for all languages.
- **yake** [ğŸ“](./yake) [ğŸŒ](https://github.com/GerHobbelt/yake) -- Yet Another Keyword Extractor (Yake) is a light-weight unsupervised automatic keyword extraction method which rests on text statistical features extracted from single documents to select the most important keywords of a text. Our system does not need to be trained on a particular set of documents, neither it depends on dictionaries, external-corpus, size of the text, language or domain.
- other *topic modeling* code on the Net:
  
  * [David Blei's list of topic modeling OSS software](http://www.cs.columbia.edu/~blei/topicmodeling_software.html) + [github repo list](https://github.com/blei-lab)
  * [Hierarchical Dirichlet Process (with Split-Merge Operations), Chong Wang](https://github.com/renaud/hdp-faster)
  * [Hierarchical Latent Tree Analysis (HLTA)](https://github.com/kmpoon/hlta)
  * [Leonard Poon - various works](https://github.com/kmpoon?tab=repositories)












### Random generators & all things random

- **EigenRand** [ğŸ“](./EigenRand) [ğŸŒ](https://github.com/GerHobbelt/EigenRand) -- EigenRand: The Fastest C++11-compatible random distribution generator for Eigen. EigenRand is a header-only library for [Eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page), providing vectorized random number engines and vectorized random distribution generators.  Since the classic Random functions of Eigen rely on an old C function `rand()`, there is no way to control random numbers and no guarantee for quality of generated numbers. In addition, Eigen's Random is slow because `rand()` is hard to vectorize. EigenRand provides a variety of random distribution functions similar to C++11 standard's random functions, which can be vectorized and easily integrated into Eigen's expressions of Matrix and Array. You can get 5~10 times speed by just replacing old Eigen's Random or unvectorizable c++11 random number generators with EigenRand.
- **fastPRNG** [ğŸ“](./fastPRNG) [ğŸŒ](https://github.com/GerHobbelt/fastPRNG) -- a single header-only FAST 32/64 bit PRNG (pseudo-random generator), highly optimized to obtain faster code from compilers, it's based on **xoshiro** / **xoroshiro** ([**Blackman/Vigna**](http://prng.di.unimi.it/)), **xorshift** and other [**Marsaglia**](https://en.wikipedia.org/wiki/George_Marsaglia) algorithms.
- **libchaos** [ğŸ“](./libchaos) [ğŸŒ](https://github.com/GerHobbelt/libchaos) -- *Advanced library for randomization, hashing and statistical analysis (devoted to [chaos machines](https://en.wikipedia.org/wiki/Chaos_machine))* written to help with the development of software for scientific research. Project goal is to *implement & analyze* various algorithms for randomization and hashing, while maintaining simplicity and security, making them suitable for use in your own code. Popular tools like [TestU01](http://simul.iro.umontreal.ca/testu01/tu01.html), [Dieharder](https://www.phy.duke.edu/~rgb/General/dieharder.php) and [Hashdeep](https://github.com/jessek/hashdeep) are obsolete or their development has been stopped. Libchaos aims to replace them.
- **pcg-cpp-random** [ğŸ“](./pcg-cpp-random) [ğŸŒ](https://github.com/GerHobbelt/pcg-cpp) -- a C++ implementation of the PCG family of random number generators, which are fast, statistically excellent, and offer a number of useful features.
- **pcg-c-random** [ğŸ“](./pcg-c-random) [ğŸŒ](https://github.com/GerHobbelt/pcg-c) -- a C implementation of the PCG family of random number generators, which are fast, statistically excellent, and offer a number of useful features.
- **prvhash** [ğŸ“](./prvhash) [ğŸŒ](https://github.com/GerHobbelt/prvhash) -- PRVHASH is a hash function that generates a [uniform pseudo-random number sequence](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) derived from the message. PRVHASH is conceptually similar (in the sense of using a pseudo-random number sequence as a hash) to [`keccak`](https://en.wikipedia.org/wiki/SHA-3) and [`RadioGatun`](https://en.wikipedia.org/wiki/RadioGat%C3%BAn) schemes, but is a completely different implementation of such concept. PRVHASH is both a ["randomness extractor"](https://en.wikipedia.org/wiki/Randomness_extractor) and an "extendable-output function" (XOF).
- **randen** [ğŸ“](./randen) [ğŸŒ](https://github.com/GerHobbelt/randen) -- What if we could default to attack-resistant random generators without excessive CPU cost? We introduce 'Randen', a new generator with security guarantees; it outperforms MT19937, pcg64_c32, Philox, ISAAC and ChaCha8 in real-world benchmarks. This is made possible by AES hardware acceleration and a large Feistel permutation.
- **random** [ğŸ“](./random) [ğŸŒ](https://github.com/GerHobbelt/random) -- random for modern C++ with a convenient API.
- **RNGSobol** [ğŸ“](./RNGSobol) [ğŸŒ](https://github.com/GerHobbelt/RNGSobol) -- Sobol quadi-random numbers generator (C++). Note that unlike pseudo-random numbers, quasi-random numbers care about dimensionality of points.
- **trng4** [ğŸ“](./trng4) [ğŸŒ](https://github.com/GerHobbelt/trng4) -- Tinaâ€™s Random Number Generator Library (TRNG) is a state of the art C++ pseudo-random number generator library for sequential and parallel Monte Carlo simulations. Its design principles are based on the extensible random number generator facility that was introduced in the C++11 standard. The TRNG library features an object oriented design, is easy to use and has been speed optimized. Its implementation does not depend on any communication library or hardware architecture.
- **Xoshiro-cpp** [ğŸ“](./Xoshiro-cpp) [ğŸŒ](https://github.com/GerHobbelt/Xoshiro-cpp) -- a header-only pseudorandom number generator library for modern C++. Based on **David Blackman and Sebastiano Vigna's [xoshiro/xoroshiro generators](http://prng.di.unimi.it/)**.











### Regression, curve fitting, polynomials, splines, geometrics, interpolation, math

- **baobzi** [ğŸ“](./baobzi) [ğŸŒ](https://github.com/GerHobbelt/baobzi) -- an adaptive fast function approximator based on tree search. Word salad aside, `baobzi` is a tool to convert very CPU intensive function calculations into relatively cheap ones (at the cost of memory). This is similar to functions like `chebeval` in `MATLAB`, but can be significantly faster since the order of the polynomial fit can be much much lower to meet similar tolerances. It also isn't constrained for use only in `MATLAB`. Internally, `baobzi` represents your function by a grid of binary/quad/oct/N trees, where the leaves represent the function in some small sub-box of the function's domain with chebyshev polynomials. When you evaluate your function at a point with baobzi, it searches the tree for the box containing your point and evaluates using this approximant.
- **blaze** [ğŸ“](./blaze) [ğŸŒ](https://github.com/GerHobbelt/blaze) -- a high-performance C++ math library for dense and sparse arithmetic. With its state-of-the-art *Smart Expression Template* implementation **Blaze** combines the elegance and ease of use of a domain-specific language with HPC-grade performance, making it one of the most intuitive and fastest C++ math libraries available.
- **Clipper2** [ğŸ“](./Clipper2) [ğŸŒ](https://github.com/GerHobbelt/Clipper2) -- a Polygon <a href="https://en.wikipedia.org/wiki/Clipping_(computer_graphics)">Clipping</a> and <a href="https://en.wikipedia.org/wiki/Parallel_curve">Offsetting</a> library.
- **fastops** [ğŸ“](./fastops) [ğŸŒ](https://github.com/GerHobbelt/fastops) -- vector operations library, which enables acceleration of bulk calls of certain math functions on AVX and AVX2 hardware. Currently supported operations are exp, log, sigmoid and tanh. The library itself implements operations using AVX and AVX2, but will work on any hardware with at least SSE2 support.
- **fastrange** [ğŸ“](./fastrange) [ğŸŒ](https://github.com/GerHobbelt/fastrange) -- a fast alternative to the modulo reduction. [It has accelerated some operations in Google's Tensorflow by 10% to 20%](https://github.com/tensorflow/tensorflow/commit/a47a300185026fe7829990def9113bf3a5109fed). Further reading : http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/ See also: Daniel Lemire, [Fast Random Integer Generation in an Interval](https://arxiv.org/abs/1805.10941), ACM Transactions on Modeling and Computer Simulation, January 2019 Article No. 3 https://doi.org/10.1145/3230636
- **figtree** [ğŸ“](./figtree) [ğŸŒ](https://github.com/GerHobbelt/figtree) -- FIGTree is a library that provides a C/C++ and MATLAB interface for speeding up the computation of the Gauss Transform.
- **fityk** [ğŸ“](./fityk) [ğŸŒ](https://github.com/GerHobbelt/fityk) -- a program for nonlinear fitting of analytical functions (especially peak-shaped) to data (usually experimental data). To put it differently, it is primarily peak fitting software, but can handle other types of functions as well. Apart from the actual fitting, the program helps with data processing and provides ergonomic graphical interface (and also command line interface and scripting API -- but if the program is popular in some fields, it's thanks to its graphical interface). It is reportedly__ used in crystallography, chromatography, photoluminescence and photoelectron spectroscopy, infrared and Raman spectroscopy, to name but a few. Fityk offers various nonlinear fitting methods, simple background subtraction and other manipulations to the dataset, easy placement of peaks and changing of peak parameters, support for analysis of series of datasets, automation of common tasks with scripts, and much more.
- **fmath** [ğŸ“](./fmath) [ğŸŒ](https://github.com/GerHobbelt/fmath) -- fast approximate function of exponential function exp and log: includes `fmath::log`, `fmath::exp`, `fmath::expd`.
- **gmt** [ğŸ“](./gmt) [ğŸŒ](https://github.com/GerHobbelt/gmt) -- GMT (Generic Mapping Tools) is an open source collection of about 100 command-line tools for manipulating geographic and Cartesian data sets (including filtering, trend fitting, gridding, projecting, etc.) and producing high-quality illustrations ranging from simple x-y plots via contour maps to artificially illuminated surfaces, 3D perspective views and animations. The GMT supplements add another 50 more specialized and discipline-specific tools. GMT supports over 30 map projections and transformations and requires support data such as [GSHHG](http://www.soest.hawaii.edu/pwessel/gshhg/) coastlines, rivers, and political boundaries and optionally [DCW](http://www.soest.hawaii.edu/pwessel/dcw) country polygons.
- **half** [ğŸ“](./half) [ğŸŒ](https://github.com/GerHobbelt/half) -- IEEE 754-based half-precision floating point library forked from http://half.sourceforge.net/. This is a C++ header-only library to provide an IEEE 754 conformant 16-bit half-precision floating-point type along with corresponding arithmetic operators, type conversions and common mathematical functions. It aims for both efficiency and ease of use, trying to accurately mimic the behaviour of the built-in floating-point types at the best performance possible.
- **hilbert_curves** [ğŸ“](./hilbert_curves) [ğŸŒ](https://github.com/GerHobbelt/hilbert_curves) -- the world's fastest implementations of 2D and 3D hilbert curve functions.
- **hilbert_hpp** [ğŸ“](./hilbert_hpp) [ğŸŒ](https://github.com/GerHobbelt/hilbert_hpp) -- contains two implementations of the hilbert curve encoding & decoding algorithm described by John Skilling in his paper "Programming the Hilbert Curve".
- **ifopt** [ğŸ“](./ifopt) [ğŸŒ](https://github.com/GerHobbelt/ifopt) -- a modern, light-weight, [Eigen]-based C++ interface to Nonlinear Programming solvers, such as Ipopt and Snopt.
- **Ipopt** [ğŸ“](./Ipopt) [ğŸŒ](https://github.com/GerHobbelt/Ipopt) -- Ipopt (Interior Point OPTimizer, pronounced eye-pea-Opt) is a software package for large-scale [nonlinear optimization](http://wiki.mcs.anl.gov/NEOS/index.php/Nonlinear_Programming_FAQ). It is designed to find (local) solutions of mathematical optimization problems.
- **libhilbert** [ğŸ“](./libhilbert) [ğŸŒ](https://github.com/GerHobbelt/libhilbert) -- an implementation of the Chenyang, Hong, Nengchao 2008 IEEE N-dimensional Hilber mapping algorithm. The Hilbert generating genes are statically compiled into the library, thus producing a rather large executable size.  This library support the forward and backward mapping algorithms from  R_N -> R_1 and R_1 -> R_N. The library is used straigth forwardly and for guidance and documentation, see hilbertKey.h.
- **libInterpolate** [ğŸ“](./libInterpolate) [ğŸŒ](https://github.com/GerHobbelt/libInterpolate) -- a C++ interpolation library, which provides classes to perform various types of 1D and 2D function interpolation (linear, spline, etc.).
- **lmfit** [ğŸ“](./lmfit) [ğŸŒ](https://github.com/GerHobbelt/lmfit) -- least squares fitting Files Levenberg-Marquardt least squares minimization and curve fitting. To minimize arbitrary user-provided functions, or to fit user-provided data. No need to provide derivatives.
- **lol** [ğŸ“](./lol) [ğŸŒ](https://github.com/GerHobbelt/lol) -- the header-only part of the Lol (Math) Engine framework.
- **lolremez** [ğŸ“](./lolremez) [ğŸŒ](https://github.com/GerHobbelt/lolremez) -- LolRemez is a Remez algorithm implementation to approximate functions using polynomials.
- **magsac** [ğŸ“](./magsac) [ğŸŒ](https://github.com/GerHobbelt/magsac) -- (MAGSAC++ had been included in OpenCV) the MAGSAC and MAGSAC++ algorithms for robust model fitting without using a single inlier-outlier threshold.
- **mathtoolbox** [ğŸ“](./mathtoolbox) [ğŸŒ](https://github.com/GerHobbelt/mathtoolbox) -- mathematical tools (interpolation, dimensionality reduction, optimization, etc.) written in C++11 and [Eigen](http://eigen.tuxfamily.org/).
- **mlinterp** [ğŸ“](./mlinterp) [ğŸŒ](https://github.com/GerHobbelt/mlinterp) -- a fast C++ routine for linear interpolation in arbitrary dimensions (i.e., multilinear interpolation).
- **nlopt-util** [ğŸ“](./nlopt-util) [ğŸŒ](https://github.com/GerHobbelt/nlopt-util) -- a single-header utility library for calling NLopt optimization in a single line using Eigen::VectorXd.
- **openlibm** [ğŸ“](./openlibm) [ğŸŒ](https://github.com/GerHobbelt/openlibm) -- [OpenLibm](https://openlibm.org/) is an effort to have a high quality, portable, standalone C mathematical library ([`libm`](http://en.wikipedia.org/wiki/libm)). The project was born out of a need to have a good `libm` for the [Julia programming language](http://www.julialang.org) that worked consistently across compilers and operating systems, and in 32-bit and 64-bit environments.
- **polatory** [ğŸ“](./polatory) [ğŸŒ](https://github.com/GerHobbelt/polatory) -- a fast and memory-efficient framework for RBF (radial basis function) interpolation. Polatory can perform kriging prediction via RBF interpolation (dual kriging). Although different terminologies are used, both methods produce the same results.
- **qHilbert** [ğŸ“](./qHilbert) [ğŸŒ](https://github.com/GerHobbelt/qHilbert) -- a vectorized speedup of Hilbert curve generation using SIMD intrinsics. A hilbert curve is a space filling self-similar curve that provides a mapping between 2D space to 1D, and 1D to 2D space while preserving locality between mappings. Hilbert curves split a finite 2D space into recursive quadrants(similar to a [full quad-tree](https://en.wikipedia.org/wiki/Quadtree)) and traverse each quadrant in recursive "U" shapes at each iteration such that every quadrant gets fully visited before moving onto the next one. qHilbert is an attempt at a vectorized speedup of mapping multiple linear 1D indices into planar 2D points in parallel that is based on the Butz Algorithm's utilization of Gray code.
- **radon-tf** [ğŸ“](./radon-tf) [ğŸŒ](https://github.com/GerHobbelt/radon-tf) -- simple implementation of the radon transform. Faster when using more than one thread to execute it. No inverse function is provided. CPU implementation only.
- **RNGSobol** [ğŸ“](./RNGSobol) [ğŸŒ](https://github.com/GerHobbelt/RNGSobol) -- Sobol quadi-random numbers generator (C++). Note that unlike pseudo-random numbers, quasi-random numbers care about dimensionality of points.
- **rotate** [ğŸ“](./rotate) [ğŸŒ](https://github.com/GerHobbelt/rotate) -- provides several classic, commonly used and novel rotation algorithms (aka block swaps), which were documented since around 1981 up to 2021: three novel rotation algorithms were introduced in 2021, notably the [trinity rotation](https://github.com/scandum/rotate#Trinity-Rotation).
- **RRD** [ğŸ“](./RRD) [ğŸŒ](https://github.com/GerHobbelt/RRD) -- RRD: Rotation-Sensitive Regression for Oriented Scene Text Detection
- **RRPN** [ğŸ“](./RRPN) [ğŸŒ](https://github.com/GerHobbelt/RRPN) -- (Arbitrary-Oriented Scene Text Detection via Rotation Proposals)[https://arxiv.org/abs/1703.01086]
- **rtl** [ğŸ“](./rtl) [ğŸŒ](https://github.com/GerHobbelt/rtl) -- _RANSAC Template Library (RTL)_ is an open-source robust regression tool especially with RANSAC family. RTL aims to provide fast, accurate, and easy ways to estimate any model parameters with data contaminated with outliers (incorrect data). RTL includes recent RANSAC variants with their performance evaluation with several models with synthetic and real data. _RANdom SAmple Consensus (RANSAC)_ is an iterative method to make any parameter estimator strong against outliers. For example of line fitting, RANSAC enable to estimate a line parameter even though data points include wrong point observations far from the true line.
- **ruy** [ğŸ“](./ruy) [ğŸŒ](https://github.com/GerHobbelt/ruy) -- a matrix multiplication library. Its focus is to cover the matrix multiplication needs of neural network inference engines. Its initial user has been TensorFlow Lite, where it is used by default on the ARM CPU architecture. `ruy` supports both floating-point and 8-bit-integer-quantized matrices.
- **scilab** [ğŸ“](./scilab) [ğŸŒ](https://github.com/GerHobbelt/scilab) -- Scilab includes hundreds of mathematical functions. It has a high-level programming language allowing access to advanced data structures, 2-D and 3-D graphical functions.
- **sequential-line-search** [ğŸ“](./sequential-line-search) [ğŸŒ](https://github.com/GerHobbelt/sequential-line-search) -- a C++ library for performing the **sequential line search** method (which is a human-in-the-loop variant of **Bayesian optimization**), following the paper "Yuki Koyama, Issei Sato, Daisuke Sakamoto, and Takeo Igarashi. 2017. Sequential Line Search for Efficient Visual Design Optimization by Crowds. ACM Trans. Graph. 36, 4, pp.48:1--48:11 (2017). (a.k.a. Proceedings of SIGGRAPH 2017), DOI: https://doi.org/10.1145/3072959.3073598"
- **Sophus** [ğŸ“](./Sophus) [ğŸŒ](https://github.com/GerHobbelt/Sophus) -- a C++ implementation of Lie groups commonly used for 2d and 3d geometric problems (i.e. for Computer Vision or Robotics applications). Among others, this package includes the special orthogonal groups SO(2) and SO(3) to present rotations in 2d and 3d as well as the special Euclidean group SE(2) and SE(3) to represent rigid body transformations (i.e. rotations and translations) in 2d and 3d.
- **spline** [ğŸ“](./spline) [ğŸŒ](https://github.com/GerHobbelt/spline) -- a lightweight C++ cubic spline interpolation library.
- **splinter** [ğŸ“](./splinter) [ğŸŒ](https://github.com/GerHobbelt/splinter) -- SPLINTER (SPLine INTERpolation) is a library for *multivariate function approximation with splines*. The library can be used for function approximation, regression, data smoothing, data reduction, and much more. Spline approximations are represented by a speedy C++ implementation of the tensor product B-spline. The B-spline consists of piecewise polynomial basis functions, offering a high flexibility and smoothness. The B-spline can be fitted to data using ordinary least squares (OLS), possibly with regularization. The library also offers construction of penalized splines (P-splines).
- **sse-popcount** [ğŸ“](./sse-popcount) [ğŸŒ](https://github.com/GerHobbelt/sse-popcount) -- SIMD popcount; sample programs for my article http://0x80.pl/articles/sse-popcount.html / Faster Population Counts using AVX2 Instructions (https://arxiv.org/abs/1611.07612)
- **theoretica** [ğŸ“](./theoretica) [ğŸŒ](https://github.com/GerHobbelt/theoretica) -- a numerical and automatic math library for scientific research and graphical applications. Theoretica is a header-only mathematical library which provides algorithms for **systems simulation**, **statistical analysis** of lab data and **numerical approximation**, using a **functional** oriented paradigm to mimic **mathematical notation** and formulas. The aim of the library is to provide _simple_ access to powerful algorithms while keeping an _elegant_ and _transparent_ interface, enabling the user to focus on the problem at hand.
- **tinynurbs** [ğŸ“](./tinynurbs) [ğŸŒ](https://github.com/GerHobbelt/tinynurbs) -- a lightweight header-only C++14 library for Non-Uniform Rational B-Spline curves and surfaces. The API is simple to use and the code is readable while being efficient.
- **tinyspline** [ğŸ“](./tinyspline) [ğŸŒ](https://github.com/GerHobbelt/tinyspline) -- TinySpline is a small, yet powerful library for interpolating, transforming, and querying arbitrary NURBS, B-Splines, and BÃ©zier curves.
- **tweeny** [ğŸ“](./tweeny) [ğŸŒ](https://github.com/GerHobbelt/tweeny) -- an inbetweening library designed for the creation of complex animations for games and other beautiful interactive software. It leverages features of modern C++ to empower developers with an intuitive API for declaring tweenings of any type of value, as long as they support arithmetic operations. The goal of Tweeny is to provide means to create fluid interpolations when animating position, scale, rotation, frames or other values of screen objects, by setting their values as the tween starting point and then, after each tween step, plugging back the result.











### Solvers, Clustering, Monte Carlo, Decision Trees

- **ArborX** [ğŸ“](./ArborX) [ğŸŒ](https://github.com/GerHobbelt/ArborX) -- a library designed to provide performance portable algorithms for geometric search, similarly to nanoflann and Boost Geometry.
- **baobzi** [ğŸ“](./baobzi) [ğŸŒ](https://github.com/GerHobbelt/baobzi) -- an adaptive fast function approximator based on tree search. Word salad aside, `baobzi` is a tool to convert very CPU intensive function calculations into relatively cheap ones (at the cost of memory). This is similar to functions like `chebeval` in `MATLAB`, but can be significantly faster since the order of the polynomial fit can be much much lower to meet similar tolerances. It also isn't constrained for use only in `MATLAB`. Internally, `baobzi` represents your function by a grid of binary/quad/oct/N trees, where the leaves represent the function in some small sub-box of the function's domain with chebyshev polynomials. When you evaluate your function at a point with baobzi, it searches the tree for the box containing your point and evaluates using this approximant.
- **brown-cluster** [ğŸ“](./brown-cluster) [ğŸŒ](https://github.com/GerHobbelt/brown-cluster) -- the Brown hierarchical word clustering algorithm. Runs in $O(N C^2)$, where $N$ is the number of word types and $C$ is the number of clusters. Algorithm by Brown, et al.: Class-Based n-gram Models of Natural Language, http://acl.ldc.upenn.edu/J/J92/J92-4003.pdf
- **CppNumericalSolvers** [ğŸ“](./CppNumericalSolvers) [ğŸŒ](https://github.com/GerHobbelt/CppNumericalSolvers) -- a header-only C++17 BFGS / L-BFGS-B optimization library.
- **dbscan** [ğŸ“](./dbscan) [ğŸŒ](https://github.com/GerHobbelt/dbscan) -- Density-Based Spatial Clustering of Applications with Noise (DBSCAN) and Related Algorithms: a fast C++ (re)implementation of several density-based algorithms with a focus on the DBSCAN family for clustering spatial data. The package includes: DBSCAN, HDBSCAN, OPTICS/OPTICSXi, FOSC, Jarvis-Patrick clustering, LOF (Local outlier factor), GLOSH (Global-Local Outlier Score from Hierarchies), kd-tree based kNN search, Fixed-radius NN search
- **FIt-SNE** [ğŸ“](./FIt-SNE) [ğŸŒ](https://github.com/GerHobbelt/FIt-SNE) -- FFT-accelerated implementation of t-Stochastic Neighborhood Embedding ([t-SNE](https://lvdmaaten.github.io/tsne/)), which is a highly successful method for dimensionality reduction and visualization of high dimensional datasets.  A popular [implementation](https://github.com/lvdmaaten/bhtsne) of t-SNE uses the Barnes-Hut algorithm to approximate the gradient at each iteration of gradient descent.
- **fityk** [ğŸ“](./fityk) [ğŸŒ](https://github.com/GerHobbelt/fityk) -- a program for nonlinear fitting of analytical functions (especially peak-shaped) to data (usually experimental data). To put it differently, it is primarily peak fitting software, but can handle other types of functions as well. Apart from the actual fitting, the program helps with data processing and provides ergonomic graphical interface (and also command line interface and scripting API -- but if the program is popular in some fields, it's thanks to its graphical interface). It is reportedly__ used in crystallography, chromatography, photoluminescence and photoelectron spectroscopy, infrared and Raman spectroscopy, to name but a few. Fityk offers various nonlinear fitting methods, simple background subtraction and other manipulations to the dataset, easy placement of peaks and changing of peak parameters, support for analysis of series of datasets, automation of common tasks with scripts, and much more.
- **genieclust** [ğŸ“](./genieclust) [ğŸŒ](https://github.com/GerHobbelt/genieclust) -- a faster and more powerful version of *Genie* (Fast and Robust Hierarchical Clustering with Noise Point Detection) â€“ a robust and outlier resistant clustering algorithm (see Gagolewski, Bartoszuk, Cena, 2016).
- **gram_savitzky_golay** [ğŸ“](./gram_savitzky_golay) [ğŸŒ](https://github.com/GerHobbelt/gram_savitzky_golay) -- Savitzky-Golay filtering based on Gram polynomials, as described in [General Least-Squares Smoothing and Differentiation by the Convolution (Savitzky-Golay) Method](http://pubs.acs.org/doi/pdf/10.1021/ac00205a007)
- **hdbscan** [ğŸ“](./hdbscan) [ğŸŒ](https://github.com/GerHobbelt/hdbscan) -- a fast parallel implementation for HDBSCAN* [[1]](https://dl.acm.org/doi/10.1145/2733381) (hierarchical DBSCAN). The implementation stems from our parallel algorithms [[2]](https://arxiv.org/pdf/2104.01126.pdf) developed at MIT, and presented at SIGMOD 2021. Our approach is based on generating a well-separated pair decomposition followed by using Kruskal's minimum spanning tree algorithm and bichromatic closest pair computations. We also give a new parallel divide-and-conquer algorithm for computing the dendrogram, which are used in visualizing clusters of different scale that arise for HDBSCAN*.
- **hdbscan-cpp** [ğŸ“](./hdbscan-cpp) [ğŸŒ](https://github.com/GerHobbelt/hdbscan-cpp) -- Fast and Efficient Implementation of HDBSCAN in C++ using STL. HDBSCAN - Hierarchical Density-Based Spatial Clustering of Applications with Noise. Performs DBSCAN over varying epsilon values and integrates the result to find a clustering that gives the best stability over epsilon. This allows HDBSCAN to find clusters of varying densities (unlike DBSCAN), and be more robust to parameter selection. In practice this means that HDBSCAN returns a good clustering straight away with little or no parameter tuning -- and the primary parameter, minimum cluster size, is intuitive and easy to select. HDBSCAN is ideal for exploratory data analysis; it's a fast and robust algorithm that you can trust to return meaningful clusters (if there are any).
- **ifopt** [ğŸ“](./ifopt) [ğŸŒ](https://github.com/GerHobbelt/ifopt) -- a modern, light-weight, [Eigen]-based C++ interface to Nonlinear Programming solvers, such as Ipopt and Snopt.
- **Ipopt** [ğŸ“](./Ipopt) [ğŸŒ](https://github.com/GerHobbelt/Ipopt) -- Ipopt (Interior Point OPTimizer, pronounced eye-pea-Opt) is a software package for large-scale [nonlinear optimization](http://wiki.mcs.anl.gov/NEOS/index.php/Nonlinear_Programming_FAQ). It is designed to find (local) solutions of mathematical optimization problems.
- **kiwi** [ğŸ“](./kiwi) [ğŸŒ](https://github.com/GerHobbelt/kiwi) -- Kiwi is an efficient C++ implementation of the Cassowary constraint solving algorithm. Kiwi is an implementation of the algorithm based on the `seminal Cassowary paper <https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf>`_. It is *not* a refactoring of the original C++ solver. Kiwi has been designed from the ground up to be lightweight and fast. Kiwi ranges from 10x to 500x faster than the original Cassowary solver with typical use cases gaining a 40x improvement. Memory savings are consistently > 5x.
- **LBFGS-Lite** [ğŸ“](./LBFGS-Lite) [ğŸŒ](https://github.com/GerHobbelt/LBFGS-Lite) -- a header-only L-BFGS unconstrained optimizer.
- **liblbfgs** [ğŸ“](./liblbfgs) [ğŸŒ](https://github.com/GerHobbelt/liblbfgs) -- libLBFGS: C library of limited-memory BFGS (L-BFGS), a C port of the implementation of Limited-memory Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) method written by Jorge Nocedal. The original FORTRAN source code is available at: http://www.ece.northwestern.edu/~nocedal/lbfgs.html
- **lmfit** [ğŸ“](./lmfit) [ğŸŒ](https://github.com/GerHobbelt/lmfit) -- least squares fitting Files Levenberg-Marquardt least squares minimization and curve fitting. To minimize arbitrary user-provided functions, or to fit user-provided data. No need to provide derivatives.
- **LMW-tree** [ğŸ“](./LMW-tree) [ğŸŒ](https://github.com/GerHobbelt/LMW-tree) -- LMW-tree: learning m-way tree is a generic template library written in C++ that implements several algorithms that use the m-way nearest neighbor tree structure to store their data. See the related [PhD thesis](http://eprints.qut.edu.au/75862/) for more details on m-way nn trees. The algorithms are primarily focussed on computationally efficient clustering. Clustering is an unsupervised machine learning process that finds interesting patterns in data. It places similar items into clusters and dissimilar items into different clusters. The data structures and algorithms can also be used for nearest neighbor search, supervised learning and other machine learning applications. The package includes EM-tree, K-tree, k-means, TSVQ, repeated k-means, clustering, random projections, random indexing, hashing, bit signatures. See the related [PhD thesis](http://eprints.qut.edu.au/75862/) for more details these algorithms and representations.
- **mapreduce** [ğŸ“](./mapreduce) [ğŸŒ](https://github.com/GerHobbelt/mapreduce) -- the MapReduce-MPI (MR-MPI) library. MapReduce is the operation popularized by Google for computing on large distributed data sets.  See the Wikipedia entry on MapReduce for an overview of what a MapReduce is. The MR-MPI library is a simple, portable implementation of MapReduce that runs on any serial desktop machine or large parallel machine using MPI message passing.
- **mathtoolbox** [ğŸ“](./mathtoolbox) [ğŸŒ](https://github.com/GerHobbelt/mathtoolbox) -- mathematical tools (interpolation, dimensionality reduction, optimization, etc.) written in C++11 and [Eigen](http://eigen.tuxfamily.org/).
- **mcmc-jags** [ğŸ“](./mcmc-jags) [ğŸŒ](https://github.com/GerHobbelt/mcmc-jags) -- JAGS (Just Another Gibbs Sampler), a program for analysis of Bayesian Graphical models by Gibbs Sampling.
- **MicroPather** [ğŸ“](./MicroPather) [ğŸŒ](https://github.com/GerHobbelt/MicroPather) -- a path finder and A* solver (astar or a-star) written in platform independent C++ that can be easily integrated into existing code. MicroPather focuses on being a path finding engine for video games but is a generic A* solver.
- **Multicore-TSNE** [ğŸ“](./Multicore-TSNE) [ğŸŒ](https://github.com/GerHobbelt/Multicore-TSNE) -- Multicore t-SNE is a multicore modification of [Barnes-Hut t-SNE](https://github.com/lvdmaaten/bhtsne) by L. Van der Maaten with Python CFFI-based wrappers. This code also works **faster than sklearn.TSNE** on 1 core (as of version 0.18).
- **nlopt** [ğŸ“](./nlopt) [ğŸŒ](https://github.com/GerHobbelt/nlopt) -- a library for nonlinear local and global optimization, for functions with and without gradient information.  It is designed as a simple, unified interface and packaging of several free/open-source nonlinear optimization libraries.
- **nlopt-util** [ğŸ“](./nlopt-util) [ğŸŒ](https://github.com/GerHobbelt/nlopt-util) -- a single-header utility library for calling NLopt optimization in a single line using Eigen::VectorXd.
- **openlibm** [ğŸ“](./openlibm) [ğŸŒ](https://github.com/GerHobbelt/openlibm) -- [OpenLibm](https://openlibm.org/) is an effort to have a high quality, portable, standalone C mathematical library ([`libm`](http://en.wikipedia.org/wiki/libm)). The project was born out of a need to have a good `libm` for the [Julia programming language](http://www.julialang.org) that worked consistently across compilers and operating systems, and in 32-bit and 64-bit environments.
- **or-tools** [ğŸ“](./or-tools) [ğŸŒ](https://github.com/GerHobbelt/or-tools) -- Google Optimization Tools (a.k.a., OR-Tools) is an open-source, fast and portable software suite for solving combinatorial optimization problems. The suite includes a constraint programming solver, a linear programming solver and various graph algorithms.
- **osqp** [ğŸ“](./osqp) [ğŸŒ](https://github.com/GerHobbelt/osqp) -- the Operator Splitting Quadratic Program Solver.
- **osqp-cpp** [ğŸ“](./osqp-cpp) [ğŸŒ](https://github.com/GerHobbelt/osqp-cpp) -- a C++ wrapper for [OSQP](https://github.com/oxfordcontrol/osqp), an [ADMM](http://stanford.edu/~boyd/admm.html)-based solver for [quadratic programming](https://en.wikipedia.org/wiki/Quadratic_programming). Compared with OSQP's native C interface, the wrapper provides a more convenient input format using Eigen sparse matrices and handles the lifetime of the `OSQPWorkspace` struct. This package has similar functionality to [osqp-eigen](https://github.com/robotology/osqp-eigen).
- **osqp-eigen** [ğŸ“](./osqp-eigen) [ğŸŒ](https://github.com/GerHobbelt/osqp-eigen) -- a simple C++ wrapper for [osqp](http://osqp.readthedocs.io/en/latest/index.html) library.
- **paramonte** [ğŸ“](./paramonte) [ğŸŒ](https://github.com/GerHobbelt/paramonte) -- ParaMonte (Plain Powerful Parallel Monte Carlo Library) is a serial/parallel library of Monte Carlo routines for sampling mathematical objective functions of arbitrary-dimensions, in particular, the posterior distributions of Bayesian models in data science, Machine Learning, and scientific inference, with the design goal of unifying the **automation** (of Monte Carlo simulations), **user-friendliness** (of the library), **accessibility** (from multiple programming environments), **high-performance** (at runtime), and **scalability** (across many parallel processors).
- **rgf** [ğŸ“](./rgf) [ğŸŒ](https://github.com/GerHobbelt/rgf) -- Regularized Greedy Forest (RGF) is a tree ensemble machine learning method described in [this paper](https://arxiv.org/abs/1109.0887). RGF can deliver better results than gradient boosted decision trees (GBDT) on a number of datasets and it has been used to win a few Kaggle competitions. Unlike the traditional boosted decision tree approach, RGF works directly with the underlying forest structure. RGF integrates two ideas: one is to include tree-structured regularization into the learning formulation; and the other is to employ the fully-corrective regularized greedy algorithm.
- **RNGSobol** [ğŸ“](./RNGSobol) [ğŸŒ](https://github.com/GerHobbelt/RNGSobol) -- Sobol quadi-random numbers generator (C++). Note that unlike pseudo-random numbers, quasi-random numbers care about dimensionality of points.
- **scilab** [ğŸ“](./scilab) [ğŸŒ](https://github.com/GerHobbelt/scilab) -- Scilab includes hundreds of mathematical functions. It has a high-level programming language allowing access to advanced data structures, 2-D and 3-D graphical functions.
- **sequential-line-search** [ğŸ“](./sequential-line-search) [ğŸŒ](https://github.com/GerHobbelt/sequential-line-search) -- a C++ library for performing the **sequential line search** method (which is a human-in-the-loop variant of **Bayesian optimization**), following the paper "Yuki Koyama, Issei Sato, Daisuke Sakamoto, and Takeo Igarashi. 2017. Sequential Line Search for Efficient Visual Design Optimization by Crowds. ACM Trans. Graph. 36, 4, pp.48:1--48:11 (2017). (a.k.a. Proceedings of SIGGRAPH 2017), DOI: https://doi.org/10.1145/3072959.3073598"
- **somoclu** [ğŸ“](./somoclu) [ğŸŒ](https://github.com/GerHobbelt/somoclu) -- a massively parallel implementation of self-organizing maps. It exploits multicore CPUs, it is able to rely on MPI for distributing the workload in a cluster, and it can be accelerated by CUDA. A sparse kernel is also included, which is useful for training maps on vector spaces generated in text mining processes.
- **theoretica** [ğŸ“](./theoretica) [ğŸŒ](https://github.com/GerHobbelt/theoretica) -- a numerical and automatic math library for scientific research and graphical applications. Theoretica is a header-only mathematical library which provides algorithms for **systems simulation**, **statistical analysis** of lab data and **numerical approximation**, using a **functional** oriented paradigm to mimic **mathematical notation** and formulas. The aim of the library is to provide _simple_ access to powerful algorithms while keeping an _elegant_ and _transparent_ interface, enabling the user to focus on the problem at hand.
- **uno-solver** [ğŸ“](./uno-solver) [ğŸŒ](https://github.com/GerHobbelt/Uno) -- a modern, modular solver for nonlinearly constrained nonconvex optimization.











### Distance Metrics, Image Quality Metrics, Image Comparison

- **edit-distance** [ğŸ“](./edit-distance) [ğŸŒ](https://github.com/GerHobbelt/editdistance) -- a fast implementation of the edit distance (Levenshtein distance). The algorithm used in this library is proposed by _Heikki HyyrÃ¶, "Explaining and extending the bit-parallel approximate string matching algorithm of Myers", (2001) <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.19.7158&rep=rep1&type=pdf>_.
- **figtree** [ğŸ“](./figtree) [ğŸŒ](https://github.com/GerHobbelt/figtree) -- FIGTree is a library that provides a C/C++ and MATLAB interface for speeding up the computation of the Gauss Transform.
- **flip** [ğŸ“](./flip) [ğŸŒ](https://github.com/GerHobbelt/flip) -- êŸ»LIP: A Tool for Visualizing and Communicating Errors in Rendered Images, implements the [LDR-êŸ»LIP](https://research.nvidia.com/publication/2020-07_FLIP) and [HDR-êŸ»LIP](https://research.nvidia.com/publication/2021-05_HDR-FLIP) image error metrics.
- **glfw** [ğŸ“](./glfw) [ğŸŒ](https://github.com/GerHobbelt/glfw) -- GLFW is an Open Source, multi-platform library for OpenGL, OpenGL ES and Vulkan application development.  It provides a simple, platform-independent API for creating windows, contexts and surfaces, reading input, handling events, etc.
- **imagedistance** [ğŸ“](./imagedistance) [ğŸŒ](https://github.com/GerHobbelt/imagedistance) -- given two images, calculate their distance in several criteria.
- **libdip** [ğŸ“](./libdip) [ğŸŒ](https://github.com/GerHobbelt/diplib) -- **[*DIPlib*](https://diplib.org/diplib-docs/)** is a C++ library for quantitative image analysis.
- **libxcam** [ğŸ“](./libxcam) [ğŸŒ](https://github.com/GerHobbelt/libxcam) -- libXCam is a project for extended camera features and focus on image quality improvement and video analysis. There are lots features supported in image pre-processing, image post-processing and smart analysis. This library makes GPU/CPU/ISP working together to improve image quality. OpenCL is used to improve performance in different platforms.
- **magsac** [ğŸ“](./magsac) [ğŸŒ](https://github.com/GerHobbelt/magsac) -- (MAGSAC++ had been included in OpenCV) the MAGSAC and MAGSAC++ algorithms for robust model fitting without using a single inlier-outlier threshold.
- **mecab** [ğŸ“](./mecab) [ğŸŒ](https://github.com/GerHobbelt/mecab) -- MeCab (Yet Another Part-of-Speech and Morphological Analyzer) is a high-performance morphological analysis engine, designed to be independent of languages, dictionaries, and corpora, using Conditional Random Fields ((CRF)[http://www.cis.upenn.edu/~pereira/papers/crf.pdf]) to estimate the parameters.
- **pg_similarity** [ğŸ“](./pg_similarity) [ğŸŒ](https://github.com/GerHobbelt/pg_similarity) -- **pg\_similarity** is an extension to support similarity queries on [PostgreSQL](http://www.postgresql.org/). The implementation is tightly integrated in the RDBMS in the sense that it defines operators so instead of the traditional operators (`=` and `<>`) you can use `~~~` and `~!~` (any of these operators represents a similarity function).
- **poisson_blend** [ğŸ“](./poisson_blend) [ğŸŒ](https://github.com/GerHobbelt/poisson_blend) -- a simple, readable implementation of Poisson Blending, that demonstrates the concepts explained in [my article](https://erkaman.github.io/posts/poisson_blending.html), seamlessly blending a source image and a target image, at some specified pixel location.
- **polatory** [ğŸ“](./polatory) [ğŸŒ](https://github.com/GerHobbelt/polatory) -- a fast and memory-efficient framework for RBF (radial basis function) interpolation. Polatory can perform kriging prediction via RBF interpolation (dual kriging). Although different terminologies are used, both methods produce the same results.
- **radon-tf** [ğŸ“](./radon-tf) [ğŸŒ](https://github.com/GerHobbelt/radon-tf) -- simple implementation of the radon transform. Faster when using more than one thread to execute it. No inverse function is provided. CPU implementation only.
- **RapidFuzz** [ğŸ“](./RapidFuzz) [ğŸŒ](https://github.com/GerHobbelt/RapidFuzz) -- rapid fuzzy string matching in Python and C++ using the Levenshtein Distance.
- **rotate** [ğŸ“](./rotate) [ğŸŒ](https://github.com/GerHobbelt/rotate) -- provides several classic, commonly used and novel rotation algorithms (aka block swaps), which were documented since around 1981 up to 2021: three novel rotation algorithms were introduced in 2021, notably the [trinity rotation](https://github.com/scandum/rotate#Trinity-Rotation).
- **Shifted-Hamming-Distance** [ğŸ“](./Shifted-Hamming-Distance) [ğŸŒ](https://github.com/GerHobbelt/Shifted-Hamming-Distance) -- Shifted Hamming Distance (SHD) is an edit-distance based filter that can quickly check whether the minimum number of edits (including insertions, deletions and substitutions) between two strings is smaller than a user defined threshold **T** (the number of allowed edits between the two strings).  Testing if two stings differs by a small amount is a prevalent function that is used in many applications. One of its biggest usage, perhaps, is in DNA or protein mapping, where a short DNA or protein string is compared against an enormous database, in order to find similar matches. In such applications, a query string is usually compared against multiple candidate strings in the database. Only candidates that are similar to the query are considered **matches** and recorded.  SHD expands the basic Hamming distance computation, which only detects substitutions, into a full-fledged edit-distance filter, which counts not only substitutions but **insertions and deletions** as well.
- **vmaf** [ğŸ“](./vmaf) [ğŸŒ](https://github.com/GerHobbelt/vmaf) -- VMAF (Video Multi-Method Assessment Fusion) is an [Emmy-winning](https://theemmys.tv/) perceptual video quality assessment algorithm developed by Netflix. It also provides a set of tools that allows a user to train and test a custom VMAF model.
- **ZLMediaKit** [ğŸ“](./ZLMediaKit) [ğŸŒ](https://github.com/GerHobbelt/ZLMediaKit) -- a high-performance operational-level streaming media service framework based on C++11, supporting multiple protocols (RTSP/RTMP/HLS/HTTP-FLV/WebSocket-FLV/GB28181/HTTP-TS/WebSocket-TS/HTTP-fMP4/WebSocket-fMP4/MP4/WebRTC) and protocol conversion.
  
  This extension supports a set of similarity algorithms. The most known algorithms are covered by this extension. You must be aware that each algorithm is suited for a specific domain. The following algorithms are provided.
  
  - Cosine Distance;
  - Dice Coefficient;
  - Euclidean Distance;
  - Hamming Distance;
  - Jaccard Coefficient;
  - Jaro Distance;
  - Jaro-Winkler Distance;
  - L1 Distance (as known as City Block or Manhattan Distance);
  - Levenshtein Distance;
  - Matching Coefficient;
  - Monge-Elkan Coefficient;
  - Needleman-Wunsch Coefficient;
  - Overlap Coefficient;
  - Q-Gram Distance;
  - Smith-Waterman Coefficient;
  - Smith-Waterman-Gotoh Coefficient;
  - Soundex Distance.












## database "backend storage"

- **arangodb** [ğŸ“](./arangodb) [ğŸŒ](https://github.com/GerHobbelt/arangodb) -- a scalable open-source multi-model database natively supporting graph, document and search. All supported data models & access patterns can be combined in queries allowing for maximal flexibility.
- **arrow** [ğŸ“](./arrow) [ğŸŒ](https://github.com/GerHobbelt/arrow) -- Apache Arrow is a development platform for in-memory analytics. It contains a set of technologies that enable big data systems to process and move data fast. The reference Arrow libraries contain many distinct software components:
  
  - Columnar vector and table-like containers (similar to data frames) supporting
    flat or nested types
  
  - Conversions to and from other in-memory data structures
  - Integration tests for verifying binary compatibility between the
    implementations (e.g. sending data from Java to C++)
  
  - IO interfaces to local and remote filesystems
  - Readers and writers for various widely-used file formats (such as Parquet, CSV)
  - Reference-counted off-heap buffer memory management, for zero-copy memory
    sharing and handling memory-mapped files
  
  - Self-describing binary wire formats (streaming and batch/file-like) for
    remote procedure calls (RPC) and interprocess communication (IPC)

- **csv-parser** [ğŸ“](./csv-parser) [ğŸŒ](https://github.com/GerHobbelt/csv-parser) -- Vince's CSV Parser: there's plenty of other CSV parsers in the wild, but I had a hard time finding what I wanted. Inspired by Python's `csv` module, I wanted a library with **simple, intuitive syntax**. Furthermore, I wanted support for special use cases such as calculating statistics on very large files. Thus, this library was created with these following goals in mind.
- **csvquote** [ğŸ“](./csvquote) [ğŸŒ](https://github.com/GerHobbelt/csvquote) -- smart and simple CSV processing on the command line. This program can be used at the start and end of a text processing pipeline so that regular unix command line tools can properly handle CSV data that contain commas and newlines inside quoted data fields. Without this program, embedded special characters would be incorrectly interpreted as separators when they are inside quoted data fields.
- **datamash** [ğŸ“](./datamash) [ğŸŒ](https://github.com/GerHobbelt/datamash) -- GNU Datamash is a command-line program which performs basic numeric, textual and statistical operations on input textual data files. It is designed to be portable and reliable, and aid researchers to easily automate analysis pipelines, without writing code or even short scripts.
- **duckdb** [ğŸ“](./duckdb) [ğŸŒ](https://github.com/GerHobbelt/duckdb) -- DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more.
- **Extensible-Storage-Engine** [ğŸ“](./Extensible-Storage-Engine) [ğŸŒ](https://github.com/GerHobbelt/Extensible-Storage-Engine) -- ESE is an embedded / ISAM-based database engine, that provides rudimentary table and indexed access. However the library provides many other strongly layered and thus reusable sub-facilities as well: A Synchronization / Locking library, a Data-structures / STL-like library, an OS-abstraction layer, and a Cache Manager, as well as the full-blown database engine itself.
- **groonga** [ğŸ“](./groonga) [ğŸŒ](https://github.com/GerHobbelt/groonga) -- an open-source fulltext search engine and column store.
- **harbour-core** [ğŸ“](./harbour-core) [ğŸŒ](https://github.com/GerHobbelt/core) -- Harbour is the free software implementation of a multi-platform, multi-threading, object-oriented, scriptable programming language, backward compatible with Clipper/xBase. Harbour consists of a compiler and runtime libraries with multiple UI and database backends, its own make system and a large collection of libraries and interfaces to many popular APIs.
- **IdGenerator** [ğŸ“](./IdGenerator) [ğŸŒ](https://github.com/GerHobbelt/IdGenerator) -- a digital ID generator using the snowflake algorithm, developed in response to the performance problems that often occur. Example use is when you, as an architecture designer, want to solve the problem of unique database primary keys, especially in multi-database distributed systems. You want the primary key of the data table to use the least storage space, while the index speed and the Select, Insert, and Update queries are fast. Meanwhile there may be more than 50 application instances, and each concurrent request can reach 10W/s. You do not want to rely on the auto-increment operation of redis to obtain continuous primary key IDs, because continuous IDs pose business data security risks.
- **iODBC** [ğŸ“](./iODBC) [ğŸŒ](https://github.com/GerHobbelt/iODBC) -- the iODBC Driver Manager provides you with everything you need to develop ODBC-compliant applications under Unix without having to pay royalties to other parties. An ODBC driver is still needed to affect your connection architecture. You may build a driver with the iODBC components or obtain an ODBC driver from a commercial vendor.
- **libcsv2** [ğŸ“](./libcsv2) [ğŸŒ](https://github.com/GerHobbelt/csv2) -- CSV file format reader/writer library.
- **lib_nas_lockfile** [ğŸ“](./lib_nas_lockfile) [ğŸŒ](https://github.com/GerHobbelt/lib_nas_lockfile) -- lockfile management on NAS and other disparate network filesystem storage. To be combined with SQLite to create a proper Qiqqa Sync operation.
- **libsiridb** [ğŸ“](./libsiridb) [ğŸŒ](https://github.com/GerHobbelt/libsiridb) -- SiriDB Connector C (libsiridb) is a library which can be used to communicate with [SiriDB](https://github.com/transceptor-technology/siridb-server) using the C program language. This library contains useful functions but does not handle the connection itself.
- **libsl3** [ğŸ“](./libsl3) [ğŸŒ](https://github.com/GerHobbelt/libsl3) -- a C++ interface for SQLite 3.x. libsl3 is designed to enable comfortable and efficient communication with a SQLite database based on its natural language, which is SQL.
- **libsql** [ğŸ“](./libsql) [ğŸŒ](https://github.com/GerHobbelt/libsql) -- libSQL is an open source, open contribution fork of SQLite. We aim to evolve it to suit many more use cases than SQLite was originally designed for, and plan to use third-party OSS code wherever it makes sense.
  
  SQLite has solidified its place in modern technology stacks, embedded in nearly any computing device you can think of. Its open source nature and public domain availability make it a popular choice for modification to meet specific use cases.
  But despite having its code available, SQLite famously doesn't accept external contributors, so community improvements cannot be widely enjoyed.
  There have been other forks in the past, but they all focus on a specific technical difference. We aim to be a community where people can contribute from many different angles and motivations.
  We want to see a world where everyone can benefit from all of the great ideas and hard work that the SQLite community contributes back to the codebase.

- **libsqlfs** [ğŸ“](./libsqlfs) [ğŸŒ](https://github.com/GerHobbelt/libsqlfs) -- a POSIX style file system on top of an SQLite database.  It allows applications to have access to a full read/write file system in a single file, complete with its own file hierarchy and name space.  This is useful for applications which needs structured storage, such as embedding documents within documents, or management of configuration data or preferences.
- **ligra-graph** [ğŸ“](./ligra-graph) [ğŸŒ](https://github.com/GerHobbelt/ligra) -- LIGRA: a Lightweight Graph Processing Framework for Shared Memory; works on both uncompressed and compressed graphs and hypergraphs.
- **mcmd** [ğŸ“](./mcmd) [ğŸŒ](https://github.com/GerHobbelt/mcmd) -- MCMD (M-Command): a set of commands for handling large scale CSV data. **MCMD** (called as M-Command) is a set of commands that are developed for the purpose of high-speed processing of large-scale structured tabular data in CSV format. It is possible to efficiently process large scale data with hundred millions row of records on a standard PC.
- **mydumper** [ğŸ“](./mydumper) [ğŸŒ](https://github.com/GerHobbelt/mydumper) -- a MySQL Logical Backup Tool. It has 2 tools:
  
  * `mydumper` which is responsible to export a consistent backup of MySQL databases
  * `myloader` reads the backup from mydumper, connects the to destination database and imports the backup.

- **mysql-connector-cpp** [ğŸ“](./mysql-connector-cpp) [ğŸŒ](https://github.com/GerHobbelt/mysql-connector-cpp) -- MySQL Connector/C++ is a release of MySQL Connector/C++, [the C++ interface](https://dev.mysql.com/doc/dev/connector-cpp/8.0/) for communicating with MySQL servers.
- **nanodbc** [ğŸ“](./nanodbc) [ğŸŒ](https://github.com/GerHobbelt/nanodbc) -- a small C++ wrapper for the native C ODBC API.
- **ormpp** [ğŸ“](./ormpp) [ğŸŒ](https://github.com/GerHobbelt/ormpp) -- modern C++ ORM, C++17, support mysql, postgresql, sqlite.
- **otl** [ğŸ“](./otl) [ğŸŒ](https://github.com/GerHobbelt/otl) -- Oracle Template Library (STL-like wrapper for SQL DB queries; supports many databases besides Oracle)
- **percona-server** [ğŸ“](./percona-server) [ğŸŒ](https://github.com/GerHobbelt/percona-server) -- Percona Server for MySQL is a free, fully compatible, enhanced, and open source drop-in replacement for any MySQL database. It provides superior performance, scalability, and instrumentation.
- **qlever** [ğŸ“](./qlever) [ğŸŒ](https://github.com/GerHobbelt/qlever) -- a SPARQL engine that can efficiently index and query very large knowledge graphs with up to 100 billion triples on a single standard PC or server. In particular, QLever is fast for queries that involve large intermediate or final results, which are notoriously hard for engines like Blazegraph or Virtuoso.
- **siridb-server** [ğŸ“](./siridb-server) [ğŸŒ](https://github.com/GerHobbelt/siridb-server) -- SiriDB Server is a highly-scalable, robust and super fast time series database. SiriDB uses a unique mechanism to operate without a global index and allows server resources to be added on the fly. SiriDBâ€™s unique query language includes dynamic grouping of time series for easy analysis over large amounts of time series. SiriDB is scalable on the fly and has no downtime while updating or expanding your database. The scalable possibilities enable you to enlarge the database time after time without losing speed. SiriDB is developed to give an unprecedented performance without downtime. A SiriDB cluster distributes time series across multiple pools. Each pool supports active replicas for load balancing and redundancy. When one of the replicas is not available the database is still accessible.
- **sqawk** [ğŸ“](./sqawk) [ğŸŒ](https://github.com/GerHobbelt/sqawk) -- apply SQL on CSV files in the shell: `sqawk` imports CSV files into an on-the-fly SQLite database, and runs a user-supplied query on the data.
- **sqlcipher** [ğŸ“](./sqlcipher) [ğŸŒ](https://github.com/GerHobbelt/sqlcipher) -- SQLCipher is a standalone fork of the [SQLite](https://www.sqlite.org/) database library that adds 256 bit AES encryption of database files and other security features.
- **sqlean** [ğŸ“](./sqlean) [ğŸŒ](https://github.com/GerHobbelt/sqlean) -- The ultimate set of SQLite extensions: SQLite has few functions compared to other database management systems. SQLite authors see this as a feature rather than a problem, because SQLite has an extension mechanism in place. There are a lot of SQLite extensions out there, but they are incomplete, inconsistent and scattered across the internet. sqlean brings them together, neatly packaged into domain modules, documented, tested, and built for Linux, Windows and macOS.
- **sqleet** [ğŸ“](./sqleet) [ğŸŒ](https://github.com/GerHobbelt/sqleet) -- an encryption extension for [SQLite3](https://www.sqlite.org/). The encryption is transparent (*on-the-fly*) and based on modern cryptographic algorithms designed for high performance in software and robust side-channel resistance.
- **sqlite** [ğŸ“](./sqlite) [ğŸŒ](https://github.com/GerHobbelt/sqlite) -- the complete [SQLite database engine](https://sqlite.org/).
- **sqlite3-compression-encryption-vfs** [ğŸ“](./sqlite3-compression-encryption-vfs) [ğŸŒ](https://github.com/GerHobbelt/sqlite3-compression-encryption-vfs) -- CEVFS: Compression & Encryption VFS for SQLite 3 is a SQLite 3 Virtual File System for compressing and encrypting data at the pager level. Once set up, you use SQLite as you normally would and the compression and encryption is transparently handled during database read/write operations via the SQLite pager.
- **sqlite3pp** [ğŸ“](./sqlite3pp) [ğŸŒ](https://github.com/GerHobbelt/sqlite3pp) -- a minimal ORM wrapper for SQLite et al.
- **sqlite-amalgamation** [ğŸ“](./sqlite-amalgamation) [ğŸŒ](https://github.com/GerHobbelt/sqlite-amalgamation) -- the [SQLite](http://www.sqlite.org/download.html) amalgamation, which is the recommended method of building SQLite into larger projects.
- **SQLiteCpp** [ğŸ“](./SQLiteCpp) [ğŸŒ](https://github.com/GerHobbelt/SQLiteCpp) -- a smart and easy to use C++ SQLite3 wrapper. SQLiteC++ offers an encapsulation around the native C APIs of SQLite, with a few intuitive and well documented C++ classes.
- **sqlite-fts5-snowball** [ğŸ“](./sqlite-fts5-snowball) [ğŸŒ](https://github.com/GerHobbelt/fts5-snowball) -- a simple extension for use with FTS5 within SQLite. It allows FTS5 to use Martin Porter's Snowball stemmers (libstemmer), which are available in several languages. Check http://snowballstem.org/ for more information about them.
- **sqlite_fts_tokenizer_chinese_simple** [ğŸ“](./sqlite_fts_tokenizer_chinese_simple) [ğŸŒ](https://github.com/GerHobbelt/simple) -- an extension of [sqlite3 fts5](https://www.sqlite.org/fts5.html) that supports Chinese and Pinyin. It fully provides a [solution to the multi-phonetic word problem of full-text retrieval on WeChat mobile terminal](https://cloud.tencent.com/developer/article/1198371): solution 4 in the article, very simple and efficient support for Chinese and Pinyin searches.
  
  On this basis we also support more accurate phrase matching through [cppjieba](https://github.com/yanyiwu/cppjieba). See the introduction article at https://www.wangfenjin.com/posts/simple-jieba-tokenizer/

- **SQLiteHistograms** [ğŸ“](./SQLiteHistograms) [ğŸŒ](https://github.com/GerHobbelt/SQLiteHistograms) -- an SQLite extension library for creating histogram tables, tables of ratio between histograms and interpolation tables of scatter point tables.
- **sqliteodbc** [ğŸ“](./sqliteodbc) [ğŸŒ](https://github.com/GerHobbelt/sqliteodbc) -- SQLite ODBC Driver for the wonderful SQLite 2.8.* and SQLite 3.* Database Engine/Library.
- **sqlite-parquet-vtable** [ğŸ“](./sqlite-parquet-vtable) [ğŸŒ](https://github.com/GerHobbelt/sqlite-parquet-vtable) -- an SQLite [virtual table](https://sqlite.org/vtab.html) extension to expose Parquet files as SQL tables. You may also find [csv2parquet](https://github.com/cldellow/csv2parquet/) useful. This [blog post](https://cldellow.com/2018/06/22/sqlite-parquet-vtable.html) provides some context on why you might use this.
- **sqlite-stats** [ğŸ“](./sqlite-stats) [ğŸŒ](https://github.com/GerHobbelt/sqlite-stats) -- provides common statistical functions for SQLite.
- **sqlite_wrapper** [ğŸ“](./sqlite_wrapper) [ğŸŒ](https://github.com/GerHobbelt/sqlite_wrapper) -- an easy-to-use, lightweight and concurrency-friendly SQLite wrapper written in C++17.
- **sqlite_zstd_vfs** [ğŸ“](./sqlite_zstd_vfs) [ğŸŒ](https://github.com/GerHobbelt/sqlite_zstd_vfs) -- SQLite VFS extension providing streaming storage compression using Zstandard (Zstd), transparently compressing pages of the main database file as they're written out and later decompressing them as they're read in. It runs page de/compression on background threads and occasionally generates dictionaries to improve subsequent compression.
- **sqlpp11** [ğŸ“](./sqlpp11) [ğŸŒ](https://github.com/GerHobbelt/sqlpp11) -- a type safe embedded domain specific language for SQL queries and results in C++.
- **unixODBC** [ğŸ“](./unixODBC) [ğŸŒ](https://github.com/GerHobbelt/unixODBC) -- an Open Source ODBC sub-system and an ODBC SDK for Linux, Mac OSX, and UNIX.
- **unqlite** [ğŸ“](./unqlite) [ğŸŒ](https://github.com/GerHobbelt/unqlite) -- UnQLite is a Transactional Embedded Database Engine, an in-process software library which implements a self-contained, serverless, zero-configuration, transactional NoSQL database engine. UnQLite is a document store database similar to MongoDB, Redis, CouchDB etc. as well a standard Key/Value store similar to BerkeleyDB, LevelDB, etc.
  
  Unlike most other NoSQL databases, UnQLite does not have a separate server process. UnQLite reads and writes directly to ordinary disk files.
  A complete database with multiple collections is contained in a single disk file.
  The database file format is cross-platform; you can freely copy a database between 32-bit and 64-bit systems or between big-endian and little-endian architectures.
  
  - BSD licensed product.
  - Built with a powerful disk storage engine which support O(1) lookup.
  - Cross-platform file format.
  - Document store (JSON) database via Jx9.
  - Pluggable run-time interchangeable storage engine.
  - Serverless, NoSQL database engine.
  - Simple, Clean and easy to use API.
  - Single database file, does not use temporary files.
  - Standard Key/Value store.
  - Support cursors for linear records traversal.
  - Support for on-disk as well in-memory databases.
  - Support Terabyte sized databases.
  - Thread safe and full reentrant.
  - Transactional (ACID) database.
  - UnQLite is a Self-Contained C library without dependency.
  - Zero configuration.

- **upscaledb** [ğŸ“](./upscaledb) [ğŸŒ](https://github.com/GerHobbelt/hamsterdb) -- a.k.a. hamsterdb: a thread-safe key/value database engine. It supports a B+Tree index structure, uses memory mapped I/O (if available), fast Cursors and variable length keys and can create In-Memory Databases.
- **zsv** [ğŸ“](./zsv) [ğŸŒ](https://github.com/GerHobbelt/zsv) -- the world's fastest (SIMD) CSV parser, with an extensible CLI for SQL querying, format conversion and more.











### LMDB, NoSQL and key/value stores

- **arrow** [ğŸ“](./arrow) [ğŸŒ](https://github.com/GerHobbelt/arrow) -- Apache Arrow is a development platform for in-memory analytics. It contains a set of technologies that enable big data systems to process and move data fast. The reference Arrow libraries contain many distinct software components:
  
  - Columnar vector and table-like containers (similar to data frames) supporting
    flat or nested types
  
  - Conversions to and from other in-memory data structures
  - Integration tests for verifying binary compatibility between the
    implementations (e.g. sending data from Java to C++)
  
  - IO interfaces to local and remote filesystems
  - Readers and writers for various widely-used file formats (such as Parquet, CSV)
  - Reference-counted off-heap buffer memory management, for zero-copy memory
    sharing and handling memory-mapped files
  
  - Self-describing binary wire formats (streaming and batch/file-like) for
    remote procedure calls (RPC) and interprocess communication (IPC)

- **comdb2-bdb** [ğŸ“](./comdb2-bdb) [ğŸŒ](https://github.com/GerHobbelt/comdb2) -- a clustered RDBMS built on Optimistic Concurrency Control techniques. It provides multiple isolation levels, including Snapshot and Serializable Isolation.
- **ctsa** [ğŸ“](./ctsa) [ğŸŒ](https://github.com/GerHobbelt/ctsa) -- a Univariate Time Series Analysis and ARIMA Modeling Package in ANSI C: CTSA is a C software package for univariate time series analysis. ARIMA and Seasonal ARIMA models have been added as of 10/30/2014. 07/24/2020 Update: SARIMAX and Auto ARIMA added. Documentation will be added in the coming days. Software is still in beta stage and older ARIMA and SARIMA functions are now superseded by SARIMAX.
- **gdbm** [ğŸ“](./gdbm) [ğŸŒ](https://github.com/GerHobbelt/gdbm) -- GNU dbm is a set of NoSQL database routines that use extendable hashing and works similar to the standard UNIX `dbm` routines.
- **libmdbx** [ğŸ“](./libmdbx) [ğŸŒ](https://github.com/GerHobbelt/libmdbx) -- one of the fastest embeddable key-value ACID database without WAL. `libmdbx` surpasses the legendary LMDB in terms of reliability, features and performance.
- **libsiridb** [ğŸ“](./libsiridb) [ğŸŒ](https://github.com/GerHobbelt/libsiridb) -- SiriDB Connector C (libsiridb) is a library which can be used to communicate with [SiriDB](https://github.com/transceptor-technology/siridb-server) using the C program language. This library contains useful functions but does not handle the connection itself.
- **Lightning.NET** [ğŸ“](./Lightning.NET) [ğŸŒ](https://github.com/GerHobbelt/Lightning.NET) -- .NET library for OpenLDAP's LMDB key-value store
- **lmdb** [ğŸ“](./lmdb) [ğŸŒ](https://github.com/GerHobbelt/lmdb) -- OpenLDAP [LMDB](http://www.lmdb.tech/doc/index.html) is an outrageously fast key/value store with semantics that make it highly interesting for many applications.  Of specific note, besides speed, is the full support for transactions and good read/write concurrency.  LMDB is also famed for its robustness **when used correctly**.
- **lmdb-safe** [ğŸ“](./lmdb-safe) [ğŸŒ](https://github.com/GerHobbelt/lmdb-safe) -- A safe modern & performant C++ wrapper of LMDB. LMDB is an outrageously fast key/value store with semantics that make it highly interesting for many applications. Of specific note, besides speed, is the full support for transactions and good read/write concurrency. LMDB is also famed for its robustness.. **when used correctly**. The design of LMDB is elegant and simple, which aids both the performance and stability. The downside of this elegant design is a nontrivial set of rules that need to be followed to not break things. In other words, LMDB delivers great things but only if you use it exactly right. This is by conscious design. The `lmdb-safe` library aims to deliver the full LMDB performance while programmatically making sure the LMDB semantics are adhered to, with very limited overhead.
- **lmdb.spreads.net** [ğŸ“](./lmdb.spreads.net) [ğŸŒ](https://github.com/GerHobbelt/Spreads.LMDB) -- Low-level zero-overhead and [the fastest](https://github.com/Spreads/Spreads.LMDB/commit/4085dde649ef9ebb64310f2627299762dd62d5ce) LMDB .NET wrapper with some additional native methods useful for [Spreads](https://github.com/Spreads/).
- **lmdb-store** [ğŸ“](./lmdb-store) [ğŸŒ](https://github.com/GerHobbelt/lmdb-store) -- an ultra-fast NodeJS interface to LMDB; probably the fastest and most efficient NodeJS key-value/database interface that exists for full storage and retrieval of structured JS data (objects, arrays, etc.) in a true persisted, scalable, [ACID compliant](https://en.wikipedia.org/wiki/ACID) database. It provides a simple interface for interacting with LMDB.
- **lmdbxx** [ğŸ“](./lmdbxx) [ğŸŒ](https://github.com/GerHobbelt/lmdbxx) -- lmdb++: a comprehensive C++11 wrapper for the LMDB embedded database library, offering both an error-checked procedural interface and an object-oriented resource interface with RAII semantics.
- **mmkv** [ğŸ“](./mmkv) [ğŸŒ](https://github.com/GerHobbelt/MMKV) -- an **efficient**, **small**, **easy-to-use** mobile key-value storage framework used in the WeChat application. It's currently available on **Android**, **iOS/macOS**, **Win32** and **POSIX**.
- **PGM-index** [ğŸ“](./PGM-index) [ğŸŒ](https://github.com/GerHobbelt/PGM-index) -- the Piecewise Geometric Model index (PGM-index) is a data structure that enables fast lookup, predecessor, range searches and updates in arrays of billions of items using orders of magnitude less space than traditional indexes while providing the same worst-case query time guarantees.
- **pmemkv** [ğŸ“](./pmemkv) [ğŸŒ](https://github.com/GerHobbelt/pmemkv) -- `pmemkv` is a local/embedded key-value datastore optimized for persistent memory. Rather than being tied to a single language or backing implementation, `pmemkv` provides different options for language bindings and storage engines.
- **pmemkv-bench** [ğŸ“](./pmemkv-bench) [ğŸŒ](https://github.com/GerHobbelt/pmemkv-bench) -- benchmark for [libpmemkv](https://github.com/pmem/pmemkv/) and its underlying libraries, based on [leveldb's db_bench](https://github.com/google/leveldb). The `pmemkv_bench` utility provides some standard read, write & remove benchmarks. It's based on the `db_bench` utility included with LevelDB and RocksDB, although the list of supported parameters is slightly different.
- **qlever** [ğŸ“](./qlever) [ğŸŒ](https://github.com/GerHobbelt/qlever) -- a SPARQL engine that can efficiently index and query very large knowledge graphs with up to 100 billion triples on a single standard PC or server. In particular, QLever is fast for queries that involve large intermediate or final results, which are notoriously hard for engines like Blazegraph or Virtuoso.
- **sdsl-lite** [ğŸ“](./sdsl-lite) [ğŸŒ](https://github.com/GerHobbelt/sdsl-lite) -- The Succinct Data Structure Library (SDSL) is a powerful and flexible C++11 library implementing succinct data structures. In total, the library contains the highlights of 40 [research publications][SDSLLIT]. Succinct data structures can represent an object (such as a bitvector or a tree) in space close to the information-theoretic lower bound of the object while supporting operations of the original object efficiently. The theoretical time complexity of an operation performed on the classical data structure and the equivalent succinct data structure are (most of the time) identical.
- **siridb-server** [ğŸ“](./siridb-server) [ğŸŒ](https://github.com/GerHobbelt/siridb-server) -- SiriDB Server is a highly-scalable, robust and super fast time series database. SiriDB uses a unique mechanism to operate without a global index and allows server resources to be added on the fly. SiriDBâ€™s unique query language includes dynamic grouping of time series for easy analysis over large amounts of time series. SiriDB is scalable on the fly and has no downtime while updating or expanding your database. The scalable possibilities enable you to enlarge the database time after time without losing speed. SiriDB is developed to give an unprecedented performance without downtime. A SiriDB cluster distributes time series across multiple pools. Each pool supports active replicas for load balancing and redundancy. When one of the replicas is not available the database is still accessible.
- **unqlite** [ğŸ“](./unqlite) [ğŸŒ](https://github.com/GerHobbelt/unqlite) -- UnQLite is a Transactional Embedded Database Engine, an in-process software library which implements a self-contained, serverless, zero-configuration, transactional NoSQL database engine. UnQLite is a document store database similar to MongoDB, Redis, CouchDB etc. as well a standard Key/Value store similar to BerkeleyDB, LevelDB, etc.
  
  Unlike most other NoSQL databases, UnQLite does not have a separate server process. UnQLite reads and writes directly to ordinary disk files.
  A complete database with multiple collections is contained in a single disk file.
  The database file format is cross-platform; you can freely copy a database between 32-bit and 64-bit systems or between big-endian and little-endian architectures.
  
  - BSD licensed product.
  - Built with a powerful disk storage engine which support O(1) lookup.
  - Cross-platform file format.
  - Document store (JSON) database via Jx9.
  - Pluggable run-time interchangeable storage engine.
  - Serverless, NoSQL database engine.
  - Simple, Clean and easy to use API.
  - Single database file, does not use temporary files.
  - Standard Key/Value store.
  - Support cursors for linear records traversal.
  - Support for on-disk as well in-memory databases.
  - Support Terabyte sized databases.
  - Thread safe and full reentrant.
  - Transactional (ACID) database.
  - UnQLite is a Self-Contained C library without dependency.
  - Zero configuration.












### SQLite specific modules & related materials

- **duckdb** [ğŸ“](./duckdb) [ğŸŒ](https://github.com/GerHobbelt/duckdb) -- DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more.
- **libdist** [ğŸ“](./libdist) [ğŸŒ](https://github.com/GerHobbelt/distlib) -- string distance related functions (Damerau-Levenshtein, Jaro-Winkler, longest common substring & subsequence) implemented as SQLite run-time loadable extension, with UTF-8 support.
- **lib_nas_lockfile** [ğŸ“](./lib_nas_lockfile) [ğŸŒ](https://github.com/GerHobbelt/lib_nas_lockfile) -- lockfile management on NAS and other disparate network filesystem storage. To be combined with SQLite to create a proper Qiqqa Sync operation.
- **libsl3** [ğŸ“](./libsl3) [ğŸŒ](https://github.com/GerHobbelt/libsl3) -- a C++ interface for SQLite 3.x. libsl3 is designed to enable comfortable and efficient communication with a SQLite database based on its natural language, which is SQL.
- **libsql** [ğŸ“](./libsql) [ğŸŒ](https://github.com/GerHobbelt/libsql) -- libSQL is an open source, open contribution fork of SQLite. We aim to evolve it to suit many more use cases than SQLite was originally designed for, and plan to use third-party OSS code wherever it makes sense.
  
  SQLite has solidified its place in modern technology stacks, embedded in nearly any computing device you can think of. Its open source nature and public domain availability make it a popular choice for modification to meet specific use cases.
  But despite having its code available, SQLite famously doesn't accept external contributors, so community improvements cannot be widely enjoyed.
  There have been other forks in the past, but they all focus on a specific technical difference. We aim to be a community where people can contribute from many different angles and motivations.
  We want to see a world where everyone can benefit from all of the great ideas and hard work that the SQLite community contributes back to the codebase.

- **libsqlfs** [ğŸ“](./libsqlfs) [ğŸŒ](https://github.com/GerHobbelt/libsqlfs) -- a POSIX style file system on top of an SQLite database.  It allows applications to have access to a full read/write file system in a single file, complete with its own file hierarchy and name space.  This is useful for applications which needs structured storage, such as embedding documents within documents, or management of configuration data or preferences.
- **sqlcipher** [ğŸ“](./sqlcipher) [ğŸŒ](https://github.com/GerHobbelt/sqlcipher) -- SQLCipher is a standalone fork of the [SQLite](https://www.sqlite.org/) database library that adds 256 bit AES encryption of database files and other security features.
- **sqlean** [ğŸ“](./sqlean) [ğŸŒ](https://github.com/GerHobbelt/sqlean) -- The ultimate set of SQLite extensions: SQLite has few functions compared to other database management systems. SQLite authors see this as a feature rather than a problem, because SQLite has an extension mechanism in place. There are a lot of SQLite extensions out there, but they are incomplete, inconsistent and scattered across the internet. sqlean brings them together, neatly packaged into domain modules, documented, tested, and built for Linux, Windows and macOS.
- **sqleet** [ğŸ“](./sqleet) [ğŸŒ](https://github.com/GerHobbelt/sqleet) -- an encryption extension for [SQLite3](https://www.sqlite.org/). The encryption is transparent (*on-the-fly*) and based on modern cryptographic algorithms designed for high performance in software and robust side-channel resistance.
- **sqlite** [ğŸ“](./sqlite) [ğŸŒ](https://github.com/GerHobbelt/sqlite) -- the complete [SQLite database engine](https://sqlite.org/).
- **sqlite3-compression-encryption-vfs** [ğŸ“](./sqlite3-compression-encryption-vfs) [ğŸŒ](https://github.com/GerHobbelt/sqlite3-compression-encryption-vfs) -- CEVFS: Compression & Encryption VFS for SQLite 3 is a SQLite 3 Virtual File System for compressing and encrypting data at the pager level. Once set up, you use SQLite as you normally would and the compression and encryption is transparently handled during database read/write operations via the SQLite pager.
- **sqlite3pp** [ğŸ“](./sqlite3pp) [ğŸŒ](https://github.com/GerHobbelt/sqlite3pp) -- a minimal ORM wrapper for SQLite et al.
- **sqlite-amalgamation** [ğŸ“](./sqlite-amalgamation) [ğŸŒ](https://github.com/GerHobbelt/sqlite-amalgamation) -- the [SQLite](http://www.sqlite.org/download.html) amalgamation, which is the recommended method of building SQLite into larger projects.
- **SQLiteCpp** [ğŸ“](./SQLiteCpp) [ğŸŒ](https://github.com/GerHobbelt/SQLiteCpp) -- a smart and easy to use C++ SQLite3 wrapper. SQLiteC++ offers an encapsulation around the native C APIs of SQLite, with a few intuitive and well documented C++ classes.
- **sqlite-fts5-snowball** [ğŸ“](./sqlite-fts5-snowball) [ğŸŒ](https://github.com/GerHobbelt/fts5-snowball) -- a simple extension for use with FTS5 within SQLite. It allows FTS5 to use Martin Porter's Snowball stemmers (libstemmer), which are available in several languages. Check http://snowballstem.org/ for more information about them.
- **sqlite_fts_tokenizer_chinese_simple** [ğŸ“](./sqlite_fts_tokenizer_chinese_simple) [ğŸŒ](https://github.com/GerHobbelt/simple) -- an extension of [sqlite3 fts5](https://www.sqlite.org/fts5.html) that supports Chinese and Pinyin. It fully provides a [solution to the multi-phonetic word problem of full-text retrieval on WeChat mobile terminal](https://cloud.tencent.com/developer/article/1198371): solution 4 in the article, very simple and efficient support for Chinese and Pinyin searches.
  
  On this basis we also support more accurate phrase matching through [cppjieba](https://github.com/yanyiwu/cppjieba). See the introduction article at https://www.wangfenjin.com/posts/simple-jieba-tokenizer/

- **SQLiteHistograms** [ğŸ“](./SQLiteHistograms) [ğŸŒ](https://github.com/GerHobbelt/SQLiteHistograms) -- an SQLite extension library for creating histogram tables, tables of ratio between histograms and interpolation tables of scatter point tables.
- **sqliteodbc** [ğŸ“](./sqliteodbc) [ğŸŒ](https://github.com/GerHobbelt/sqliteodbc) -- SQLite ODBC Driver for the wonderful SQLite 2.8.* and SQLite 3.* Database Engine/Library.
- **sqlite-parquet-vtable** [ğŸ“](./sqlite-parquet-vtable) [ğŸŒ](https://github.com/GerHobbelt/sqlite-parquet-vtable) -- an SQLite [virtual table](https://sqlite.org/vtab.html) extension to expose Parquet files as SQL tables. You may also find [csv2parquet](https://github.com/cldellow/csv2parquet/) useful. This [blog post](https://cldellow.com/2018/06/22/sqlite-parquet-vtable.html) provides some context on why you might use this.
- **sqlite-stats** [ğŸ“](./sqlite-stats) [ğŸŒ](https://github.com/GerHobbelt/sqlite-stats) -- provides common statistical functions for SQLite.
- **sqlite_wrapper** [ğŸ“](./sqlite_wrapper) [ğŸŒ](https://github.com/GerHobbelt/sqlite_wrapper) -- an easy-to-use, lightweight and concurrency-friendly SQLite wrapper written in C++17.
- **sqlite_zstd_vfs** [ğŸ“](./sqlite_zstd_vfs) [ğŸŒ](https://github.com/GerHobbelt/sqlite_zstd_vfs) -- SQLite VFS extension providing streaming storage compression using Zstandard (Zstd), transparently compressing pages of the main database file as they're written out and later decompressing them as they're read in. It runs page de/compression on background threads and occasionally generates dictionaries to improve subsequent compression.











## metadata & text (OCR et al) -- language detect, suggesting fixes, ...

- **cld1-language-detect** [ğŸ“](./cld1-language-detect) [ğŸŒ](https://github.com/GerHobbelt/cld) -- the CLD (Compact Language Detection) library, extracted from the source code for Google's Chromium library. CLD1 probabilistically detects languages in Unicode UTF-8 text.
- **cld2-language-detect** [ğŸ“](./cld2-language-detect) [ğŸŒ](https://github.com/GerHobbelt/cld2) -- CLD2 probabilistically detects over 80 languages in Unicode UTF-8 text, either plain text or HTML/XML. For mixed-language input, CLD2 returns the top three languages found and their approximate percentages of the total text bytes.  Optionally, it also returns a vector of text spans with the language of each identified. The design target is web pages of at least 200 characters (about two sentences); CLD2 is not designed to do well on very short text.
- **cld3-language-detect** [ğŸ“](./cld3-language-detect) [ğŸŒ](https://github.com/GerHobbelt/cld3) -- CLD3 is a neural network model for language identification. The inference code extracts character ngrams from the input text and computes the fraction of times each of them appears. The model outputs BCP-47-style language codes, shown in the table below. For some languages, output is differentiated by script. Language and script names from Unicode CLDR.
- **compact_enc_det** [ğŸ“](./compact_enc_det) [ğŸŒ](https://github.com/GerHobbelt/compact_enc_det) -- Compact Encoding Detection (CED for short) is a library written in C++ that scans given raw bytes and detect the most likely text encoding.
- **cppjieba** [ğŸ“](./cppjieba) [ğŸŒ](https://github.com/GerHobbelt/cppjieba) -- the C++ version of the Chinese "Jieba" project:
  
  - Supports loading a custom user dictionary, using the '|' separator when multipathing or the ';' separator for separate, multiple, dictionaries.
  - Supports 'utf8' encoding.
  - The project comes with a relatively complete unit test, and the stability of the core function Chinese word segmentation (utf8) has been tested by the online environment.

- **detect-character-encoding** [ğŸ“](./detect-character-encoding) [ğŸŒ](https://github.com/GerHobbelt/detect-character-encoding) -- detect character encoding using [ICU](http://site.icu-project.org).  **Tip:** If you donâ€™t need ICU in particular, consider using [ced](https://github.com/sonicdoe/ced), which is based on Googleâ€™s lighter [compact_enc_det](https://github.com/google/compact_enc_det) library.
- **enca** [ğŸ“](./enca) [ğŸŒ](https://github.com/GerHobbelt/enca) -- Enca (Extremely Naive Charset Analyser) consists of two main components: `libenca`, an encoding detection library, and `enca`, a command line frontend, integrating libenca and several charset conversion libraries and tools (GNU `recode`, UNIX98 `iconv`, perl `Unicode::Map`, `cstocs`).
- **fastBPE** [ğŸ“](./fastBPE) [ğŸŒ](https://github.com/GerHobbelt/fastBPE) -- text tokenization / ngrams
- **fastText** [ğŸ“](./fastText) [ğŸŒ](https://github.com/GerHobbelt/fastText) -- [fastText](https://fasttext.cc/) is a library for efficient learning of word representations and sentence classification.
- **glyph_name** [ğŸ“](./glyph_name) [ğŸŒ](https://github.com/GerHobbelt/glyph_name) -- a library for computing Unicode sequences from glyph names according to the Adobe Glyph Naming convention: https://github.com/adobe-type-tools/agl-specification
- **libchardet** [ğŸ“](./libchardet) [ğŸŒ](https://github.com/GerHobbelt/libchardet) -- is based on Mozilla Universal Charset Detector library and, detects the character set used to encode data.
- **libchopshop** [ğŸ“](./libchopshop) [ğŸŒ](https://github.com/GerHobbelt/libchopshop) -- NLP/text processing with automated stop word detection and stemmer-based filtering. This library / toolkit is engineered to be able to provide **both** of the (often more or less disparate) n-gram token streams / vectors required for (1) initializing / training FTS databases, neural nets, etc. and (2) executing effective queries / matches on these engines.
- **libcppjieba** [ğŸ“](./libcppjieba) [ğŸŒ](https://github.com/GerHobbelt/libcppjieba) -- source code extracted from the [CppJieba] project to form a separate project, making it easier to understand and use.
- **libiconv** [ğŸ“](./libiconv) [ğŸŒ](https://github.com/GerHobbelt/libiconv-win-build) -- provides conversion between many platform, language or country dependent character encodings to & from Unicode. This library provides an `iconv()` implementation, for use on systems which don't have one, or whose implementation cannot convert from/to Unicode. It provides support for the encodings: European languages (ASCII, ISO-8859-{1,2,3,4,5,7,9,10,13,14,15,16}, KOI8-R, KOI8-U, KOI8-RU, CP{1250,1251,1252,1253,1254,1257}, CP{850,866,1131}, Mac{Roman,CentralEurope,Iceland,Croatian,Romania}, Mac{Cyrillic,Ukraine,Greek,Turkish}, Macintosh), Semitic languages (ISO-8859-{6,8}, CP{1255,1256}, CP862, Mac{Hebrew,Arabic}), Japanese (EUC-JP, SHIFT_JIS, CP932, ISO-2022-JP, ISO-2022-JP-2, ISO-2022-JP-1, ISO-2022-JP-MS), Chinese (EUC-CN, HZ, GBK, CP936, GB18030, EUC-TW, BIG5, CP950, BIG5-HKSCS, BIG5-HKSCS:2004, BIG5-HKSCS:2001, BIG5-HKSCS:1999, ISO-2022-CN, ISO-2022-CN-EXT), Korean (EUC-KR, CP949, ISO-2022-KR, JOHAB), Armenian (ARMSCII-8), Georgian (Georgian-Academy, Georgian-PS), Tajik (KOI8-T), Kazakh (PT154, RK1048), Thai (ISO-8859-11, TIS-620, CP874, MacThai), Laotian (MuleLao-1, CP1133), Vietnamese (VISCII, TCVN, CP1258), Platform specifics (HP-ROMAN8, NEXTSTEP), Full Unicode (UTF-8, UCS-2, UCS-2BE, UCS-2LE, UCS-4, UCS-4BE, UCS-4LE, UTF-16, UTF-16BE, UTF-16LE, UTF-32, UTF-32BE, UTF-32LE, UTF-7, C99, JAVA, UCS-2-INTERNAL, UCS-4-INTERNAL). It also provides support for a few extra encodings: European languages (CP{437,737,775,852,853,855,857,858,860,861,863,865,869,1125}), Semitic languages (CP864), Japanese (EUC-JISX0213, Shift_JISX0213, ISO-2022-JP-3), Chinese (BIG5-2003), Turkmen (TDS565), Platform specifics (ATARIST, RISCOS-LATIN1). It has also some limited support for transliteration, i.e. when a character cannot be represented in the target character set, it can be approximated through one or several similarly looking characters.
- **libpinyin** [ğŸ“](./libpinyin) [ğŸŒ](https://github.com/GerHobbelt/libpinyin) -- the libpinyin project aims to provide the algorithms core for intelligent sentence-based Chinese pinyin input methods.
- **libpostal** [ğŸ“](./libpostal) [ğŸŒ](https://github.com/GerHobbelt/libpostal) -- a C library for parsing/normalizing street addresses around the world using statistical NLP and open data. The goal of this project is to understand location-based strings in every language, everywhere.
- **libtextcat** [ğŸ“](./libtextcat) [ğŸŒ](https://github.com/GerHobbelt/libtextcat) -- text language detection
- **libunibreak** [ğŸ“](./libunibreak) [ğŸŒ](https://github.com/GerHobbelt/libunibreak) -- an implementation of the line breaking and word breaking algorithms as described in (Unicode Standard Annex 14)[http://www.unicode.org/reports/tr14/] and (Unicode Standard Annex 29)[http://www.unicode.org/reports/tr29/].
- **line_detector** [ğŸ“](./line_detector) [ğŸŒ](https://github.com/GerHobbelt/line_detector) -- line segment detector ([lsd](http://www.ipol.im/pub/art/2012/gjmr-lsd/)) &. edge drawing line detector (edl) &. hough line detector (standard &. probabilistic) for detection.
- **marian** [ğŸ“](./marian) [ğŸŒ](https://github.com/GerHobbelt/marian) -- an efficient Neural Machine Translation framework written in pure C++ with minimal dependencies.
- **pinyin** [ğŸ“](./pinyin) [ğŸŒ](https://github.com/GerHobbelt/pinyin) -- pÄ«nyÄ«n is a tool for converting Chinese characters to *pinyin*. It can be used for Chinese phonetic notation, sorting, and retrieval.
- **sentencepiece** [ğŸ“](./sentencepiece) [ğŸŒ](https://github.com/GerHobbelt/sentencepiece) -- text tokenization
- **sentence-tokenizer** [ğŸ“](./sentence-tokenizer) [ğŸŒ](https://github.com/GerHobbelt/Tokenizer) -- text tokenization
- **uchardet** [ğŸ“](./uchardet) [ğŸŒ](https://github.com/GerHobbelt/uchardet) -- [uchardet](https://www.freedesktop.org/wiki/Software/uchardet/) is an encoding and language detector library, which attempts to determine the encoding of the text. It can reliably detect many charsets. Moreover it also works as a very good and fast language detector.
- **ucto** [ğŸ“](./ucto) [ğŸŒ](https://github.com/GerHobbelt/ucto) -- text tokenization
  
  - **libfolia** [ğŸ“](./libfolia) [ğŸŒ](https://github.com/GerHobbelt/libfolia) -- working with the Format for Linguistic Annotation (FoLiA). Provides a high-level API to read, manipulate, and create FoLiA documents.
  - **uctodata** [ğŸ“](./uctodata) [ğŸŒ](https://github.com/GerHobbelt/uctodata) -- data for `ucto` library

- **unicode-cldr** [ğŸ“](./unicode-cldr) [ğŸŒ](https://github.com/GerHobbelt/cldr) -- Unicode CLDR Project: provides key building blocks for software to support the world's languages, with the largest and most extensive standard repository of locale data available. This data is used by a wide spectrum of companies for their software internationalization and localization, adapting software to the conventions of different languages for such common software tasks.
- **unicode-cldr-data** [ğŸ“](./unicode-cldr-data) [ğŸŒ](https://github.com/GerHobbelt/cldr-json) -- the JSON distribution of CLDR locale data for internationalization. While XML (not JSON) is the "official" format for all CLDR data, this data is programatically generated from the corresponding XML, using the CLDR tooling. This JSON data is generated using only data that has achieved draft="contributed" or draft="approved" status in the CLDR. This is the same threshhold as is used by the ICU (International Components for Unicode).
- **unicode-icu** [ğŸ“](./unicode-icu) [ğŸŒ](https://github.com/GerHobbelt/icu) -- the [International Components for Unicode](https://icu.unicode.org/).
- **unicode-icu-data** [ğŸ“](./unicode-icu-data) [ğŸŒ](https://github.com/GerHobbelt/icu-data) -- International Components for Unicode: Data Repository. This is an auxiliary repository for the International Components for Unicode.
- **unicode-icu-demos** [ğŸ“](./unicode-icu-demos) [ğŸŒ](https://github.com/GerHobbelt/icu-demos) -- ICU Demos contains sample applications built using the International Components for Unicode (ICU) C++ library ICU4C.
- **unilib** [ğŸ“](./unilib) [ğŸŒ](https://github.com/GerHobbelt/unilib) -- an embeddable C++17 Unicode library.
- **utfcpp** [ğŸ“](./utfcpp) [ğŸŒ](https://github.com/GerHobbelt/utfcpp) -- UTF-8 with C++ in a Portable Way
- **win-iconv** [ğŸ“](./win-iconv) [ğŸŒ](https://github.com/GerHobbelt/win-iconv) -- an `iconv` implementation using Win32 API to convert.
- **worde_butcher** [ğŸ“](./worde_butcher) [ğŸŒ](https://github.com/GerHobbelt/worde_butcher) -- a tool for text segmentation, keyword extraction and speech tagging. Butchers any text into prime word / phrase cuts, deboning all incoming based on our definitive set of stopwords for all languages.
- **xmunch** [ğŸ“](./xmunch) [ğŸŒ](https://github.com/GerHobbelt/xmunch) -- xmunch essentially does, what the 'munch' command of, for example, hunspell does, but is not compatible with hunspell affix definition files. So why use it then? What makes xmunch different from the other tools is the ability to extend incomplete word-lists. For hunspell's munch to identify a stem and add an affix mark, every word formed by the affix with the stem has to be in the original word-list. This makes sense for a compression tool. However if your word list is incomplete, you have to add all possible word-forms of a word first, before any compression is done. Using xmunch instead, you can define a subset of forms which are required to be in the word-list to allow the word to be used as stem. Like this, you can extend the word-list.
- **you-token-to-me** [ğŸ“](./you-token-to-me) [ğŸŒ](https://github.com/GerHobbelt/YouTokenToMe) -- text tokenization











## PDF (XML) metadata editing

for round-trip annotation and other "external application editing" of known documents; metadata embedding / *export*

- **PDFGen** [ğŸ“](./PDFGen) [ğŸŒ](https://github.com/GerHobbelt/PDFGen) -- a simple PDF Creation/Generation library, contained in a single C-file with header and no external library dependencies. Useful for embedding into other programs that require rudimentary PDF output.
- **pdfgrep** [ğŸ“](./pdfgrep) [ğŸŒ](https://github.com/GerHobbelt/pdfgrep) -- a tool to search text in PDF files. It works similarly to *grep*.
- **pdfium** [ğŸ“](./pdfium) [ğŸŒ](https://github.com/GerHobbelt/pdfium) -- the PDF library used by the Chromium project.
- **podofo** [ğŸ“](./podofo) [ğŸŒ](https://github.com/GerHobbelt/podofo) -- a library to work with the PDF file format and includes also a few tools. The name comes from the first two letters of PDF (<b>Po</b>rtable <b>Do</b>cument <b>Fo</b>rmat). The PoDoFo library is a free portable C++ library which includes classes to parse a PDF file and modify its contents into memory. The changes can be written back to disk easily. PoDoFo is designed to avoid loading large PDF objects into memory until they are required and can write large streams immediately to disk, so it is possible to manipulate quite large files with it.
- **poppler** [ğŸ“](./poppler) [ğŸŒ](https://github.com/GerHobbelt/poppler) -- Poppler is a library for rendering PDF files, and examining or modifying their structure.  Poppler originally came from the XPDF sources.
- **qpdf** [ğŸ“](./qpdf) [ğŸŒ](https://github.com/GerHobbelt/qpdf) -- QPDF is a command-line tool and C++ library that performs content-preserving transformations on PDF files. It supports linearization, encryption, and numerous other features. It can also be used for splitting and merging files, creating PDF files, and inspecting files for study or analysis. QPDF does not render PDFs or perform text extraction, and it does not contain higher-level interfaces for working with page contents. It is a low-level tool for working with the structure of PDF files and can be a valuable tool for anyone who wants to do programmatic or command-line-based manipulation of PDF files.
- **sioyek** [ğŸ“](./sioyek) [ğŸŒ](https://github.com/GerHobbelt/sioyek) -- a PDF viewer with a focus on textbooks and research papers.
- **sumatrapdf** [ğŸ“](./sumatrapdf) [ğŸŒ](https://github.com/GerHobbelt/sumatrapdf) -- SumatraPDF is a multi-format (PDF, EPUB, MOBI, CBZ, CBR, FB2, CHM, XPS, DjVu) reader for Windows.
- **XMP-Toolkit-SDK** [ğŸ“](./XMP-Toolkit-SDK) [ğŸŒ](https://github.com/GerHobbelt/XMP-Toolkit-SDK) -- the XMP Toolkit allows you to integrate XMP functionality into your product, supplying an API for locating, adding, or updating the XMP metadata in a file.
- **xpdf** [ğŸ“](./xpdf) [ğŸŒ](https://github.com/GerHobbelt/xpdf) -- Xpdf is an open source viewer for Portable Document Format (PDF) files.











## web scraping (document extraction, cleaning, metadata extraction, BibTeX, ...)

(see also investigation notes in Qiqqa docs)

- **boost-url** [ğŸ“](./boost-url) [ğŸŒ](https://github.com/GerHobbelt/boost-url) -- a library for manipulating (RFC3986) Uniform Resource Identifiers (URIs) and Locators (URLs).
- **cURL** [ğŸ“](../../thirdparty/curl) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-curl) -- the ubiquitous [libcurl](http://curl.haxx.se/libcurl).
- **curl-impersonate** [ğŸ“](./curl-impersonate) [ğŸŒ](https://github.com/GerHobbelt/curl-impersonate) -- a special build of [curl](https://github.com/curl/curl) that can impersonate the four major browsers: Chrome, Edge, Safari & Firefox. curl-impersonate is able to perform TLS and HTTP handshakes that are identical to that of a real browser.
- **curl-www** [ğŸ“](./curl-www) [ğŸŒ](https://github.com/GerHobbelt/curl-www) -- the curl.se web site contents.
- **easyexif** [ğŸ“](./easyexif) [ğŸŒ](https://github.com/GerHobbelt/easyexif) -- EasyEXIF is a tiny, lightweight C++ library that parses basic (EXIF) information out of JPEG files. It uses only the std::string library and is otherwise pure C++. You pass it the binary contents of a JPEG file, and it parses several of the most important EXIF fields for you.
- **everything-curl** [ğŸ“](./everything-curl) [ğŸŒ](https://github.com/GerHobbelt/everything-curl) -- *Everything curl* is an extensive guide for all things curl. The project, the command-line tool, the library, how everything started and how it came to be the useful tool it is today. It explains how we work on developing it further, what it takes to use it, how you can contribute with code or bug reports and why millions of existing users use it.
- **exiv2** [ğŸ“](./exiv2) [ğŸŒ](https://github.com/GerHobbelt/exiv2) -- a C++ library and a command-line utility to read, write, delete and modify Exif, IPTC, XMP and ICC image metadata.
- **extract** [ğŸ“](../../thirdparty/extract) [ğŸŒ](https://github.com/GerHobbelt/thirdparty_extract) -- clone of git://git.ghostscript.com/extract.git
- **faup** [ğŸ“](./faup) [ğŸŒ](https://github.com/GerHobbelt/faup) -- **Faup** stands for Finally An Url Parser and is a library and command line tool to parse URLs and normalize fields with two constraints: (1) work with real-life urls (resilient to badly formated ones), and (2) be fast: no allocation for string parsing and read characters only once.
- **GQ-gumbo-css-selectors** [ğŸ“](./GQ-gumbo-css-selectors) [ğŸŒ](https://github.com/GerHobbelt/GQ) -- GQ is a CSS Selector Engine for [Gumbo Parser](https://github.com/google/gumbo-parser) written in C++11. Using Gumbo Parser as a backend, GQ can parse input HTML and allow users to select and modify elements in the parsed document with CSS Selectors and the provided simple, but powerful mutation API.
- **gumbo-libxml** [ğŸ“](./gumbo-libxml) [ğŸŒ](https://github.com/GerHobbelt/gumbo-libxml) -- LibXML2 bindings for the Gumbo HTML5 parser: this provides a libxml2 API on top of the Gumbo parser.  It lets you use a modern parser - Gumbo now passes all html5lib tests, including the template tag, and should be fully conformant with the HTML5 spec - with the full ecosystem of libxml tools, including XPath, tree modification, DTD validation, etc.
- **gumbo-parser** [ğŸ“](../../thirdparty/gumbo-parser) [ğŸŒ](https://github.com/GerHobbelt/gumbo-parser) -- HTML parser
- **gumbo_pp** [ğŸ“](./gumbo_pp) [ğŸŒ](https://github.com/GerHobbelt/gumbo_pp) -- a C++ wrapper over Gumbo that provides a higher level query mechanism.
- **gumbo-query** [ğŸ“](./gumbo-query) [ğŸŒ](https://github.com/GerHobbelt/gumbo-query) -- HTML DOM access in C/C++
- **hescape** [ğŸ“](./hescape) [ğŸŒ](https://github.com/GerHobbelt/hescape) -- a C library for fast HTML escape using SSE instruction, `pcmpestri`. Hescape provides only one API, `hesc_escape_html()`.
- **houdini** [ğŸ“](./houdini) [ğŸŒ](https://github.com/GerHobbelt/houdini) -- Houdini - The Escapist: is zero-dependency and modular. Houdini is a simple API for escaping text for the web. And unescaping it. HTML escaping follows the OWASP suggestion. All other entities are left as-is. HTML unescaping is fully RFC-compliant. Yes, that's the 253 different entities for you, and decimal/hex code point specifiers. URI escaping and unescaping is fully RFC-compliant. URL escaping and unescaping is the same as generic URIs, but spaces are changed to `+`.
- **htmlstreamparser** [ğŸ“](./htmlstreamparser) [ğŸŒ](https://github.com/GerHobbelt/htmlstreamparser) -- used in a demo of zsync2
- **http-parser** [ğŸ“](./http-parser) [ğŸŒ](https://github.com/GerHobbelt/http-parser) -- a parser for HTTP messages written in C. It parses both requests and responses. The parser is designed to be used in performance HTTP applications. It does not make any syscalls nor allocations, it does not buffer data, it can be interrupted at anytime. Depending on your architecture, it only requires about 40 bytes of data per message stream (in a web server that is per connection).
- **lexbor** [ğŸ“](./lexbor) [ğŸŒ](https://github.com/GerHobbelt/lexbor) -- fast HTML5 fully-conformant HTML + CSS parser.
- **libcpr** [ğŸ“](./libcpr) [ğŸŒ](https://github.com/GerHobbelt/cpr) -- wrapper library for cURL. C++ Requests is a simple wrapper around [libcurl](http://curl.haxx.se/libcurl) inspired by the excellent [Python Requests](https://github.com/kennethreitz/requests) project. Despite its name, libcurl's easy interface is anything but, and making mistakes misusing it is a common source of error and frustration. Using the more expressive language facilities of C++11, this library captures the essence of making network calls into a few concise idioms.
- **libexpat** [ğŸ“](./libexpat) [ğŸŒ](https://github.com/GerHobbelt/libexpat) -- XML read/write
- **libhog** [ğŸ“](./libhog) [ğŸŒ](https://github.com/GerHobbelt/libhog) -- `hog` a.k.a. `hound` - fetch the (PDF,EPUB,HTML) document you seek using maximum effort: `hog` is a tool for fetching *files* from the internet, specifically PDFs. Intended to be used where you browse the 'Net and decide you want to download a given PDF from any site: this can be done through the browser itself, but is sometimes convoluted or neigh impossible (ftp links require another tool, PDFs stored at servers which report as having their SSL certificates *expired* are a hassle to get through for the user-in-a-hurry, etc. etc.) and `hog` is meant to cope with all these.
- **libidn2** [ğŸ“](./libidn2) [ğŸŒ](https://github.com/GerHobbelt/libidn2) -- international domain name parsing
- **libpsl** [ğŸ“](./libpsl) [ğŸŒ](https://github.com/GerHobbelt/libpsl) -- handles the *Public Suffix List* (a collection of Top Level Domains (TLDs) suffixes, e.g. `.com`, `.net`, *Country Top Level Domains* (ccTLDs) like `.de` and `.cn` and *[Brand Top Level Domains](https://icannwiki.org/Brand_TLD)* like `.apple` and `.google`. Can be used to:
  
  - avoid privacy-leaking "super domain" certificates ([see post from Jeffry Walton](https://lists.gnu.org/archive/html/bug-wget/2014-03/msg00093.html))
  - avoid privacy-leaking "supercookies"
  - domain highlighting parts of the domain in a user interface
  - sorting domain lists by site

- **libxml2** [ğŸ“](./libxml2) [ğŸŒ](https://github.com/GerHobbelt/libxml2) -- [libxml](http://xmlsoft.org/): XML read/write
- **LLhttp-parser** [ğŸ“](./LLhttp-parser) [ğŸŒ](https://github.com/GerHobbelt/llhttp) -- a port and replacement of [http_parser](https://github.com/nodejs/http-parser) to TypeScript. [llparse](https://github.com/nodejs/llparse) is used to generate the output C source file, which could be compiled and linked with the embedder's program (like Node.js).
- **picohttpparser** [ğŸ“](./picohttpparser) [ğŸŒ](https://github.com/GerHobbelt/picohttpparser) -- PicoHTTPParser is a tiny, primitive, fast HTTP request/response parser. Unlike most parsers, it is stateless and does not allocate memory by itself. All it does is accept pointer to buffer and the output structure, and setups the pointers in the latter to point at the necessary portions of the buffer.
- **qs_parse** [ğŸ“](./qs_parse) [ğŸŒ](https://github.com/GerHobbelt/qs_parse) -- a set of simple and easy functions for parsing URL query strings, such as those generated in an HTTP GET form submission.
- **robotstxt** [ğŸ“](./robotstxt) [ğŸŒ](https://github.com/GerHobbelt/robotstxt) -- Google `robots.txt` Parser and Matcher Library. The Robots Exclusion Protocol (REP) is a standard that enables website owners to control which URLs may be accessed by automated clients (i.e. crawlers) through a simple text file with a specific syntax. It's one of the basic building blocks of the internet as we know it and what allows search engines to operate. Because the REP was only a de-facto standard for the past 25 years, different implementers implement parsing of robots.txt slightly differently, leading to confusion. This project aims to fix that by releasing the parser that Google uses.
- **sist2** [ğŸ“](./sist2) [ğŸŒ](https://github.com/GerHobbelt/sist2) -- sist2 (Simple incremental search tool) is a fast, low memory usage, multi-threaded application, which scans drives and directory trees, extracts text and metadata from common file types, generates thumbnails and comes with OCR support (with tesseract) and  Named-Entity Recognition (using pre-trained client-side tensorflow models).
- **tidy-html5** [ğŸ“](./tidy-html5) [ğŸŒ](https://github.com/GerHobbelt/tidy-html5) -- clean up HTML documents before archiving/processing
- **URI-Encode-C** [ğŸ“](./URI-Encode-C) [ğŸŒ](https://github.com/GerHobbelt/URI-Encode-C) -- an optimized C library for percent encoding/decoding text, i.e. a URI encoder/decoder written in C based on [RFC3986](https://tools.ietf.org/html/rfc3986).
- **url** [ğŸ“](./url) [ğŸŒ](https://github.com/GerHobbelt/url) -- URI parsing and other utility functions
- **URL-Detector** [ğŸ“](./URL-Detector) [ğŸŒ](https://github.com/GerHobbelt/URL-Detector) -- Url Detector is a library created by the Linkedin Security Team to detect and extract urls in a long piece of text. Keep in mind that for security purposes, its better to overdetect urls: instead of complying with RFC 3986 (http://www.ietf.org/rfc/rfc3986.txt), we try to detect based on browser behavior, optimizing detection for urls that are visitable through the address bar of Chrome, Firefox, Internet Explorer, and Safari. It is also able to identify the parts of the identified urls.
- **url-parser** [ğŸ“](./url-parser) [ğŸŒ](https://github.com/GerHobbelt/url.h) -- parse URLs much like Node's [url](http://nodejs.org/api/url.html) module.
- **wget2** [ğŸ“](./wget2) [ğŸŒ](https://github.com/GerHobbelt/wget2) -- GNU Wget2 is the successor of GNU Wget, a file and recursive website downloader. Designed and written from scratch it wraps around libwget, that provides the basic functions needed by a web client. Wget2 works multi-threaded and uses many features to allow fast operation. In many cases Wget2 downloads much faster than Wget1.x due to HTTP2, HTTP compression, parallel connections and use of If-Modified-Since HTTP header.
- **xml-pugixml** [ğŸ“](./xml-pugixml) [ğŸŒ](https://github.com/GerHobbelt/pugixml) -- light-weight, simple and fast XML parser for C++ with XPath support.











## audio files & processing

Not just speech processing & speech recognition, but sometimes data is easier "visualized" as audio (sound).

- **AudioFile** [ğŸ“](./AudioFile) [ğŸŒ](https://github.com/GerHobbelt/AudioFile) -- a simple header-only C++ library for reading and writing audio files. (WAV, AIFF)
- **dr_libs** [ğŸ“](./dr_libs) [ğŸŒ](https://github.com/GerHobbelt/dr_libs) -- single file audio decoding libraries for C and C++ (FLAC, MP3, WAV)
- **flac** [ğŸ“](./flac) [ğŸŒ](https://github.com/GerHobbelt/flac) -- a software that can reduce the amount of storage space needed to store digital audio signals without needing to remove information in doing so. The files read and produced by this software are called FLAC files. As these files (which follow the [FLAC format](https://xiph.org/flac/format.html)) can be read from and written to by other software as well, this software is often referred to as the FLAC reference implementation.
- **libsndfile** [ğŸ“](./libsndfile) [ğŸŒ](https://github.com/GerHobbelt/libsndfile) -- a C library for reading and writing files containing sampled audio data, e.g. Ogg, Vorbis and FLAC.
- **minimp3** [ğŸ“](./minimp3) [ğŸŒ](https://github.com/GerHobbelt/minimp3) -- a minimalistic, single-header library for decoding MP3. minimp3 is designed to be small, fast (with SSE and NEON support), and accurate (ISO conformant).
- **opus** [ğŸ“](./opus) [ğŸŒ](https://github.com/GerHobbelt/opus) -- an audio codec for interactive speech and audio transmission over the Internet. Opus can handle a wide range of interactive audio applications, including Voice over IP, videoconferencing, in-game  chat, and even remote live music performances. It can scale from low bit-rate narrowband speech to very high quality stereo music.
- **qoa** [ğŸ“](./qoa) [ğŸŒ](https://github.com/GerHobbelt/qoa) -- QOA - The â€œQuite OK Audio Formatâ€ for fast, lossy audio compression - is a single-file library for C/C++.  More info at: https://qoaformat.org
- **r8brain-free-src** [ğŸ“](./r8brain-free-src) [ğŸŒ](https://github.com/GerHobbelt/r8brain-free-src) -- high-quality professional audio sample rate converter (SRC) / resampler C++ library.  Features routines for SRC, both up- and downsampling, to/from any sample rate, including non-integer sample rates: it can be also used for conversion to/from SACD/DSD sample rates, and even go beyond that. Also suitable for fast general-purpose 1D time-series resampling / interpolation (with relaxed filter parameters).
- **sac** [ğŸ“](./sac) [ğŸŒ](https://github.com/GerHobbelt/sac) -- a state-of-the-art lossless audio compression model. Lossless audio compression is a complex problem, because PCM data is highly non-stationary and uses high sample resolution (typically >=16bit). That's why classic context modelling suffers from context dilution problems. Sac employs a simple OLS-NLMS predictor per frame including bias correction. Prediction residuals are encoded using a sophisticated bitplane coder including SSE and various forms of probability estimations. Meta-parameters of the predictor are optimized via binary search (or [DDS](https://agupubs.onlinelibrary.wiley.com/doi/10.1029/2005WR004723)) on by-frame basis. This results in a highly asymmetric codec design. We throw a lot of muscles at the problem and archive only little gains - by practically predicting noise.
- **silk-codec** [ğŸ“](./silk-codec) [ğŸŒ](https://github.com/GerHobbelt/silk-codec) -- a library to convert PCM to TenCent Silk files and vice versa.
- **silk-v3-decoder** [ğŸ“](./silk-v3-decoder) [ğŸŒ](https://github.com/GerHobbelt/silk-v3-decoder) -- decodes Silk v3 audio files (like WeChat amr, aud files, qq slk files) and converts to other formats (like mp3).
- **Solo** [ğŸ“](./Solo) [ğŸŒ](https://github.com/GerHobbelt/Solo) -- Agora SOLO is a speech codec, developed based on Silk with BWE(Bandwidth Extension) and MDC(Multi Description Coding). With these technologies, SOLO is able to resist weak networks at low bitrates. The main reason for SOLO to use bandwidth expansion is to reduce the computational complexity.
- **speex** [ğŸ“](./speex) [ğŸŒ](https://github.com/GerHobbelt/speex) -- a patent-free voice codec. Unlike other codecs like MP3 and Ogg Vorbis, Speex is designed to compress voice at bitrates in the 2-45 kbps range. Possible applications include VoIP, internet audio streaming, archiving of speech data (e.g. voice mail), and audio books.











## file format support

- **AudioFile** [ğŸ“](./AudioFile) [ğŸŒ](https://github.com/GerHobbelt/AudioFile) -- a simple header-only C++ library for reading and writing audio files. (WAV, AIFF)
- **basez** [ğŸ“](./basez) [ğŸŒ](https://github.com/GerHobbelt/basez) -- encode data into/decode data from base16, base32, base32hex, base64 or base64url stream per RFC 4648; MIME base64 Content-Transfer-Encoding per RFC 2045; or PEM Printable Encoding per RFC 1421.
- **CHM-lib** [ğŸ“](./CHM-lib) [ğŸŒ](https://github.com/GerHobbelt/CHMLib) -- as I have several HTML pages stored in this format. See also MHTML: `mht-rip`
- **csv-parser** [ğŸ“](./csv-parser) [ğŸŒ](https://github.com/GerHobbelt/csv-parser) -- Vince's CSV Parser: there's plenty of other CSV parsers in the wild, but I had a hard time finding what I wanted. Inspired by Python's `csv` module, I wanted a library with **simple, intuitive syntax**. Furthermore, I wanted support for special use cases such as calculating statistics on very large files. Thus, this library was created with these following goals in mind.
- **cvmatio** [ğŸ“](./cvmatio) [ğŸŒ](https://github.com/GerHobbelt/cvmatio) -- an open source Matlab v7 MAT file parser written in C++, giving users the ability to interact with binary MAT files in their own projects.
- **datamash** [ğŸ“](./datamash) [ğŸŒ](https://github.com/GerHobbelt/datamash) -- GNU Datamash is a command-line program which performs basic numeric, textual and statistical operations on input textual data files. It is designed to be portable and reliable, and aid researchers to easily automate analysis pipelines, without writing code or even short scripts.
- **djvulibre** [ğŸ“](./djvulibre) [ğŸŒ](https://github.com/GerHobbelt/djvulibre) -- DjVu (pronounced "dÃ©jÃ  vu") a set of compression technologies, a file format, and a software platform for the delivery over the Web of digital documents, scanned documents, and high resolution images.
- **extract** [ğŸ“](../../thirdparty/extract) [ğŸŒ](https://github.com/GerHobbelt/thirdparty_extract) -- clone of git://git.ghostscript.com/extract.git
- **fastgron** [ğŸ“](./fastgron) [ğŸŒ](https://github.com/GerHobbelt/fastgron) -- `fastgron` makes JSON greppable super fast! `fastgron` transforms JSON into discrete assignments to make it easier to grep for what you want and see the absolute 'path' to it. It eases the exploration of APIs that return large blobs of JSON but lack documentation.
- **FFmpeg** [ğŸ“](./FFmpeg) [ğŸŒ](https://github.com/GerHobbelt/FFmpeg) -- a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata.
- **file** [ğŸ“](./file) [ğŸŒ](https://github.com/GerHobbelt/file) -- `file` filetype recognizer tool & mimemagic
- **flac** [ğŸ“](./flac) [ğŸŒ](https://github.com/GerHobbelt/flac) -- a software that can reduce the amount of storage space needed to store digital audio signals without needing to remove information in doing so. The files read and produced by this software are called FLAC files. As these files (which follow the [FLAC format](https://xiph.org/flac/format.html)) can be read from and written to by other software as well, this software is often referred to as the FLAC reference implementation.
- **gmt** [ğŸ“](./gmt) [ğŸŒ](https://github.com/GerHobbelt/gmt) -- GMT (Generic Mapping Tools) is an open source collection of about 100 command-line tools for manipulating geographic and Cartesian data sets (including filtering, trend fitting, gridding, projecting, etc.) and producing high-quality illustrations ranging from simple x-y plots via contour maps to artificially illuminated surfaces, 3D perspective views and animations. The GMT supplements add another 50 more specialized and discipline-specific tools. GMT supports over 30 map projections and transformations and requires support data such as [GSHHG](http://www.soest.hawaii.edu/pwessel/gshhg/) coastlines, rivers, and political boundaries and optionally [DCW](http://www.soest.hawaii.edu/pwessel/dcw) country polygons.
- **gumbo-libxml** [ğŸ“](./gumbo-libxml) [ğŸŒ](https://github.com/GerHobbelt/gumbo-libxml) -- LibXML2 bindings for the Gumbo HTML5 parser: this provides a libxml2 API on top of the Gumbo parser.  It lets you use a modern parser - Gumbo now passes all html5lib tests, including the template tag, and should be fully conformant with the HTML5 spec - with the full ecosystem of libxml tools, including XPath, tree modification, DTD validation, etc.
- **gumbo-parser** [ğŸ“](../../thirdparty/gumbo-parser) [ğŸŒ](https://github.com/GerHobbelt/gumbo-parser) -- HTML parser
- **gumbo_pp** [ğŸ“](./gumbo_pp) [ğŸŒ](https://github.com/GerHobbelt/gumbo_pp) -- a C++ wrapper over Gumbo that provides a higher level query mechanism.
- **gumbo-query** [ğŸ“](./gumbo-query) [ğŸŒ](https://github.com/GerHobbelt/gumbo-query) -- HTML DOM access in C/C++
- **http-parser** [ğŸ“](./http-parser) [ğŸŒ](https://github.com/GerHobbelt/http-parser) -- a parser for HTTP messages written in C. It parses both requests and responses. The parser is designed to be used in performance HTTP applications. It does not make any syscalls nor allocations, it does not buffer data, it can be interrupted at anytime. Depending on your architecture, it only requires about 40 bytes of data per message stream (in a web server that is per connection).
- **id3-tagparser** [ğŸ“](./id3-tagparser) [ğŸŒ](https://github.com/GerHobbelt/tagparser) -- a C++ library for reading and writing MP4 (iTunes), ID3, Vorbis, Opus, FLAC and Matroska tags.
- **jq** [ğŸ“](./jq) [ğŸŒ](https://github.com/GerHobbelt/jq) -- a lightweight and flexible command-line JSON processor.
- **jtc** [ğŸ“](./jtc) [ğŸŒ](https://github.com/GerHobbelt/jtc) -- `jtc` stand for: **_JSON transformational chains_** (used to be _JSON test console_) and is a cli tool to extract, manipulate and transform source JSON, offering powerful ways to select one or multiple elements from a source JSON and apply various actions on the selected elements at once (wrap selected elements into a new JSON, filter in/out, sort elements, update elements, insert new elements, remove, copy, move, compare, transform, swap around and many other operations).
- **lexbor** [ğŸ“](./lexbor) [ğŸŒ](https://github.com/GerHobbelt/lexbor) -- fast HTML5 fully-conformant HTML + CSS parser.
- **libaom** [ğŸ“](./libaom) [ğŸŒ](https://github.com/GerHobbelt/libaom) -- AV1 Codec Library
- **libarchive** [ğŸ“](./libarchive) [ğŸŒ](https://github.com/GerHobbelt/libarchive) -- a portable, efficient C library that can read and write streaming archives in a variety of formats. It also includes implementations of the common `tar`, `cpio`, and `zcat` command-line tools that use the libarchive library.
- **libase** [ğŸ“](./libase) [ğŸŒ](https://github.com/GerHobbelt/libase) -- a tiny library for interpreting the Adobe Swatch Exchange (`.ase`) file format for color palettes since Adobe Creative Suite 3.
- **libass** [ğŸ“](./libass) [ğŸŒ](https://github.com/GerHobbelt/libass) -- `libass` is a portable subtitle renderer for the ASS/SSA (Advanced Substation Alpha/Substation Alpha) subtitle format.
- **libavif** [ğŸ“](./libavif) [ğŸŒ](https://github.com/GerHobbelt/libavif) -- a friendly, portable C implementation of the AV1 Image File Format, as described here: <https://aomediacodec.github.io/av1-avif/>
- **libcmime** [ğŸ“](./libcmime) [ğŸŒ](https://github.com/GerHobbelt/libcmime) -- MIME extract/insert/encode/decode: use for MHTML support
- **libcsv2** [ğŸ“](./libcsv2) [ğŸŒ](https://github.com/GerHobbelt/csv2) -- CSV file format reader/writer library.
- **libde265** [ğŸ“](./libde265) [ğŸŒ](https://github.com/GerHobbelt/libde265) -- libde265 is an open source implementation of the h.265 video codec. It is written from scratch and has a plain C API to enable a simple integration into other software. libde265 supports WPP and tile-based multithreading and includes SSE optimizations. The decoder includes all features of the Main profile and correctly decodes almost all conformance streams (see [[wiki page](https://github.com/strukturag/libde265/wiki/Decoder-conformance)]).
- **libexpat** [ğŸ“](./libexpat) [ğŸŒ](https://github.com/GerHobbelt/libexpat) -- XML read/write
- **libheif** [ğŸ“](./libheif) [ğŸŒ](https://github.com/GerHobbelt/heif) -- High Efficiency Image File Format (HEIF) :: a visual media container format standardized by the Moving Picture Experts Group (MPEG) for storage and sharing of images and image sequences. It is based on the well-known ISO Base Media File Format (ISOBMFF) standard. HEIF Reader/Writer Engine is an implementation of HEIF standard in order to demonstrate its powerful features and capabilities.
- **libheif-alt** [ğŸ“](./libheif-alt) [ğŸŒ](https://github.com/GerHobbelt/libheif) -- an ISO/IEC 23008-12:2017 HEIF and AVIF (AV1 Image File Format) file format decoder and encoder. HEIF and AVIF are new image file formats employing HEVC (h.265) or AV1 image coding, respectively, for the best compression ratios currently possible.
- **libics** [ğŸ“](./libics) [ğŸŒ](https://github.com/GerHobbelt/libics) -- the reference library for ICS (Image Cytometry Standard), an open standard for writing images of any dimensionality and data type to file, together with associated information regarding the recording equipment or recorded subject.
  
  ICS stands for Image Cytometry Standard, and was first proposed in: P. Dean, L. Mascio, D. Ow, D. Sudar, J. Mullikin, "Propsed standard for image cytometry data files", Cytometry, n.11, pp.561-569, 1990. 
  
  It writes 2 files, one is the header, with an '.ics' extension, and the other is the actual image data (with an '.ids' extension.)
  
  ICS version 2.0 extends this standard to allow for a more versatile placement of the image data. It can now be placed either in the same '.ics' file or inbedded in any other file, by specifying the file name and the byte offset for the data.
  
  The advantage of ICS over other open standards such as TIFF is that it allows data of any type and dimensionality to be stored. A TIFF file can contain a collection of 2D images; it's up to the user to determine how these relate to each other. An ICS file can contain, for exmaple, a 5D image in which the 4th dimension is the light frequency and the 5th time. Also, all of the information regarding the microscope settings (or whatever instument was used to acquire the image) and the sample preparation can be included in the file.

- **libmetalink** [ğŸ“](./libmetalink) [ğŸŒ](https://github.com/GerHobbelt/libmetalink) -- a library to read Metalink XML download description format. It supports both [_Metalink version 3_](http://www.metalinker.org/Metalink_3.0_Spec.pdf) and [_Metalink version 4 (RFC 5854)_](https://tools.ietf.org/html/rfc5854).
- **libmobi** [ğŸ“](./libmobi) [ğŸŒ](https://github.com/GerHobbelt/libmobi) -- a library for handling Mobipocket/Kindle (MOBI) ebook format documents.
- **libpsd** [ğŸ“](./libpsd) [ğŸŒ](https://github.com/GerHobbelt/libpsd) -- a library for Adobe Photoshop `.psd` file's decoding and rendering.
- **libsndfile** [ğŸ“](./libsndfile) [ğŸŒ](https://github.com/GerHobbelt/libsndfile) -- a C library for reading and writing files containing sampled audio data, e.g. Ogg, Vorbis and FLAC.
- **libwarc** [ğŸ“](./libwarc) [ğŸŒ](https://github.com/GerHobbelt/libwarc) -- C++ library to parse WARC files. WARC is the official storage format of the Internet Archive for storing scraped content. WARC format used: http://bibnum.bnf.fr/WARC/WARC_ISO_28500_version1_latestdraft.pdf
- **libxml2** [ğŸ“](./libxml2) [ğŸŒ](https://github.com/GerHobbelt/libxml2) -- [libxml](http://xmlsoft.org/): XML read/write
- **libzip** [ğŸ“](./libzip) [ğŸŒ](https://github.com/GerHobbelt/libzip) -- a C library for reading, creating, and modifying zip and zip64 archives.
- **LLhttp-parser** [ğŸ“](./LLhttp-parser) [ğŸŒ](https://github.com/GerHobbelt/llhttp) -- a port and replacement of [http_parser](https://github.com/nodejs/http-parser) to TypeScript. [llparse](https://github.com/nodejs/llparse) is used to generate the output C source file, which could be compiled and linked with the embedder's program (like Node.js).
- **mcmd** [ğŸ“](./mcmd) [ğŸŒ](https://github.com/GerHobbelt/mcmd) -- MCMD (M-Command): a set of commands for handling large scale CSV data. **MCMD** (called as M-Command) is a set of commands that are developed for the purpose of high-speed processing of large-scale structured tabular data in CSV format. It is possible to efficiently process large scale data with hundred millions row of records on a standard PC.
- **metalink-cli** [ğŸ“](./metalink-cli) [ğŸŒ](https://github.com/GerHobbelt/command) -- a small program which generates a metalink record on `stdout` for every file given on the commandline and using the mirror list from `stdin`.
- **metalink-mini-downloader** [ğŸ“](./metalink-mini-downloader) [ğŸŒ](https://github.com/GerHobbelt/mini-downloader) -- a small metalink downloader written in C++, using boost, libcurl and expat. It can either be compiled so that it downloads a specific file and then (optionally) launches it or be compiled into a "downloader template", which can later be used to create a custom downloader by replacing text strings inside the executable (they are marked in a special way, to make this easy).
- **mht-rip** [ğŸ“](./mht-rip) [ğŸŒ](https://github.com/GerHobbelt/mht-rip) -- as I have several HTML pages stored in this MHTML format. See also CHM: `CHM-lib`
- **mime-mega** [ğŸ“](./mime-mega) [ğŸŒ](https://github.com/GerHobbelt/MegaMimes) -- MIME extract/insert/encode/decode: use for MHTML support
- **mimetic** [ğŸ“](./mimetic) [ğŸŒ](https://github.com/GerHobbelt/mimetic) -- MIME: use for MHTML support
- **minizip-ng** [ğŸ“](./minizip-ng) [ğŸŒ](https://github.com/GerHobbelt/minizip-ng) -- a zip manipulation library written in C that is supported on Windows, macOS, and Linux. Minizip was originally developed by [Gilles Vollant](https://www.winimage.com/zLibDll/minizip.html) in 1998. It was first included in the zlib distribution as an additional code contribution starting in zlib 1.1.2. Since that time, it has been continually improved upon and contributed to by many people. The original [project](https://github.com/madler/zlib/tree/master/contrib/minizip) can still be found in the zlib distribution that is maintained by Mark Adler.
- **netpbm** [ğŸ“](./netpbm) [ğŸŒ](https://github.com/GerHobbelt/netpbm-mirror) -- a toolkit for manipulation of graphic images, including conversion of images between a variety of different formats.  There are over 300 separate tools in the package including converters for about 100 graphics formats.  Examples of the sort of image manipulation we're talking about are: Shrinking an image by 10%; Cutting the top half off of an image; Making a mirror image; Creating a sequence of images that fade from one image to another, etc.
- **OpenEXR** [ğŸ“](./OpenEXR) [ğŸŒ](https://github.com/GerHobbelt/openexr) -- a high dynamic-range (HDR) image file format developed by Industrial Light & Magic (ILM) for use in computer imaging applications.
- **openexr-images** [ğŸ“](./openexr-images) [ğŸŒ](https://github.com/GerHobbelt/openexr-images) -- collection of images associated with the OpenEXR distribution.
- **pdf2htmlEX** [ğŸ“](./pdf2htmlEX) [ğŸŒ](https://github.com/GerHobbelt/pdf2htmlEX) -- convert PDF to HTML without losing text or format.
- **picohttpparser** [ğŸ“](./picohttpparser) [ğŸŒ](https://github.com/GerHobbelt/picohttpparser) -- PicoHTTPParser is a tiny, primitive, fast HTTP request/response parser. Unlike most parsers, it is stateless and does not allocate memory by itself. All it does is accept pointer to buffer and the output structure, and setups the pointers in the latter to point at the necessary portions of the buffer.
- **pisa_formatter** [ğŸ“](./pisa_formatter) [ğŸŒ](https://github.com/GerHobbelt/pisa_formatter) -- converts list of documents to the [pisa-engine](https://github.com/pisa-engine/pisa) binary format: {.docs, .freqs, .sizes}. Its input should be a text file where each line is a document.  Each document starts with the document name (which should not have whitespaces) followed by a list of ascii terms separated by whitespaces which define the document. This also generates a binary .terms file which has the information to convert from term to index and is used by the query_transformer executable. This file stores all the unique terms from all the documents.
- **psd_sdk** [ğŸ“](./psd_sdk) [ğŸŒ](https://github.com/GerHobbelt/psd_sdk) -- a C++ library that directly reads Photoshop PSD files. The library supports:
  
  * Groups
  * Nested layers
  * Smart Objects
  * User and vector masks
  * Transparency masks and additional alpha channels
  * 8-bit, 16-bit, and 32-bit data in grayscale and RGB color mode
  * All compression types known to Photoshop
  
  Additionally, limited export functionality is also supported.

- **qs_parse** [ğŸ“](./qs_parse) [ğŸŒ](https://github.com/GerHobbelt/qs_parse) -- a set of simple and easy functions for parsing URL query strings, such as those generated in an HTTP GET form submission.
- **robotstxt** [ğŸ“](./robotstxt) [ğŸŒ](https://github.com/GerHobbelt/robotstxt) -- Google `robots.txt` Parser and Matcher Library. The Robots Exclusion Protocol (REP) is a standard that enables website owners to control which URLs may be accessed by automated clients (i.e. crawlers) through a simple text file with a specific syntax. It's one of the basic building blocks of the internet as we know it and what allows search engines to operate. Because the REP was only a de-facto standard for the past 25 years, different implementers implement parsing of robots.txt slightly differently, leading to confusion. This project aims to fix that by releasing the parser that Google uses.
- **silk-codec** [ğŸ“](./silk-codec) [ğŸŒ](https://github.com/GerHobbelt/silk-codec) -- a library to convert PCM to TenCent Silk files and vice versa.
- **silk-v3-decoder** [ğŸ“](./silk-v3-decoder) [ğŸŒ](https://github.com/GerHobbelt/silk-v3-decoder) -- decodes Silk v3 audio files (like WeChat amr, aud files, qq slk files) and converts to other formats (like mp3).
- **sqawk** [ğŸ“](./sqawk) [ğŸŒ](https://github.com/GerHobbelt/sqawk) -- apply SQL on CSV files in the shell: `sqawk` imports CSV files into an on-the-fly SQLite database, and runs a user-supplied query on the data.
- **taglib** [ğŸ“](./taglib) [ğŸŒ](https://github.com/GerHobbelt/taglib) -- TagLib is a library for reading and editing the metadata of several popular audio formats. Currently it supports both ID3v1 and [ID3v2][] for MP3 files, [Ogg Vorbis][] comments and ID3 tags in [FLAC][], MPC, Speex, WavPack, TrueAudio, WAV, AIFF, MP4, APE, and ASF files.
- **ticpp** [ğŸ“](./ticpp) [ğŸŒ](https://github.com/GerHobbelt/ticpp) -- TinyXML++: XML read/write
- **tidy-html5** [ğŸ“](./tidy-html5) [ğŸŒ](https://github.com/GerHobbelt/tidy-html5) -- clean up HTML documents before archiving/processing
- **tinyexr** [ğŸ“](./tinyexr) [ğŸŒ](https://github.com/GerHobbelt/tinyexr) -- Tiny OpenEXR: `tinyexr` is a small, single header-only library to load and save OpenEXR (.exr) images.
- **upskirt-markdown** [ğŸ“](./upskirt-markdown) [ğŸŒ](https://github.com/GerHobbelt/soldout) -- MarkDown renderer
  
  - **svg-charter** [ğŸ“](./svg-charter) [ğŸŒ](https://github.com/GerHobbelt/charter) -- SVG chart renderer
    
    - **tinyexpr** [ğŸ“](./tinyexpr) [ğŸŒ](https://github.com/GerHobbelt/tinyexpr) -- a very small recursive descent parser and evaluation engine for math expressions.

- **url-parser** [ğŸ“](./url-parser) [ğŸŒ](https://github.com/GerHobbelt/url.h) -- parse URLs much like Node's [url](http://nodejs.org/api/url.html) module.
- **warc2text** [ğŸ“](./warc2text) [ğŸŒ](https://github.com/GerHobbelt/warc2text) -- Extracts plain text, language identification and more metadata from WARC records.
- **xlnt** [ğŸ“](./xlnt) [ğŸŒ](https://github.com/GerHobbelt/xlnt) -- a modern C++ library for manipulating spreadsheets in memory and reading/writing them from/to XLSX files as described in [ECMA 376 4th edition](http://www.ecma-international.org/publications/standards/Ecma-376.htm).
- **xml-pugixml** [ğŸ“](./xml-pugixml) [ğŸŒ](https://github.com/GerHobbelt/pugixml) -- light-weight, simple and fast XML parser for C++ with XPath support.
- **xmunch** [ğŸ“](./xmunch) [ğŸŒ](https://github.com/GerHobbelt/xmunch) -- xmunch essentially does, what the 'munch' command of, for example, hunspell does, but is not compatible with hunspell affix definition files. So why use it then? What makes xmunch different from the other tools is the ability to extend incomplete word-lists. For hunspell's munch to identify a stem and add an affix mark, every word formed by the affix with the stem has to be in the original word-list. This makes sense for a compression tool. However if your word list is incomplete, you have to add all possible word-forms of a word first, before any compression is done. Using xmunch instead, you can define a subset of forms which are required to be in the word-list to allow the word to be used as stem. Like this, you can extend the word-list.
- **zsv** [ğŸ“](./zsv) [ğŸŒ](https://github.com/GerHobbelt/zsv) -- the world's fastest (SIMD) CSV parser, with an extensible CLI for SQL querying, format conversion and more.
- ~~**gmime** [ğŸŒ](https://github.com/jstedfast/gmime) (alternative repo [here](https://github.com/GNOME/gmime)) -- multipart MIME library; serves as a fundamental building block for full MHTML file format I/O support~~
  
  - **removed**; reason: GNOME libraries are horrible to integrate with other codebases.












## BibTeX and similar library metadata formats' support

- **bibtex-robust-decoder** [ğŸ“](./bibtex-robust-decoder) [ğŸŒ](https://github.com/GerHobbelt/bibtex-robust-decoder) -- BibTeX parser which is robust: it will cope well with various BibTeX input errors which may be caused by manual entry of a BibTeX record.
- **bibtool** [ğŸ“](./bibtool) [ğŸŒ](https://github.com/GerHobbelt/bibtool) -- a tool for manipulating BibTeX data bases. BibTeX provides a mean to integrate citations into LaTeX documents. BibTool allows the manipulation of BibTeX files which goes beyond the possibilities -- and intentions -- of BibTeX.
- **bibutils** [ğŸ“](./bibutils) [ğŸŒ](https://github.com/GerHobbelt/bibutils) -- the `bibutils` set interconverts between various bibliography formats using a common MODS-format XML intermediate. For example, one can convert RIS-format files to Bibtex by doing two transformations: RIS->MODS->Bibtex. By using a common intermediate for N formats, only 2N programs are required and not NÂ²-N.











## export / output file formats, text formatting, etc.

- **fast_double_parser** [ğŸ“](./fast_double_parser) [ğŸŒ](https://github.com/GerHobbelt/fast_double_parser) -- 4x faster than `strtod()`. Unless you need support for [RFC 7159](https://tools.ietf.org/html/rfc7159) (JSON standard), we encourage users to adopt [fast_float](https://github.com/fastfloat/fast_float) library instead. It has more functionality. Fast function to parse ASCII strings containing decimal numbers into double-precision (binary64) floating-point values.  That is, given the string "1.0e10", it should return a 64-bit floating-point value equal to 10000000000. We do not sacrifice accuracy. The function will match exactly (down the smallest bit) the result of a standard function like `strtod`.
- **fast_float** [ğŸ“](./fast_float) [ğŸŒ](https://github.com/GerHobbelt/fast_float) -- fast and exact implementation of the C++ `from_chars` functions for float and double types: 4x faster than `strtod`
- **fast-hex** [ğŸ“](./fast-hex) [ğŸŒ](https://github.com/GerHobbelt/fast-hex) -- a fast, SIMD (vectorized) hex string encoder/decoder.
- **fmt** [ğŸ“](./fmt) [ğŸŒ](https://github.com/GerHobbelt/fmt) -- advanced C++ data-to-text formatter. The modern answer to classic `printf()`.
- **hypertextcpp** [ğŸ“](./hypertextcpp) [ğŸŒ](https://github.com/GerHobbelt/hypertextcpp) -- string/text template engine & source-to-source compiler.
- **libfort** [ğŸ“](./libfort) [ğŸŒ](https://github.com/GerHobbelt/libfort) -- a simple crossplatform library to create formatted text tables.
- **libqrencode** [ğŸ“](./libqrencode) [ğŸŒ](https://github.com/GerHobbelt/libqrencode) -- generate QRcodes from anything (e.g. URLs). `libqrencode` is a fast and compact library for encoding data in a QR Code, a 2D symbology that can be scanned by handy terminals such as a smartphone. The capacity of QR Code is up to 7000 digits or 4000 characters and has high robustness. `libqrencode` supports QR Code model 2, described in JIS (Japanese Industrial Standards) X0510:2004 or ISO/IEC 18004. Most of features in the specification are implemented: Numeric, alphabet, Japanese kanji (Shift-JIS) or any 8 bit code, Optimized encoding of a string, Structured-append of symbols, Micro QR Code (experimental).
- **PDFGen** [ğŸ“](./PDFGen) [ğŸŒ](https://github.com/GerHobbelt/PDFGen) -- a simple PDF Creation/Generation library, contained in a single C-file with header and no external library dependencies. Useful for embedding into other programs that require rudimentary PDF output.
- **quirc** [ğŸ“](./quirc) [ğŸŒ](https://github.com/GerHobbelt/quirc) -- a library for extracting and decoding QR codes, which are a type of high-density matrix barcodes, from images. It features a fast, robust and tolerant recognition algorithm. It can correctly recognise and decode QR codes which are rotated and/or oblique to the camera. It can also distinguish and decode multiple codes within the same image.
- **sile-typesetter** [ğŸ“](./sile-typesetter) [ğŸŒ](https://github.com/GerHobbelt/sile) -- SILE is a typesetting system; its job is to produce beautiful printed documents. Conceptually, SILE is similar to TeXâ€”from which it borrows some concepts and even syntax and algorithmsâ€”but the similarities end there. Rather than being a derivative of the TeX family SILE is a new typesetting and layout engine written from the ground up using modern technologies and borrowing some ideas from graphical systems such as Adobe InDesign.
- **tabulate** [ğŸ“](./tabulate) [ğŸŒ](https://github.com/GerHobbelt/tabulate) -- Table Maker for Modern C++, for when you want to display table formatted data in the terminal/console text window.
- **textflowcpp** [ğŸ“](./textflowcpp) [ğŸŒ](https://github.com/GerHobbelt/textflowcpp) -- a simple way to wrap a string at different line lengths, optionally with indents.
- **upskirt-markdown** [ğŸ“](./upskirt-markdown) [ğŸŒ](https://github.com/GerHobbelt/soldout) -- MarkDown renderer
  
  - **svg-charter** [ğŸ“](./svg-charter) [ğŸŒ](https://github.com/GerHobbelt/charter) -- SVG chart renderer
    
    - **tinyexpr** [ğŸ“](./tinyexpr) [ğŸŒ](https://github.com/GerHobbelt/tinyexpr) -- a very small recursive descent parser and evaluation engine for math expressions.

- **variadic_table** [ğŸ“](./variadic_table) [ğŸŒ](https://github.com/GerHobbelt/variadic_table) -- for "pretty-printing" a formatted table of data to the console. It uses "variadic templates" to allow you to specify the types of data in each column.











## FTS (*Full Text Search*) and related: SOLR/Lucene et al: document content search

We'll be using SOLR mostly, but here might be some interface libraries and an intersting alternative

- **Bi-Sent2Vec** [ğŸ“](./Bi-Sent2Vec) [ğŸŒ](https://github.com/GerHobbelt/Bi-Sent2Vec) -- provides cross-lingual numerical representations (features) for words, short texts, or sentences, which can be used as input to any machine learning task with applications geared towards cross-lingual word translation, cross-lingual sentence retrieval as well as cross-lingual downstream NLP tasks. The library is a cross-lingual extension of [Sent2Vec](https://github.com/epfml/sent2vec). Bi-Sent2Vec vectors are also well suited to monolingual tasks as indicated by a marked improvement in the monolingual quality of the word embeddings. (For more details, see [paper](https://arxiv.org/abs/1912.12481))
- **BitFunnel** [ğŸ“](./BitFunnel) [ğŸŒ](https://github.com/GerHobbelt/BitFunnel) -- the BitFunnel search index is used by [Bing's](http://www.bing.com) super-fresh, news, and media indexes. The algorithm is described in [BitFunnel: Revisiting Signatures for
- **completesearch** [ğŸ“](./completesearch) [ğŸŒ](https://github.com/GerHobbelt/completesearch) -- a fast and interactive search engine for *context-sensitive prefix search* on a given collection of documents. It does not only provide search results, like a regular search engine, but also completions for the last (maybe only partially typed) query word that lead to a hit.
- **edit-distance** [ğŸ“](./edit-distance) [ğŸŒ](https://github.com/GerHobbelt/editdistance) -- a fast implementation of the edit distance (Levenshtein distance). The algorithm used in this library is proposed by _Heikki HyyrÃ¶, "Explaining and extending the bit-parallel approximate string matching algorithm of Myers", (2001) <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.19.7158&rep=rep1&type=pdf>_.
- **fxt** [ğŸ“](./fxt) [ğŸŒ](https://github.com/GerHobbelt/fxt) -- a large scale feature extraction tool for text-based machine learning.
- **groonga** [ğŸ“](./groonga) [ğŸŒ](https://github.com/GerHobbelt/groonga) -- an open-source fulltext search engine and column store.
- **iresearch** [ğŸ“](./iresearch) [ğŸŒ](https://github.com/GerHobbelt/iresearch) -- the IResearch search engine is meant to be treated as a standalone index that is capable of both indexing and storing individual values verbatim. Indexed data is treated on a per-version/per-revision basis, i.e. existing data version/revision is never modified and updates/removals are treated as new versions/revisions of the said data. This allows for trivial multi-threaded read/write operations on the index. The index exposes its data processing functionality via a multi-threaded 'writer' interface that treats each document abstraction as a collection of fields to index and/or store. The index exposes its data retrieval functionality via 'reader' interface that returns records from an index matching a specified query. The queries themselves are constructed query trees built directly using the query building blocks available in the API. The querying infrastructure provides the capability of ordering the result set by one or more ranking/scoring implementations. The ranking/scoring implementation logic is plugin-based and lazy-initialized during runtime as needed, allowing for addition of custom ranking/scoring logic without the need to even recompile the IResearch library.
- **libchopshop** [ğŸ“](./libchopshop) [ğŸŒ](https://github.com/GerHobbelt/libchopshop) -- NLP/text processing with automated stop word detection and stemmer-based filtering. This library / toolkit is engineered to be able to provide **both** of the (often more or less disparate) n-gram token streams / vectors required for (1) initializing / training FTS databases, neural nets, etc. and (2) executing effective queries / matches on these engines.
- **libunibreak** [ğŸ“](./libunibreak) [ğŸŒ](https://github.com/GerHobbelt/libunibreak) -- an implementation of the line breaking and word breaking algorithms as described in (Unicode Standard Annex 14)[http://www.unicode.org/reports/tr14/] and (Unicode Standard Annex 29)[http://www.unicode.org/reports/tr29/].
- [Manticore](https://manticoresearch.com/) -- while the userbase is much smaller than for the *Lucene Gang* (Lucene/SOLR/ES/OpenSearch), this still got me. Can't say exactly why. All the other Lucene/SOLR alternatives out there didn't appeal to me (old tech, slow dev, ...).
  
  - **manticore-columnar** [ğŸ“](./manticore-columnar) [ğŸŒ](https://github.com/GerHobbelt/columnar) -- Manticore Columnar Library is a column-oriented storage and secondary indexing library, aiming to provide **decent performance with low memory footprint at big data volume**. When used in combination with [Manticore Search](https://github.com/manticoresoftware/manticoresearch) it can be beneficial for those looking for:
    
    1. log analytics including rich free text search capabities (which is missing in e.g. [Clickhouse](https://github.com/ClickHouse/ClickHouse) - great tool for metrics analytics)
    2. faster / low resource consumption log/metrics analytics. Since the library and Manticore Search are both written in C++ with low optimizations in mind, in many cases the performance / RAM consumption is better than in Lucene / SOLR / Elasticsearch
    3. running log / metric analytics in docker / kubernetes. Manticore Search + the library can work with as little as 30 megabytes of RAM which Elasticsearch / Clickhouse can't. It also starts in less than a second or a few seconds in the worst case. Since the overhead is so little you can afford having more nodes of Manticore Search + the library than Elasticsearch. More nodes and quicker start means higher high availability and agility.
    4. powerful SQL for logs/metrics analytics and everything else [Manticore Search](https://github.com/manticoresoftware/manticoresearch) can give you
  
  - **manticore-plugins** [ğŸ“](./manticore-plugins) [ğŸŒ](https://github.com/GerHobbelt/manticore-plugins) -- Manticore Search plugins and UDFs (user defined functions) -- Manticore Search can be extended with help of plugins and custom functions (aka user defined functions or UDFs).
  - **manticoresearch** [ğŸ“](./manticoresearch) [ğŸŒ](https://github.com/GerHobbelt/manticoresearch) -- Manticore Search is an easy to use open source fast database for search. Good alternative for Elasticsearch. What distinguishes it from other solutions is:
    
    * It's very fast and therefore more cost-efficient than alternatives, for example Manticore is:
    * Modern MPP architecture and smart query parallelization capabilities allow to fully utilize all your CPU cores to **lower response time** as much as possible, when needed.
    * Powerful and fast full-text search which **works fine for small and big datasets**
    * Traditional **row-wise storage** for small, medium and big size datasets
    * **Columnar storage** support via the [Manticore Columnar Library](https://github.com/manticoresoftware/columnar/) for bigger datasets (much bigger than can fit in RAM)
    * Easy to use secondary indexes (you don't need to create them manually)
    * Cost-based optimizer for search queries
    * SQL-first: Manticore's **native syntax is SQL**. It speaks SQL over HTTP and uses the MySQL protocol (you can use your preferred MySQL client)
    * **JSON over HTTP**: to provide a more programmatic way to manage your data and schemas, Manticore provides a HTTP JSON protocol
    * Written fully in C++: **starts fast, doesn't take much RAM**, and low-level optimizations provide good performance
    * **Real-time inserts**: after an INSERT is made, the document is accessible immediately
    * [Interactive courses](https://play.manticoresearch.com/) for **easier learning**
    * **Built-in replication and load balancing**
    * **Can sync** from MySQL/PostgreSQL/ODBC/xml/csv out of the box
    * Not fully ACID-compliant, but **supports transactions and binlog** for safe writes

- **mitlm** [ğŸ“](./mitlm) [ğŸŒ](https://github.com/GerHobbelt/mitlm) -- the MIT Language Modeling Toolkit (MITLM) toolkit is a set of tools designed for the efficient estimation of statistical n-gram language models involving iterative parameter estimation.  It achieves much of its efficiency through the use of a compact vector representation of n-grams.
- **pg_similarity** [ğŸ“](./pg_similarity) [ğŸŒ](https://github.com/GerHobbelt/pg_similarity) -- **pg\_similarity** is an extension to support similarity queries on [PostgreSQL](http://www.postgresql.org/). The implementation is tightly integrated in the RDBMS in the sense that it defines operators so instead of the traditional operators (`=` and `<>`) you can use `~~~` and `~!~` (any of these operators represents a similarity function).
- **pisa** [ğŸ“](./pisa) [ğŸŒ](https://github.com/GerHobbelt/pisa) -- a text search engine able to run on large-scale collections of documents. It allows researchers to experiment with state-of-the-art techniques, allowing an ideal environment for rapid development. PISA is a text search engine, though the "PISA Project" is a set of tools that help experiment with indexing and query processing. Given a text collection, PISA can build an inverted index over this corpus, allowing the corpus to be searched. The inverted index, put simply, is an efficient data structure that represents the document corpus by storing a list of documents for each unique term (see here). At query time, PISA stores its index in main memory for rapid retrieval.
- **pisa_formatter** [ğŸ“](./pisa_formatter) [ğŸŒ](https://github.com/GerHobbelt/pisa_formatter) -- converts list of documents to the [pisa-engine](https://github.com/pisa-engine/pisa) binary format: {.docs, .freqs, .sizes}. Its input should be a text file where each line is a document.  Each document starts with the document name (which should not have whitespaces) followed by a list of ascii terms separated by whitespaces which define the document. This also generates a binary .terms file which has the information to convert from term to index and is used by the query_transformer executable. This file stores all the unique terms from all the documents.
- **sent2vec** [ğŸ“](./sent2vec) [ğŸŒ](https://github.com/GerHobbelt/sent2vec) -- a tool and pre-trained models related to the [Bi-Sent2vec](https://arxiv.org/abs/1912.12481). The cross-lingual extension of Sent2Vec can be found [here](https://github.com/epfml/Bi-sent2vec). This library provides numerical representations (features) for words, short texts, or sentences, which can be used as input to any machine learning task.
- **sist2** [ğŸ“](./sist2) [ğŸŒ](https://github.com/GerHobbelt/sist2) -- sist2 (Simple incremental search tool) is a fast, low memory usage, multi-threaded application, which scans drives and directory trees, extracts text and metadata from common file types, generates thumbnails and comes with OCR support (with tesseract) and  Named-Entity Recognition (using pre-trained client-side tensorflow models).
- **sqlite-fts5-snowball** [ğŸ“](./sqlite-fts5-snowball) [ğŸŒ](https://github.com/GerHobbelt/fts5-snowball) -- a simple extension for use with FTS5 within SQLite. It allows FTS5 to use Martin Porter's Snowball stemmers (libstemmer), which are available in several languages. Check http://snowballstem.org/ for more information about them.
- **sqlite_fts_tokenizer_chinese_simple** [ğŸ“](./sqlite_fts_tokenizer_chinese_simple) [ğŸŒ](https://github.com/GerHobbelt/simple) -- an extension of [sqlite3 fts5](https://www.sqlite.org/fts5.html) that supports Chinese and Pinyin. It fully provides a [solution to the multi-phonetic word problem of full-text retrieval on WeChat mobile terminal](https://cloud.tencent.com/developer/article/1198371): solution 4 in the article, very simple and efficient support for Chinese and Pinyin searches.
  
  On this basis we also support more accurate phrase matching through [cppjieba](https://github.com/yanyiwu/cppjieba). See the introduction article at https://www.wangfenjin.com/posts/simple-jieba-tokenizer/

- **typesense** [ğŸ“](./typesense) [ğŸŒ](https://github.com/GerHobbelt/typesense) -- a fast, typo-tolerant search engine for building delightful search experiences. Open Source alternative to Algolia and an Easier-to-Use alternative to ElasticSearch. âš¡ğŸ”âœ¨ Fast, typo tolerant, in-memory fuzzy Search Engine for building delightful search experiences.











### stemmers

- **libstemmer** [ğŸ“](./libstemmer) [ğŸŒ](https://github.com/GerHobbelt/libstemmer) -- SnowBall stemmer for many languages.
- **snowball** [ğŸ“](./snowball) [ğŸŒ](https://github.com/GerHobbelt/snowball) -- SnowBall stemming compiler (code generator)











### language detection / inference

- **cld1-language-detect** [ğŸ“](./cld1-language-detect) [ğŸŒ](https://github.com/GerHobbelt/cld) -- the CLD (Compact Language Detection) library, extracted from the source code for Google's Chromium library. CLD1 probabilistically detects languages in Unicode UTF-8 text.
- **cld2-language-detect** [ğŸ“](./cld2-language-detect) [ğŸŒ](https://github.com/GerHobbelt/cld2) -- CLD2 probabilistically detects over 80 languages in Unicode UTF-8 text, either plain text or HTML/XML. For mixed-language input, CLD2 returns the top three languages found and their approximate percentages of the total text bytes.  Optionally, it also returns a vector of text spans with the language of each identified. The design target is web pages of at least 200 characters (about two sentences); CLD2 is not designed to do well on very short text.
- **cld3-language-detect** [ğŸ“](./cld3-language-detect) [ğŸŒ](https://github.com/GerHobbelt/cld3) -- CLD3 is a neural network model for language identification. The inference code extracts character ngrams from the input text and computes the fraction of times each of them appears. The model outputs BCP-47-style language codes, shown in the table below. For some languages, output is differentiated by script. Language and script names from Unicode CLDR.
- **libchardet** [ğŸ“](./libchardet) [ğŸŒ](https://github.com/GerHobbelt/libchardet) -- is based on Mozilla Universal Charset Detector library and, detects the character set used to encode data.
- **uchardet** [ğŸ“](./uchardet) [ğŸŒ](https://github.com/GerHobbelt/uchardet) -- [uchardet](https://www.freedesktop.org/wiki/Software/uchardet/) is an encoding and language detector library, which attempts to determine the encoding of the text. It can reliably detect many charsets. Moreover it also works as a very good and fast language detector.











## scripting *user-tunable tasks* such as OCR preprocessing, metadata extraction, metadata cleaning & other \[post-\]processing, ...

- **cel-cpp** [ğŸ“](./cel-cpp) [ğŸŒ](https://github.com/GerHobbelt/cel-cpp) -- C++ Implementations of the Common Expression Language. For background on the Common Expression Language see the cel-spec repo. Common Expression Language specification: the Common Expression Language (CEL) implements common semantics for expression evaluation, enabling different applications to more easily interoperate. Key Applications are (1) Security policy: organizations have complex infrastructure and need common tooling to reason about the system as a whole and (2) Protocols: expressions are a useful data type and require interoperability across programming languages and platforms.
- **cel-spec** [ğŸ“](./cel-spec) [ğŸŒ](https://github.com/GerHobbelt/cel-spec) -- Common Expression Language specification: the Common Expression Language (CEL) implements common semantics for expression evaluation, enabling different applications to more easily interoperate. Key Applications are (1) Security policy: organizations have complex infrastructure and need common tooling to reason about the system as a whole and (2) Protocols: expressions are a useful data type and require interoperability across programming languages and platforms.
- **chibi-scheme** [ğŸ“](./chibi-scheme) [ğŸŒ](https://github.com/GerHobbelt/chibi-scheme) -- Chibi-Scheme is a very small library intended for use as an extension and scripting language in C programs.  In addition to support for lightweight VM-based threads, each VM itself runs in an isolated heap allowing multiple VMs to run simultaneously in different OS threads.
- **cppdap** [ğŸ“](./cppdap) [ğŸŒ](https://github.com/GerHobbelt/cppdap) -- a C++11 library (["SDK"](https://microsoft.github.io/debug-adapter-protocol/implementors/sdks/)) implementation of the [Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/), providing an API for implementing a DAP client or server. `cppdap` provides C++ type-safe structures for the full [DAP specification](https://microsoft.github.io/debug-adapter-protocol/specification), and provides a simple way to add custom protocol messages.
- **cpython** [ğŸ“](./cpython) [ğŸŒ](https://github.com/GerHobbelt/cpython) -- Python version 3. Note: Building a complete Python installation requires the use of various additional third-party libraries, depending on your build platform and configure options.  Not all standard library modules are buildable or useable on all platforms.
- **duktape** [ğŸ“](./duktape) [ğŸŒ](https://github.com/GerHobbelt/duktape) -- [Duktape](http://duktape.org/) is an **embeddable Javascript** engine, with a focus on **portability** and **compact** footprint. Duktape is ECMAScript E5/E5.1 compliant, with some semantics updated from ES2015+, with partial support for ECMAScript 2015 (E6) and ECMAScript 2016 (E7), ES2015 TypedArray, Node.js Buffer bindings and comes with a built-in debugger.
- **ECMA262** [ğŸ“](./ECMA262) [ğŸŒ](https://github.com/GerHobbelt/ecma262) -- ECMAScript :: the source for the current draft of ECMA-262, the ECMAScriptÂ® Language Specification.
- **guile** [ğŸ“](./guile) [ğŸŒ](https://github.com/GerHobbelt/guile) -- Guile is Project GNU's extension language library. Guile is an implementation of the Scheme programming language, packaged as a library that can be linked into applications to give them their own extension language.  Guile supports other languages as well, giving users of Guile-based applications a choice of languages.
- **harbour-core** [ğŸ“](./harbour-core) [ğŸŒ](https://github.com/GerHobbelt/core) -- Harbour is the free software implementation of a multi-platform, multi-threading, object-oriented, scriptable programming language, backward compatible with Clipper/xBase. Harbour consists of a compiler and runtime libraries with multiple UI and database backends, its own make system and a large collection of libraries and interfaces to many popular APIs.
- **itcl** [ğŸ“](./itcl) [ğŸŒ](https://github.com/GerHobbelt/itcl) -- Itcl is an object oriented extension for Tcl.
- **jerryscript** [ğŸ“](./jerryscript) [ğŸŒ](https://github.com/GerHobbelt/jerryscript) -- [JerryScript](https://github.com/jerryscript-project/jerryscript/) is a lightweight JavaScript engine for resource-constrained devices such as microcontrollers. It can run on devices with less than 64 KB of RAM and less than 200 KB of flash memory.
  
  Key characteristics of JerryScript:
  
  * Full ECMAScript 5.1 standard compliance
  * 160K binary size when compiled for ARM Thumb-2
  * Heavily optimized for low memory consumption
  * Written in C99 for maximum portability
  * Snapshot support for precompiling JavaScript source code to byte code
  * Mature C API, easy to embed in applications
  
  Additional information can be found at the [project page](http://jerryscript.net) and [Wiki](https://github.com/jerryscript-project/jerryscript/wiki).

- **jimtcl** [ğŸ“](./jimtcl) [ğŸŒ](https://github.com/GerHobbelt/jimtcl) -- the Jim Interpreter is a small-footprint implementation of the Tcl programming language written from scratch. Currently Jim Tcl is very feature complete with an extensive test suite (see the tests directory). There are some Tcl commands and features which are not implemented (and likely never will be), including traces and Tk. However, Jim Tcl offers a number of both Tcl8.5 and Tcl8.6 features ({*}, dict, lassign, tailcall and optional UTF-8 support) and some unique features. These unique features include [lambda] with garbage collection, a general GC/references system, arrays as syntax sugar for [dict]tionaries, object-based I/O and more. Other common features of the Tcl programming language are present, like the "everything is a string" behaviour, implemented internally as dual ported objects to ensure that the execution time does not reflect the semantic of the language :)
- **linenoise** [ğŸ“](./linenoise) [ğŸŒ](https://github.com/GerHobbelt/linenoise) -- `readline` simile for REPL/interactive runs in a CLI
- **miniscript** [ğŸ“](./miniscript) [ğŸŒ](https://github.com/GerHobbelt/miniscript) -- the [MiniScript scripting language](http://miniscript.org).
- **mujs** [ğŸ“](../../thirdparty/mujs) [ğŸŒ](https://github.com/GerHobbelt/mujs) -- a lightweight ES5 Javascript interpreter designed for embedding in other software to extend them with scripting capabilities.
- **newlisp** [ğŸ“](./newlisp) [ğŸŒ](https://github.com/GerHobbelt/newlisp) -- newLISP is a LISP-like scripting language for doing things you typically do with scripting languages: programming for the internet, system administration, text processing, gluing other programs together, etc. newLISP is a scripting LISP for people who are fascinated by LISP's beauty and power of expression, but who need it stripped down to easy-to-learn essentials. newLISP is LISP reborn as a scripting language: pragmatic and casual, simple to learn without requiring you to know advanced computer science concepts. Like any good scripting language, newLISP is quick to get into and gets the job done without fuss. newLISP has a very fast startup time, is small on resources like disk space and memory and has a deep, practical API with functions for networking, statistics, machine learning, regular expressions, multiprocessing and distributed computing built right into it, not added as a second thought in external modules.
- **owl** [ğŸ“](./owl) [ğŸŒ](https://github.com/GerHobbelt/owl) -- Owl Lisp is a functional dialect of the Scheme programming language. It is mainly based on the applicative subset of the R7RS standard.
- **picoc** [ğŸ“](./picoc) [ğŸŒ](https://github.com/GerHobbelt/picoc) -- PicoC is a very small C interpreter for scripting. It was originally written as a script language for a UAV's on-board flight system. It's also very suitable for other robotic, embedded and non-embedded applications. The core C source code is around 3500 lines of code. It's not intended to be a complete implementation of ISO C but it has all the essentials.
- **pybind11** [ğŸ“](./pybind11) [ğŸŒ](https://github.com/GerHobbelt/pybind11) -- a lightweight header-only library that exposes C++ types in Python and vice versa, mainly to create Python bindings of existing C++ code.
- **QuickJS** [ğŸ“](./QuickJS) [ğŸŒ](https://github.com/GerHobbelt/quickjs) -- a small and embeddable Javascript engine. It supports the <a href="https://tc39.github.io/ecma262/">ES2020</a> specification including modules, asynchronous generators, proxies and BigInt. It optionally supports mathematical extensions such as big decimal floating point numbers (BigDecimal), big binary floating point numbers (BigFloat) and operator overloading.
  
  - **libbf** [ğŸ“](./libbf) [ğŸŒ](https://github.com/GerHobbelt/libbf) -- a small library to handle arbitrary precision binary or decimal floating point numbers
  - **QuickJS-C++-Wrapper** [ğŸ“](./QuickJS-C++-Wrapper) [ğŸŒ](https://github.com/GerHobbelt/quickjscpp) -- quickjscpp is a header-only wrapper around the [quickjs](https://bellard.org/quickjs/) JavaScript engine, which allows easy integration into C++11 code. This wrapper also automatically tracks the lifetime of values and objects, is exception-safe, and automates clean-up.
  - **QuickJS-C++-Wrapper2** [ğŸ“](./QuickJS-C++-Wrapper2) [ğŸŒ](https://github.com/GerHobbelt/quickjspp) -- QuickJSPP is QuickJS wrapper for C++. It allows you to easily embed Javascript engine into your program.
  - **txiki** [ğŸ“](./txiki.js) [ğŸŒ](https://github.com/GerHobbelt/txiki.js) -- uses QuickJS as its kernel

- **replxx** [ğŸ“](./replxx) [ğŸŒ](https://github.com/GerHobbelt/replxx) -- REPL CLI component: `readline` simile for REPL/interactive runs in a CLI
- **sbcl** [ğŸ“](./sbcl) [ğŸŒ](https://github.com/GerHobbelt/sbcl) -- SBCL is an implementation of ANSI Common Lisp, featuring a high-performance native compiler, native threads on several platforms, a socket interface, a source-level debugger, a statistical profiler, and much more.
- **ScriptX** [ğŸ“](./ScriptX) [ğŸŒ](https://github.com/GerHobbelt/ScriptX) -- wrapper for V8, QuickJS, Lua, Python, ...
- **tcl** [ğŸ“](./tcl) [ğŸŒ](https://github.com/GerHobbelt/tcl) -- the latest **Tcl** source distribution. Tcl provides a powerful platform for creating integration applications that tie together diverse applications, protocols, devices, and frameworks.
- **tclclockmod** [ğŸ“](./tclclockmod) [ğŸŒ](https://github.com/GerHobbelt/tclclockmod) -- TclClockMod is the fastest, most powerful Tcl clock engine written in C. This Tcl clock extension is the faster Tcl-module for the replacement of the standard "clock" ensemble of tcl.
- **tcllib** [ğŸ“](./tcllib) [ğŸŒ](https://github.com/GerHobbelt/tcllib) -- the Tcl Standard Library.
- **txiki** [ğŸ“](./txiki.js) [ğŸŒ](https://github.com/GerHobbelt/txiki.js) -- a small and powerful JavaScript runtime. It's built on the shoulders of giants: it uses [QuickJS] as its JavaScript engine, [libuv] as the platform layer, [wasm3] as the WebAssembly engine and [curl] as the HTTP / WebSocket client.
- **VisualScriptEngine** [ğŸ“](./VisualScriptEngine) [ğŸŒ](https://github.com/GerHobbelt/VisualScriptEngine) -- A visual scripting engine designed for embedding. The engine is written in modern C++ and compiles on several platforms with no external dependencies.
- **wxVisualScriptEngine** [ğŸ“](./wxVisualScriptEngine) [ğŸŒ](https://github.com/GerHobbelt/VisualScriptEngineWxWidgets) -- a utility module for [VisualScriptEngine](https://github.com/kovacsv/VisualScriptEngine) which provides helper classes for embedding the engine in a wxWidgets application.
- **yasl** [ğŸ“](./yasl) [ğŸŒ](https://github.com/GerHobbelt/yasl) -- Bytecode Interpreter for Yet Another Scripting Language (YASL).
- ~~**CPython** [ğŸŒ](https://github.com/python/cpython)~~
  
  - **removed**; reason: we've decided to offer any application user facing scripting features in JavaScript only: Python and the others can use socket-based messaging when someone wants to write their user scripts in any of those languages.


The additional (and more important) reason to ditch CPython from the R&D set is hairiness of integrating Python into an application as an embedded scripting language, instead of the other way around. With the envisioned advent of ZeroMQ/socket based IPC, any Python scripts can hook into that instead of spending the effort and maintenance of having that large language as an embedded 'assistive' scripting/configuration language: it's simply too huge and complicated. We're not Blender and we don't have the funding.

- **linecook** [ğŸ“](./linecook) [ğŸŒ](https://github.com/GerHobbelt/linecook) -- a C library for editing the command line, much like the [readline](https://tiswww.cwru.edu/php/chet/readline/readline.html) library used in <b>bash</b> and <b>gdb</b>.
- **txiki.js** [ğŸ“](./txiki.js) [ğŸŒ](https://github.com/GerHobbelt/txiki.js) -- a small and powerful JavaScript runtime.  It targets ECMAScript 2020 and implements many web platform features.
- ~~**lua** [ğŸŒ](https://github.com/lua/lua)~~
  
  - **removed**; reason: we've decided to offer any application user facing scripting features in JavaScript only: Python and the others can use socket-based messaging when someone wants to write their user scripts in any of those languages. See also the `CPython` entry.

- ~~**luaJIT** [ğŸŒ](https://github.com/LuaJIT/LuaJIT)~~
  
  - **removed**; reason: see the `lua` entry above.












### QuickJS specific modules & related materials

- **libbf** [ğŸ“](./libbf) [ğŸŒ](https://github.com/GerHobbelt/libbf) -- a small library to handle arbitrary precision binary or decimal floating point numbers
- **nanovg-qjs** [ğŸ“](./nanovg-qjs) [ğŸŒ](https://github.com/GerHobbelt/nanovg-qjs) -- QuickJS binding for nanovg
- **qjs-ffi** [ğŸ“](./qjs-ffi) [ğŸŒ](https://github.com/GerHobbelt/qjs-ffi) -- a simple interface to FFI from QuickJS.
- **qjs-modules** [ğŸ“](./qjs-modules) [ğŸŒ](https://github.com/GerHobbelt/qjs-modules) -- some modules for QuickJS.
- **qjs-opencv** [ğŸ“](./qjs-opencv) [ğŸŒ](https://github.com/GerHobbelt/qjs-opencv) -- OpenCV bindings for QuickJS (https://bellard.org/quickjs/)
- **qjs-sqlite3** [ğŸ“](./qjs-sqlite3) [ğŸŒ](https://github.com/GerHobbelt/qjs-sqlite3) -- a simple interface to SQLite3 from QuickJS.
- **QuickJS** [ğŸ“](./QuickJS) [ğŸŒ](https://github.com/GerHobbelt/quickjs) -- a small and embeddable Javascript engine. It supports the <a href="https://tc39.github.io/ecma262/">ES2020</a> specification including modules, asynchronous generators, proxies and BigInt. It optionally supports mathematical extensions such as big decimal floating point numbers (BigDecimal), big binary floating point numbers (BigFloat) and operator overloading.
- **QuickJS-C++-Wrapper** [ğŸ“](./QuickJS-C++-Wrapper) [ğŸŒ](https://github.com/GerHobbelt/quickjscpp) -- quickjscpp is a header-only wrapper around the [quickjs](https://bellard.org/quickjs/) JavaScript engine, which allows easy integration into C++11 code. This wrapper also automatically tracks the lifetime of values and objects, is exception-safe, and automates clean-up.
- **QuickJS-C++-Wrapper2** [ğŸ“](./QuickJS-C++-Wrapper2) [ğŸŒ](https://github.com/GerHobbelt/quickjspp) -- QuickJSPP is QuickJS wrapper for C++. It allows you to easily embed Javascript engine into your program.
- **quickjs-ffi** [ğŸ“](./quickjs-ffi) [ğŸŒ](https://github.com/GerHobbelt/quickjs-ffi) -- libffi wrapper for QuickJS. Now supports almost every features of C including primitive types, structs, callbacks and so on.
- **ScriptX** [ğŸ“](./ScriptX) [ğŸŒ](https://github.com/GerHobbelt/ScriptX) -- wrapper for V8, QuickJS, Lua, Python, ...
- **txiki** [ğŸ“](./txiki.js) [ğŸŒ](https://github.com/GerHobbelt/txiki.js) -- uses QuickJS as its kernel











## multi-processing core technologies













### CLI: commandline parsing & perusing

- **argparse** [ğŸ“](./argparse) [ğŸŒ](https://github.com/GerHobbelt/argparse) -- simply include argparse.hpp and start parsing command-line arguments.
- **cli11** [ğŸ“](./cli11) [ğŸŒ](https://github.com/GerHobbelt/CLI11) -- command line options parser
- **clipp** [ğŸ“](./clipp) [ğŸŒ](https://github.com/GerHobbelt/clipp) -- commandline parser
  
  - **left-for-dead**; reason: looks really nice, but MSVC coughs up some pretty-hard-to-diagnose compiler errors and warnings. The writer of this library is clearly better versed in writing C++ templating code than *me*, alas. Initial attempts to fix the issues left me in the dirt, humiliated, and reading up on the latest C++ *goodnesses* did not improve my success rate, alas.

- **cxxopts** [ğŸ“](./cxxopts) [ğŸŒ](https://github.com/GerHobbelt/cxxopts) -- a lightweight C++ option parser library, supporting the standard GNU style syntax for options.
- **tclap** [ğŸ“](./tclap) [ğŸŒ](https://github.com/GerHobbelt/tclap) -- TCLAP (Templatized Command Line Argument Parser) is a simple C++ library that facilitates parsing command line arguments in a type independent manner. It doesn't conform exactly to either the GNU or POSIX standards, although it is close.
- ~~**clippson** [ğŸŒ](https://github.com/heavywatal/clippson) -- commandline parser + JSON data diagnostical dumper~~
  
  - **removed**; reason: deemed cool but unsuitable for our needs. Besides, we intend to use `cli11` instead of `clipp` for that library is easier to read and support is more active there.

- ~~**docopt** [ğŸŒ](https://github.com/docopt/docopt.cpp) -- generate documentation for command line options~~
  
  - **removed**; reason: deemed cool but unsuitable for our needs. We intend to use `cli11` instead.












### CPU features & capabilities detection

- **cpu_features** [ğŸ“](./cpu_features) [ğŸŒ](https://github.com/GerHobbelt/cpu_features) -- a cross-platform C library to retrieve CPU features (such as available instructions) at runtime.
- **cpuinfo** [ğŸ“](./cpuinfo) [ğŸŒ](https://github.com/GerHobbelt/cpuinfo) -- CPU & hardware info
- **infoware** [ğŸ“](./infoware) [ğŸŒ](https://github.com/GerHobbelt/infoware) -- C++ Library for pulling system and hardware information, without hitting the command line.
- **libcpuid** [ğŸ“](./libcpuid) [ğŸŒ](https://github.com/GerHobbelt/libcpuid) -- CPU & hardware info
- **mammut** [ğŸ“](./mammut) [ğŸŒ](https://github.com/GerHobbelt/mammut) -- provides an object oriented abstraction of architectural features normally exposed by means of `sysfs` files or CPU registries. It also provides the possibility to manage remote machines by using a client server mechanism.
- **osquery** [ğŸ“](./osquery) [ğŸŒ](https://github.com/GerHobbelt/osquery) -- a SQL powered operating system instrumentation, monitoring, and analytics framework. `osquery` exposes an operating system as a high-performance relational database.  This allows you to write SQL-based queries to explore operating system data.  With osquery, SQL tables represent abstract concepts such as running processes, loaded kernel modules, open network connections, browser plugins, hardware events or file hashes.
- **pcm** [ğŸ“](./pcm) [ğŸŒ](https://github.com/GerHobbelt/pcm) -- Intel&reg; Performance Counter Monitor (Intel&reg; PCM) is an application programming interface (API) and a set of tools based on the API to monitor performance and energy metrics of Intel&reg; Core&trade;, Xeon&reg;, Atom&trade; and Xeon Phi&trade; processors. PCM works on Linux, Windows, Mac OS X, FreeBSD, DragonFlyBSD and ChromeOS operating systems.
- **PlatformFolders** [ğŸ“](./PlatformFolders) [ğŸŒ](https://github.com/GerHobbelt/PlatformFolders) -- a C++ library to look for directories like `My Documents`, `~/.config`, `%APPDATA%`, etc. so that you do not need to write platform-specific code.
- **spy-build-sysinfo** [ğŸ“](./spy-build-sysinfo) [ğŸŒ](https://github.com/GerHobbelt/spy) -- build system info
- ~~**cpuinfo** [ğŸ“](./cpuinfo) [ğŸŒ](https://github.com/GerHobbelt/cpuinfo) -- CPU & hardware info~~
  
  - **removed**; reason: Linux-only, non-portable, deemed unsuitable for our needs.

- ~~**cpu_features** [ğŸŒ](https://github.com/google/cpu_features) -- a cross-platform C library to retrieve CPU features (such as available instructions) at runtime.
  
  - **removed**; reason: Linux-only, non-portable, deemed unsuitable for our needs.

- ~~**cpu_stat** [ğŸŒ](https://github.com/vivaladav/cpu-stat)~~
  
  - **removed**; reason: Linux-only, non-portable, deemed unsuitable for our needs.












### Date & time functionality

- **cctz** [ğŸ“](./cctz) [ğŸŒ](https://github.com/GerHobbelt/cctz) -- CCTZ contains two libraries that cooperate with `<chrono>` to give C++ programmers all the necessary tools for computing with dates, times, and time zones in a simple and correct manner.
- **date** [ğŸ“](./date) [ğŸŒ](https://github.com/GerHobbelt/date) -- a combo of several separate C++11/C++14/C++17 libraries, all geared towards formatting and working with date and time stamps in human-centric formats.
- **datetimepp** [ğŸ“](./datetimepp) [ğŸŒ](https://github.com/GerHobbelt/datetimepp) -- datetime++ is an attempt to port [Python Datetime](https://docs.python.org/3/library/datetime.html) to C++. Finally easy datetime management in C++ !
- **dateutils** [ğŸ“](./dateutils) [ğŸŒ](https://github.com/GerHobbelt/dateutils) -- a bunch of tools that revolve around fiddling with dates and times on the command line with a strong focus on use cases that arise when dealing with large amounts of financial data.
- **libeternaltimestamp** [ğŸ“](./libeternaltimestamp) [ğŸŒ](https://github.com/GerHobbelt/libeternaltimestamp) -- provide/encode/decode 64-bit integer timestamps which can encode *any* date/time in the lifetime of our planet from before the Big Bang up to about 3000 AD in the future.











### Misc. core functionality

- **asio** [ğŸ“](./asio) [ğŸŒ](https://github.com/GerHobbelt/asio) -- a cross-platform C++ library for network and low-level I/O programming that provides developers with a consistent asynchronous model using a modern C++ approach.
  
  Note: (older) Boost.Asio is also included in Boost.

- **backward-cpp** [ğŸ“](./backward-cpp) [ğŸŒ](https://github.com/GerHobbelt/backward-cpp) -- a beautiful stack trace pretty printer for C++. Backward supports pretty printed stack traces on GNU/Linux, macOS and Windows.
- **binary_search** [ğŸ“](./binary_search) [ğŸŒ](https://github.com/GerHobbelt/binary_search) -- includes both the most commonly used binary search variant, as first published by Hermann Bottenbruch in 1962, plus several novel variants with improved performance. The most notable variant, the monobound binary search, executes two to four times faster than the standard binary search on arrays smaller than 1 million 32 bit integers: Boundless Binary Search, Doubletapped Binary Search, Monobound Binary Search, Tripletapped Binary Search, Quaternary Binary Search, Monobound Interpolated Binary Search, Adaptive Binary Search.
- **blitsort** [ğŸ“](./blitsort) [ğŸŒ](https://github.com/GerHobbelt/blitsort) -- Blitsort is an in-place rotate quick/merge sort based on the stable out-of-place merge sort [quadsort](https://github.com/scandum/quadsort), stable out-of-place quicksort [fluxsort](https://github.com/scandum/fluxsort), and unstable in-place [crumsort](https://github.com/scandum/crumsort).
- **bplustree** [ğŸ“](./bplustree) [ğŸŒ](https://github.com/GerHobbelt/bplustree) -- a minimal B+Tree implementation for millions (even billions) of key-value storage based on POSIX.
- **capture-thread** [ğŸ“](./capture-thread) [ğŸŒ](https://github.com/GerHobbelt/capture-thread) -- framework for loggers, tracers, and mockers in multithreaded C++ programs. When developing C++ projects, [instrumentation][instrumentation] is frequently used to collect information from the system, inject information into the system, or both. The role of this information within the system rarely lines up with the actual structure of the project. This library is designed to handle all of these situations with minimal intrusion into your project, and without leaking details in your API. The **Capture Thread Library** is designed around the concept of thread-locality, which allows the sharing of static variables *only within the current thread*. Canonical static variables, on the other hand, are problematic due to ownership and thread-safety issues.
- **cfgpath** [ğŸ“](./cfgpath) [ğŸŒ](https://github.com/GerHobbelt/cfgpath) -- cross platform methods for obtaining paths to configuration files
- **colorm** [ğŸ“](./colorm) [ğŸŒ](https://github.com/GerHobbelt/colorm) -- ColorM is a C++11 header-only color conversion and manipulation library for [CSS colors](https://www.w3.org/TR/css-color-4/) with an API similar to [chroma.js](https://github.com/gka/chroma.js/)'s API.
- **colormap-shaders** [ğŸ“](./colormap-shaders) [ğŸŒ](https://github.com/GerHobbelt/colormap-shaders) -- a collection of shaders to draw color maps.
- **color-util** [ğŸ“](./color-util) [ğŸŒ](https://github.com/GerHobbelt/color-util) -- a header-only C++11 library for handling colors, including color space converters between RGB, XYZ, Lab, etc. and color difference calculators such as CIEDE2000.
- **coost** [ğŸ“](./coost) [ğŸŒ](https://github.com/GerHobbelt/coost) -- A tiny boost library in C++11. `coost` (formerly known as `cocoyaxi`) is an elegant and efficient cross-platform C++ base library, it is not as heavy as `boost`, but still provides enough powerful features.
- **cppdap** [ğŸ“](./cppdap) [ğŸŒ](https://github.com/GerHobbelt/cppdap) -- a C++11 library (["SDK"](https://microsoft.github.io/debug-adapter-protocol/implementors/sdks/)) implementation of the [Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/), providing an API for implementing a DAP client or server. `cppdap` provides C++ type-safe structures for the full [DAP specification](https://microsoft.github.io/debug-adapter-protocol/specification), and provides a simple way to add custom protocol messages.
- **cpplocate** [ğŸ“](./cpplocate) [ğŸŒ](https://github.com/GerHobbelt/cpplocate) -- a cross-platform C++ library that provides tools for applications to locate their binary files and data assets, as well as those of dependent modules.
- **cr** [ğŸ“](./cr) [ğŸŒ](https://github.com/GerHobbelt/cr) -- a single file header-only live reload solution for C, written in C++: simple public API, 3 functions to use only (and another to export); works and tested on Linux, MacOSX and Windows; based on dynamic reloadable binary (.so/.dylib/.dll).
- **crumsort** [ğŸ“](./crumsort) [ğŸŒ](https://github.com/GerHobbelt/crumsort) -- is a hybrid quicksort / mergesort algorithm. The sort is in-place, unstable, adaptive, branchless, and has exceptional performance.
- **delegate** [ğŸ“](./delegate) [ğŸŒ](https://github.com/GerHobbelt/delegate) -- an embedded friendly alternative to `std::function`. The main purpose is to store callable things such as free functions, member functions, and functors. Once stored, the delegate can be called without knowledge of the type of stored thing. The `delegate` guarantees no heap allocation and [is `trivially_copyable`](https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable). It will never throw exceptions itself. Intended use is as general callback storage (think function pointer analog). The price to pay is that the delegate only stores a pointer to referenced functor objects or objects to call member functions on. The user needs to handle the lifetime of a referred object. In addition, the delegation object has a smaller footprint compared to common `std::function` implementations, using only 2 pointers (free function pointer and void pointer). This is small enough so that a delegate will use small object optimization.
- **detect-character-encoding** [ğŸ“](./detect-character-encoding) [ğŸŒ](https://github.com/GerHobbelt/detect-character-encoding) -- detect character encoding using [ICU](http://site.icu-project.org).  **Tip:** If you donâ€™t need ICU in particular, consider using [ced](https://github.com/sonicdoe/ced), which is based on Googleâ€™s lighter [compact_enc_det](https://github.com/google/compact_enc_det) library.
- **expected** [ğŸ“](./expected) [ğŸŒ](https://github.com/GerHobbelt/expected) -- a C++ single header implementation of `std::expected` with functional-style extensions. [`std::expected`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf) is proposed as the preferred way to represent object which will either have an expected value, or an unexpected value giving information about why something failed. Unfortunately, chaining together many computations which may fail can be verbose, as error-checking code will be mixed in with the actual programming logic. This implementation provides a number of utilities to make coding with `expected` cleaner.
- **fast_float** [ğŸ“](./fast_float) [ğŸŒ](https://github.com/GerHobbelt/fast_float) -- fast and exact implementation of the C++ `from_chars` functions for float and double types: 4x faster than `strtod`
- **fastrange** [ğŸ“](./fastrange) [ğŸŒ](https://github.com/GerHobbelt/fastrange) -- a fast alternative to the modulo reduction. [It has accelerated some operations in Google's Tensorflow by 10% to 20%](https://github.com/tensorflow/tensorflow/commit/a47a300185026fe7829990def9113bf3a5109fed). Further reading : http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/ See also: Daniel Lemire, [Fast Random Integer Generation in an Interval](https://arxiv.org/abs/1805.10941), ACM Transactions on Modeling and Computer Simulation, January 2019 Article No. 3 https://doi.org/10.1145/3230636
- **FastString** [ğŸ“](./FastString) [ğŸŒ](https://github.com/GerHobbelt/FastString) -- fast, in stack, fixed size string implementation with **constexpr noexcept** constructors and accessors. **FastString** improves **memory locality and latency** of strings by avoiding heap allocations.
- **fluxsort** [ğŸ“](./fluxsort) [ğŸŒ](https://github.com/GerHobbelt/fluxsort) -- is a stable quicksort / mergesort hybrid algorithm. The sort is stable, adaptive, branchless, and has exceptional performance.
- **fnmatch** [ğŸ“](./fnmatch) [ğŸŒ](https://github.com/GerHobbelt/fnmatch) -- match a filename string or a pathname using POSIX wildcards.
- **highway** [ğŸ“](./highway) [ğŸŒ](https://github.com/GerHobbelt/highway) -- dependency of JpegXL
- **libcnl** [ğŸ“](./libcnl) [ğŸŒ](https://github.com/GerHobbelt/cnl) -- The Compositional Numeric Library (CNL) is a C++ library of fixed-precision numeric classes which enhance integers to deliver safer, simpler, cheaper arithmetic types. CNL is particularly well-suited to: (1) compute on energy-constrained environments where FPUs are absent or costly; (2) compute on energy-intensive environments where arithmetic is the bottleneck such as simulations, machine learning applications and DSPs; and (3) domains such as finance where precision is essential.
- **libdi-dependency-injection** [ğŸ“](./libdi-dependency-injection) [ğŸŒ](https://github.com/GerHobbelt/di) -- \[Boost::ext\].DI :: your C++14 **one header only** Dependency Injection library with no dependencies
- **libffi** [ğŸ“](./libffi) [ğŸŒ](https://github.com/GerHobbelt/libffi) -- provides a portable, high level programming interface to various calling conventions. This allows a programmer to call any function specified by a call interface description at run time.
- **libpathutils** [ğŸ“](./libpathutils) [ğŸŒ](https://github.com/GerHobbelt/libpathutils) -- cross-platform filesystem path utility functions
- **libpopcnt** [ğŸ“](./libpopcnt) [ğŸŒ](https://github.com/GerHobbelt/libpopcnt) -- a header-only C/C++ library for counting the number of 1 bits (bit population count) in an array as quickly as possible using specialized CPU instructions.
- **libstb** [ğŸ“](./libstb) [ğŸŒ](https://github.com/GerHobbelt/stb) -- single-file public domain (or MIT licensed) libraries for C/C++.
- **libwil** [ğŸ“](./libwil) [ğŸŒ](https://github.com/GerHobbelt/wil) -- The Windows Implementation Libraries (WIL) is a header-only C++ library created to make life easier for developers on Windows through readable type-safe C++ interfaces for common Windows coding patterns.
- **lockfree** [ğŸ“](./lockfree) [ğŸŒ](https://github.com/GerHobbelt/lockfree) -- a collection of lock-free data structures written in standard C++11 and suitable for all platforms - from deeply embedded to HPC.
- **memory** [ğŸ“](./memory) [ğŸŒ](https://github.com/GerHobbelt/memory) -- the C++ STL allocator model has various flaws. For example, they are fixed to a certain type, because they are almost necessarily required to be templates. So you can't easily share a single allocator for multiple types. In addition, you can only get a copy from the containers and not the original allocator object. At least with C++11 they are allowed to be stateful and so can be made object not instance based. But still, the model has many flaws. Over the course of the years many solutions have been proposed, for example [EASTL]. This library is another. But instead of trying to change the STL, it works with the current implementation.
- **mesh-allocator** [ğŸ“](./mesh-allocator) [ğŸŒ](https://github.com/GerHobbelt/Mesh) -- Mesh: Compacting Memory Management for C/C++ -- Mesh is a drop in replacement for [malloc(3)](http://man7.org/linux/man-pages/man3/malloc.3.html) that can transparently recover from memory fragmentation without any changes to application code. Mesh is described in detail in a [paper (PDF)](https://github.com/plasma-umass/Mesh/raw/master/mesh-pldi19-powers.pdf) that appeared at PLDI 2019.
- **pdiff** [ğŸ“](./pdiff) [ğŸŒ](https://github.com/GerHobbelt/pdiff) -- perceptualdiff (pdiff): a program that compares two images using a perceptually based image metric.
- **pfp-cst** [ğŸ“](./pfp-cst) [ğŸŒ](https://github.com/GerHobbelt/pfp-cst) -- Prefix-Free Parsing Compressed Suffix Tree is a compressed suffix tree, built on the prefix-free parsing of the text. If you use the PFP-CST in your research, please cite: Christina Boucher, OndÅ™ej Cvacho, Travis Gagie, Jan Holub, Giovanni Manzini, Gonzalo Navarro, and Massimiliano Rossi . *"PFP Compressed Suffix Tree"*, In Proc. of the SIAM Symposium onAlgorithm Engineering and Experiments (ALENEX21), pp. 60-72. (2021).
- **piposort** [ğŸ“](./piposort) [ğŸŒ](https://github.com/GerHobbelt/piposort) -- a stable top-down adaptive branchless merge sort named piposort. It is intended as a simplified [quadsort](https://github.com/scandum/quadsort) with reduced adaptivity, but a great reduction in lines of code and overall complexity. The name stands for ping-pong.
- **quadsort** [ğŸ“](./quadsort) [ğŸŒ](https://github.com/GerHobbelt/quadsort) -- a high performance stable bottom-up adaptive branchless merge sort algorithm.
- **recycle** [ğŸ“](./recycle) [ğŸŒ](https://github.com/GerHobbelt/recycle) -- an implementation of a simple resource pool for recycling resources in C++.
- **refl-cpp** [ğŸ“](./refl-cpp) [ğŸŒ](https://github.com/GerHobbelt/refl-cpp) -- static reflection for C++17 (compile-time enumeration, attributes, proxies, overloads, template functions, metaprogramming).
- **result-cpp** [ğŸ“](./result-cpp) [ğŸŒ](https://github.com/GerHobbelt/result) -- `Result<T, E>` is a modern, simple, and light-weight error-handling alternative to C++ exceptions with a rich feature-set.
- **rttr** [ğŸ“](./rttr) [ğŸŒ](https://github.com/GerHobbelt/rttr) -- RTTR - Run Time Type Reflection - provides the ability to introspect and modify an object at runtime and is written in C++. Features:
- **simdcomp** [ğŸ“](./simdcomp) [ğŸŒ](https://github.com/GerHobbelt/simdcomp) -- SIMDComp is a simple C library for compressing lists of integers using binary packing and SIMD instructions. The assumption is either that you have a list of 32-bit integers where most of them are small, or a list of 32-bit integers where differences between successive integers are small. No software is able to reliably compress an array of 32-bit random numbers.
- **SIMDString** [ğŸ“](./SIMDString) [ğŸŒ](https://github.com/GerHobbelt/SIMDString) -- a [MIT-licensed](https://opensource.org/licenses/MIT) open source implementation of a fast C++ string class designed for use in games. It is a drop-in replacement for `std::string` that is 10-100x faster for many common operations, such as small `string::operator+=(const char*)`, `string::string(const string&)`, `string::string(const char*)`, and `string::c_str()`.
- **stx-error-handling** [ğŸ“](./stx-error-handling) [ğŸŒ](https://github.com/GerHobbelt/STX) -- C++ 17 & C++ 20 error-handling and utility extensions.
- **swig** [ğŸ“](./swig) [ğŸŒ](https://github.com/GerHobbelt/swig) -- SWIG (Simplified Wrapper and Interface Generator) is a software development tool (code generator) that connects programs written in C and C++ with a variety of high-level programming languages. It is used for building scripting language interfaces to C and C++ programs. SWIG simplifies development by largely automating the task of scripting language integration, allowing developers and users to focus on more important problems.
  
  *[SWIG ğŸŒ](https://swig.readthedocs.io/en/latest/Manual/SWIG.html) was not considered initially; more suitable for RPC than what we have in mind, which is purely data messages enchange. MAY be of use for transitional applications which are mixed-(programming-)language based, e.g. where we want to mix C/C++ and C# in a single Test Application.*

- **SZ** [ğŸ“](./SZ) [ğŸŒ](https://github.com/GerHobbelt/SZ) -- SZ2: Error-bounded Lossy Compressor for HPC Data, (C) 2016-2022 by Mathematics and Computer Science (MCS), Argonne National Laboratory.
- **SZ3** [ğŸ“](./SZ3) [ğŸŒ](https://github.com/GerHobbelt/SZ3) -- SZ3: A Modular Error-bounded Lossy Compression Framework for Scientific Datasets, 2016 by Mathematics and Computer Science (MCS), Argonne National Laboratory.
- **text-wrangler** [ğŸ“](./text-wrangler) [ğŸŒ](https://github.com/GerHobbelt/text-wrangler) -- a library + utility for text wrangling: text from in images, text from text. text line detection, text keyphrase extraction, text metadata extraction, ...
- **tinycolormap** [ğŸ“](./tinycolormap) [ğŸŒ](https://github.com/GerHobbelt/tinycolormap) -- a header-only, single-file library for colormaps written in C++11.
- **utf8proc** [ğŸ“](./utf8proc) [ğŸŒ](https://github.com/GerHobbelt/utf8proc) -- [utf8proc](http://juliastrings.github.io/utf8proc/) is a small, clean C library that provides Unicode normalization, case-folding, and other operations for data in the [UTF-8 encoding](http://en.wikipedia.org/wiki/UTF-8).
- **wcwidth9** [ğŸ“](./wcwidth9) [ğŸŒ](https://github.com/GerHobbelt/wcwidth9) -- platform independent, header only, `wcwidth` with full Unicode 9 wide character support.
- **wolfsort** [ğŸ“](./wolfsort) [ğŸŒ](https://github.com/GerHobbelt/wolfsort) -- a stable adaptive hybrid bucket / quick / merge / drop sort named wolfsort. The bucket sort, forming the core of wolfsort, is not a comparison sort, so wolfsort can be considered a member of the radix-sort family. Quicksort and mergesort are well known. Dropsort gained popularity after it was reinvented as Stalin sort.
- **xcdat** [ğŸ“](./xcdat) [ğŸŒ](https://github.com/GerHobbelt/xcdat) -- a C++17 header-only library of a fast compressed string dictionary based on an improved double-array trie structure described in the paper: [Compressed double-array tries for string dictionaries supporting fast lookup](https://doi.org/10.1007/s10115-016-0999-8), *Knowledge and Information Systems*, 2017, available [here](https://kampersanda.github.io/pdf/KAIS2017.pdf).
- **zvec** [ğŸ“](./zvec) [ğŸŒ](https://github.com/GerHobbelt/zvec) -- _zip_vector_ is a compressed variable length array that uses vectorized block codecs to compress and decompress integers using variable bit-width deltas. The integer block codecs are optimized for vector instruction sets using Google's Highway C++ library for portable SIMD/vector intrinsics.
- ~~**merror** [ğŸ“](./merror) [ğŸŒ](https://github.com/GerHobbelt/merror) -- a library for error handling in C++ without exceptions.~~
  
  - **removed**; reason: code is non-portable to compilers other than GCC, or at least would require more effort than we're willing to expend on this.












### multi-processing: invoking external applications

- **cpplocate** [ğŸ“](./cpplocate) [ğŸŒ](https://github.com/GerHobbelt/cpplocate) -- a cross-platform C++ library that provides tools for applications to locate their binary files and data assets, as well as those of dependent modules.
- **cr** [ğŸ“](./cr) [ğŸŒ](https://github.com/GerHobbelt/cr) -- a single file header-only live reload solution for C, written in C++: simple public API, 3 functions to use only (and another to export); works and tested on Linux, MacOSX and Windows; based on dynamic reloadable binary (.so/.dylib/.dll).
- **createprocess-windows** [ğŸ“](./createprocess-windows) [ğŸŒ](https://github.com/GerHobbelt/createprocess-windows) -- drive `CreateProcess` Win32 API
- **dlfcn-win32** [ğŸ“](./dlfcn-win32) [ğŸŒ](https://github.com/GerHobbelt/dlfcn-win32) -- an implementation of `dlfcn` for Windows. `dlfcn` is a set of functions that allows runtime dynamic library loading. It is standardized in the POSIX. Windows also provide similar routines, but not in a POSIX-compatible way. This library attempts to implement a wrapper around the Windows functions to make programs written for POSIX that use dlfcn work in Windows without any modifications.
- **PlatformFolders** [ğŸ“](./PlatformFolders) [ğŸŒ](https://github.com/GerHobbelt/PlatformFolders) -- a C++ library to look for directories like `My Documents`, `~/.config`, `%APPDATA%`, etc. so that you do not need to write platform-specific code.
- **reproc** [ğŸ“](./reproc) [ğŸŒ](https://github.com/GerHobbelt/reproc) -- reproc (Redirected Process) is a cross-platform C/C++ library that simplifies starting, stopping and communicating with external programs. The main use case is executing command line applications directly from C or C++ code and retrieving their output.
- **subprocess** [ğŸ“](./subprocess) [ğŸŒ](https://github.com/GerHobbelt/subprocess) -- cross platform subprocess library for C++ similar to design of Python `subprocess`.
- **subprocess-cpp** [ğŸ“](./subprocess-cpp) [ğŸŒ](https://github.com/GerHobbelt/subprocess-cpp) -- a no nonsense library for writing shell commands in C++.
- **tiny-process-library** [ğŸ“](./tiny-process-library) [ğŸŒ](https://github.com/GerHobbelt/tiny-process-library) -- small platform independent library making it simple to create and stop new processes, as well as writing to stdin and reading from stdout and stderr of a new process.
- https://github.com/arun11299/cpp-subprocess -- as close as possible to Python2.7 `subprocess` module in dealing with processes.
- https://github.com/pnappa/subprocesscpp -- A header-only library that allows you to execute processes either synchronously or asynchronously, whilst providing input and output handling. No more calling `exec` in C++!
- https://github.com/rajatjain1997/subprocess -- A C++ high level library for running shell processes
- https://github.com/sheredom/subprocess.h -- A one header solution to launching processes and interacting with them for C/C++.











### multi-processing: Promise/A+

The key distinction between Promises/A+ and `std::promise` in C++11 is that Promises/A+ provides non-blocking synchronization (via chaining function objects) and `std::promise` provides blocking synchronization (or polling). Both have their uses and one is not a direct replacement for the other.

IMPORTANT NOTE: there is one major difference, though. Most modern Javascript promises (including JS Native promises) resolve asynchronously, i.e. their `resolve()` method does not directly call the `then()` handlers, but schedules the calls on the next message loop iteration. The same happens when a `then()`/`catch()` handler is attached to an already resolved/rejected promise. This may be a bit less efficient, but makes the behavior symmetric and more predictable. These libraries *SHOULD* resolve synchronously, because they are unaware of the message loop that is used in the application. (Look into task schedulers above for when you need such awareness, e.g. `taskflow`.)

- **asynqro** [ğŸ“](./asynqro) [ğŸŒ](https://github.com/GerHobbelt/asynqro) -- Futures and thread pool for C++: Asynqro gives developers a rich monadic Future API (inspired by Future API in Scala language), a clean API, refined task scheduling logic and is not tied to any framework.
- **concurrencpp** [ğŸ“](./concurrencpp) [ğŸŒ](https://github.com/GerHobbelt/concurrencpp) -- the C++ concurrency library: concurrencpp is a tasking library for C++ allowing developers to write highly concurrent applications easily and safely by using tasks, executors and coroutines.
- **continuable** [ğŸ“](./continuable) [ğŸŒ](https://github.com/GerHobbelt/continuable) -- a C++14 library that provides full support for:
  
  * lazy async continuation chaining based on callbacks (**then**) and expression templates, callbacks are wrapped nicely as **promises**.
  * **no enforced type-erasure** which means we need **less heap allocations** than comparable libraries, strictly following the **"don't pay for what you don't use"** principle.
  * support for *all*, *any* and *sequential* connections between continuables through expressive operator overloads **&&**, **||** and **>>** as well as free functions **when_all**, **when_any** and **when_seq**.
  * asynchronous **error handling** through **exceptions**, **error codes** and **user defined types**.
  * syntactic sugar for instance: **partial invocation**, **tuple unpacking**, `co_await` support and **executors**.
  * **encapsuled from any runtime**, larger framework or executors makes it possible to use continuable even in smaller or esoteric usage scenarios.

- **libq** [ğŸ“](./libq) [ğŸŒ](https://github.com/GerHobbelt/q) -- A platform-independent promise library for C++, implementing asynchronous continuations.
- **portable_concurrency-std-future** [ğŸ“](./portable_concurrency-std-future) [ğŸŒ](https://github.com/GerHobbelt/portable_concurrency) -- Portable implementation of future/promise API in C++. `std::future` done right.
- **promise-cpp** [ğŸ“](./promise-cpp) [ğŸŒ](https://github.com/GerHobbelt/promise-cpp) -- advanced C++ promise/A+ library in Javascript style
- **promise-hpp** [ğŸ“](./promise-hpp) [ğŸŒ](https://github.com/GerHobbelt/promise.hpp) -- C++ asynchronous promises like a Promises/A+
- **quantum** [ğŸ“](./quantum) [ğŸŒ](https://github.com/GerHobbelt/quantum) -- a full-featured and powerful C++ framework build on top of the [Boost coroutine](https://www.boost.org/doc/libs/1_65_0/libs/coroutine2/doc/html/index.html) library. The framework allows users to dispatch units of work (a.k.a. _tasks_) as coroutines and execute them concurrently using the 'reactor' pattern.
- **YACLib** [ğŸ“](./YACLib) [ğŸŒ](https://github.com/GerHobbelt/YACLib) -- YACLib is a lightweight C++ library for concurrent and parallel task execution.
- https://github.com/alxvasilev/cpp-promise -- Javascript-like C++ promise library
- https://github.com/rhashimoto/poolqueue -- C++ Asynchronous Promises, inspired by Promises/A+.
- https://github.com/YACLib/YACLib -- Yet Another lightweight C++ library for concurrent and parallel task execution.











### multi-processing: running tasks in parallel: multi-processing, multithreading, async, ...

- **asyncplusplus** [ğŸ“](./asyncplusplus) [ğŸŒ](https://github.com/GerHobbelt/asyncplusplus) -- Async++ is a lightweight concurrency framework for C++11.
- **continuable** [ğŸ“](./continuable) [ğŸŒ](https://github.com/GerHobbelt/continuable) -- a C++14 library that provides full support for:
  
  * lazy async continuation chaining based on callbacks (**then**) and expression templates, callbacks are wrapped nicely as **promises**.
  * **no enforced type-erasure** which means we need **less heap allocations** than comparable libraries, strictly following the **"don't pay for what you don't use"** principle.
  * support for *all*, *any* and *sequential* connections between continuables through expressive operator overloads **&&**, **||** and **>>** as well as free functions **when_all**, **when_any** and **when_seq**.
  * asynchronous **error handling** through **exceptions**, **error codes** and **user defined types**.
  * syntactic sugar for instance: **partial invocation**, **tuple unpacking**, `co_await` support and **executors**.
  * **encapsuled from any runtime**, larger framework or executors makes it possible to use continuable even in smaller or esoteric usage scenarios.

- **createprocess-windows** [ğŸ“](./createprocess-windows) [ğŸŒ](https://github.com/GerHobbelt/createprocess-windows) -- drive `CreateProcess` Win32 API
- **FiberTaskingLib** [ğŸ“](./FiberTaskingLib) [ğŸŒ](https://github.com/GerHobbelt/FiberTaskingLib) -- a library for enabling task-based multi-threading. It allows execution of task graphs with arbitrary dependencies. Dependencies are represented as atomic counters. Under the covers, the task graph is executed using fibers, which in turn, are run on a pool of worker threads (one thread per CPU core). This allows the scheduler to wait on dependencies without task chaining or context switches.
- **libaco** [ğŸ“](./libaco) [ğŸŒ](https://github.com/GerHobbelt/libaco) -- a blazing fast and lightweight C asymmetric coroutine library ğŸ’ â›…ğŸš€â›…ğŸŒ Along with the implementation of a production-ready C coroutine library, it has detailed documentation about how to implement a fastest and correct coroutine library, includes a strict mathematical proof. It has no more than 700 LOC but has the full functionality which you may want from a coroutine library. (The phrase "fastest" here means the fastest context switching implementation which complies to the Sys V ABI of Intel386 or AMD64.)
- **libcopp** [ğŸ“](./libcopp) [ğŸŒ](https://github.com/GerHobbelt/libcopp) -- cross-platform coroutine library in C++
- **libcsp** [ğŸ“](./libcsp) [ğŸŒ](https://github.com/GerHobbelt/libcsp) -- a concurrency C library 10x faster than Golang, influenced by the CSP model.
- **libpipeline** [ğŸ“](./libpipeline) [ğŸŒ](https://github.com/GerHobbelt/libpipeline) -- libpipeline, a pipeline manipulation library for setting up and running pipelines of processes, without needing to involve shell command-line parsing which is often error-prone and insecure.  This alleviates programmers of the need to laboriously construct pipelines using lower-level primitives such as fork(2) and execve(2).
- **libtuv** [ğŸ“](./libtuv) [ğŸŒ](https://github.com/GerHobbelt/libtuv) -- a multi-platform tiny event library refactored from `libuv` source for IoT and embedded systems.
- **libunifex** [ğŸ“](./libunifex) [ğŸŒ](https://github.com/GerHobbelt/libunifex) -- a prototype implementation of the C++ sender/receiver async programming model that is currently being considered for standardisation. This project contains implementations of the following: Schedulers, Timers, Asynchronous I/O, Algorithms that encapsulate certain concurrency patterns, Async streams, Cancellation, Coroutine integration.
- **nsync** [ğŸ“](./nsync) [ğŸŒ](https://github.com/GerHobbelt/nsync) -- a C library that exports various synchronization primitives. `nsync` may be desirable in place of `pthread` primitives in some cases:  (1) nsync locks are reader-writer locks (but are as efficient as mutexes).  (2) nsync locks and condition variables occupy only two words each.  (3) nsync works on Unix-like systems and Windows.  It should be portable to other platforms straightforwardly.  (4) nsync provides conditional critical sections.  These fill the same role as condition variables, but are usually easier to use, and in most common cases are comparable in speed.  They can be easier to use in two ways:  (A) it's not necessary to surround the "wait" operation in a while loop; instead the condition is passed to the call as a function and arbitrary pointer argument.  (B) it's not necessary to wake or signal explicitly when the condition(s) become true; they are checked automatically. The primary downsides are:  (A) they are not available in most other common synchronization APIs, and so they may be unfamiliar (even though they date back to the 1960s), and (B) if threads routinely wait on many distinct, false conditions associated with the same lock, they may be slower than condition variables. In this case, clients can use condition variables in the normal way; conditional critical sections and condition variables can be used with the same lock.  (5) nsync waits can be cancelled via an object passed to the wait calls, unlike the pthread model in which threads are cancelled.  This difference can be useful if the computation needs multiple threads, or if cancellation affects only sub-operations within a larger operation by the thread.
- **oneTBB** [ğŸ“](./oneTBB) [ğŸŒ](https://github.com/GerHobbelt/oneTBB) -- Intel's Thread Building Blocks library: used with OpenImageIO, ...
- **openpbs** [ğŸ“](./openpbs) [ğŸŒ](https://github.com/GerHobbelt/openpbs) -- in May 2020, OpenPBS became the new name for the PBS Professional Open Source Project. OpenPBSÂ® software optimizes job scheduling and workload management in high-performance computing (HPC) environments â€“ clusters, clouds, and supercomputers â€“ improving system efficiency and peopleâ€™s productivity.  Built by HPC people for HPC people, OpenPBS is fast, scalable, secure, and resilient, and supports all modern infrastructure, middleware, and applications.
- **pevents** [ğŸ“](./pevents) [ğŸŒ](https://github.com/GerHobbelt/pevents) -- Win32 events for *nix/POSIX platforms, built on top of `pthreads`. `pevents` provides most of the functionality of both manual- and auto-reset events on Windows, most-notably including simultaneous waits on multiple events (Ã  la `WaitForMultipleObjects`). `pevents` also doubles as a thin, sane wrapper for `CreateEvent()` & co. on Windows, meaning you can use `pevents` directly in your cross-platform code without `#ifdef`s for Windows/pthreads. While POSIX condition variables (pthread_cond_t) and WIN32 events both provide the essential building blocks of the synchronization primitives required to write multithreaded code with signaling, the nature of the differences between the two have lent their way towards creating different synchronization and multithreaded-programming paradigms. The only features not included are only named events and support for security attributes. To the author's best knowledge, this is the only implementation of WIN32 events available for Linux and other posix platforms that provides support for simultaneously waiting on multiple events. Depending on your needs, we've been told that pevents may be used as a lightweight alternative to libuv/libev while still allowing your code to embrace asynchronous event handling with ease.
- **PhotonLibOS** [ğŸ“](./PhotonLibOS) [ğŸŒ](https://github.com/GerHobbelt/PhotonLibOS) -- a high-efficiency LibOS framework, based on a set of carefully selected C++ libs. The role of LibOS is to connect user apps and the kernel. Photon's API is as consistent as possible with C++ std and glibc semantics. This flattens the learning curve for lib users and brings convenience when migrating legacy codebases. Photon's runtime is driven by a coroutine lib. Out tests show that it has the best I/O performance in the open source world by the year of 2022, even among different programing languages.
- **pipes** [ğŸ“](./pipes) [ğŸŒ](https://github.com/GerHobbelt/pipes) -- Pipes are small components for writing expressive code when working on collections. Pipes chain together into a pipeline that receives data from a source, operates on that data, and send the results to a destination. This is a header-only library, implemented in C++14.
- **pthread-win32** [ğŸ“](./pthread-win32) [ğŸŒ](https://github.com/GerHobbelt/pthread-win32) -- `pthread` for MS Windows
- **quantum** [ğŸ“](./quantum) [ğŸŒ](https://github.com/GerHobbelt/quantum) -- a full-featured and powerful C++ framework build on top of the [Boost coroutine](https://www.boost.org/doc/libs/1_65_0/libs/coroutine2/doc/html/index.html) library. The framework allows users to dispatch units of work (a.k.a. _tasks_) as coroutines and execute them concurrently using the 'reactor' pattern.
- **state-threads** [ğŸ“](./state-threads) [ğŸŒ](https://github.com/GerHobbelt/state-threads) -- a lightweight thread library for C/C++ coroutine (similar to goroutine), for high performance network servers: the State Threads Library is a small application library which provides a foundation for writing fast and highly scalable Internet applications (such as web servers, proxy servers, mail transfer agents, and so on) on UNIX-like platforms.
- **subprocess** [ğŸ“](./subprocess) [ğŸŒ](https://github.com/GerHobbelt/subprocess) -- cross platform subprocess library for C++ similar to design of Python `subprocess`.
- **subprocess_h** [ğŸ“](./subprocess_h) [ğŸŒ](https://github.com/GerHobbelt/subprocess.h) -- ğŸœ a simple one header solution to launching processes and interacting with them for C/C++.
- **tiny-process-library** [ğŸ“](./tiny-process-library) [ğŸŒ](https://github.com/GerHobbelt/tiny-process-library) -- small platform independent library making it simple to create and stop new processes, as well as writing to stdin and reading from stdout and stderr of a new process.
- **transwarp** [ğŸ“](./transwarp) [ğŸŒ](https://github.com/GerHobbelt/transwarp) -- a header-only C++ library for task concurrency. It allows you to easily create a graph of tasks where every task can be executed synchronously. transwarp is written in C++17 and only depends on the standard library.
- **uvw** [ğŸ“](./uvw) [ğŸŒ](https://github.com/GerHobbelt/uvw) -- `libuv` wrapper in modern C++. `uvw` started as a header-only, event based, tiny and easy to use wrapper for [`libuv`](https://github.com/libuv/libuv) written in modern C++.  Now it's finally available also as a compilable static library. The basic idea is to wrap the *C-ish* interface of `libuv` behind a graceful C++ API.
- https://github.com/arun11299/cpp-subprocess -- as close as possible to Python2.7 `subprocess` module in dealing with processes.
- https://github.com/pnappa/subprocesscpp -- A header-only library that allows you to execute processes either synchronously or asynchronously, whilst providing input and output handling. No more calling `exec` in C++!
- https://github.com/rajatjain1997/subprocess -- A C++ high level library for running shell processes
- https://github.com/sheredom/subprocess.h -- A one header solution to launching processes and interacting with them for C/C++.











### multi-processing: event handling, signals, asynchronous operation

- **eventpp** [ğŸ“](./eventpp) [ğŸŒ](https://github.com/GerHobbelt/eventpp) -- a C++ event library for callbacks, event dispatcher, and event queue. With eventpp you can easily implement signal and slot mechanism, publisher and subscriber pattern, or observer pattern.
- **libevent** [ğŸ“](./libevent) [ğŸŒ](https://github.com/GerHobbelt/libevent) -- _libevent_ is meant to replace the event loop found in event driven network servers.
  
  Currently, _libevent_ supports _[/dev/poll](http://download.oracle.com/docs/cd/E19253-01/816-5177/6mbbc4g9n/index.html)_, _[kqueue(2)](http://www.freebsd.org/cgi/man.cgi?query=kqueue&apropos=0&sektion=0&format=html)_, _[event ports](http://developers.sun.com/solaris/articles/event_completion.html)_, [POSIX _select(2)_](http://manpages.debian.net/cgi-bin/man.cgi?query=select), [Windows _select()_](http://msdn.microsoft.com/en-us/library/ms740141(v=vs.85).aspx), [_poll(2)_](http://manpages.debian.net/cgi-bin/man.cgi?query=poll), and _[epoll(4)](http://www.xmailserver.org/linux-patches/epoll.txt)_. The internal event mechanism is completely independent of the exposed event API, and a simple update of libevent can provide new functionality without having to redesign the applications. As a result, _Libevent_ allows for portable application development and provides the most scalable event notification mechanism available on an operating system. Libevent can also be used for multi-threaded applications, either by isolating each `event_base` so that only a single thread accesses it, or by locked access to a single shared `event_base`. _Libevent_ should compile on Linux, *BSD, Mac OS X, Solaris, Windows, and more.
  
  Libevent additionally provides a sophisticated framework for buffered network IO, with support for sockets, filters, rate-limiting, SSL, zero-copy file transmission, and IOCP. Libevent includes support for several useful protocols, including DNS, HTTP, and a minimal RPC framework.

- **libocca** [ğŸ“](./libocca) [ğŸŒ](https://github.com/GerHobbelt/occa) -- a portable and vendor neutral framework for parallel programming on heterogeneous platforms. The OCCA API provides unified models for heterogeneous programming concepts&mdash;such as a device, memory, or kernel&mdash;while the OCCA Kernel Language (OKL) enables the creation of portable device kernels using a directive-based extension to the C-language.
- **libsigcplusplus** [ğŸ“](./libsigcplusplus) [ğŸŒ](https://github.com/GerHobbelt/libsigcplusplus) -- libsigc++ : The Typesafe Callback Framework for C++. It allows you to define signals and to connect those signals to any callback function, either global or a member function, regardless of whether it is static or virtual.
- **libuv** [ğŸ“](./libuv) [ğŸŒ](https://github.com/GerHobbelt/libuv) -- a multi-platform support library with a focus on asynchronous I/O.
  
  Feature highlights:
  
  * Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
  * Asynchronous TCP and UDP sockets
  * Asynchronous DNS resolution
  * Asynchronous file and file system operations
  * File system events
  * ANSI escape code controlled TTY
  * IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
  * Child processes
  * Thread pool
  * Signal handling
  * High resolution clock
  * Threading and synchronization primitives

- **nano-signal-slot** [ğŸ“](./nano-signal-slot) [ğŸŒ](https://github.com/GerHobbelt/nano-signal-slot) -- pure C++17 Signals and Slots (observer pattern)
- **Signals** [ğŸ“](./Signals) [ğŸŒ](https://github.com/GerHobbelt/Signals) -- a lightweight "signals and slots" implementation using fast delegates. When GUI programming in C++, delegates and the signals and slots paradigm can vastly simplify your code. It implements the Observer pattern while avoiding all the boilerplate code. I needed a lightweight and efficient implementation that I could just drop into my projects and use without adding weird macros, inheriting from crazy templates or having external dependencies. I wanted something simpler and more efficient than libsigc++, sigslot, and boost.signals.
- **uvw** [ğŸ“](./uvw) [ğŸŒ](https://github.com/GerHobbelt/uvw) -- `libuv` wrapper in modern C++. `uvw` started as a header-only, event based, tiny and easy to use wrapper for [`libuv`](https://github.com/libuv/libuv) written in modern C++.  Now it's finally available also as a compilable static library. The basic idea is to wrap the *C-ish* interface of `libuv` behind a graceful C++ API.











### multi-processing: task schedulers

- **asynqro** [ğŸ“](./asynqro) [ğŸŒ](https://github.com/GerHobbelt/asynqro) -- Futures and thread pool for C++: Asynqro gives developers a rich monadic Future API (inspired by Future API in Scala language), a clean API, refined task scheduling logic and is not tied to any framework.
- **continuable** [ğŸ“](./continuable) [ğŸŒ](https://github.com/GerHobbelt/continuable) -- a C++14 library that provides full support for:
  
  * lazy async continuation chaining based on callbacks (**then**) and expression templates, callbacks are wrapped nicely as **promises**.
  * **no enforced type-erasure** which means we need **less heap allocations** than comparable libraries, strictly following the **"don't pay for what you don't use"** principle.
  * support for *all*, *any* and *sequential* connections between continuables through expressive operator overloads **&&**, **||** and **>>** as well as free functions **when_all**, **when_any** and **when_seq**.
  * asynchronous **error handling** through **exceptions**, **error codes** and **user defined types**.
  * syntactic sugar for instance: **partial invocation**, **tuple unpacking**, `co_await` support and **executors**.
  * **encapsuled from any runtime**, larger framework or executors makes it possible to use continuable even in smaller or esoteric usage scenarios.

- **enkiTS-TaskScheduler** [ğŸ“](./enkiTS-TaskScheduler) [ğŸŒ](https://github.com/GerHobbelt/enkiTS) -- a permissively licensed C++11 Task Scheduler for creating parallel programs. The primary goal of enkiTS is to help developers create programs which handle both data and task level parallelism to utilize the full performance of multicore CPUs, whilst being lightweight (only a small amount of code) and easy to use.
  
  Features:
  
    - Braided parallelism - can issue tasks from another task as well as from the thread which created the Task System, and has a simple task interface for both data and task parallelism.
    - Can pin tasks to a given thread - can schedule a task which will only be run on the specified thread.
    - Can register external threads to use with enkiTS
    - Can set task priorities - Up to 5 task priorities can be configured via define ENKITS_TASK_PRIORITIES_NUM (defaults to 3). Higher priority tasks are run before lower priority ones.
    - Can wait for pinned tasks - useful for creating IO threads which do no other work.
    - Completion Actions - can perform an action on task completion. This avoids the expensive action of adding the task to the scheduler, and can be used to safely delete a completed task.
    - Dependencies - can set dependencies between tasks.
    - Fast, then scalable - designed for consumer devices first, so performance on a low number of threads is important, followed by scalability.
    - Lightweight
    - Up-front Allocation friendly - designed for zero allocations during scheduling.

- **FiberTaskingLib** [ğŸ“](./FiberTaskingLib) [ğŸŒ](https://github.com/GerHobbelt/FiberTaskingLib) -- a library for enabling task-based multi-threading. It allows execution of task graphs with arbitrary dependencies. Dependencies are represented as atomic counters. Under the covers, the task graph is executed using fibers, which in turn, are run on a pool of worker threads (one thread per CPU core). This allows the scheduler to wait on dependencies without task chaining or context switches.
- **google::marl** [ğŸ“](./google-marl) [ğŸŒ](https://github.com/GerHobbelt/marl) -- a hybrid thread / fiber task scheduler written in C++ 11. Marl uses a combination of fibers and threads to allow efficient execution of tasks that can block, while keeping a fixed number of hardware threads.
- **libpipeline** [ğŸ“](./libpipeline) [ğŸŒ](https://github.com/GerHobbelt/libpipeline) -- libpipeline, a pipeline manipulation library for setting up and running pipelines of processes, without needing to involve shell command-line parsing which is often error-prone and insecure.  This alleviates programmers of the need to laboriously construct pipelines using lower-level primitives such as fork(2) and execve(2).
- **taskflow** [ğŸ“](./taskflow) [ğŸŒ](https://github.com/GerHobbelt/taskflow) -- Quickly write parallel and heterogeneous task programs in modern C++. Taskflow is faster, more expressive, and easier for drop-in integration than many of existing task programming frameworks in handling complex parallel workloads.
- **transwarp** [ğŸ“](./transwarp) [ğŸŒ](https://github.com/GerHobbelt/transwarp) -- a header-only C++ library for task concurrency. It allows you to easily create a graph of tasks where every task can be executed synchronously. transwarp is written in C++17 and only depends on the standard library.











### multi-processing: thread pools

- **concurrencpp** [ğŸ“](./concurrencpp) [ğŸŒ](https://github.com/GerHobbelt/concurrencpp) -- the C++ concurrency library: concurrencpp is a tasking library for C++ allowing developers to write highly concurrent applications easily and safely by using tasks, executors and coroutines.
- **concurrentqueue** [ğŸ“](./concurrentqueue) [ğŸŒ](https://github.com/GerHobbelt/concurrentqueue) -- moodycamel::ConcurrentQueue, an industrial-strength and fast multi-producer, multi-consumer lock-free concurrent queue for C++11.
- **CTPL-Thread-Pool** [ğŸ“](./CTPL-Thread-Pool) [ğŸŒ](https://github.com/GerHobbelt/CTPL) -- Modern and efficient C++ Thread Pool Library. More specifically, there are some threads dedicated to the pool and a container of jobs. The jobs come to the pool dynamically. A job is fetched and deleted from the container when there is an idle thread. The job is then run on that thread.
- **pthreadpool** [ğŸ“](./pthreadpool) [ğŸŒ](https://github.com/GerHobbelt/pthreadpool) -- pthreadpool is a portable and efficient thread pool implementation. It provides similar functionality to `#pragma omp parallel for`, but with additional features.
- **thread-pool** [ğŸ“](./thread-pool) [ğŸŒ](https://github.com/GerHobbelt/thread-pool) -- `BS::thread_pool`: a fast, lightweight, and easy-to-use C++17 thread pool library (by Barak Shoshany)
- **thread-pool-c** [ğŸ“](./thread-pool-c) [ğŸŒ](https://github.com/GerHobbelt/C-Thread-Pool) -- a minimal but advanced threadpool implementation.
- **thread-pool-cpp** [ğŸ“](./thread-pool-cpp) [ğŸŒ](https://github.com/GerHobbelt/thread-pool-cpp) -- highly scalable and fast thread pool. It implements both work-stealing and work-distribution balancing startegies. It implements cooperative scheduling strategy.
- **YACLib** [ğŸ“](./YACLib) [ğŸŒ](https://github.com/GerHobbelt/YACLib) -- YACLib is a lightweight C++ library for concurrent and parallel task execution.











### run-time library core features: logging, formatting, ...

- **agg** [ğŸ“](./agg) [ğŸŒ](https://github.com/GerHobbelt/agg) -- Anti-Grain Geometry library, written by Maxim Shemanarev in C++. It is an Open Source, 2D vector graphics library. Agg produces pixel images in memory from vectorial data. AGG doesn't depend on any graphic API or technology. Basically, you can think of AGG as of a rendering engine that produces pixel images in memory from some vectorial data.
- **cfgpath** [ğŸ“](./cfgpath) [ğŸŒ](https://github.com/GerHobbelt/cfgpath) -- cross platform methods for obtaining paths to configuration files
- **clp** [ğŸ“](./clp) [ğŸŒ](https://github.com/GerHobbelt/clp) -- YScope's Compressed Log Processor (CLP) compresses your logs, and allows you to search the compressed logs without decompression. CLP supports both JSON logs and unstructured (i.e., free text) logs. It also supports real-time log compression within several logging libraries. CLP also includes purpose-built web interfaces for searching and viewing the compressed logs.
- **detect-character-encoding** [ğŸ“](./detect-character-encoding) [ğŸŒ](https://github.com/GerHobbelt/detect-character-encoding) -- detect character encoding using [ICU](http://site.icu-project.org).  **Tip:** If you donâ€™t need ICU in particular, consider using [ced](https://github.com/sonicdoe/ced), which is based on Googleâ€™s lighter [compact_enc_det](https://github.com/google/compact_enc_det) library.
- **easyloggingpp** [ğŸ“](./easyloggingpp) [ğŸŒ](https://github.com/GerHobbelt/easyloggingpp) -- Easylogging++ is single header efficient logging library for C++ applications. It is extremely powerful, highly extendable and configurable to user's requirements. It provides ability to write your own _sinks_ (via a feature referred as `LogDispatchCallback`).
- **expected-lite** [ğŸ“](./expected-lite) [ğŸŒ](https://github.com/GerHobbelt/expected-lite) -- a single-file header-only library to represent value objects that either contain a valid value or an error. The library is a partly implementation of the proposal for [`std::expected`](https://en.cppreference.com/w/cpp/utility/expected) for use with C++11 and later.
- **fast_double_parser** [ğŸ“](./fast_double_parser) [ğŸŒ](https://github.com/GerHobbelt/fast_double_parser) -- 4x faster than `strtod()`. Unless you need support for [RFC 7159](https://tools.ietf.org/html/rfc7159) (JSON standard), we encourage users to adopt [fast_float](https://github.com/fastfloat/fast_float) library instead. It has more functionality. Fast function to parse ASCII strings containing decimal numbers into double-precision (binary64) floating-point values.  That is, given the string "1.0e10", it should return a 64-bit floating-point value equal to 10000000000. We do not sacrifice accuracy. The function will match exactly (down the smallest bit) the result of a standard function like `strtod`.
- **fast_float** [ğŸ“](./fast_float) [ğŸŒ](https://github.com/GerHobbelt/fast_float) -- fast and exact implementation of the C++ `from_chars` functions for float and double types: 4x faster than `strtod`
- **fast-hex** [ğŸ“](./fast-hex) [ğŸŒ](https://github.com/GerHobbelt/fast-hex) -- a fast, SIMD (vectorized) hex string encoder/decoder.
- **FastString** [ğŸ“](./FastString) [ğŸŒ](https://github.com/GerHobbelt/FastString) -- fast, in stack, fixed size string implementation with **constexpr noexcept** constructors and accessors. **FastString** improves **memory locality and latency** of strings by avoiding heap allocations.
- **fluent-bit** [ğŸ“](./fluent-bit) [ğŸŒ](https://github.com/GerHobbelt/fluent-bit) -- [Fluent Bit](http://fluentbit.io) is a fast Log Processor and Forwarder for Linux, Windows, Embedded Linux, MacOS and BSD family operating systems. It's part of the Graduated [Fluentd](http://fluentd.org) Ecosystem and a [CNCF](https://cncf.io) sub-project. Fluent Bit allows to collect log events or metrics from different sources, process them and deliver them to different backends such as [Fluentd](http://fluentd.org), Elasticsearch, Splunk, DataDog, Kafka, New Relic, Azure services, AWS services, Google services, NATS, InfluxDB or any custom HTTP end-point.
- **fmt** [ğŸ“](./fmt) [ğŸŒ](https://github.com/GerHobbelt/fmt) -- advanced C++ data-to-text formatter. The modern answer to classic `printf()`.
- **fmtlog** [ğŸ“](./fmtlog) [ğŸŒ](https://github.com/GerHobbelt/fmtlog) -- a performant fmtlib-style logging library with latency in nanoseconds (i.e. using fmt library format).
- **frozen** [ğŸ“](./frozen) [ğŸŒ](https://github.com/GerHobbelt/frozen) -- provides 0 cost initialization for immutable containers, fixed-size containers, and various algorithms.
- **hedley** [ğŸ“](./hedley) [ğŸŒ](https://github.com/GerHobbelt/hedley) -- a C/C++ header file designed to smooth over some platform-specific annoyances.
- **hypertextcpp** [ğŸ“](./hypertextcpp) [ğŸŒ](https://github.com/GerHobbelt/hypertextcpp) -- string/text template engine & source-to-source compiler.
- **libpathutils** [ğŸ“](./libpathutils) [ğŸŒ](https://github.com/GerHobbelt/libpathutils) -- cross-platform filesystem path utility functions
- **libquill** [ğŸ“](./libquill) [ğŸŒ](https://github.com/GerHobbelt/quill) -- a cross-platform low latency logging library based on C++14.
- **libscanf** [ğŸ“](./libscanf) [ğŸŒ](https://github.com/GerHobbelt/scnlib) -- a modern C++ library for replacing `scanf` and `std::istream`. This library attempts to move us ever so closer to replacing `iostream`s and C stdio altogether. It's faster than `iostream` (see Benchmarks) and type-safe, unlike `scanf`. Think [{fmt}](https://github.com/fmtlib/fmt) but in the other direction.
- **libwil** [ğŸ“](./libwil) [ğŸŒ](https://github.com/GerHobbelt/wil) -- The Windows Implementation Libraries (WIL) is a header-only C++ library created to make life easier for developers on Windows through readable type-safe C++ interfaces for common Windows coding patterns.
- **libxo** [ğŸ“](./libxo) [ğŸŒ](https://github.com/GerHobbelt/libxo) -- `libxo` allows an application to generate text, XML, JSON, and HTML output using a common set of function calls (rather than the application using old skool `printf()`).  The application decides at run time which output style should be produced.
- **linecook** [ğŸ“](./linecook) [ğŸŒ](https://github.com/GerHobbelt/linecook) -- a C library for editing the command line, much like the [readline](https://tiswww.cwru.edu/php/chet/readline/readline.html) library used in <b>bash</b> and <b>gdb</b>.
- **lnav** [ğŸ“](./lnav) [ğŸŒ](https://github.com/GerHobbelt/lnav) -- the Log File Navigator, **lnav** for short, is an advanced log file viewer for the small-scale.  It is a terminal application that can understand your log files and make it easy for you to find problems with little to no setup.
- **magic_enum** [ğŸ“](./magic_enum) [ğŸŒ](https://github.com/GerHobbelt/magic_enum) -- Header-only C++17 library provides static reflection for enums; works with any enum type without any macro or boilerplate code.
- **messagebox-windows** [ğŸ“](./messagebox-windows) [ğŸŒ](https://github.com/GerHobbelt/messagebox-windows) -- drive `MessageBox` and `MessageBeep` Win32 APIs
- **microsoft-performance-toolkit-sdk** [ğŸ“](./microsoft-performance-toolkit-sdk) [ğŸŒ](https://github.com/GerHobbelt/microsoft-performance-toolkit-sdk) -- The Microsoft Performance Toolkit is a collection of cross-platform tools developers can use to create and extend performance analysis applications. It serves as the runtime of the Windows Performance Analyzer, a Windows program included in the Windows Performance Toolkit. By using the Microsoft Performance Toolkit SDK, Windows Performance Analyzer - or any performance analysis application - can be configured to process and display performance data from arbitrary sources.
- **NanoLog** [ğŸ“](./NanoLog) [ğŸŒ](https://github.com/GerHobbelt/NanoLog) -- an extremely performant nanosecond scale logging system for C++ that exposes a simple printf-like API and achieves over 80 million logs/second at a median latency of just over 7 nanoseconds.
- **numero** [ğŸ“](./numero) [ğŸŒ](https://github.com/GerHobbelt/numero) -- a library which parses/extracts a decimal number, either integer or floating-point, either in scientific notation or not, from the given input string. It uses the thousands and decimal separator symbols given in the conversion options. It also provides methods for the inverse operation, i.e. converting a value to a (English) human-readable text, e.g. "one thousand and twenty four" for `1024`.
- **oppat** [ğŸ“](./oppat) [ğŸŒ](https://github.com/GerHobbelt/oppat) -- Open Power/Performance Analysis Tool (OPPAT) is a cross-OS, cross-architecture Power and Performance Analysis Tool. cross-OS: supports Windows ETW trace files and Linux/Android perf/trace-cmd trace files. cross-architecture: supports Intel and ARM chips hardware events (using perf and/or PCM).
- **pcg-cpp-random** [ğŸ“](./pcg-cpp-random) [ğŸŒ](https://github.com/GerHobbelt/pcg-cpp) -- a C++ implementation of the PCG family of random number generators, which are fast, statistically excellent, and offer a number of useful features.
- **pcg-c-random** [ğŸ“](./pcg-c-random) [ğŸŒ](https://github.com/GerHobbelt/pcg-c) -- a C implementation of the PCG family of random number generators, which are fast, statistically excellent, and offer a number of useful features.
- **plf_nanotimer** [ğŸ“](./plf_nanotimer) [ğŸŒ](https://github.com/GerHobbelt/plf_nanotimer) -- high precision cross-platform performance timer
- **prio_queue** [ğŸ“](./prio_queue) [ğŸŒ](https://github.com/GerHobbelt/prio_queue) -- a cache friendly priority queue, done as a B-heap.
- **randen** [ğŸ“](./randen) [ğŸŒ](https://github.com/GerHobbelt/randen) -- What if we could default to attack-resistant random generators without excessive CPU cost? We introduce 'Randen', a new generator with security guarantees; it outperforms MT19937, pcg64_c32, Philox, ISAAC and ChaCha8 in real-world benchmarks. This is made possible by AES hardware acceleration and a large Feistel permutation.
- **random** [ğŸ“](./random) [ğŸŒ](https://github.com/GerHobbelt/random) -- random for modern C++ with a convenient API.
- **refl-cpp** [ğŸ“](./refl-cpp) [ğŸŒ](https://github.com/GerHobbelt/refl-cpp) -- static reflection for C++17 (compile-time enumeration, attributes, proxies, overloads, template functions, metaprogramming).
- **result-cpp** [ğŸ“](./result-cpp) [ğŸŒ](https://github.com/GerHobbelt/result) -- `Result<T, E>` is a modern, simple, and light-weight error-handling alternative to C++ exceptions with a rich feature-set.
- **spdlog** [ğŸ“](./spdlog) [ğŸŒ](https://github.com/GerHobbelt/spdlog) -- very fast, header-only/compiled, C++ logging library.
- **spdlog_setup** [ğŸ“](./spdlog_setup) [ğŸŒ](https://github.com/GerHobbelt/spdlog_setup) -- file-based setup library for convenience in initializing spdlog.
- **sqlplot-tools** [ğŸ“](./sqlplot-tools) [ğŸŒ](https://github.com/GerHobbelt/sqlplot-tools) -- a tool to **process data series** from algorithm experiments **using SQL statements** and embed the results in **gnuplot** datafiles or **pgfplots** LaTeX files. Using SQL to generate plots can be see as **cracking a nut with a sledgehammer**, but it really works well in practice.
- **stdext-path** [ğŸ“](./stdext-path) [ğŸŒ](https://github.com/GerHobbelt/stdext-path) -- path manipulations (`dirname` et al)
  
  - **taolog** [ğŸ“](./taolog) [ğŸŒ](https://github.com/GerHobbelt/taolog) -- A Win32 logger based on DebugView & ETW.

- **stx-error-handling** [ğŸ“](./stx-error-handling) [ğŸŒ](https://github.com/GerHobbelt/STX) -- C++ 17 & C++ 20 error-handling and utility extensions.
- **TraceETW** [ğŸ“](./TraceETW) [ğŸŒ](https://github.com/GerHobbelt/TraceEtw) -- [Event Tracing for Windows (ETW)](http://msdn.microsoft.com/en-us/library/windows/desktop/aa363668(v=vs.85).aspx) is  powerful but notoriously complex. In C#, [EventSource](http://msdn.microsoft.com/en-us/library/system.diagnostics.tracing.eventsource(v=vs.110).aspx) made that technology much more approachable. This project aims at providing a similar solution for C++, both for Desktop apps and for Windows/Windows Phone Universal Store apps.
- **utf8proc** [ğŸ“](./utf8proc) [ğŸŒ](https://github.com/GerHobbelt/utf8proc) -- [utf8proc](http://juliastrings.github.io/utf8proc/) is a small, clean C library that provides Unicode normalization, case-folding, and other operations for data in the [UTF-8 encoding](http://en.wikipedia.org/wiki/UTF-8).
- **wcwidth9** [ğŸ“](./wcwidth9) [ğŸŒ](https://github.com/GerHobbelt/wcwidth9) -- platform independent, header only, `wcwidth` with full Unicode 9 wide character support.
- **WinToast** [ğŸ“](./WinToast) [ğŸŒ](https://github.com/GerHobbelt/WinToast) -- a library which delivers a complete integration of the modern **toast notifications** of **Windows 8**, **Windows 10** and **Windows 11**.  Toast notifications allows your app to inform the users about relevant information and timely events that they should see and take action upon inside your app, such as a new instant message, a new friend request, breaking news, or a calendar event.
- ~~**merror** [ğŸ“](./merror) [ğŸŒ](https://github.com/GerHobbelt/merror) -- a library for error handling in C++ without exceptions.~~
  
  - **removed**; reason: code is non-portable to compilers other than GCC, or at least would require more effort than we're willing to expend on this.












## web servers, generic sockets I/O (IPC)

- **civetweb** [ğŸ“](./civetweb) [ğŸŒ](https://github.com/GerHobbelt/civetweb) -- an easy to use, powerful, C (C/C++) embeddable web server with optional CGI, SSL and Lua support.
- **crow** [ğŸ“](./crow) [ğŸŒ](https://github.com/GerHobbelt/crow) -- IPC / server framework
- **drogon** [ğŸ“](./drogon) [ğŸŒ](https://github.com/GerHobbelt/drogon) -- a C++14/17-based HTTP application framework to easily build various types of web application server programs.
- **proxygen** [ğŸ“](./proxygen) [ğŸŒ](https://github.com/GerHobbelt/proxygen) -- the core C++ HTTP abstractions used at Facebook. Internally, it is used as the basis for building many HTTP servers, proxies, and clients, focusing on the common HTTP abstractions and our simple HTTPServer framework. The framework supports HTTP/1.1, SPDY/3, SPDY/3.1, HTTP/2, and HTTP/3.
- **wget** [ğŸ“](./wget) [ğŸŒ](https://github.com/GerHobbelt/wget) -- GNU Wget is a free utility for non-interactive download of files from the Web.  It supports HTTP, HTTPS, and FTP protocols, as well as retrieval through HTTP proxies.
- ~~**h2o-server** [ğŸ“](./h2o-server) [ğŸŒ](https://github.com/GerHobbelt/h2o) -- an optimized HTTP/1, HTTP/2, HTTP/3 server.~~
  
  - **removed**; reason: we've decided on using `crow` as the main server framework. Second choice is `civetweb`. As we're looking for a non-public-facing web server, we don't need h2o and it's complexity.

- ~~**libmicrohttpd** [ğŸŒ](https://github.com/Karlson2k/libmicrohttpd)~~
  
  - **removed**; reason: we've decided on using `crow` as the main server framework. Second choices are `civetweb` and `h2o`. This GNU library is way too 'Unix-is-the-world' oriented for a smooth portable dev experience.

- ~~**oatpp** [ğŸŒ](https://github.com/oatpp/oatpp) -- IPC / server framework~~
  
  - **removed**; reason: we've decided on using `crow` as the main server framework.












## socket I/O: websockets

- **libwebsocketpp** [ğŸ“](./libwebsocketpp) [ğŸŒ](https://github.com/GerHobbelt/websocketpp) -- WebSocket++ is a header only C++ library that implements RFC6455 The WebSocket Protocol.
- **libwebsockets** [ğŸ“](./libwebsockets) [ğŸŒ](https://github.com/GerHobbelt/libwebsockets) -- a simple-to-use C library providing client and server for HTTP/1, HTTP/2, WebSockets, MQTT and other protocols. It supports a lot of lightweight ancilliary implementations for things like JSON, CBOR, JOSE, COSE. It's very gregarious when it comes to event loop sharing, supporting libuv, libevent, libev, sdevent, glib and uloop, as well as custom event libs.
- **websocket-sharp** [ğŸ“](./websocket-sharp) [ğŸŒ](https://github.com/GerHobbelt/websocket-sharp) -- a C# implementation of the WebSocket protocol client and server.











## disk I/O, monitoring import locations, ...

- **asio** [ğŸ“](./asio) [ğŸŒ](https://github.com/GerHobbelt/asio) -- a cross-platform C++ library for network and low-level I/O programming that provides developers with a consistent asynchronous model using a modern C++ approach.
  
  Note: (older) Boost.Asio is also included in Boost.

- **cfgpath** [ğŸ“](./cfgpath) [ğŸŒ](https://github.com/GerHobbelt/cfgpath) -- cross platform methods for obtaining paths to configuration files
- **cpplocate** [ğŸ“](./cpplocate) [ğŸŒ](https://github.com/GerHobbelt/cpplocate) -- a cross-platform C++ library that provides tools for applications to locate their binary files and data assets, as well as those of dependent modules.
- **directorywatcher** [ğŸ“](./directorywatcher) [ğŸŒ](https://github.com/GerHobbelt/myoddweb.directorywatcher) -- a fast and reliable File/Directory watcher for C#/C++ to replace the current .NET `FileSystemWatcher` class.
- **dirent** [ğŸ“](./dirent) [ğŸŒ](https://github.com/GerHobbelt/dirent) -- POSIX `dirent.h` ported to MS Windows (Win32/Win64); used by several libraries.
- **efsw** [ğŸ“](./efsw) [ğŸŒ](https://github.com/GerHobbelt/efsw) -- cross-platform file system watcher and notifier
- **FastGlobbing** [ğŸ“](./FastGlobbing) [ğŸŒ](https://github.com/GerHobbelt/FastGlobbing) -- a Fast String Matching with Wildcards, Globs, and Gitignore-Style Globs. Wildcard string matching and globbing isnâ€™t as trivial as it may seem at first.  In fact, mistakes in the past resulted in serious vulnerabilities such as denial of service due to exponential blow-up in execution time. This fast non-recursive algorithm performs safe gitignore-style wildcard matching.  Implementations in C, C++, Java, Javascript and Python are included.
- **filesystem** [ğŸ“](./filesystem) [ğŸŒ](https://github.com/GerHobbelt/filesystem) -- a header-only single-file `std::filesystem` compatible helper library, based on the C++17 and C++20 specs, but implemented for C++11, C++14, C++17 or C++20 (tightly following the C++17 standard with very few documented exceptions). It is of course in its own namespace `ghc::filesystem` to not interfere with a regular `std::filesystem` should you use it in a mixed C++17 environment (which is possible).
- **fnmatch** [ğŸ“](./fnmatch) [ğŸŒ](https://github.com/GerHobbelt/fnmatch) -- match a filename string or a pathname using POSIX wildcards.
- **fswatch** [ğŸ“](./fswatch) [ğŸŒ](https://github.com/GerHobbelt/fswatch) -- a cross-platform file change monitor that receives notifications when the contents of the specified files or directories are modified.
- **glob** [ğŸ“](./glob) [ğŸŒ](https://github.com/GerHobbelt/glob) -- directory scanner
- **libpathutils** [ğŸ“](./libpathutils) [ğŸŒ](https://github.com/GerHobbelt/libpathutils) -- cross-platform filesystem path utility functions
- **libwildmatch** [ğŸ“](./libwildmatch) [ğŸŒ](https://github.com/GerHobbelt/wildmatch) -- wildmatch is a BSD-licensed C/C++ library for git/rsync-style pattern matching.
- **tinydir** [ğŸ“](./tinydir) [ğŸŒ](https://github.com/GerHobbelt/tinydir) -- lightweight, portable and easy to integrate C directory and file reader. TinyDir wraps `dirent` for POSIX and `FindFirstFile` for Windows. Windows unicode is supported.
- **Win32_read_directory_changes** [ğŸ“](./Win32_read_directory_changes) [ğŸŒ](https://github.com/GerHobbelt/readdirectorychanges) -- sample code which goes with [Understanding ReadDirectoryChangesW](http://qualapps.blogspot.com/2010/05/understanding-readdirectorychangesw.html)
- **Win32_read_directory_changes_IOCP** [ğŸ“](./Win32_read_directory_changes_IOCP) [ğŸŒ](https://github.com/GerHobbelt/ReadDirectoryChangesIOCP) -- inspired by jimbeveridge's artical [Understanding ReadDirectoryChangesW](http://qualapps.blogspot.com/2010/05/understanding-readdirectorychangesw.html)! The project shows how to read directory changes by IO completion port on windows platform.











## configuration / parameterization

- **cfgpath** [ğŸ“](./cfgpath) [ğŸŒ](https://github.com/GerHobbelt/cfgpath) -- cross platform methods for obtaining paths to configuration files
- **cjose** [ğŸ“](./cjose) [ğŸŒ](https://github.com/GerHobbelt/cjose) -- JOSE for C/C++
- **config-cpp** [ğŸ“](./config-cpp) [ğŸŒ](https://github.com/GerHobbelt/config-cpp) -- a C++ Configuration library patterned after [`viper`](https://github.com/spf13/viper) package for golang.  It is designed to work within an application and handle configuration needs.
- **figcone** [ğŸ“](./figcone) [ğŸŒ](https://github.com/GerHobbelt/figcone) -- a C++17 / C++20 library, providing a convenient declarative interface for configuration parsers and built-in support for reading `JSON`, `YAML`, `TOML`, `XML`, `INI` and `shoal` config files.
- **gflags** [ğŸ“](./gflags) [ğŸŒ](https://github.com/GerHobbelt/gflags) -- google::flags library, used by other libs in this set.
- **libconfig** [ğŸ“](./libconfig) [ğŸŒ](https://github.com/GerHobbelt/libconfig) -- generic config (file) reader/writer
- **libparameters** [ğŸ“](./libparameters) [ğŸŒ](https://github.com/GerHobbelt/libparameters) -- use C++ runtime configurable typed parameters as if they were native types, while you can track read/write access/usage of each in your code sections for improved diagnostics of your application's behaviour. Used in enhanced tesseract, f.e.
- **libucl** [ğŸ“](./libucl) [ğŸŒ](https://github.com/GerHobbelt/libucl) -- the configuration language called UCL - Universal Configuration Language.  UCL is heavily infused by nginx configuration as the example of a convenient configuration system. However, UCL is fully compatible with JSON format and is able to parse json files.











### TOML

- **cpptoml** [ğŸ“](./cpptoml) [ğŸŒ](https://github.com/GerHobbelt/cpptoml) -- a header-only library for parsing [TOML][toml] configuration files. This includes support for the new DateTime format, inline tables, multi-line basic and raw strings, digit separators, hexadecimal integers, octal integers, binary integers, and float special values.
- **toml11** [ğŸ“](./toml11) [ğŸŒ](https://github.com/GerHobbelt/toml11) -- a C++11 header-only TOML parser/encoder depending only on C++ standard library, compatible to the latest version of [TOML v1.0.0](https://toml.io/en/v1.0.0), including UTF-8 support.
- **tomlpp** [ğŸ“](./tomlpp) [ğŸŒ](https://github.com/GerHobbelt/tomlplusplus) -- TOML++











### YAML

- **libcyaml** [ğŸ“](./libcyaml) [ğŸŒ](https://github.com/GerHobbelt/libcyaml) -- a C library for reading and writing structured YAML documents. The fundamental idea behind CYAML is to allow applications to construct schemas which describe both the permissible structure of the YAML documents to read/write, and the C data structure(s) in which the loaded data is arranged in memory.
- **libfyaml** [ğŸ“](./libfyaml) [ğŸŒ](https://github.com/GerHobbelt/libfyaml) -- a fancy 1.2 YAML and JSON parser/writer. Fully feature complete YAML parser and emitter, supporting the latest YAML spec and passing the full YAML testsuite. It is designed to be very efficient, avoiding copies of data, and has no artificial limits like the 1024 character limit for implicit keys.
- **libyaml** [ğŸ“](./libyaml) [ğŸŒ](https://github.com/GerHobbelt/libyaml) -- YAML
- **libyaml-examples** [ğŸ“](./libyaml-examples) [ğŸŒ](https://github.com/GerHobbelt/libyaml-examples) -- a small set of C language example programs to demonstrate how to use the [libyaml library](http://pyyaml.org/wiki/LibYAML).
- **rapidyaml** [ğŸ“](./rapidyaml) [ğŸŒ](https://github.com/GerHobbelt/rapidyaml) -- *Rapid YAML*, or `ryml`, for short. ryml is a C++ library to parse and emit YAML, and do it fast, on everything from x64 to bare-metal chips without operating system. `ryml` parses both read-only and in-situ source buffers; the resulting data nodes hold only views to sub-ranges of the source buffer. No string copies or duplications are done, and no virtual functions are used. The data tree is a flat index-based structure stored in a single array. Serialization happens only at your direct request, after parsing / before emitting. Internally, the data tree representation stores only string views and has no knowledge of types, but of course, every node can have a YAML type tag. `ryml` makes it easy and fast to read and modify the data tree.
- **yaml-cpp** [ğŸ“](./yaml-cpp) [ğŸŒ](https://github.com/GerHobbelt/yaml-cpp) -- a YAML parser and emitter in C++ matching the YAML 1.2 spec.
- **yaml-test-suite** [ğŸ“](./yaml-test-suite) [ğŸŒ](https://github.com/GerHobbelt/yaml-test-suite) -- comprehensive Test Suite for YAML











### INI

- ~~**inih** [ğŸŒ](https://github.com/benhoyt/inih)~~
  
  - **removed**; reason: we've decided on using `libconfig` for configuration files.

- ~~**iniparser** [ğŸŒ](https://github.com/ndevilla/iniparser)~~
  
  - **removed**; reason: we've decided on using `libconfig` for configuration files.












## testing, benchmarking & fuzzing

- **AFLplusplus** [ğŸ“](./AFLplusplus) [ğŸŒ](https://github.com/GerHobbelt/AFLplusplus) -- American Fuzzy Lop plus plus (AFL++) is a superior fork to Google's AFL fuzzer - more speed, more and better mutations, more and better instrumentation, custom module support, etc.
- **ApprovalTestsCpp** [ğŸ“](./ApprovalTestsCpp) [ğŸŒ](https://github.com/GerHobbelt/ApprovalTests.cpp) -- Approval Tests for C++: also known as **Golden Master Tests** or **Snapshot Testing**, Approval Tests are an alternative to asserts.
- **BoxFort** [ğŸ“](./BoxFort) [ğŸŒ](https://github.com/GerHobbelt/BoxFort) -- a simple, cross-platform sandboxing C library powering [Criterion](https://github.com/Snaipe/Criterion). BoxFort provides a simple API to run user code in isolated processes. The main goal of this project **is not** security, but portable code isolation -- if you want complete system isolation, consider using properly configured containers.
- **Criterion** [ğŸ“](./Criterion) [ğŸŒ](https://github.com/GerHobbelt/Criterion) -- a dead-simple, yet extensible, C and C++ unit testing framework.
- **cxxtest** [ğŸ“](./cxxtest) [ğŸŒ](https://github.com/GerHobbelt/cxxtest) -- a unit testing framework for C++ that is similar in spirit to JUnit, CppUnit, and xUnit. CxxTest is easy to use because it does not require precompiling a CxxTest testing library, it employs no advanced features of C++ (e.g. RTTI) and it supports a very flexible form of test discovery.
- **cxxtest_catch_2_gtest** [ğŸ“](./cxxtest_catch_2_gtest) [ğŸŒ](https://github.com/GerHobbelt/cxxtest_catch_2_gtest) -- quick & dirty converter from various test suites to googletest, i.e. allows us to use a single test framework, despite some libraries having been set up to use another, e.g. [Catch2](https://github.com/catchorg/Catch2).
- **doctest** [ğŸ“](./doctest) [ğŸŒ](https://github.com/GerHobbelt/doctest) -- a C++ testing framework, by far the fastest both in compile times (by [**orders of magnitude**](doc/markdown/benchmarks.md)) and runtime compared to other feature-rich alternatives.
- **dtoa-benchmark** [ğŸ“](./dtoa-benchmark) [ğŸŒ](https://github.com/GerHobbelt/dtoa-benchmark) -- This benchmark evaluates the performance of conversion from double precision IEEE-754 floating point (double) to ASCII string.
- **gbenchmark** [ğŸ“](./gbenchmark) [ğŸŒ](https://github.com/GerHobbelt/benchmark) -- a library to benchmark code snippets, similar to unit tests.
- **googletest** [ğŸ“](./googletest) [ğŸŒ](https://github.com/GerHobbelt/googletest) -- unit test framework: see the [GoogleTest User's Guide](https://google.github.io/googletest/) for documentation. We recommend starting with the [GoogleTest Primer](https://google.github.io/googletest/primer.html).
  
  Features:
  
  * An [xUnit](https://en.wikipedia.org/wiki/XUnit) test framework.
  * Test discovery.
  * A rich set of assertions.
  * User-defined assertions.
  * Death tests.
  * Fatal and non-fatal failures.
  * Value-parameterized tests.
  * Type-parameterized tests.
  * Various options for running the tests.
  * XML test report generation.

- **honggfuzz** [ğŸ“](./honggfuzz) [ğŸŒ](https://github.com/GerHobbelt/honggfuzz) -- a security oriented, feedback-driven, evolutionary, easy-to-use fuzzer with interesting analysis options.
- **libassert** [ğŸ“](./libassert) [ğŸŒ](https://github.com/GerHobbelt/libassert) -- the most over-engineered and overpowered C++ assertion library. **Library philosophy**: Provide as much helpful diagnostic info as possible.
- **radamsa** [ğŸ“](./radamsa) [ğŸŒ](https://github.com/GerHobbelt/radamsa) -- Radamsa is a test case generator for robustness testing, a.k.a. a fuzzer. It is typically used to test how well a program can withstand malformed and potentially malicious inputs. It works by reading sample files of valid data and generating interestingly different outputs from them. The main selling points of radamsa are that it has already found a slew of bugs in programs that actually matter, it is easily scriptable and easy to get up and running.
- **resumable-assert** [ğŸ“](./resumable-assert) [ğŸŒ](https://github.com/GerHobbelt/resumable-assert) -- `assert` replacement to continue execution in debugger. In any large app, it sometimes happens that some asserts are failing in code you don't currently care about, and blocking the entire team from being able to run the app until the issue is fixed is not the best workflow. So we usually end up moving the execution marker past the assert line in IDE or debugger, or even comment the assert out, recompile and relaunch. With Resumable Assert, you can simply continue execution when an assertion fails in debugger, or even disable asserts that you are not interested in, so that those never bother you again.
- **Verify** [ğŸ“](./Verify) [ğŸŒ](https://github.com/GerHobbelt/Verify) -- a snapshot tool that simplifies the assertion of complex data models and documents. Verify is called on the test result during the assertion phase. It serializes that result and stores it in a file that matches the test name. On the next test execution, the result is again serialized and compared to the existing file. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new result.











## logging & debugging

- **binlog** [ğŸ“](./binlog) [ğŸŒ](https://github.com/GerHobbelt/binlog) -- a high performance C++ log library to produce structured binary logs.
- **breakpad** [ğŸ“](./breakpad) [ğŸŒ](https://github.com/GerHobbelt/breakpad) -- a set of client and server components which implement a crash-reporting system.
  
  - **left-for-dead**; reason: nice idea, but slightly too GCC specific. has some GCC + Linux specific coding constructs: intrinsics + Linux-only API calls, which increase the cost of porting.

- **capture-thread** [ğŸ“](./capture-thread) [ğŸŒ](https://github.com/GerHobbelt/capture-thread) -- framework for loggers, tracers, and mockers in multithreaded C++ programs. When developing C++ projects, [instrumentation][instrumentation] is frequently used to collect information from the system, inject information into the system, or both. The role of this information within the system rarely lines up with the actual structure of the project. This library is designed to handle all of these situations with minimal intrusion into your project, and without leaking details in your API. The **Capture Thread Library** is designed around the concept of thread-locality, which allows the sharing of static variables *only within the current thread*. Canonical static variables, on the other hand, are problematic due to ownership and thread-safety issues.
- **clp** [ğŸ“](./clp) [ğŸŒ](https://github.com/GerHobbelt/clp) -- YScope's Compressed Log Processor (CLP) compresses your logs, and allows you to search the compressed logs without decompression. CLP supports both JSON logs and unstructured (i.e., free text) logs. It also supports real-time log compression within several logging libraries. CLP also includes purpose-built web interfaces for searching and viewing the compressed logs.
- **fmt** [ğŸ“](./fmt) [ğŸŒ](https://github.com/GerHobbelt/fmt) -- advanced C++ data-to-text formatter. The modern answer to classic `printf()`.
- **g3log** [ğŸ“](./g3log) [ğŸŒ](https://github.com/GerHobbelt/g3log) -- G3log is an asynchronous logger with three main features: 
  
  1. Intuitive `LOG(...)` API
  2. `Design-by-contract` `CHECK(...)` functionality
  3. Fatal crash handling for graceful shutdown of the logged process without loosing any log details up to the point of the crash.

- **glog** [ğŸ“](./glog) [ğŸŒ](https://github.com/GerHobbelt/glog) -- Google Logging is a C++98 library that implements application-level logging. The library provides logging APIs based on C++-style streams and various helper macros.
- **KDSPDSetup** [ğŸ“](./KDSPDSetup) [ğŸŒ](https://github.com/GerHobbelt/KDSPDSetup) -- a minimal reimplementation of the unmaintained [spdlog_setup](https://github.com/guangie88/spdlog_setup) library for modern C++ projects.
- **libassert** [ğŸ“](./libassert) [ğŸŒ](https://github.com/GerHobbelt/libassert) -- the most over-engineered and overpowered C++ assertion library. **Library philosophy**: Provide as much helpful diagnostic info as possible.
- **libdiagnostics** [ğŸ“](./libdiagnostics) [ğŸŒ](https://github.com/GerHobbelt/libdiagnostics) -- a C/C++ diagnostics logging library with support for writing HTML and store images and misc binary data to disk alongside. or when a mere logfile doesn't suffice.
- **libevt** [ğŸ“](./libevt) [ğŸŒ](https://github.com/GerHobbelt/libevt) -- a library to access the Windows Event Log (EVT) format.
- **loguru** [ğŸ“](./loguru) [ğŸŒ](https://github.com/GerHobbelt/loguru) -- a lightweight and flexible C++ logging library.
- **loki** [ğŸ“](./loki) [ğŸŒ](https://github.com/GerHobbelt/loki) -- Grafana Loki: like Prometheus, but for logs. Loki is a horizontally-scalable, highly-available, multi-tenant log aggregation system inspired by [Prometheus](https://prometheus.io/). It is designed to be very cost effective and easy to operate. It does not index the contents of the logs, but rather a set of labels for each log stream.
- **microsoft-performance-toolkit-sdk** [ğŸ“](./microsoft-performance-toolkit-sdk) [ğŸŒ](https://github.com/GerHobbelt/microsoft-performance-toolkit-sdk) -- The Microsoft Performance Toolkit is a collection of cross-platform tools developers can use to create and extend performance analysis applications. It serves as the runtime of the Windows Performance Analyzer, a Windows program included in the Windows Performance Toolkit. By using the Microsoft Performance Toolkit SDK, Windows Performance Analyzer - or any performance analysis application - can be configured to process and display performance data from arbitrary sources.
- **MuPDF itself**  [ğŸ“](../../) [ğŸŒ](https://github.com/GerHobbelt/mupdf) -- this MuPDF fork is geared towards use with [Qiqqa (document and citation manager)](https://github.com/jimmejardine/qiqqa-open-source/). It is based on [the original MuPDF work done by Artifex](https://artifex.com/products/mupdf/), _closely tracks the developments overthere_ and augments the codebase with other C/C++ based tools, which are useful in and around the Qiqqa document processes, such as
  
  * text extraction
  * metadata extraction (including annotations)
  * OCR (_text recognition_ as an required extension of _text extraction_ when you have image-based PDFs, which happens quite often in the wild)
  * Qiqqa database support (SQLite I/O; we do include the generic SQLite tools as well to "open up" the Qiqqa _core components_ for advanced usage and users who wish to perform custom actions on the collected and managed data)

- **netdata** [ğŸ“](./netdata) [ğŸŒ](https://github.com/GerHobbelt/netdata) -- <a href="https://www.netdata.cloud">Netdata</a> collects metrics per second and presents them in beautiful low-latency dashboards. It is designed to run on all of your physical and virtual servers, cloud deployments, Kubernetes clusters, and edge/IoT devices, to monitor your systems, containers, and applications. It scales nicely from just a single server to thousands of servers, even in complex multi/mixed/hybrid cloud environments, and given enough disk space it can keep your metrics for years.
- **oppat** [ğŸ“](./oppat) [ğŸŒ](https://github.com/GerHobbelt/oppat) -- Open Power/Performance Analysis Tool (OPPAT) is a cross-OS, cross-architecture Power and Performance Analysis Tool. cross-OS: supports Windows ETW trace files and Linux/Android perf/trace-cmd trace files. cross-architecture: supports Intel and ARM chips hardware events (using perf and/or PCM).
- **palanteer** [ğŸ“](./palanteer) [ğŸŒ](https://github.com/GerHobbelt/palanteer) -- Visual Python and C++ nanosecond profiler, logger, tests enabler: a set of lean and efficient tools to improve the quality of software, for C++ and Python programs.
- **plf_nanotimer** [ğŸ“](./plf_nanotimer) [ğŸŒ](https://github.com/GerHobbelt/plf_nanotimer) -- high precision cross-platform performance timer
- **quill-logging** [ğŸ“](./quill-logging) [ğŸŒ](https://github.com/GerHobbelt/quill) -- asynchronous cross-platform low latency logging library based on C++14/C++17.
- **reckless** [ğŸ“](./reckless) [ğŸŒ](https://github.com/GerHobbelt/reckless) -- Reckless is an extremely low-latency, high-throughput logging library.
- **replxx** [ğŸ“](./replxx) [ğŸŒ](https://github.com/GerHobbelt/replxx) -- REPL CLI component: `readline` simile for REPL/interactive runs in a CLI
- **resumable-assert** [ğŸ“](./resumable-assert) [ğŸŒ](https://github.com/GerHobbelt/resumable-assert) -- `assert` replacement to continue execution in debugger. In any large app, it sometimes happens that some asserts are failing in code you don't currently care about, and blocking the entire team from being able to run the app until the issue is fixed is not the best workflow. So we usually end up moving the execution marker past the assert line in IDE or debugger, or even comment the assert out, recompile and relaunch. With Resumable Assert, you can simply continue execution when an assertion fails in debugger, or even disable asserts that you are not interested in, so that those never bother you again.
- **spdlog_sqlite_sink** [ğŸ“](./spdlog_sqlite_sink) [ğŸŒ](https://github.com/GerHobbelt/sqlite_sink) -- SQLite 3 database sink for `spdlog`: a simple custom sink made for spdlog that writes to SQLite database.
- **spdmon** [ğŸ“](./spdmon) [ğŸŒ](https://github.com/GerHobbelt/spdmon) -- a progress monitor based on spdlog library. In just one function call visualize your loop progress!
- **sqlplot-tools** [ğŸ“](./sqlplot-tools) [ğŸŒ](https://github.com/GerHobbelt/sqlplot-tools) -- a tool to **process data series** from algorithm experiments **using SQL statements** and embed the results in **gnuplot** datafiles or **pgfplots** LaTeX files. Using SQL to generate plots can be see as **cracking a nut with a sledgehammer**, but it really works well in practice.
- **taolog** [ğŸ“](./taolog) [ğŸŒ](https://github.com/GerHobbelt/taolog) -- A Win32 logger based on DebugView & ETW.
- **tempo** [ğŸ“](./tempo) [ğŸŒ](https://github.com/GerHobbelt/tempo) -- Grafana Tempo is an open source, easy-to-use and high-scale distributed tracing backend. Tempo is cost-efficient, requiring only object storage to operate, and is deeply integrated with Grafana, Prometheus, and Loki. Tempo is Jaeger, Zipkin, Kafka, OpenCensus and OpenTelemetry compatible.  It ingests batches in any of the mentioned formats, buffers them and then writes them to Azure, GCS, S3 or local disk.  As such it is robust, cheap and easy to operate! Tempo implements [TraceQL](https://grafana.com/docs/tempo/latest/traceql/), a traces-first query language inspired by LogQL and PromQL. This query language allows users to very precisely and easily select spans and jump directly to these spans.
- **uberlog** [ğŸ“](./uberlog) [ğŸŒ](https://github.com/GerHobbelt/uberlog) -- a cross platform C++ logging system that is focused on fast and small, writing to a shared memory ring buffer.
- ~~**EasyLogger** [ğŸŒ](https://github.com/armink/EasyLogger) -- an ultra-lightweight (ROM<1.6K, RAM<0.3K), high-performance C/C++ log library, very suitable for resource-sensitive software projects. Compared with the well-known C/C++ log libraries such as log4c and zlog, EasyLogger has simpler functions and provides fewer interfaces to users, but it will be quick to get started. More practical functions support dynamic expansion in the form of plug-ins.~~
  
  - **removed**; reason: we've decided on using `glog` as the logging library for everything: while that one isn't perfect, most of the other stuff we've been looking at is using that one already and it matches our needs 80% of the time, while I'm okay with patching that library for the other 20% (syslog-like use, i.e. logging to localhost logging server where all logging is collected -- these log messages should travel across as part of the ZeroMQ message streams.)

- ~~**log4cplus** [ğŸŒ](https://github.com/log4cplus/log4cplus)~~
  
  - **removed**; reason: we've decided on using `glog` as the logging library for everything. log4cplus, at the same time, is a tad too much. (I consider `log4j` et al *overdone* as it caters to every need instead of just providing those things as contrib code which can be integrated at need -- should not be as far run-time configurable as it currently is.)

- ~~**spdlog** [ğŸŒ](https://github.com/gabime/spdlog)~~
  
  - **removed**; reason: we've decided on using `glog` as the logging library for everything. `spdlog` has some nice features but in the end it was ease of cross-platform compilation and installed base that won out here...

- ~~**zlog** [ğŸŒ](https://github.com/HardySimpson/zlog)~~
  
  - **removed**; `zlog` has a nice overall design but is too 'Unix-is-the-world' in its coding: in the end it was ease of cross-platform compilation of `glog` that won the day and I'm okay with layering on top of that one to get the zlog category and other channel features, once I really need them.












### Colour Processing & Conversion

- **1D-RGB-color-gradient** [ğŸ“](./1D-RGB-color-gradient) [ğŸŒ](https://github.com/GerHobbelt/1D-RGB-color-gradient) -- 1D (univariate) continous (smooth) [color gradients](https://en.wikipedia.org/wiki/Color_gradient) (colormaps) for gnuplot.
- **2D-color-gradient-or-Procedural-texture** [ğŸ“](./2D-color-gradient-or-Procedural-texture) [ğŸŒ](https://github.com/GerHobbelt/2D-color-gradient-or-Procedural-texture) -- 2D continous (smooth) [color gradients](https://en.wikipedia.org/wiki/Color_gradient) (colormaps) for gnuplot.
- **colorm** [ğŸ“](./colorm) [ğŸŒ](https://github.com/GerHobbelt/colorm) -- ColorM is a C++11 header-only color conversion and manipulation library for [CSS colors](https://www.w3.org/TR/css-color-4/) with an API similar to [chroma.js](https://github.com/gka/chroma.js/)'s API.
- **ColorMagic** [ğŸ“](./ColorMagic) [ğŸŒ](https://github.com/GerHobbelt/ColorMagic) -- a C++ Library that allows manipulation and conversion of colors. Supports these Color Spaces: RGB/A, Grey/A, CMYK, HSV, HSL, XYZ, XYY, CieLUV, Lab. Supports adding, mixing, averaging and subtracting colors (optionally with weights), calculating color distances (Euclidean, CMC, CIELAB76, CIELAB94, CIELAB2000), creating color sets (Complementary, Triplet, Quartet, Quintet, Analogous, Complementary Split, Custom) & adjusting colors (Saturate, Desaturate, Lighten, Unlighten).
- **ColorPaletteCodable** [ğŸ“](./ColorPaletteCodable) [ğŸŒ](https://github.com/GerHobbelt/ColorPaletteCodable) -- a color palette reader/editor/writer package for iOS, macOS, macCatalyst, tvOS, watchOS and Linux. Supports many palette formats, including Adobe Swatch Exchange (`.ase`), Adobe Photoshop Color Swatch (`.aco`), Adobe Color Table (`.act`) and Microsoft RIFF palette files (`.pal`)
- **gencolormap** [ğŸ“](./gencolormap) [ğŸŒ](https://github.com/GerHobbelt/gencolormap) -- generate color maps for visualization. A variety of methods for sequential, diverging, and qualitative maps is available.
- **hsluv-color-gradient** [ğŸ“](./hsluv-color-gradient) [ğŸŒ](https://github.com/GerHobbelt/hsluv-color-gradient) -- 1D discrete and continous perceptually uniform ordered color gradients rendered in [HSL](https://www.hsluv.org/)
- **libase** [ğŸ“](./libase) [ğŸŒ](https://github.com/GerHobbelt/libase) -- a tiny library for interpreting the Adobe Swatch Exchange (`.ase`) file format for color palettes since Adobe Creative Suite 3.
- **lterpalettefinder** [ğŸ“](./lterpalettefinder) [ğŸŒ](https://github.com/GerHobbelt/lterpalettefinder) -- extract Color Palettes from Photos and Pick Official LTER Palettes. The goal of `lterpalettefinder` is to provide high quality color palettes derived from photos at Long Term Ecological Research (LTER) sites. This allows users to create beautiful graphics that have close visual ties to photos from the places where data were collected. This package also allows users to generate their own palettes from any photo (PNG, JPEG, TIFF, or HEIC) if the current palettes in the function do not meet their needs. For more information on the LTER Network, check out [our website](https://lternet.edu/)!
- **MetBrewer** [ğŸ“](./MetBrewer) [ğŸŒ](https://github.com/GerHobbelt/MetBrewer) -- palettes inspired by works at the Metropolitan Museum of Art in New York. Pieces selected come from various time periods, regions, and mediums.
- **PNWColors** [ğŸ“](./PNWColors) [ğŸŒ](https://github.com/GerHobbelt/PNWColors) -- Four years spent in the most beautiful place in the world, immortalized in an R color palette package. May the colors of Washington State and the Pacific Northwest live on in our presentation figures forever.  Palettes are pulled from photos I took in some of the dreamiest, most colorful, PNW-iest places I know.
- **we-love-colors** [ğŸ“](./we-love-colors) [ğŸŒ](https://github.com/GerHobbelt/we-love-colors) -- a library to easily generate **color palettes**.
- **yy_color_convertor** [ğŸ“](./yy_color_convertor) [ğŸŒ](https://github.com/GerHobbelt/yy_color_convertor) -- convert color between RGB,HSL,HSB,CMYK,YUV,YIQ,XYZ,xyY,Lab,Luv,LCH ...











### Visualization

- **agg** [ğŸ“](./agg) [ğŸŒ](https://github.com/GerHobbelt/agg) -- Anti-Grain Geometry library, written by Maxim Shemanarev in C++. It is an Open Source, 2D vector graphics library. Agg produces pixel images in memory from vectorial data. AGG doesn't depend on any graphic API or technology. Basically, you can think of AGG as of a rendering engine that produces pixel images in memory from some vectorial data.
- **butteraugli** [ğŸ“](./butteraugli) [ğŸŒ](https://github.com/GerHobbelt/butteraugli) -- a tool for measuring perceived differences between images. Butteraugli is a project that estimates the psychovisual similarity of two images. It gives a score for the images that is reliable in the domain of barely noticeable differences. Butteraugli not only gives a scalar score, but also computes a spatial map of the level of differences. One of the main motivations for this project is the statistical differences in location and density of different color receptors, particularly the low density of blue cones in the fovea. Another motivation comes from more accurate modeling of ganglion cells, particularly the frequency space inhibition.
- **colorm** [ğŸ“](./colorm) [ğŸŒ](https://github.com/GerHobbelt/colorm) -- ColorM is a C++11 header-only color conversion and manipulation library for [CSS colors](https://www.w3.org/TR/css-color-4/) with an API similar to [chroma.js](https://github.com/gka/chroma.js/)'s API.
- **colormap-shaders** [ğŸ“](./colormap-shaders) [ğŸŒ](https://github.com/GerHobbelt/colormap-shaders) -- a collection of shaders to draw color maps.
- **ColorPaletteCodable** [ğŸ“](./ColorPaletteCodable) [ğŸŒ](https://github.com/GerHobbelt/ColorPaletteCodable) -- a color palette reader/editor/writer package for iOS, macOS, macCatalyst, tvOS, watchOS and Linux. Supports many palette formats, including Adobe Swatch Exchange (`.ase`), Adobe Photoshop Color Swatch (`.aco`), Adobe Color Table (`.act`) and Microsoft RIFF palette files (`.pal`)
- **ColorSpace** [ğŸ“](./ColorSpace) [ğŸŒ](https://github.com/GerHobbelt/ColorSpace) -- library for converting between color spaces and comparing colors.
- **color-util** [ğŸ“](./color-util) [ğŸŒ](https://github.com/GerHobbelt/color-util) -- a header-only C++11 library for handling colors, including color space converters between RGB, XYZ, Lab, etc. and color difference calculators such as CIEDE2000.
- **gnuplot** [ğŸ“](./gnuplot) [ğŸŒ](https://github.com/GerHobbelt/gnuplot) -- the Gnuplot Plotting Utility is a command-line driven interactive function plotting utility for linux, OSX, MSWin, VMS, and many other platforms. Gnuplot handles both curves (2 dimensions) and surfaces (3 dimensions). Surfaces can be plotted as a mesh fitting the specified function, floating in the 3-d coordinate space, or as a contour plot on the x-y plane. For 2-d plots, there are also many plot styles including lines, points, boxes, heat maps, stacked histograms, and contoured projections of 3D data. Graphs may be labeled with arbitrary labels and arrows, axis labels, a title, date and time, and a key.  The interface includes command-line editing and history on most platforms.
- **gnuplot_i** [ğŸ“](./gnuplot_i) [ğŸŒ](https://github.com/GerHobbelt/gnuplot_i) -- gnuplot C interface library enables developers to create [gnuplots](http://www.gnuplot.info/) directly from their C programs.
- **gnuplot-palettes** [ğŸ“](./gnuplot-palettes) [ğŸŒ](https://github.com/GerHobbelt/gnuplot-palettes) -- color palettes for gnuplot.
- **graph-coloring** [ğŸ“](./graph-coloring) [ğŸŒ](https://github.com/GerHobbelt/graph-coloring) -- a C++ Graph Coloring Package. This project has two primary uses:
  
  * As an executable for finding the chromatic number for an input graph (in edge list or edge matrix format)
  * As a library for finding the particular coloring of an input graph (represented as a `map<string,vector<string>>` edge list)

- **hsluv-c** [ğŸ“](./hsluv-c) [ğŸŒ](https://github.com/GerHobbelt/hsluv-c) -- HSLuv (revision 4) is a human-friendly alternative to HSL. HSLuv is very similar to CIELUV, a color space designed for perceptual uniformity based on human experiments. When accessed by polar coordinates, it becomes functionally similar to HSL with a single problem: its chroma component doesn't fit into a specific range. HSLuv extends CIELUV with a new saturation component that allows you to span all the available chroma as a neat percentage.
- **IconFontCppHeaders** [ğŸ“](./IconFontCppHeaders) [ğŸŒ](https://github.com/GerHobbelt/IconFontCppHeaders) -- provides C and C++ headers, among others, for icon fonts Font Awesome, Fork Awesome, Google Material Design, Pictogrammers Material Design icons, Kenney game icons, Fontaudio, Codicons and Lucide. Useful in UI applications such as ones built in Dear ImGui.
- **leptonica-hillshade** [ğŸ“](./leptonica-hillshade) [ğŸŒ](https://github.com/GerHobbelt/leptonica-hillshade) -- apply hillshade elevation/shadow render to leptonica PIX & FPIX
- **libchiaroscuramente** [ğŸ“](./libchiaroscuramente) [ğŸŒ](https://github.com/GerHobbelt/libchiaroscuramente) -- a collection of C/C++ functions (components) to help improving / enhancing your images for various purposes (e.g. helping an OCR engine detect and recognize the text in the page scan image)
- **libjpegqs** [ğŸ“](./libjpegqs) [ğŸŒ](https://github.com/GerHobbelt/libjpegqs) -- JPEG Quant Smooth tries to recreate lost precision of DCT coefficients based on quantization table from jpeg image. You may not notice jpeg artifacts on the screen without zooming in, but you may notice them after printing. Also, when editing compressed images, artifacts can accumulate, but if you use this program before editing - the result will be better.
- **lterpalettefinder** [ğŸ“](./lterpalettefinder) [ğŸŒ](https://github.com/GerHobbelt/lterpalettefinder) -- extract Color Palettes from Photos and Pick Official LTER Palettes. The goal of `lterpalettefinder` is to provide high quality color palettes derived from photos at Long Term Ecological Research (LTER) sites. This allows users to create beautiful graphics that have close visual ties to photos from the places where data were collected. This package also allows users to generate their own palettes from any photo (PNG, JPEG, TIFF, or HEIC) if the current palettes in the function do not meet their needs. For more information on the LTER Network, check out [our website](https://lternet.edu/)!
- **matplotplusplus** [ğŸ“](./matplotplusplus) [ğŸŒ](https://github.com/GerHobbelt/matplotplusplus) -- **Matplot++** is a graphics library for data visualization that provides interactive plotting, means for exporting plots in high-quality formats for scientific publications, a compact syntax consistent with similar libraries, dozens of plot categories with specialized algorithms, multiple coding styles, and supports generic backends.
- **MetBrewer** [ğŸ“](./MetBrewer) [ğŸŒ](https://github.com/GerHobbelt/MetBrewer) -- palettes inspired by works at the Metropolitan Museum of Art in New York. Pieces selected come from various time periods, regions, and mediums.
- **netdata** [ğŸ“](./netdata) [ğŸŒ](https://github.com/GerHobbelt/netdata) -- <a href="https://www.netdata.cloud">Netdata</a> collects metrics per second and presents them in beautiful low-latency dashboards. It is designed to run on all of your physical and virtual servers, cloud deployments, Kubernetes clusters, and edge/IoT devices, to monitor your systems, containers, and applications. It scales nicely from just a single server to thousands of servers, even in complex multi/mixed/hybrid cloud environments, and given enough disk space it can keep your metrics for years.
- **nodesoup** [ğŸ“](./nodesoup) [ğŸŒ](https://github.com/GerHobbelt/nodesoup) -- delivers graph untangling: a force-directed graph layout simulates forces to give motion to vertices and arrange them in a way that is visually pleasing and/or reveals structure. The Fruchterman-Reingold algorithm assigns a repelling force to vertices pair of the graph, effectively pushing apart vertices so they don't overlap, and a attraction force between each adjacent vertices pair, thus dragging closer connected vertices. The forces attenuate when the vertices get respectively further apart or closer, and a global temperature also serves as a simulated annealing, capping the maximum vertex displacement at each iteration. As the forces between each component and the temperature gradually diminish, the layout stabilizes.  Another method, the Kamada Kawai algorithm, relies on the simulation of springs between each vertex, which strength is determined by the length of the shortest path between both vertices. The potential energy of each vertex, i.e. the sum of the energy of all its springs, is then computed. The goal being to reduce the global energy of the layout, each vertex is moved step-by-step until its potential energy is considered low-enough, using a Newton-Raphson algorithm.
- **OpenColorIO** [ğŸ“](./OpenColorIO) [ğŸŒ](https://github.com/GerHobbelt/OpenColorIO) -- OpenColorIO (OCIO) is a complete color management solution geared towards motion picture production with an emphasis on visual effects and computer animation. OCIO provides a straightforward and consistent user experience across all supporting applications while allowing for sophisticated back-end configuration options suitable for high-end production usage. OCIO is compatible with the Academy Color Encoding Specification (ACES) and is LUT-format agnostic, supporting many popular formats.
- **paintingReorganize** [ğŸ“](./paintingReorganize) [ğŸŒ](https://github.com/GerHobbelt/paintingReorganize) -- color palatte extraction demo, based on PCA.
- **pdiff** [ğŸ“](./pdiff) [ğŸŒ](https://github.com/GerHobbelt/pdiff) -- perceptualdiff (pdiff): a program that compares two images using a perceptually based image metric.
- **PNWColors** [ğŸ“](./PNWColors) [ğŸŒ](https://github.com/GerHobbelt/PNWColors) -- Four years spent in the most beautiful place in the world, immortalized in an R color palette package. May the colors of Washington State and the Pacific Northwest live on in our presentation figures forever.  Palettes are pulled from photos I took in some of the dreamiest, most colorful, PNW-iest places I know.
- **sqlplot-tools** [ğŸ“](./sqlplot-tools) [ğŸŒ](https://github.com/GerHobbelt/sqlplot-tools) -- a tool to **process data series** from algorithm experiments **using SQL statements** and embed the results in **gnuplot** datafiles or **pgfplots** LaTeX files. Using SQL to generate plots can be see as **cracking a nut with a sledgehammer**, but it really works well in practice.
- **svg-charter** [ğŸ“](./svg-charter) [ğŸŒ](https://github.com/GerHobbelt/charter) -- SVG chart renderer
- **tinycolormap** [ğŸ“](./tinycolormap) [ğŸŒ](https://github.com/GerHobbelt/tinycolormap) -- a header-only, single-file library for colormaps written in C++11.
- **tmap** [ğŸ“](./tmap) [ğŸŒ](https://github.com/GerHobbelt/tmap) -- a very fast visualization library for large, high-dimensional data sets. tmap's graph layouts are based on the [OGDF](https://ogdf.uos.de/) library.
- **vizzu** [ğŸ“](./vizzu) [ğŸŒ](https://github.com/GerHobbelt/vizzu-lib) -- Vizzu is a Javascript/C++ library for animated data visualizations and data stories, utilizing a generic dataviz engine that generates many types of charts and seamlessly animates between them. It can be used to create static charts but more importantly, it is designed for building animated data stories and interactive explorers as Vizzu enables showing different perspectives of the data that the viewers can easily follow due to the animation.
- **VTK** [ğŸ“](./VTK) [ğŸŒ](https://github.com/GerHobbelt/VTK) -- VTK - The Visualization Toolkit - is an open-source software system for image processing, 3D graphics, volume rendering and visualization. VTK includes many advanced algorithms (e.g., surface reconstruction, implicit modeling, decimation) and rendering techniques (e.g., hardware-accelerated volume rendering, LOD control).
- **wesanderson** [ğŸ“](./wesanderson) [ğŸŒ](https://github.com/GerHobbelt/wesanderson) -- Wes Anderson color palettes demo.  Hereâ€™s the most indie thing you can do to your plots.  ;-)











### ETW (Event Tracing for Microsoft Windows)

- **EtwExplorer** [ğŸ“](./EtwExplorer) [ğŸŒ](https://github.com/GerHobbelt/EtwExplorer) -- View ETW Provider metadata. Event Tracing for Windows (ETW) is a logging facility built into the Windows OS. Modern providers register a manifest that describes all the events they support, with their properties. Classic providers register a MOF instead.
- **krabsETW** [ğŸ“](./krabsETW) [ğŸŒ](https://github.com/GerHobbelt/krabsetw) -- a C++ library that simplifies interacting with ETW. It allows for any number of traces and providers to be enabled and for client code to register for event notifications from these traces.
- **libevt** [ğŸ“](./libevt) [ğŸŒ](https://github.com/GerHobbelt/libevt) -- a library to access the Windows Event Log (EVT) format.
- **Sealighter** [ğŸ“](./Sealighter) [ğŸŒ](https://github.com/GerHobbelt/Sealighter) -- Sysmon-Like research tool for ETW: helps non-developers dive into researching Event Tracing for Windows (ETW) and Windows PreProcessor Tracing (WPP).
- **SilkETW** [ğŸ“](./SilkETW) [ğŸŒ](https://github.com/GerHobbelt/SilkETW) -- SilkETW & SilkService are flexible C# wrappers for ETW, they are meant to abstract away the complexities of ETW and give people a simple interface to perform research and introspection. While both projects have obvious defensive (and offensive) applications they should primarily be considered as research tools.
- **tracelogging-for-ETW** [ğŸ“](./tracelogging-for-ETW) [ğŸŒ](https://github.com/GerHobbelt/tracelogging) -- C++ Wrapper for Windows ETW TraceLogging
- **UIforETW** [ğŸ“](./UIforETW) [ğŸŒ](https://github.com/GerHobbelt/UIforETW) -- Bruce Dawson's user interface for recording ETW (Event Tracing for Windows) traces, which allow amazingly deep investigations of performance problems on Windows.
- **Windows10EtwEvents** [ğŸ“](./Windows10EtwEvents) [ğŸŒ](https://github.com/GerHobbelt/Windows10EtwEvents) -- Events from all manifest-based and mof-based ETW providers across Windows 10 versions.











## telemetry

- **loki** [ğŸ“](./loki) [ğŸŒ](https://github.com/GerHobbelt/loki) -- Grafana Loki: like Prometheus, but for logs. Loki is a horizontally-scalable, highly-available, multi-tenant log aggregation system inspired by [Prometheus](https://prometheus.io/). It is designed to be very cost effective and easy to operate. It does not index the contents of the logs, but rather a set of labels for each log stream.
- **ms_cpp_client_telemetry** [ğŸ“](./ms_cpp_client_telemetry) [ğŸŒ](https://github.com/GerHobbelt/cpp_client_telemetry) -- 1DS C/C++ SDK enables cross-platform telemetry collection from various Microsoft products. It enables data / telemetry upload to Collector++. 1DS (One Data Strategy), also known as One Observability, is a cross-org initiative with five teams across the company coming together to unify multiple telemetry efforts at Microsoft. Collector++ is the externally-facing destination end-point where telemetry data is uploaded to that subsequently routes the data to Microsoft internal data pipeline.
- **netdata** [ğŸ“](./netdata) [ğŸŒ](https://github.com/GerHobbelt/netdata) -- <a href="https://www.netdata.cloud">Netdata</a> collects metrics per second and presents them in beautiful low-latency dashboards. It is designed to run on all of your physical and virtual servers, cloud deployments, Kubernetes clusters, and edge/IoT devices, to monitor your systems, containers, and applications. It scales nicely from just a single server to thousands of servers, even in complex multi/mixed/hybrid cloud environments, and given enough disk space it can keep your metrics for years.
- **opentelemetry-cpp** [ğŸ“](./opentelemetry-cpp) [ğŸŒ](https://github.com/GerHobbelt/opentelemetry-cpp) -- The OpenTelemetry C++ Client
- **opentelemetry-cpp-contrib** [ğŸ“](./opentelemetry-cpp-contrib) [ğŸŒ](https://github.com/GerHobbelt/opentelemetry-cpp-contrib) -- OpenTelemetry C++ Contrib repository which contains set of components extending functionality of the OpenTelemetry SDK. Instrumentation libraries, exporters, and other components can find their home here.
- **siridb-server** [ğŸ“](./siridb-server) [ğŸŒ](https://github.com/GerHobbelt/siridb-server) -- SiriDB Server is a highly-scalable, robust and super fast time series database. SiriDB uses a unique mechanism to operate without a global index and allows server resources to be added on the fly. SiriDBâ€™s unique query language includes dynamic grouping of time series for easy analysis over large amounts of time series. SiriDB is scalable on the fly and has no downtime while updating or expanding your database. The scalable possibilities enable you to enlarge the database time after time without losing speed. SiriDB is developed to give an unprecedented performance without downtime. A SiriDB cluster distributes time series across multiple pools. Each pool supports active replicas for load balancing and redundancy. When one of the replicas is not available the database is still accessible.
- **statsite** [ğŸ“](./statsite) [ğŸŒ](https://github.com/GerHobbelt/statsite) -- a metrics aggregation server. Statsite is based heavily on Etsy's StatsD <https://github.com/etsy/statsd>, and is wire compatible.
- **TelemetrySourcerer** [ğŸ“](./TelemetrySourcerer) [ğŸŒ](https://github.com/GerHobbelt/TelemetrySourcerer) -- Telemetry Sourcerer can enumerate and disable common sources of telemetry used by AV/EDR on Windows. Red teamers and security enthusiasts can use this tool in a lab environment for various purposes, including ETW event monitoring.
- **tempo** [ğŸ“](./tempo) [ğŸŒ](https://github.com/GerHobbelt/tempo) -- Grafana Tempo is an open source, easy-to-use and high-scale distributed tracing backend. Tempo is cost-efficient, requiring only object storage to operate, and is deeply integrated with Grafana, Prometheus, and Loki. Tempo is Jaeger, Zipkin, Kafka, OpenCensus and OpenTelemetry compatible.  It ingests batches in any of the mentioned formats, buffers them and then writes them to Azure, GCS, S3 or local disk.  As such it is robust, cheap and easy to operate! Tempo implements [TraceQL](https://grafana.com/docs/tempo/latest/traceql/), a traces-first query language inspired by LogQL and PromQL. This query language allows users to very precisely and easily select spans and jump directly to these spans.











## OCR core (*tesseract*)

- **DocLayNet** [ğŸ“](./DocLayNet) [ğŸŒ](https://github.com/GerHobbelt/DocLayNet) -- DocLayNet provides page-by-page layout segmentation ground-truth using bounding-boxes for 11 distinct class labels on 80863 unique pages from 6 document categories. It provides several unique features compared to related work such as PubLayNet or DocBank, e.g. *Human Annotation*: DocLayNet is hand-annotated by well-trained experts, providing a gold-standard in layout segmentation through human recognition and interpretation of each page layout.
- **EasyOCR** [ğŸ“](./EasyOCR) [ğŸŒ](https://github.com/GerHobbelt/EasyOCR) -- ready-to-use OCR with 80+ [supported languages](https://www.jaided.ai/easyocr) and all popular writing scripts including: Latin, Chinese, Arabic, Devanagari, Cyrillic, etc.
- **EasyOCR-cpp** [ğŸ“](./EasyOCR-cpp) [ğŸŒ](https://github.com/GerHobbelt/EasyOCR-cpp) -- custom C++ implementation of [EasyOCR](https://github.com/JaidedAI/EasyOCR). This C++ project implements the pre/post processing to run a OCR pipeline consisting of a text detector [CRAFT](https://arxiv.org/abs/1904.01941), and a CRNN based text recognizer. Unlike the EasyOCR python which is API based, this repo provides a set of classes to show how you can integrate OCR in any C++ program for maximum flexibility.
- **IMGUR5K-Handwriting-Dataset** [ğŸ“](./IMGUR5K-Handwriting-Dataset) [ğŸŒ](https://github.com/GerHobbelt/IMGUR5K-Handwriting-Dataset) -- the IMGUR5K Handwriting Dataset for OCR/image preprocessing benchmarks.
- **langdata_LSTM** [ğŸ“](../../thirdparty/langdata_LSTM) [ğŸŒ](https://github.com/GerHobbelt/langdata_lstm) -- tesseract data
- **ocr_eval_tools** [ğŸ“](./ocr_eval_tools) [ğŸŒ](https://github.com/GerHobbelt/ocr_eval_tools) -- toolkit to help evaluate / benchmark tesseract OCR performance.
- **openalpr** [ğŸ“](./openalpr) [ğŸŒ](https://github.com/GerHobbelt/openalpr) -- OpenALPR is an open source *Automatic License Plate Recognition* library written in C++.  The library analyzes images and video streams to identify license plates.  The output is the text representation of any license plate characters.
- **Sancho.Panza.on.tesseract.OCR** [ğŸ“](./Sancho.Panza.on.tesseract.OCR) [ğŸŒ](https://github.com/GerHobbelt/Sancho.Panza.on.tesseract.OCR) -- a book about tesseract OCR programming and usage.
- **tessconfigs** [ğŸ“](../../thirdparty/tessconfigs) [ğŸŒ](https://github.com/GerHobbelt/tessconfigs) -- Tesseract Config files
- **tessdata** [ğŸ“](../../thirdparty/tessdata) [ğŸŒ](https://github.com/GerHobbelt/tessdata) -- trained models for Tesseract. These have models for legacy tesseract engine (--oem 0) as well as the new LSTM neural net based engine (--oem 1). The LSTM models (--oem 1) in these files have been updated to the integerized versions of [tessdata_best](https://github.com/tesseract-ocr/tessdata_best) on GitHub. So, they should be faster but probably a little less accurate than tessdata_best.
- **tessdata_best** [ğŸ“](../../thirdparty/tessdata_best) [ğŸŒ](https://github.com/GerHobbelt/tessdata_best) -- the best trained models for the [Tesseract Open Source OCR Engine](https://github.com/tesseract-ocr/tesseract). These models only work with the LSTM OCR engine of Tesseract 4 / 5.
- **tessdata_contrib** [ğŸ“](../../thirdparty/tessdata_contrib) [ğŸŒ](https://github.com/GerHobbelt/tessdata_contrib) -- user contributions (non Google) for Tesseract 4 / 5.
- **tessdata_fast** [ğŸ“](../../thirdparty/tessdata_fast) [ğŸŒ](https://github.com/GerHobbelt/tessdata_fast) -- fast integer versions of trained models for the [Tesseract Open Source OCR Engine](https://github.com/tesseract-ocr/tesseract). These models only work with the LSTM OCR engine of Tesseract 4 / 5.
- **tessdoc** [ğŸ“](../../thirdparty/tessdoc) [ğŸŒ](https://github.com/GerHobbelt/tessdoc) -- user manual for Tesseract versions `5.x`.
- **tesseract** [ğŸ“](../../thirdparty/tesseract) [ğŸŒ](https://github.com/GerHobbelt/tesseract) -- `tesseract-ocr` with `--visible-pdf-image` and other tweaks.
- **tesseract_docs** [ğŸ“](../../thirdparty/tesseract_docs) [ğŸŒ](https://github.com/GerHobbelt/tesseract_docs) -- various documents related to Tesseract OCR.
- **tesseract-gImgRdrGui** [ğŸ“](./tesseract-gImgRdrGui) [ğŸŒ](https://github.com/GerHobbelt/gImageReader) -- a Gtk/Qt front-end to tesseract-ocr.
- **tesseract_langdata** [ğŸ“](../../thirdparty/tesseract_langdata) [ğŸŒ](https://github.com/GerHobbelt/langdata) -- source training data for Tesseract for lots of languages.
- **tesslinesplit** [ğŸ“](./tesslinesplit) [ğŸŒ](https://github.com/GerHobbelt/tesslinesplit) -- a standalone program for using Tesseract's line segmentation algorithm to split up document images.
- **tesstrain** [ğŸ“](../../thirdparty/tesstrain) [ğŸŒ](https://github.com/GerHobbelt/tesstrain) -- training workflow for Tesseract 4.











## PDF render & metadata core (*mupdf*)

- **extract** [ğŸ“](../../thirdparty/extract) [ğŸŒ](https://github.com/GerHobbelt/thirdparty_extract) -- clone of git://git.ghostscript.com/extract.git
- **farver-OKlab** [ğŸ“](./farver-OKlab) [ğŸŒ](https://github.com/GerHobbelt/farver) -- provides very fast, vectorised functions for conversion of colours between different colour spaces, colour comparisons (distance between colours), encoding/decoding, and channel manipulation in colour strings.
- **freeglut** [ğŸ“](../../thirdparty/freeglut) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-freeglut) -- Freeglut, the Free OpenGL Utility Toolkit, is meant to be a free alternative to Mark Kilgard's GLUT library. In short, freeglut can be used by OpenGL programs to perform those tasks which would normally require platform-specific code. Tasks like creating a window, creating an OpenGL context and binding it to the window, and processing input events. Freeglut provides a concise and elegant API to handle those tasks, in a platform-independent manner, keeping the application simple and portable.
- **freetype** [ğŸ“](../../thirdparty/freetype) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-freetype2) -- FreeType is a freely available software library to render fonts.
- **graph-coloring** [ğŸ“](./graph-coloring) [ğŸŒ](https://github.com/GerHobbelt/graph-coloring) -- a C++ Graph Coloring Package. This project has two primary uses:
  
  * As an executable for finding the chromatic number for an input graph (in edge list or edge matrix format)
  * As a library for finding the particular coloring of an input graph (represented as a `map<string,vector<string>>` edge list)

- **harfbuzz** [ğŸ“](../../thirdparty/harfbuzz) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-harfbuzz) -- a text shaping engine. It primarily supports [OpenType][1], but also [Apple Advanced Typography][2].
- **jbig2dec** [ğŸ“](../../thirdparty/jbig2dec) [ğŸŒ](https://github.com/GerHobbelt/jbig2dec) -- a decoder library and example utility implementing the JBIG2 bi-level image compression spec. Also known as ITU T.88 and ISO IEC 14492, and included by reference in Adobe's PDF version 1.4 and later.
- **lcms2** [ğŸ“](../../thirdparty/lcms2) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-lcms2) -- `lcms2mt` is a thread-safe fork of `lcms` (a.k.a. Little CMS). Little CMS intends to be a small-footprint color management engine, with special focus on accuracy and performance. It uses the International Color Consortium standard (ICC), which is the modern standard when regarding to color management. The ICC specification is widely used and is referred to in many International and other de-facto standards. It was approved as an International Standard, ISO 15076-1, in 2005. Little CMS is a **full implementation** of ICC specification 4.3, it fully supports all kind of V2 and V4 profiles, including abstract, devicelink and named color profiles.
- **leptonica** [ğŸ“](../../thirdparty/leptonica) [ğŸŒ](https://github.com/GerHobbelt/leptonica) -- supports many operations that are useful on images.
  
  Features:
  
  * Rasterop (aka bitblt)
  * Affine transforms (scaling, translation, rotation, shear) on images of arbitrary pixel depth
  * Projective and bilinear transforms
  * Binary and grayscale morphology, rank order filters, and convolution
  * Seedfill and connected components
  * Image transformations with changes in pixel depth, both at the same scale and with scale change
  * Pixelwise masking, blending, enhancement, arithmetic ops, etc.

- **libjpeg** [ğŸ“](../../thirdparty/libjpeg) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-libjpeg) -- the Independent JPEG Group's JPEG software
- **libpng** [ğŸ“](../../thirdparty/libpng) [ğŸŒ](https://github.com/GerHobbelt/libpng) -- LIBPNG: Portable Network Graphics support, official libpng repository.
- **libtiff** [ğŸ“](../../thirdparty/libtiff) [ğŸŒ](https://github.com/GerHobbelt/libtiff) -- TIFF Software Distribution
- **mozjpeg** [ğŸ“](./mozjpeg) [ğŸŒ](https://github.com/GerHobbelt/mozjpeg) -- the Mozilla JPEG Encoder Project improves JPEG compression efficiency achieving higher visual quality and smaller file sizes at the same time. It is compatible with the JPEG standard, and the vast majority of the world's deployed JPEG decoders. MozJPEG is a patch for [libjpeg-turbo](https://github.com/libjpeg-turbo/libjpeg-turbo).
- **OpenColorIO** [ğŸ“](./OpenColorIO) [ğŸŒ](https://github.com/GerHobbelt/OpenColorIO) -- OpenColorIO (OCIO) is a complete color management solution geared towards motion picture production with an emphasis on visual effects and computer animation. OCIO provides a straightforward and consistent user experience across all supporting applications while allowing for sophisticated back-end configuration options suitable for high-end production usage. OCIO is compatible with the Academy Color Encoding Specification (ACES) and is LUT-format agnostic, supporting many popular formats.
- **openjpeg** [ğŸ“](../../thirdparty/openjpeg) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-openjpeg) -- OPENJPEG Library and Applications -- OpenJPEG is an open-source JPEG 2000 codec written in C language. It has been developed in order to promote the use of [JPEG 2000](http://www.jpeg.org/jpeg2000), a still-image compression standard from the Joint Photographic Experts Group ([JPEG](http://www.jpeg.org)).  Since April 2015, it is officially recognized by ISO/IEC and ITU-T as a [JPEG 2000 Reference Software](http://www.itu.int/rec/T-REC-T.804-201504-I!Amd2).
- **PDFGen** [ğŸ“](./PDFGen) [ğŸŒ](https://github.com/GerHobbelt/PDFGen) -- a simple PDF Creation/Generation library, contained in a single C-file with header and no external library dependencies. Useful for embedding into other programs that require rudimentary PDF output.
- **zlib** [ğŸ“](../../thirdparty/zlib) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-zlib) -- zlib-ng: zlib data compression library for the next generation systems.











## UI / GUI

- **agg** [ğŸ“](./agg) [ğŸŒ](https://github.com/GerHobbelt/agg) -- Anti-Grain Geometry library, written by Maxim Shemanarev in C++. It is an Open Source, 2D vector graphics library. Agg produces pixel images in memory from vectorial data. AGG doesn't depend on any graphic API or technology. Basically, you can think of AGG as of a rendering engine that produces pixel images in memory from some vectorial data.
- **clp** [ğŸ“](./clp) [ğŸŒ](https://github.com/GerHobbelt/clp) -- YScope's Compressed Log Processor (CLP) compresses your logs, and allows you to search the compressed logs without decompression. CLP supports both JSON logs and unstructured (i.e., free text) logs. It also supports real-time log compression within several logging libraries. CLP also includes purpose-built web interfaces for searching and viewing the compressed logs.
- **horsejs** [ğŸ“](./horsejs) [ğŸŒ](https://github.com/GerHobbelt/horsejs) -- a framework similar to Electron. Unlike Electron, it has no built-in Node.js, but directly uses C++ to provide most of Electron's capabilities, such as accessing files using JavaScript, opening dialog boxes, creating new windows, etc. Since there is no Node.js, HorseJs runs faster, uses less memory, and is more stable.
- **indicators** [ğŸ“](./indicators) [ğŸŒ](https://github.com/GerHobbelt/indicators) -- thread-safe progress bars and spinners for console applications.
- **libclip** [ğŸ“](./libclip) [ğŸŒ](https://github.com/GerHobbelt/clip) -- a library to copy/retrieve content to/from the clipboard/pasteboard.
- **libclipboard** [ğŸ“](./libclipboard) [ğŸŒ](https://github.com/GerHobbelt/libclipboard) -- a lightweight cross-platform clipboard library.
- **libgateY** [ğŸ“](./libgateY) [ğŸŒ](https://github.com/GerHobbelt/libgateY) -- Use a web browser to easily visualize data from your C++ program and control itâ€™s behaviour. libgateY allows you to add variables shared between the native C++ code and the javascript code.
- **nanogui** [ğŸ“](./nanogui) [ğŸŒ](https://github.com/GerHobbelt/nanogui) -- NanoGUI is a minimalistic cross-platform widget library for OpenGL 3+, GLES 2/3, and Metal. It supports automatic layout generation, stateful C++ lambdas callbacks, a variety of useful widget types and Retina-capable rendering on Apple devices thanks to NanoVG_ by Mikko Mononen.
- **nativefiledialog-extended** [ğŸ“](./nativefiledialog-extended) [ğŸŒ](https://github.com/GerHobbelt/nativefiledialog-extended) -- a small C library with that portably invokes native file open, folder select and file save dialogs.  Write dialog code once and have it pop up native dialogs on all supported platforms.  Avoid linking large dependencies like wxWidgets and Qt.
- **neutralinoJS** [ğŸ“](./neutralinoJS) [ğŸŒ](https://github.com/GerHobbelt/neutralinojs) -- a lightweight and portable desktop application development framework. It lets you develop lightweight cross-platform desktop applications using JavaScript, HTML and CSS. Neutralinojs offers a lightweight SDK which is an alternative for Electron and NW.js. Neutralinojs doesn't bundle Chromium and uses the existing web browser library in the operating system. Neutralinojs implements a WebSocket connection for native operations and embeds a static web server to serve the web content. Also, it offers a built-in [JavaScript client library](https://github.com/neutralinojs/neutralino.js) for developers.
- **neutralinoJS-CLI** [ğŸ“](./neutralinoJS-CLI) [ğŸŒ](https://github.com/GerHobbelt/neutralinojs-cli) -- The official CLI of Neutralinojs.
- **nodesoup** [ğŸ“](./nodesoup) [ğŸŒ](https://github.com/GerHobbelt/nodesoup) -- delivers graph untangling: a force-directed graph layout simulates forces to give motion to vertices and arrange them in a way that is visually pleasing and/or reveals structure. The Fruchterman-Reingold algorithm assigns a repelling force to vertices pair of the graph, effectively pushing apart vertices so they don't overlap, and a attraction force between each adjacent vertices pair, thus dragging closer connected vertices. The forces attenuate when the vertices get respectively further apart or closer, and a global temperature also serves as a simulated annealing, capping the maximum vertex displacement at each iteration. As the forces between each component and the temperature gradually diminish, the layout stabilizes.  Another method, the Kamada Kawai algorithm, relies on the simulation of springs between each vertex, which strength is determined by the length of the shortest path between both vertices. The potential energy of each vertex, i.e. the sum of the energy of all its springs, is then computed. The goal being to reduce the global energy of the layout, each vertex is moved step-by-step until its potential energy is considered low-enough, using a Newton-Raphson algorithm.
- **notcurses** [ğŸ“](./notcurses) [ğŸŒ](https://github.com/GerHobbelt/notcurses) -- a library facilitating complex TUIs on modern terminal emulators, supporting vivid colors, multimedia, threads, and Unicode to the maximum degree possible. Things can be done with Notcurses that simply can't be done with NCURSES. It is furthermore fast as shit. What it is not: a source-compatible X/Open Curses implementation, nor a replacement for NCURSES on existing systems.
- **oof** [ğŸ“](./oof) [ğŸŒ](https://github.com/GerHobbelt/oof) -- OOF (omnipotent output friend) is a single C++20 header that wraps so-called [Virtual Terminal sequences](https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences) (sometimes also confusingly called ["escape codes"](https://en.wikipedia.org/wiki/ANSI_escape_code)) in a convenient way, enabling console applications using OOF to be far more capable than usual: complete control over position, color and other properties of written characters.
- **photino.native** [ğŸ“](./photino.native) [ğŸŒ](https://github.com/GerHobbelt/photino.Native) -- a lightweight open-source framework for building native, cross-platform desktop applications with Web UI technology. Photino enables developers to use fast, natively compiled languages like C#, C++, Java and more. Photino uses the OSs built-in WebKit-based browser control for Windows, macOS and Linux. Photino is the lightest cross-platform framework.
- **scintilla** [ğŸ“](./scintilla) [ğŸŒ](https://github.com/GerHobbelt/scintilla) -- text editor
- **svg-charter** [ğŸ“](./svg-charter) [ğŸŒ](https://github.com/GerHobbelt/charter) -- SVG chart renderer
- **tinycolormap** [ğŸ“](./tinycolormap) [ğŸŒ](https://github.com/GerHobbelt/tinycolormap) -- a header-only, single-file library for colormaps written in C++11.
- **tvision** [ğŸ“](./tvision) [ğŸŒ](https://github.com/GerHobbelt/tvision) -- a modern port of Borland's Turbo Vision 2.0, the classical framework for text-based user interfaces. Now cross-platform and with Unicode support. (**retro fun**)
- **u8g2** [ğŸ“](./u8g2) [ğŸŒ](https://github.com/GerHobbelt/u8g2) -- a monochrome graphics library for embedded devices. U8g2 supports monochrome OLEDs and LCDs, which include the following controllers: SSD1305, SSD1306, SSD1309, SSD1312, SSD1316, SSD1318, SSD1320, SSD1322, SSD1325, SSD1327, SSD1329, SSD1606, SSD1607, SH1106, SH1107, SH1108, SH1122, T6963, RA8835, LC7981, PCD8544, PCF8812, HX1230, UC1601, UC1604, UC1608, UC1610, UC1611, UC1617, UC1638, UC1701, ST7511, ST7528, ST7565, ST7567, ST7571, ST7586, ST7588, ST75160, ST75256, ST75320, NT7534, ST7920, IST3020, IST3088, IST7920, LD7032, KS0108, KS0713, HD44102, T7932, SED1520, SBN1661, IL3820, MAX7219, GP1287, GP1247, GU800 (see [here](https://github.com/olikraus/u8g2/wiki/u8g2setupcpp) for a full list).
- **vtm** [ğŸ“](./vtm) [ğŸŒ](https://github.com/GerHobbelt/vtm) -- Terminal multiplexer with window manager and session sharing. Text-based desktop environment inside your terminal. Includes `destopio`, a text/terminal oriented layout engine.
- **webview** [ğŸ“](./webview) [ğŸŒ](https://github.com/GerHobbelt/webview) -- cross-platform embedding of the system-default web browser: a tiny cross-platform webview library for C/C++/Golang to build modern cross-platform GUIs. The goal of the project is to create a common HTML5 UI abstraction layer for the most widely used platforms. It supports two-way JavaScript bindings (to call JavaScript from C/C++/Go and to call C/C++/Go from JavaScript).
- **win32-dpi** [ğŸ“](./win32-dpi) [ğŸŒ](https://github.com/GerHobbelt/win32-dpi) -- Win32 DPI-aware window example, showcasing how to write a Win32 DPI-aware GUI application that scales properly on everything starting from Windows XP up to and including latest Windows 11.
- **WinToast** [ğŸ“](./WinToast) [ğŸŒ](https://github.com/GerHobbelt/WinToast) -- a library which delivers a complete integration of the modern **toast notifications** of **Windows 8**, **Windows 10** and **Windows 11**.  Toast notifications allows your app to inform the users about relevant information and timely events that they should see and take action upon inside your app, such as a new instant message, a new friend request, breaking news, or a calendar event.
- **wxCharts** [ğŸ“](./wxCharts) [ğŸŒ](https://github.com/GerHobbelt/wxCharts) -- charts for wxWidgets
- **wxCurl** [ğŸ“](./wxCurl) [ğŸŒ](https://github.com/GerHobbelt/wxCurl) -- clone of improved wxCurl from OpenCPN. wxCURL is a simplified and integrated interface between LibCURL and wxWidgets. wxCURL provides several sub-classes for simplified interfaces to HTTP, WebDAV, FTP and Telnet based resources, threads specialized for non-blocking downloads/uploads, stock download and upload dialogs.
- **wxDatabase** [ğŸ“](./wxDatabase) [ğŸŒ](https://github.com/GerHobbelt/wxDatabase) -- wxDatabase is built on the excellent work of Joseph Blough called DatabaseLayer. The wxDatabase classes provide a database independent interface similar to JDBC (but only VERY basic functionality). So far, the only database backends supported are SQLite3, MySQL, PostGreSQL, ODBC, and TDS.
- **wxExamples** [ğŸ“](./wxExamples) [ğŸŒ](https://github.com/GerHobbelt/Examples_wxWidgets) -- examples using wxWidgets
- **wxFormBuilder** [ğŸ“](./wxFormBuilder) [ğŸŒ](https://github.com/GerHobbelt/wxFormBuilder) -- resource editor and GUI designer for wxWidgets
- **wxMEdit** [ğŸ“](./wxMEdit) [ğŸŒ](https://github.com/GerHobbelt/wxMEdit) -- a cross-platform Text/Hex Editor written in C++ & wxWidgets. wxMEdit supports many useful functions, e.g. Bookmark, Syntax Highlightings, Word Wraps, Encodings and Column/Hex Modes.
- **wxPdfDocument** [ğŸ“](./wxPdfDocument) [ğŸŒ](https://github.com/GerHobbelt/wxpdfdoc) -- **wxPdfDocument** allows wxWidgets applications to generate PDF documents. The code is a port of FPDF - a free PHP class for generating PDF files - to C++ using the wxWidgets library. Several add-on PHP scripts found on the FPDF web site are incorporated into wxPdfDocument.
- **wxPDFView** [ğŸ“](./wxPDFView) [ğŸŒ](https://github.com/GerHobbelt/wxPDFView) -- wxWidgets PDF viewer/reader control
- **wxSQLite3** [ğŸ“](./wxSQLite3) [ğŸŒ](https://github.com/GerHobbelt/wxsqlite3) -- a C++ wrapper around the SQLite 3.x database and is specifically designed for use in programs based on the wxWidgets library. **wxSQLite3** does not try to hide the underlying database, in contrary almost all special features of the current SQLite3 version are supported, like for example the creation of user defined scalar or aggregate functions.
- **wxVisualScriptEngine** [ğŸ“](./wxVisualScriptEngine) [ğŸŒ](https://github.com/GerHobbelt/VisualScriptEngineWxWidgets) -- a utility module for [VisualScriptEngine](https://github.com/kovacsv/VisualScriptEngine) which provides helper classes for embedding the engine in a wxWidgets application.
- **wxWebViewChromium** [ğŸ“](./wxWebViewChromium) [ğŸŒ](https://github.com/GerHobbelt/wxWebViewChromium) -- Chromium CEF3-based embedded browser for wxWidgets
- **wxWidgets** [ğŸ“](./wxWidgets) [ğŸŒ](https://github.com/GerHobbelt/wxWidgets) -- cross-platform GUI framework.











### Language translation & transliteration

- **gettext** [ğŸ“](./gettext) [ğŸŒ](https://github.com/GerHobbelt/gettext) -- the GNU gettext package.  It is interesting for authors or maintainers of other packages or programs which they want to see internationalized.  As one step the handling of messages in different languages should be implemented.  For this task GNU gettext provides the needed tools and library functions. It is also interesting for translators, because GNU gettext provides the 'msgmerge' program, which prepares a message catalog before a translation update.
- **marian** [ğŸ“](./marian) [ğŸŒ](https://github.com/GerHobbelt/marian) -- an efficient Neural Machine Translation framework written in pure C++ with minimal dependencies.
- **NiuTrans.NMT** [ğŸ“](./NiuTrans.NMT) [ğŸŒ](https://github.com/GerHobbelt/NiuTrans.NMT) -- a lightweight and efficient Transformer-based neural machine translation system. Its main features are:
  
  - Few dependencies. It is implemented with pure C++, and all dependencies are optional.
  - Flexible running modes. The system can run with various systems and devices (Linux vs. Windows, CPUs vs. GPUs, and FP32 vs. FP16, etc.).
  - Framework agnostic. It supports various models trained with other tools, e.g., fairseq models.
  - High efficiency. It is heavily optimized for fast decoding, see [our WMT paper](https://arxiv.org/pdf/2109.08003.pdf) for more details.

- **OpenFST** [ğŸ“](./OpenFST) [ğŸŒ](https://github.com/GerHobbelt/openfst) -- a library for constructing, combining, optimizing, and searching weighted finite-state transducers (FSTs). Weighted finite-state transducers are automata where each transition has an input label, an output label, and a weight. The more familiar finite-state acceptor is represented as a transducer with each transition's input and output label equal. Finite-state acceptors are used to represent sets of strings (specifically, regular or rational sets); finite-state transducers are used to represent binary relations between pairs of strings (specifically, rational transductions). The weights can be used to represent the cost of taking a particular transition. FSTs have key applications in speech recognition and synthesis, machine translation, optical character recognition, pattern matching, string processing, machine learning, information extraction and retrieval among others. Often a weighted transducer is used to represent a probabilistic model (e.g., an n-gram model, pronunciation model). FSTs can be optimized by determinization and minimization, models can be applied to hypothesis sets (also represented as automata) or cascaded by finite-state composition, and the best results can be selected by shortest-path algorithms.
- **OpenFST-utils** [ğŸ“](./OpenFST-utils) [ğŸŒ](https://github.com/GerHobbelt/openfst-utils) -- a set of useful programs for manipulating Finite State Transducer with the OpenFst library.
- **tinygettext** [ğŸ“](./tinygettext) [ğŸŒ](https://github.com/GerHobbelt/tinygettext) -- a minimal replacement for gettext written in C++. It can read `.po` files directly and doesn't need `.mo` files generated from `.po`. It also can read the `.po` files from arbitrary locations, so it's better suited for non-Unix systems and situations in which one wants to store or distribute `.po` files separately from the software itself.
- **zotero-translate** [ğŸ“](./zotero-translate) [ğŸŒ](https://github.com/GerHobbelt/translate) -- browser-based standalone zotero translator.
- **zotero-translation-server** [ğŸ“](./zotero-translation-server) [ğŸŒ](https://github.com/GerHobbelt/translation-server) -- lets you use Zotero translators without the Zotero client.
- **zotero-translators** [ğŸ“](./zotero-translators) [ğŸŒ](https://github.com/GerHobbelt/translators) -- Zotero Translators : automatically detect journal articles, library records, news items, and other objects you might like to save to your Zotero library. Zotero uses so-called â€œtranslatorsâ€ to detect and import data from websites. There are currently more than 600 different translators, facilitating data import from countless sites.











## Application Installers (NSIS, et al)

- **libmetalink** [ğŸ“](./libmetalink) [ğŸŒ](https://github.com/GerHobbelt/libmetalink) -- a library to read Metalink XML download description format. It supports both [_Metalink version 3_](http://www.metalinker.org/Metalink_3.0_Spec.pdf) and [_Metalink version 4 (RFC 5854)_](https://tools.ietf.org/html/rfc5854).
- **metalink-cli** [ğŸ“](./metalink-cli) [ğŸŒ](https://github.com/GerHobbelt/command) -- a small program which generates a metalink record on `stdout` for every file given on the commandline and using the mirror list from `stdin`.
- **metalink-mini-downloader** [ğŸ“](./metalink-mini-downloader) [ğŸŒ](https://github.com/GerHobbelt/mini-downloader) -- a small metalink downloader written in C++, using boost, libcurl and expat. It can either be compiled so that it downloads a specific file and then (optionally) launches it or be compiled into a "downloader template", which can later be used to create a custom downloader by replacing text strings inside the executable (they are marked in a special way, to make this easy).
- **nsis** [ğŸ“](./nsis) [ğŸŒ](https://github.com/GerHobbelt/nsis) -- **Unofficial** "Nullsoft Scriptable Install System" (NSIS) builds
- **NSISDotNetChecker** [ğŸ“](./NSISDotNetChecker) [ğŸŒ](https://github.com/GerHobbelt/NsisDotNetChecker) -- .NET Framework Checker NSIS plugin, used to detect if the required .NET Framework is installed and if it is not - plugin will download and install the required package. The plugin's C++ source code is based on the [work of Aaron Stebner](http://blogs.msdn.com/b/astebner/archive/2009/06/16/9763379.aspx).
- **NSISFileCheck** [ğŸ“](./NSISFileCheck) [ğŸŒ](https://github.com/GerHobbelt/nsisfilecheck) -- NSIS FileCheck is a [NSIS (Nullsoft Scriptable Install System)](https://en.wikipedia.org/wiki/Nullsoft_Scriptable_Install_System) plugin that enables:
  
  - Calculating a file's hash (SHA1, SHA2)
  - Obtaining a file's string version info
  - Verifying a file's Authenticode code signature (including details)

- **NSISMultiUser** [ğŸ“](./NSISMultiUser) [ğŸŒ](https://github.com/GerHobbelt/NsisMultiUser) -- NSIS Multi User Plugin allows "per-user" (no admin required) and "per-machine" (asks elevation *only when necessary*) installations. This plugin was inspired by [MultiUser.nsh (by Joost Verburg)](http://nsis.sourceforge.net/Docs/MultiUser/Readme.html), but supports a lot of new features and is easier to use.
- **nsis-nscurl** [ğŸ“](./nsis-nscurl) [ğŸŒ](https://github.com/GerHobbelt/nsis-nscurl) -- NScurl is a NSIS (Nullsoft Scriptable Install System) plugin with advanced HTTP/HTTPS capabilities. It's implemented on top of [libcurl](https://curl.haxx.se/libcurl/) with [OpenSSL](https://www.openssl.org/) as SSL backend.
- **NSIS-OBSInstallerUtils** [ğŸ“](./NSIS-OBSInstallerUtils) [ğŸŒ](https://github.com/GerHobbelt/OBSInstallerUtils) -- designed to be used with NSIS (Unicode version). It provides the following features:
  
  ```
  OBSInstallerUtils::IsProcessRunning
  OBSInstallerUtils::IsDLLLoaded
  OBSInstallerUtils::AddInUseFileCheck
  OBSInstallerUtils::ResetInUseFileChecks
  OBSInstallerUtils::GetAppNameForInUseFiles
  OBSInstallerUtils::KillProcess
  OBSInstallerUtils::AddAllApplicationPackages
  ```

- **nsis-stdutils** [ğŸ“](./nsis-stdutils) [ğŸŒ](https://github.com/GerHobbelt/stdutils) -- StdUtils plug-in for NSIS
- **vcpkg** [ğŸ“](./vcpkg) [ğŸŒ](https://github.com/GerHobbelt/vcpkg) -- `Vcpkg` helps you manage C and C++ libraries on Windows, Linux and MacOS.











## checking out the competition / compatriots for Qiqqa + re-use useful components

- **bibtool** [ğŸ“](./bibtool) [ğŸŒ](https://github.com/GerHobbelt/bibtool) -- a tool for manipulating BibTeX data bases. BibTeX provides a mean to integrate citations into LaTeX documents. BibTool allows the manipulation of BibTeX files which goes beyond the possibilities -- and intentions -- of BibTeX.
- **calibre** [ğŸ“](./calibre) [ğŸŒ](https://github.com/GerHobbelt/calibre) -- an e-book manager. It can view, convert, edit and catalog e-books in all of the major e-book formats. It can also talk to e-book reader devices. It can go out to the internet and fetch metadata for your books. It can download newspapers and convert them into e-books for convenient reading. It is cross platform, running on Linux, Windows and macOS.
- **cef-pdf** [ğŸ“](./cef-pdf) [ğŸŒ](https://github.com/GerHobbelt/cef-pdf) -- a command line utility (with embedded HTTP server as an optional mode) for creating PDF documents from HTML content. It uses Google Chrome browser's [Chromium Embedded Framework (CEF)](https://bitbucket.org/chromiumembedded/cef/overview) library for all it's internal work; loading urls, rendering HTML & CSS pages and PDF printing, therefore, it produces perfect, accurate, excellent quality PDF documents.
- **citation-abbreviations** [ğŸ“](./citation-abbreviations) [ğŸŒ](https://github.com/GerHobbelt/abbreviations) -- Journal Title Abbreviations
- **JabRef-abbreviations** [ğŸ“](./JabRef-abbreviations) [ğŸŒ](https://github.com/GerHobbelt/jabref-abbreviations) -- Jabref journal name abbreviations: some journal require you to use the abbreviated names for journals. If you have to change this manually, it's quite cumbersome to do. Luckily there exist tools to help. [Jabref](http://jabref.sourceforge.net) is open source bibliography reference manager. It has an option to abbreviate journal names. However, when it comes to Physics journals, the internal list is far from complete.
  
  The original list of abbreviations is located at [ISI](https://images.webofknowledge.com/WOK46/help/WOS/A_abrvjt.html).

- **JabRef-Browser-Extension** [ğŸ“](./JabRef-Browser-Extension) [ğŸŒ](https://github.com/GerHobbelt/JabRef-Browser-Extension) -- a browser extension for users of the bibliographic reference manager [JabRef](https://www.jabref.org/). It automatically identifies and extracts bibliographic information on websites and sends them to JabRef with one click. When you find an interesting article through Google Scholar, the arXiv or journal websites, this browser extension allows you to add those references to JabRef. Even links to accompanying PDFs are sent to JabRef, where those documents can easily be downloaded, renamed and placed in the correct folder. [A wide range of publisher sites, library catalogs and databases are supported](https://www.zotero.org/support/translators).
- **papis-zotero** [ğŸ“](./papis-zotero) [ğŸŒ](https://github.com/GerHobbelt/papis-zotero) -- Zotero compatiblity scripts for papis. Includes a script that decodes the zotero.sqlite sqlite file that zotero uses to manage documents and creates papis Documents out of it. This script will retrieve the documents from zotero (be it pdf documents or something else) and important information like tags.
- **tesseract-gImgRdrGui** [ğŸ“](./tesseract-gImgRdrGui) [ğŸŒ](https://github.com/GerHobbelt/gImageReader) -- a Gtk/Qt front-end to tesseract-ocr.
- **zotero** [ğŸ“](./zotero) [ğŸŒ](https://github.com/GerHobbelt/zotero) -- [Zotero](https://www.zotero.org/) is a free, easy-to-use tool to help you collect, organize, cite, and share your research sources.
- **zotero-better-bibtex** [ğŸ“](./zotero-better-bibtex) [ğŸŒ](https://github.com/GerHobbelt/zotero-better-bibtex) -- Better BibTeX (BBT) is an extension for Zotero and Juris-M that makes it easier to manage bibliographic data, especially for people authoring documents using text-based toolchains (e.g. based on LaTeX / Markdown).
- **zotero-bib** [ğŸ“](./zotero-bib) [ğŸŒ](https://github.com/GerHobbelt/bib) -- Zotero Translation Client is a library that can process URLs and identifiers (such as ISBN or DOI) into CSL-JSON bibliography items using a translation server.
- **zotero-build** [ğŸ“](./zotero-build) [ğŸŒ](https://github.com/GerHobbelt/zotero-build) -- Zotero client build scripts.
- **zotero-connectors** [ğŸ“](./zotero-connectors) [ğŸŒ](https://github.com/GerHobbelt/zotero-connectors) -- Chrome, Firefox, and Safari browser extensions for Zotero.
- **zotero-google-docs-integration** [ğŸ“](./zotero-google-docs-integration) [ğŸŒ](https://github.com/GerHobbelt/zotero-google-docs-integration) -- a Zotero integration plugin that communicates between Google Docs and Zotero via the Connector.
- **zotero-libreoffice-integration** [ğŸ“](./zotero-libreoffice-integration) [ğŸŒ](https://github.com/GerHobbelt/zotero-libreoffice-integration) -- comprises extensions for LibreOffice/OpenOffice.org/NeoOffice and Zotero communicating using local web servers.
- **zotero-scholar-citations** [ğŸ“](./zotero-scholar-citations) [ğŸŒ](https://github.com/GerHobbelt/zotero-scholar-citations) -- an add-on for Zotero. The add-on automatically fetches numbers of citations of your Zotero items from Google Scholar and makes it possible to sort your items by the citations. Moreover, it allows batch updating the citations, as they may change over time.
  
  **When updating multiple citations in a batch, it may happen that citation queries are blocked by Google Scholar for multiple automated requests. If a blockage happens, the add-on opens a browser window and directs it to http://scholar.google.com/, where you should see a Captcha displayed by Google Scholar, which you need to enter to get unblocked and then re-try updating the citations. It may happen that Google Scholar displays a message like the following "*We're sorry... but your computer or network may be sending automated queries. To protect our users, we can't process your request right now.*" In that case, the only solution is to wait for a while until Google unblocks you.**

- **zotero-shortdoi** [ğŸ“](./zotero-shortdoi) [ğŸŒ](https://github.com/GerHobbelt/zotero-shortdoi) -- an add-on for Zotero. The add-on can auto-fetch DOI names for journal articles using the CrossRef API, as well as look up shortDOI names using http://shortdoi.org. The add-on additionally verifies that stored DOIs are valid and marks invalid DOIs.
- **zotero-standalone-build** [ğŸ“](./zotero-standalone-build) [ğŸŒ](https://github.com/GerHobbelt/zotero-standalone-build) -- build scripts used to bundle the Zotero core into distributable bundles for Mac, Windows, and Linux.
- **zotero-translate** [ğŸ“](./zotero-translate) [ğŸŒ](https://github.com/GerHobbelt/translate) -- browser-based standalone zotero translator.
- **zotero-translation-server** [ğŸ“](./zotero-translation-server) [ğŸŒ](https://github.com/GerHobbelt/translation-server) -- lets you use Zotero translators without the Zotero client.
- **zotero-translators** [ğŸ“](./zotero-translators) [ğŸŒ](https://github.com/GerHobbelt/translators) -- Zotero Translators : automatically detect journal articles, library records, news items, and other objects you might like to save to your Zotero library. Zotero uses so-called â€œtranslatorsâ€ to detect and import data from websites. There are currently more than 600 different translators, facilitating data import from countless sites.
- **zotero-web-library** [ğŸ“](./zotero-web-library) [ğŸŒ](https://github.com/GerHobbelt/web-library) -- a Web Library capable of being installed/run on other websites. It is a single-page application implemented in Javascript. It uses Zotero API via CORS requests.
- **zotero-word-for-windows-integration** [ğŸ“](./zotero-word-for-windows-integration) [ğŸŒ](https://github.com/GerHobbelt/zotero-word-for-windows-integration) -- a Firefox add-on that consists of a library written in C++ that communicates with Microsoft Word out of process using OLE Automation, a js-ctypes wrapper for said library, and a template that is installed into Microsoft Word to communicate with Zotero.
- **zotero-zotfile** [ğŸ“](./zotero-zotfile) [ğŸŒ](https://github.com/GerHobbelt/zotfile) -- Zotero plugin to manage your attachments: automatically rename, move, and attach PDFs (or other files) to Zotero items, sync PDFs from your Zotero library to your (mobile) PDF reader (e.g. an iPad, Android tablet, etc.), and extract PDF annotations.











## citations output (CSL)

- **citation-abbreviations** [ğŸ“](./citation-abbreviations) [ğŸŒ](https://github.com/GerHobbelt/abbreviations) -- Journal Title Abbreviations
- **citation-journals** [ğŸ“](./citation-journals) [ğŸŒ](https://github.com/GerHobbelt/journals) -- Tools and journal metadata for generating dependent CSL styles.
- **citation-styles** [ğŸ“](./citation-styles) [ğŸŒ](https://github.com/GerHobbelt/styles) -- the Citation Style Language (CSL) citation styles.
- **citeproc-js** [ğŸ“](./citeproc-js) [ğŸŒ](https://github.com/GerHobbelt/citeproc-js) -- a JavaScript implementation of the Citation Style Language (CSL) https://citeproc-js.readthedocs.io
- **JabRef-abbreviations** [ğŸ“](./JabRef-abbreviations) [ğŸŒ](https://github.com/GerHobbelt/jabref-abbreviations) -- Jabref journal name abbreviations: some journal require you to use the abbreviated names for journals. If you have to change this manually, it's quite cumbersome to do. Luckily there exist tools to help. [Jabref](http://jabref.sourceforge.net) is open source bibliography reference manager. It has an option to abbreviate journal names. However, when it comes to Physics journals, the internal list is far from complete.
  
  The original list of abbreviations is located at [ISI](https://images.webofknowledge.com/images/help/WOS/A_abrvjt.html).












## Microsoft Word, Google Docs, LibreOffice: application integration

- **JabRef-Browser-Extension** [ğŸ“](./JabRef-Browser-Extension) [ğŸŒ](https://github.com/GerHobbelt/JabRef-Browser-Extension) -- a browser extension for users of the bibliographic reference manager [JabRef](https://www.jabref.org/). It automatically identifies and extracts bibliographic information on websites and sends them to JabRef with one click. When you find an interesting article through Google Scholar, the arXiv or journal websites, this browser extension allows you to add those references to JabRef. Even links to accompanying PDFs are sent to JabRef, where those documents can easily be downloaded, renamed and placed in the correct folder. [A wide range of publisher sites, library catalogs and databases are supported](https://www.zotero.org/support/translators).
- **zotero-connectors** [ğŸ“](./zotero-connectors) [ğŸŒ](https://github.com/GerHobbelt/zotero-connectors) -- Chrome, Firefox, and Safari browser extensions for Zotero.
- **zotero-google-docs-integration** [ğŸ“](./zotero-google-docs-integration) [ğŸŒ](https://github.com/GerHobbelt/zotero-google-docs-integration) -- a Zotero integration plugin that communicates between Google Docs and Zotero via the Connector.
- **zotero-libreoffice-integration** [ğŸ“](./zotero-libreoffice-integration) [ğŸŒ](https://github.com/GerHobbelt/zotero-libreoffice-integration) -- comprises extensions for LibreOffice/OpenOffice.org/NeoOffice and Zotero communicating using local web servers.
- **zotero-word-for-windows-integration** [ğŸ“](./zotero-word-for-windows-integration) [ğŸŒ](https://github.com/GerHobbelt/zotero-word-for-windows-integration) -- a Firefox add-on that consists of a library written in C++ that communicates with Microsoft Word out of process using OLE Automation, a js-ctypes wrapper for said library, and a template that is installed into Microsoft Word to communicate with Zotero.











## XML & XSLT tooling

- **gumbo-libxml** [ğŸ“](./gumbo-libxml) [ğŸŒ](https://github.com/GerHobbelt/gumbo-libxml) -- LibXML2 bindings for the Gumbo HTML5 parser: this provides a libxml2 API on top of the Gumbo parser.  It lets you use a modern parser - Gumbo now passes all html5lib tests, including the template tag, and should be fully conformant with the HTML5 spec - with the full ecosystem of libxml tools, including XPath, tree modification, DTD validation, etc.
- **libexpat** [ğŸ“](./libexpat) [ğŸŒ](https://github.com/GerHobbelt/libexpat) -- XML read/write
- **libxml2** [ğŸ“](./libxml2) [ğŸŒ](https://github.com/GerHobbelt/libxml2) -- XML read/write
- **libxslt** [ğŸ“](./libxslt) [ğŸŒ](https://github.com/GerHobbelt/libxslt) -- XSLT support for libxml2 (XML toolkit from the GNOME project)
- **rapidxml** [ğŸ“](./rapidxml) [ğŸŒ](https://github.com/GerHobbelt/rapidxml) -- RapidXML is an ancient C++ library for parsing XML quickly and flexibly.
- **xml-pugixml** [ğŸ“](./xml-pugixml) [ğŸŒ](https://github.com/GerHobbelt/pugixml) -- light-weight, simple and fast XML parser for C++ with XPath support.
- **xsldbg** [ğŸ“](./xsldbg) [ğŸŒ](https://github.com/GerHobbelt/xsldbg) -- a debugger for xsl/xslt stylesheets which has functionality similar to a Unix/Linux "gdb", using libxml2 and libxslt.











## Microsoft DOCX ~ OpenXML & other XML & XSLT tooling

- **b2xtranslator** [ğŸ“](./b2xtranslator) [ğŸŒ](https://github.com/GerHobbelt/b2xtranslator) -- .NET Core library to convert Microsoft Office binary files (doc, xls and ppt) to Open XML (docx, xlsx and pptx). You can use the Open XML SDK to mainpulate those.
- **docxBox** [ğŸ“](./docxBox) [ğŸŒ](https://github.com/GerHobbelt/docxBox) -- CLI tool for Word DOCX templating and analysis.
- **html2openxml** [ğŸ“](./html2openxml) [ğŸŒ](https://github.com/GerHobbelt/html2openxml) -- Html2OpenXml is a small .NET library that converts simple or advanced HTML to plain OpenXml components (docx).
- **MariGold.OpenXHTML** [ğŸ“](./MariGold.OpenXHTML) [ğŸŒ](https://github.com/GerHobbelt/MariGold.OpenXHTML) -- a wrapper library for Open XML SDK to convert HTML documents into Open XML word documents. It has simply encapsulated the complexity of Open XML yet exposes the properties of Open XML for manipulation.
- **npoi** [ğŸ“](./npoi) [ğŸŒ](https://github.com/GerHobbelt/npoi) -- a .NET library that can read/write Office formats without Microsoft Office installed. No COM+, no interop. With NPOI, you can read/write Office 2003/2007 files very easily.
- **OfficeIMO** [ğŸ“](./OfficeIMO) [ğŸŒ](https://github.com/GerHobbelt/OfficeIMO) -- fast and easy to use cross-platform .NET library that creates or modifies Microsoft Word (.docx) files without installing any software. Underneath it uses OpenXML SDK but heavily simplifies it.
- **Open-XML-SDK** [ğŸ“](./Open-XML-SDK) [ğŸŒ](https://github.com/GerHobbelt/Open-XML-SDK) -- the Microsoft Open XML SDK (.NET) provides tools for working with Office Word, Excel, and PowerPoint documents.
- **ShapeCrawler** [ğŸ“](./ShapeCrawler) [ğŸŒ](https://github.com/GerHobbelt/ShapeCrawler) -- a .NET library for manipulating PowerPoint presentations.











## Misc. / Other

- **ADE-graph-management** [ğŸ“](./ADE-graph-management) [ğŸŒ](https://github.com/GerHobbelt/ade) -- ADE Framework is a graph construction, manipulation, and processing framework.  ADE Framework is suitable for organizing data flow processing and execution.
- **awesome-c** [ğŸ“](./awesome-c) [ğŸŒ](https://github.com/GerHobbelt/awesome-c) -- a curated list of C good stuff.
- **BayerToRGB** [ğŸ“](./BayerToRGB) [ğŸŒ](https://github.com/GerHobbelt/BayerToRGB) -- a image processing demo project, which can do raw data interpolation and also scaling.
- **bbe** [ğŸ“](./bbe) [ğŸŒ](https://github.com/GerHobbelt/bbe) -- Binary block editor, i.e. kinda like `sed` for binary files
- **better-enums** [ğŸ“](./better-enums) [ğŸŒ](https://github.com/GerHobbelt/better-enums) -- reflective compile-time enum library with clean syntax, in a single header file, and without dependencies. In C++11, *everything* can be used at compile time. You can convert your enums, loop over them, find their max, statically enforce conventions, and pass along the results as template arguments or to `constexpr` functions. All the reflection is available for your metaprogramming needs.
- **bin2cpp** [ğŸ“](./bin2cpp) [ğŸŒ](https://github.com/GerHobbelt/bin2cpp) -- a command line tool for embedding small files (like images, icons or raw data files) into a C++ executable.
- **binary2strings** [ğŸ“](./binary2strings) [ğŸŒ](https://github.com/GerHobbelt/binary2strings) -- a module to extract strings from binary blobs. Extracts ASCII, UTF8, and UCS-2 wide strings from binary data. Supports Unicode characters. This is designed to extract strings from binary content such as compiled executables.
- **binary_bakery** [ğŸ“](./binary_bakery) [ğŸŒ](https://github.com/GerHobbelt/binary_bakery) -- Binary bakery translates binary files (images, fonts etc.) into **C++ source code** and gives access to that data at compile- or runtime.
- **BoxFort** [ğŸ“](./BoxFort) [ğŸŒ](https://github.com/GerHobbelt/BoxFort) -- a simple, cross-platform sandboxing C library powering [Criterion](https://github.com/Snaipe/Criterion). BoxFort provides a simple API to run user code in isolated processes. The main goal of this project **is not** security, but portable code isolation -- if you want complete system isolation, consider using properly configured containers.
- **bustache** [ğŸ“](./bustache) [ğŸŒ](https://github.com/GerHobbelt/bustache) -- C++20 implementation of [{{ mustache }}](http://mustache.github.io/), compliant with [spec](https://github.com/mustache/spec) v1.1.3.
- **chromium-snss-parse** [ğŸ“](./chromium-snss-parse) [ğŸŒ](https://github.com/GerHobbelt/chromium-snss-parse) -- Chromium SNSS parse library parses Chromium's SNSS files, e.g. Current Session, Current Tabs, Last Session, Last Tabs and other files.
- **cilantro** [ğŸ“](./cilantro) [ğŸŒ](https://github.com/GerHobbelt/cilantro) -- a lean and fast C++ library for 2D/3D point cloud data processing, with emphasis given to the 3D case. It includes efficient implementations for a variety of common operations, providing a clean API and attempting to minimize the amount of boilerplate code. The library is extensively templated, enabling operations on data of arbitrary numerical type and dimensionality (where applicable) and featuring a modular/extensible design of the more complex procedures. At the same time, convenience aliases/wrappers for the most common cases are provided.
- **Cmathtuts** [ğŸ“](./Cmathtuts) [ğŸŒ](https://github.com/GerHobbelt/Cmathtuts) -- a collection of linear algebra math tutorials in C for BLAS, LAPACK and other fundamental APIs. These include samples for BLAS, LAPACK, CLAPACK, LAPACKE, ATLAS, OpenBLAS ...
- **concat** [ğŸ“](./concat) [ğŸŒ](https://github.com/GerHobbelt/concat) -- because string concatenation deserves one-liners in C++11 too. **concat** concatenates strings using optional separators, but also works with containers, tuples, other scalar types (including `nullptr`) and any mixes thereof. You can print/concatenate **arrays**, **containers**, **tuples**, **pairs** or other **stringstreams** in a uniform and concise manner.
- **cpp-terminal** [ğŸ“](./cpp-terminal) [ğŸŒ](https://github.com/GerHobbelt/cpp-terminal) -- CPP-Terminal is a small C++ library for writing platform independent terminal-based applications. It follows the "Zero-overhead principle" and limits externally included files to the C++ STL. Being crossplatform we support Windows, Linux and MacOS and provide a unified API across all platforms. Our main features are consisting of Colors, Keyboard input, terminal resize handling, as well as other common terminal functionality. It's also possible to open a managed terminal from a windows GUI application.
- **cv-VanishingPoint** [ğŸ“](./cv-VanishingPoint) [ğŸŒ](https://github.com/GerHobbelt/cv-VanishingPoint) -- detection of multiple finite/infinite vanishing points using MSAC.
- **Cysboard** [ğŸ“](./Cysboard) [ğŸŒ](https://github.com/GerHobbelt/Cysboard) -- a lightweight system monitor similar to `conky` but with html and css for themes.
- **dashing** [ğŸ“](./dashing) [ğŸŒ](https://github.com/GerHobbelt/dashing) -- dashing sketches and computes distances between fasta and fastq data. Our paper is available [here](https://www.biorxiv.org/content/10.1101/501726v2) as a preprint and [here](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1875-0) at Genome Biology.
- **debugbreak** [ğŸ“](./debugbreak) [ğŸŒ](https://github.com/GerHobbelt/debugbreak) -- allows you to put breakpoints in your C/C++ code with a call to **`debug_break()`**.
- **design-patterns-cpp** [ğŸ“](./design-patterns-cpp) [ğŸŒ](https://github.com/GerHobbelt/design-patterns-cpp) -- C++ Design Patterns
- **Digital-Halftoning** [ğŸ“](./Digital-Halftoning) [ğŸŒ](https://github.com/GerHobbelt/Digital-Halftoning) -- code for several digital halftoning techniques: Bayers, Ulichney, Dot Diffusion, Floyd-Steinberg Error Diffusion
- **doh** [ğŸ“](./doh) [ğŸŒ](https://github.com/GerHobbelt/doh) -- a libcurl-using application that resolves a host name using DNS-over-HTTPS (DoH).
- **doxygen-awesome-css** [ğŸ“](./doxygen-awesome-css) [ğŸŒ](https://github.com/GerHobbelt/doxygen-awesome-css) -- a custom **CSS theme for Doxygen HTML-documentation** with lots of customization parameters.
- **epeg** [ğŸ“](./epeg) [ğŸŒ](https://github.com/GerHobbelt/epeg) -- an IMMENSELY FAST JPEG thumbnailer library API. It's a convenience library API to using libjpeg to load JPEG images destined to be turned into thumbnails of the original, saving information with these thumbnails, retreiving it and managing to load the image ready for scaling with the minimum of fuss and CPU overhead.
- **ex-leptonica-freetype-harfbuzz** [ğŸ“](./ex-leptonica-freetype-harfbuzz) [ğŸŒ](https://github.com/GerHobbelt/ex-leptonica-freetype-harfbuzz) -- a simple sample application to get from zero to rendering unicode text using harfbuzz to do the text layout, freetype for the underlying font magic and some trivial code for the anti-aliased font rasterization.
- **expected** [ğŸ“](./expected) [ğŸŒ](https://github.com/GerHobbelt/expected) -- a C++ single header implementation of `std::expected` with functional-style extensions. [`std::expected`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf) is proposed as the preferred way to represent object which will either have an expected value, or an unexpected value giving information about why something failed. Unfortunately, chaining together many computations which may fail can be verbose, as error-checking code will be mixed in with the actual programming logic. This implementation provides a number of utilities to make coding with `expected` cleaner.
- **exprtk** [ğŸ“](./exprtk) [ğŸŒ](https://github.com/GerHobbelt/exprtk) -- C++ Mathematical Expression Toolkit Library is a simple to use, easy to integrate and extremely efficient run-time mathematical expression parsing and evaluation engine. The parsing engine supports numerous forms of functional and logic processing semantics and is easily extensible.
- **fatal** [ğŸ“](./fatal) [ğŸŒ](https://github.com/GerHobbelt/fatal) -- Fatal (Facebook Template Library) is a library for fast prototyping software in modern C++. It provides facilities heavily based on template meta-programming, while keeping most of the complexity under-the-hood, to enhance the expressive power of C++. Fatal also provides lessons on how to write meta-programs, as well as on how to make the best use of the library, starting at beginner levels.
- **flare-floss** [ğŸ“](./flare-floss) [ğŸŒ](https://github.com/GerHobbelt/flare-floss) -- the FLARE Obfuscated String Solver (FLOSS, formerly FireEye Labs Obfuscated String Solver) uses advanced static analysis techniques to automatically extract and deobfuscate all strings from malware binaries. You can use it just like `strings.exe` to enhance the basic static analysis of unknown binaries.
- **flatton-offline** [ğŸ“](./flatton-offline) [ğŸŒ](https://github.com/GerHobbelt/flatton-offline) -- Flatton-Offline is an utility that allows you to quickly "flatten" an inked comics page. You pass in a png image with line art and Flatton fills each white area with a random color. It then grows each area so that it bleeds under the line art, touching the other neighboring areas. It is derived from the online utility which you can find [here](https://www.ayalpinkus.nl/Flatton.html).
- **folly** [ğŸ“](./folly) [ğŸŒ](https://github.com/GerHobbelt/folly) -- Folly (acronymed loosely after Facebook Open Source Library) is a library of C++14 components designed with practicality and efficiency in mind. **Folly contains a variety of core library components used extensively at Facebook**. In particular, it's often a dependency of Facebook's other open source C++ efforts and place where those projects can share code.
- **fontbm** [ğŸ“](./fontbm) [ğŸŒ](https://github.com/GerHobbelt/fontbm) -- [BMFont](http://www.angelcode.com/products/bmfont/) compatible, cross-platform (Linux/macOS/Windows) command line bitmap font generator (FreeType2 based render).
- **fontview** [ğŸ“](./fontview) [ğŸŒ](https://github.com/GerHobbelt/fontview) -- â€œFontViewâ€ is a little demo app that shows the contents of a font file. It opens `*.ttf`, `*.otf`, `*.ttc`, `*.otc`, `*.pfa`, and `*.pfb` files. To render text, FontView uses the open-source libraries [FreeType](https://www.freetype.org/), [HarfBuzz](https://www.freedesktop.org/wiki/Software/HarfBuzz/), and [Raqm](http://host-oman.github.io/libraqm/).
- **getopt** [ğŸ“](./getopt) [ğŸŒ](https://github.com/GerHobbelt/getopt_port) -- an original implementation of `getopt` and `getopt_long` with limited GNU extensions. Provided under the BSD license, to allow non-GPL projects to use `getopt`-style command-line parsing.
- **glm** [ğŸ“](./glm) [ğŸŒ](https://github.com/GerHobbelt/glm) -- [OpenGL Mathematics](http://glm.g-truc.net/) (*GLM*) is a header only C++ mathematics library for graphics software based on the [OpenGL Shading Language (GLSL) specifications](https://www.opengl.org/registry/doc/GLSLangSpec.4.50.diff.pdf). *GLM* provides classes and functions designed and implemented with the same naming conventions and functionality than *GLSL* so that anyone who knows *GLSL*, can use *GLM* as well in C++.
- **GSL** [ğŸ“](./GSL) [ğŸŒ](https://github.com/GerHobbelt/GSL) -- the Guidelines Support Library (GSL) contains functions and types that are suggested for use by the [C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines) maintained by the [Standard C++ Foundation](https://isocpp.org). This repo contains Microsoft's implementation of GSL.
- **Hackers-Delight** [ğŸ“](./Hackers-Delight) [ğŸŒ](https://github.com/GerHobbelt/Hackers-Delight) -- the code to accompany the book Hacker's Delight 2nd Edition by Henry S Warren, Jr.  The original package can be found at http://www.hackersdelight.org/
- **hikyuu** [ğŸ“](./hikyuu) [ğŸŒ](https://github.com/GerHobbelt/hikyuu) -- Hikyuu Quant Framework is an open source quantitative trading research framework based on C++/Python, which is used for strategy analysis and backtesting. Its core idea is based on the current mature systematic trading method, which abstracts the entire systematic trading into judging strategies based on market environment, system effective conditions, signal indicators, stop loss/take profit strategies, fund management strategies, profit target strategies, slippage There are seven components of the price difference algorithm. You can build the strategy asset library of these components separately, and freely combine them in actual research to observe the effectiveness, stability of the system and the effect of a single type of strategy.
- **html5lib-tests** [ğŸ“](./html5lib-tests) [ğŸŒ](https://github.com/GerHobbelt/html5lib-tests) -- testsuite data for html5lib, including the de-facto standard HTML parsing tests.
- **hydraquill** [ğŸ“](./hydraquill) [ğŸŒ](https://github.com/GerHobbelt/hydraquill) -- Hydraquill is a simple helper library preparing a selection of Noto fonts for use with a library like Freetype. Our list only contains the regular-weight variable-width sans-serif fonts, which results in 74MiB of raw data for full unicode coverage. The whole package however shrinks down to only 16MiB when compressed with zstd, which is why an archive in this format will be prepared when building examples (the library includes a zstd decoder and is able to unpack it at runtime). The library also provides a way to confirm the existence of unpacked font files and to verify their integrity using sha256 checksums.
- **IconFontCppHeaders** [ğŸ“](./IconFontCppHeaders) [ğŸŒ](https://github.com/GerHobbelt/IconFontCppHeaders) -- provides C and C++ headers, among others, for icon fonts Font Awesome, Fork Awesome, Google Material Design, Pictogrammers Material Design icons, Kenney game icons, Fontaudio, Codicons and Lucide. Useful in UI applications such as ones built in Dear ImGui.
- **javascript-serialization-benchmark** [ğŸ“](./javascript-serialization-benchmark) [ğŸŒ](https://github.com/GerHobbelt/javascript-serialization-benchmark) -- a binary serialization comparison tool in JavaScript (Protocol Buffer, Avro, BSON, etc.). This is a comparison and benchmark of various binary serialization formats and libraries used in JavaScript as of 2020-07-28.
- **jpegview** [ğŸ“](./jpegview) [ğŸŒ](https://github.com/GerHobbelt/jpegview) -- JPEGView is a lean, fast and highly configurable image viewer/editor with a minimal GUI.
- **kfr** [ğŸ“](./kfr) [ğŸŒ](https://github.com/GerHobbelt/kfr) -- an open source C++ DSP framework that contains high performance building blocks for DSP, audio, scientific and other applications.
- **klib** [ğŸ“](./klib) [ğŸŒ](https://github.com/GerHobbelt/klib) -- Klib is a standalone and lightweight C library. Most components are independent of external libraries, except the standard C library, and independent of each other. To use a component of this library, you only need to copy a couple of files to your source code tree without worrying about library dependencies. Klib strives for efficiency and a small memory footprint. Some components, such as khash.h, kbtree.h, ksort.h and kvec.h, are among the most efficient implementations of similar algorithms or data structures in all programming languages, in terms of both speed and memory use.
- **krita** [ğŸ“](./krita) [ğŸŒ](https://github.com/GerHobbelt/krita) -- a free and open source digital painting application. It is for artists who want to create professional work from start to end. Krita is used by comic book artists, illustrators, concept artists, matte and texture painters and in the digital VFX industry.
- **L1Flattening** [ğŸ“](./L1Flattening) [ğŸŒ](https://github.com/GerHobbelt/L1Flattening) -- L1 image flattening is the code for our 2015 SIGGRAPH paper *An L1 Image Transform for Edge-Preserving Smoothing and Scene-Level Intrinsic Decomposition*. If you use this code, please cite our paper.
- **learnopencv** [ğŸ“](./learnopencv) [ğŸŒ](https://github.com/GerHobbelt/learnopencv) -- contains code for Computer Vision, Deep learning, and AI research articles shared on our blog [LearnOpenCV.com](https://www.LearnOpenCV.com).
- **libascii** [ğŸ“](./libascii) [ğŸŒ](https://github.com/GerHobbelt/libascii) -- C/C++ header files carrying the ASCII, Z-modem, etc. control codes as named definitions.
- **libclip** [ğŸ“](./libclip) [ğŸŒ](https://github.com/GerHobbelt/clip) -- a library to copy/retrieve content to/from the clipboard/pasteboard.
- **libclipboard** [ğŸ“](./libclipboard) [ğŸŒ](https://github.com/GerHobbelt/libclipboard) -- a lightweight cross-platform clipboard library.
- **libdivide** [ğŸ“](./libdivide) [ğŸŒ](https://github.com/GerHobbelt/libdivide) -- libdivide.h is a header-only C/C++ library for optimizing integer division. Integer division is one of the slowest instructions on most CPUs e.g. on current x64 CPUs a 64-bit integer division has a latency of up to 90 clock cycles whereas a multiplication has a latency of only 3 clock cycles. `libdivide` allows you to replace expensive integer divsion instructions by a sequence of shift, add and multiply instructions that will calculate the integer division much faster.
- **libicns** [ğŸ“](./libicns) [ğŸŒ](https://github.com/GerHobbelt/libicns) -- a library for manipulation of the Mac OS `icns` resource format, also known as the IconFamily resource type. It can read and write files from the Mac OS X icns format, as well as read from Mac OS resource files and macbinary encoded Mac OS resource forks.
- **libintrinsics** [ğŸ“](./libintrinsics) [ğŸŒ](https://github.com/GerHobbelt/libintrinsics) -- C/C++ compiler / CPU intrinsics for bit ops and various other math.
- **libmodbus** [ğŸ“](./libmodbus) [ğŸŒ](https://github.com/GerHobbelt/libmodbus) -- a groovy modbus library to send/receive data with a device which respects the Modbus protocol. This library can use a serial port or an Ethernet connection. The functions included in the library have been derived from the Modicon Modbus Protocol Reference Guide which can be obtained from [www.modbus.org](http://www.modbus.org).
- **liboauth2** [ğŸ“](./liboauth2) [ğŸŒ](https://github.com/GerHobbelt/liboauth2) -- a library to build C-based OAuth 2.x and OpenID Connect servers and clients e.g. web-server plugins; extends cjose into OAuth 2.x and OpenID Connect specific claims, secrets, and hashes; adds OAuth 2.x and OpenID Connect protocols by abstracting HTTP requests and responses from web server implementation specifics.
- **librs232** [ğŸ“](./librs232) [ğŸŒ](https://github.com/GerHobbelt/librs232) -- multiplatform library for serial communications over RS-232 (serial port).
- **libserialport** [ğŸ“](./libserialport) [ğŸŒ](https://github.com/GerHobbelt/libserialport) -- a cross-platform library for accessing serial ports. libserialport is a minimal library written in C that is intended to take care of the OS-specific details when writing software that uses serial ports.
- **libsiridb** [ğŸ“](./libsiridb) [ğŸŒ](https://github.com/GerHobbelt/libsiridb) -- SiriDB Connector C (libsiridb) is a library which can be used to communicate with [SiriDB](https://github.com/transceptor-technology/siridb-server) using the C program language. This library contains useful functions but does not handle the connection itself.
- **libusb** [ğŸ“](./libusb) [ğŸŒ](https://github.com/GerHobbelt/libusb) -- a library for USB device access from Linux, macOS, Windows, OpenBSD/NetBSD, Solaris userspace, etc.; libusb is abstracted internally in such a way that it can hopefully be ported to other operating systems.
- **libzint** [ğŸ“](./libzint) [ğŸŒ](https://github.com/GerHobbelt/libzint) -- Zint is a suite of programs to allow easy encoding of data in any of the wide range of public domain barcode standards.
- **linecook** [ğŸ“](./linecook) [ğŸŒ](https://github.com/GerHobbelt/linecook) -- a C library for editing the command line, much like the [readline](https://tiswww.cwru.edu/php/chet/readline/readline.html) library used in <b>bash</b> and <b>gdb</b>.
- **luple** [ğŸ“](./luple) [ğŸŒ](https://github.com/GerHobbelt/luple) -- provides C++ Type Loophole, luple, nuple, C++ String Interning, Struct Reader. Luple is a tuple-like data structure. Its primary advantage is that it's very thin and also non-recursive (uses multiple inheritance). std::tuple is usually implemented as a single inheritance hierarchy and as a result its layout can vary between compilers. Also it stores data in reverse order. Luple is built on multiple inheritance and its layout is consistent among compilers. It has the same layout as a non-virtual flat data structure with the same data members (formally luple is not a POD and we should keep that in mind when we reinterpret\_cast it). Luple can be used in constexpr functions if its data members are of literal type.   nuple extends luple and allows giving names to data members.   Struct Reader can detect and create a type list of the data member types of a flat data structure if they are literal, non-const/non-reference types. So, it's a form of primitive RTTI.
- **LZMA-Vizualizer** [ğŸ“](./LZMA-Vizualizer) [ğŸŒ](https://github.com/GerHobbelt/LZMA-Vizualizer) -- visualises per-byte perplexity of the compressed data in an LZMA file.
- **mcmd** [ğŸ“](./mcmd) [ğŸŒ](https://github.com/GerHobbelt/mcmd) -- MCMD (M-Command): a set of commands for handling large scale CSV data. **MCMD** (called as M-Command) is a set of commands that are developed for the purpose of high-speed processing of large-scale structured tabular data in CSV format. It is possible to efficiently process large scale data with hundred millions row of records on a standard PC.
- **mechascribe** [ğŸ“](./mechascribe) [ğŸŒ](https://github.com/GerHobbelt/mechascribe) -- a text rendering abstraction trying to support as much scripts as possible by combining the best publicly available libraries. Features support for complex text layout (using the `raqm` library), feature-complete rendering (using Freetype), very fast software rendering, modern 2-step CPU+GPU rendering, simplified distribution of the Noto fonts for extensive unicode coverage and completely independent font fallback management. The first step to supporting as much scripts as possible consists in gathering a set of fonts covering all the required glyphs. The Noto fonts were created by Google to solve this exact issue. The complete collection weights more than 1.5GiB, but keeping only the regular-weight variable-width sans-serif variants makes it only 74MiB. Zstd compression can help us reduce its size even further: using its most aggressive parameters, our set can be made to fit a 16MiB file. While the compression takes quite some time even on a powerful computer, the resulting archive still unpacks almost instantaneously.
- **merror** [ğŸ“](./merror) [ğŸŒ](https://github.com/GerHobbelt/merror) -- **MError** C++ Macro Error Handling Library is a library for error handling in C++ without exceptions. It requires C++17 and only works for gcc or clang compilers.
- **minifb** [ğŸ“](./minifb) [ğŸŒ](https://github.com/GerHobbelt/minifb) -- MiniFB (Mini FrameBuffer) is a small cross platform library that makes it easy to render (32-bit) pixels in a window.
- **modbus-esp8266** [ğŸ“](./modbus-esp8266) [ğŸŒ](https://github.com/GerHobbelt/modbus-esp8266) -- a Modbus Library for Arduino. Supports ModbusRTU, ModbusTCP and ModbusTCP Security.
- **ModernCppStarter** [ğŸ“](./ModernCppStarter) [ğŸŒ](https://github.com/GerHobbelt/ModernCppStarter) -- for setting up a new C++ project, providing a significant amount of preparation and boilerplate code, even more so for modern C++ projects with tests, executables and continuous integration. This template is the result of learnings from many previous projects and should help reduce the work required to setup up a modern C++ project.
- **monolith** [ğŸ“](./monolith) [ğŸŒ](https://github.com/GerHobbelt/monolith) -- a monorepo with several optimization projects.
  
  One of the highlights is a state-of-the-art scheduler using column generation, which significantly outperforms all other optimizers at [schedulingbenchmarks.org](http://www.schedulingbenchmarks.org/). **Try it in the browser (wasm) [here](https://www.strandmark.net/wasm/shift_scheduling_colgen_page.html)!**
  
  Implements the algorithm described in [_First-order Linear Programming in a Column Generation-Based Heuristic Approach to the Nurse Rostering Problem_](https://www.strandmark.net/papers/first-order-scheduling.pdf) (2020) [doi link](https://doi.org/10.1016/j.cor.2020.104945).
  
  The `minimum::linear::colgen` module contains code for solving scheduling problems. It significantly outperforms all other optimizers at [schedulingbenchmarks.org](http://www.schedulingbenchmarks.org/).
  
  Some of the reasons it is fast:
  
  - It uses a first-order LP solver based on papers by Chambolle and Pock.
  - The pricing problem uses highly optimized dynamic programming in a DAG (in `minimum::algorithms`).
  - The [Ryan-Foster rule](https://strandmark.wordpress.com/2018/01/24/visualizing-the-ryan-foster-rule/) is used to iteratively work towards an integer solution. There is no time to branch and bound for big problems.

- **nameof** [ğŸ“](./nameof) [ğŸŒ](https://github.com/GerHobbelt/nameof) -- header-only C++17 library providing nameof macros and functions to simply obtain the name of a variable, type, function, macro, and enum.
- **omaha** [ğŸ“](./omaha) [ğŸŒ](https://github.com/GerHobbelt/omaha) -- Omaha is the open-source version of Google Update, a program to install requested software and keep it up to date.  The Google-branded version of Omaha is used to support software patching (both background updating, and on-demand update checks) for Google Chrome, Earth, and a variety of other Google products on Windows 7, 8, and 10.
- **oof** [ğŸ“](./oof) [ğŸŒ](https://github.com/GerHobbelt/oof) -- OOF (omnipotent output friend) is a single C++20 header that wraps so-called [Virtual Terminal sequences](https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences) (sometimes also confusingly called ["escape codes"](https://en.wikipedia.org/wiki/ANSI_escape_code)) in a convenient way, enabling console applications using OOF to be far more capable than usual: complete control over position, color and other properties of written characters.
- **OTB** [ğŸ“](./OTB) [ğŸŒ](https://github.com/GerHobbelt/OTB) -- Orfeo ToolBox (OTB) is an open-source project for state-of-the-art remote sensing. Built on the shoulders of the open-source geospatial community, it can process high resolution optical, multispectral and radar images at the terabyte scale. A wide variety of applications are available: from ortho-rectification or pansharpening, all the way to classification, SAR processing, and much more!
- **pcl** [ğŸ“](./pcl) [ğŸŒ](https://github.com/GerHobbelt/pcl) -- the Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D image and point cloud processing.
- **PEGTL** [ğŸ“](./PEGTL) [ğŸŒ](https://github.com/GerHobbelt/PEGTL) -- the Parsing Expression Grammar Template Library (PEGTL) is a zero-dependency C++ header-only parser combinator library for creating parsers according to a [Parsing Expression Grammar](http://en.wikipedia.org/wiki/Parsing_expression_grammar) (PEG).
- **pikchr** [ğŸ“](./pikchr) [ğŸŒ](https://github.com/GerHobbelt/pikchr) -- Pikchr (pronounced like "picture") is a [PIC][1]-like markup language for diagrams in technical documentation.  Pikchr is designed to be embedded in [fenced code blocks][2] of Markdown (or in similar mechanisms in other markup languages) to provide a convenient means of showing diagrams.
- **poco** [ğŸ“](./poco) [ğŸŒ](https://github.com/GerHobbelt/poco) -- POCO (Portable Components) C++ Libraries are a collection of C++ class libraries, conceptually similar to the Java Class Library or the .NET Framework, focused on solutions to frequently-encountered practical problems.
- **portable-snippets** [ğŸ“](./portable-snippets) [ğŸŒ](https://github.com/GerHobbelt/portable-snippets) -- a collection of public domain (CC0) code snippets written in C for performing various common tasks which are typically OS, architecture, and/or compiler-dependent.  Basically, our goal is to move those annoying preprocessor conditionals from your code to ours.
- **preprocess-corpuses** [ğŸ“](./preprocess-corpuses) [ğŸŒ](https://github.com/GerHobbelt/preprocess) -- Pipelines for preprocessing corpora.
- **quirc** [ğŸ“](./quirc) [ğŸŒ](https://github.com/GerHobbelt/quirc) -- a library for extracting and decoding QR codes, which are a type of high-density matrix barcodes, from images. It features a fast, robust and tolerant recognition algorithm. It can correctly recognise and decode QR codes which are rotated and/or oblique to the camera. It can also distinguish and decode multiple codes within the same image.
- **RectangleBinPack** [ğŸ“](./RectangleBinPack) [ğŸŒ](https://github.com/GerHobbelt/RectangleBinPack) -- the source code used in "A Thousand Ways to Pack the Bin - A Practical Approach to Two-Dimensional Rectangle Bin Packing." The code can be
- **remake** [ğŸ“](./remake) [ğŸŒ](https://github.com/GerHobbelt/remake) -- a patched GNU Make 4.3 sourcecode adding improved error reporting, tracing, target listing, graph visualization, profiling, and more. It also contains a [debugger](https://remake.readthedocs.io/en/latest/debugger.html).
- **RuntimeCompiledCPlusPlus** [ğŸ“](./RuntimeCompiledCPlusPlus) [ğŸŒ](https://github.com/GerHobbelt/RuntimeCompiledCPlusPlus) -- Runtime-Compiled C++ (RCC++) is a way to reliably make major changes to your C++ code at runtime and see the results immediately. It's aimed at games development but could be useful in any industry where turnaround times are a bottleneck. RCC++ is primarily designed to shorten iteration times in development - developers can build their project, run it, make changes during runtime and see the results almost immediately. If needed, shipping code can [disable runtime compilation](https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus/wiki/Disabling-runtime-compilation) in a number of ways. RCC++ is not intended as a method to allow end users of a shipped binary to compile modifications, though with some work it can be used this way.
- **RxCpp** [ğŸ“](./RxCpp) [ğŸŒ](https://github.com/GerHobbelt/RxCpp) -- the Reactive Extensions for C++ (__RxCpp__) is a library of algorithms for values-distributed-in-time. The [__Range-v3__](https://github.com/ericniebler/range-v3) library does the same for values-distributed-in-space.
- **safeclib** [ğŸ“](./safeclib) [ğŸŒ](https://github.com/GerHobbelt/safeclib) -- Safe C Library implements the secure C11 Annex K[^5] functions on top of most libc implementations, which are missing from them. The ISO TR24731 Bounds Checking Interface documents indicate that the key motivation for the new specification is to help mitigate the ever increasing security attacks, specifically the buffer overrun.
- **safestringlib** [ğŸ“](./safestringlib) [ğŸŒ](https://github.com/GerHobbelt/safestringlib) -- The Safe String Library is based on the Safe C Library by Cisco, and provides routines for safe string operations (like `strcpy`) and memory routines (like `memcpy`) that are recommended for Linux/Android operating systems, and will also work for Windows. This library is especially useful for cross-platform situations where one library for these routines is preferred.
- **salieri** [ğŸ“](./salieri) [ğŸŒ](https://github.com/GerHobbelt/salieri) -- provides function arguments' in/out annotation definitions for Microsoft's [source-code annotation language (SAL)](https://msdn.microsoft.com/en-us/library/hh916383.aspx). SAL provides lots of annotations you can use to describe the behavior
- **sdcc** [ğŸ“](./sdcc) [ğŸŒ](https://github.com/GerHobbelt/sdcc) -- SDCC is the free open source, retargettable, optimizing ISO C compiler for small devices, including the Intel MCS-51 based microprocessors (8031, 8032, 8051, 8052, etc.), Maxim (formerly Dallas) DS80C390 variants, Freescale (formerly Motorola) HC08 based (hc08, s08), Zilog Z80 based MCUs (Z80, Z80N, Z180, SM83 (e.g. Game Boy), Rabbit 2000, Rabbit 2000A/3000, Rabbit 3000A, TLCS-90, R800), STMicroelectronics STM8, Padauk PDK14 and PDK15 and MOS 6502. Work is in progress on supporting the Padauk PDK13 target. There are unmaintained Microchip PIC16 and PIC18 targets.
- **sdsl-lite** [ğŸ“](./sdsl-lite) [ğŸŒ](https://github.com/GerHobbelt/sdsl-lite) -- The Succinct Data Structure Library (SDSL) is a powerful and flexible C++11 library implementing succinct data structures. In total, the library contains the highlights of 40 [research publications][SDSLLIT]. Succinct data structures can represent an object (such as a bitvector or a tree) in space close to the information-theoretic lower bound of the object while supporting operations of the original object efficiently. The theoretical time complexity of an operation performed on the classical data structure and the equivalent succinct data structure are (most of the time) identical.
- **see-phit** [ğŸ“](./see-phit) [ğŸŒ](https://github.com/GerHobbelt/see-phit) -- a compile time HTML templating library written in modern C++/14. You write plain HTML as C++ string literals and it is parsed at compile time into a DOM like data structure. It makes your "stringly typed" HTML text into an actual strongly typed DSL.
- **siridb-server** [ğŸ“](./siridb-server) [ğŸŒ](https://github.com/GerHobbelt/siridb-server) -- SiriDB Server is a highly-scalable, robust and super fast time series database. SiriDB uses a unique mechanism to operate without a global index and allows server resources to be added on the fly. SiriDBâ€™s unique query language includes dynamic grouping of time series for easy analysis over large amounts of time series. SiriDB is scalable on the fly and has no downtime while updating or expanding your database. The scalable possibilities enable you to enlarge the database time after time without losing speed. SiriDB is developed to give an unprecedented performance without downtime. A SiriDB cluster distributes time series across multiple pools. Each pool supports active replicas for load balancing and redundancy. When one of the replicas is not available the database is still accessible.
- **splitmerge** [ğŸ“](./splitmerge) [ğŸŒ](https://github.com/GerHobbelt/splitmerge) -- simple binary file splitter and (re)merger tool.
- **stringi** [ğŸ“](./stringi) [ğŸŒ](https://github.com/GerHobbelt/stringi) -- fast and portable character string processing in R (with the Unicode ICU).
- **strings2** [ğŸ“](./strings2) [ğŸŒ](https://github.com/GerHobbelt/strings2) -- Strings2 is a Windows command-line tool for extracting strings from binary data: either binary files or process memory. On top of the classic Sysinternals strings approach, this tool includes multi-lingual string extraction, such as Russian, Chinese, etc. while a machine learning model filters out junk erroneous string extractions to reduce noise.
- **StringZilla** [ğŸ“](./StringZilla) [ğŸŒ](https://github.com/GerHobbelt/StringZilla) -- StringZilla ğŸ¦– : The world wastes a minimum of $100M annually due to inefficient string operations. A typical codebase processes strings character by character, resulting in too many branches and data-dependencies, neglecting 90% of modern CPU's potential. That's why StringZilla was created. To provide predictably high performance, portable to any modern platform, operating system, and programming language. StringZilla is the GodZilla of string libraries, using SIMD and SWAR to accelerate string operations on modern CPUs. It is up to __10x faster than the default and even other SIMD-accelerated string libraries__ in C, C++, Python, and other languages, while covering broad functionality. It __accelerates exact and fuzzy string matching, edit distance computations, sorting, lazily-evaluated ranges to avoid memory allocations, and even random-string generators__.
- **strtk** [ğŸ“](./strtk) [ğŸŒ](https://github.com/GerHobbelt/strtk) -- the C++ String Toolkit Library (StrTk) consists of robust, optimized and portable string processing algorithms for the C++ language. StrTk is designed to be easy to use and integrate within existing code bases. Furthermore the library has a rich set of features  that makes light work of any kind of string processing task.
- **SuperString** [ğŸ“](./SuperString) [ğŸŒ](https://github.com/GerHobbelt/SuperString) -- an efficient string library for C++, that achieves a remarkable memory and CPU optimization. SuperString uses Rope (data structure) and optimization techniques.
- **tab** [ğŸ“](./tab) [ğŸŒ](https://github.com/GerHobbelt/tab) -- a tutorial and reference for [tab](http://tab-lang.xyz), a kind of programming language/shell calculator.
- **tee-win32** [ğŸ“](./tee-win32) [ğŸŒ](https://github.com/GerHobbelt/tee-win32) -- a simple [**`tee`**](https://en.wikipedia.org/wiki/Tee_(command)) implementation for Microsoft Windows.
- **termcolor** [ğŸ“](./termcolor) [ğŸŒ](https://github.com/GerHobbelt/termcolor) -- a header-only C++ library for printing colored messages to the terminal. Termcolor uses ANSI color formatting, so you can use it on every system that is used such terminals (most *nix systems, including Linux and Mac OS).
  
  On MS Windows the Windows API is used instead of escape codes but some limitations apply (not everything is supported). That's why it's recommended to enter virtual terminal processing mode and set the TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES macro to trick termcolor to use ANSI color codes.

- **tesseract-dev-mailing-list-archive** [ğŸ“](./tesseract-dev-mailing-list-archive) [ğŸŒ](https://github.com/GerHobbelt/tesseract-dev-mailing-list-archive) -- tesseract-dev mailing list archive, Mechanical Turked because Google does not offer this and has, through their actions, persistently obstructed any and all automation efforts to date.
- **tesseract-ocr-mailing-list-archive** [ğŸ“](./tesseract-ocr-mailing-list-archive) [ğŸŒ](https://github.com/GerHobbelt/tesseract-ocr-mailing-list-archive) -- tesseract-ocr mailing list archive, Mechanical Turked because Google does not offer this and has, through their actions, persistently obstructed any and all automation efforts to date.
- **tinydir** [ğŸ“](./tinydir) [ğŸŒ](https://github.com/GerHobbelt/tinydir) -- lightweight, portable and easy to integrate C directory and file reader. TinyDir wraps `dirent` for POSIX and `FindFirstFile` for Windows. Windows unicode is supported.
- **tinyexpr** [ğŸ“](./tinyexpr) [ğŸŒ](https://github.com/GerHobbelt/tinyexpr) -- a very small recursive descent parser and evaluation engine for math expressions.
- **tiny-utf8** [ğŸ“](./tiny-utf8) [ğŸŒ](https://github.com/GerHobbelt/tiny-utf8) -- a library for extremely easy integration of Unicode into an arbitrary C++11 project. The library consists solely of the class `utf8_string`, which acts as a drop-in replacement for `std::string`. Its implementation is successfully in the middle between small memory footprint and fast access. All functionality of `std::string` is therefore replaced by the corresponding codepoint-based UTF-32 version - translating every access to UTF-8 under the hood.
- **tray** [ğŸ“](./tray) [ğŸŒ](https://github.com/GerHobbelt/tray) -- cross-platform, single header, super tiny C99 implementation of a system tray icon with a popup menu.
- **u8g2** [ğŸ“](./u8g2) [ğŸŒ](https://github.com/GerHobbelt/u8g2) -- a monochrome graphics library for embedded devices. U8g2 supports monochrome OLEDs and LCDs, which include the following controllers: SSD1305, SSD1306, SSD1309, SSD1312, SSD1316, SSD1318, SSD1320, SSD1322, SSD1325, SSD1327, SSD1329, SSD1606, SSD1607, SH1106, SH1107, SH1108, SH1122, T6963, RA8835, LC7981, PCD8544, PCF8812, HX1230, UC1601, UC1604, UC1608, UC1610, UC1611, UC1617, UC1638, UC1701, ST7511, ST7528, ST7565, ST7567, ST7571, ST7586, ST7588, ST75160, ST75256, ST75320, NT7534, ST7920, IST3020, IST3088, IST7920, LD7032, KS0108, KS0713, HD44102, T7932, SED1520, SBN1661, IL3820, MAX7219, GP1287, GP1247, GU800 (see [here](https://github.com/olikraus/u8g2/wiki/u8g2setupcpp) for a full list).
- **u8_to_std_string** [ğŸ“](./u8_to_std_string) [ğŸŒ](https://github.com/GerHobbelt/u8_to_std_string) -- C++ u8_to_std_string (`u8` and `char8_t` based string to `std::string`) inlines to convert between `u8` (`char8_t[]`) string constants and `char`-based `std::string` types to shut up C++17 âœ C++20 transitioning codebases & compilers.
- **units** [ğŸ“](./units) [ğŸŒ](https://github.com/GerHobbelt/units) -- the Units library provides a means of working with units of measurement at runtime, including conversion to and from strings. It provides a small number of types for working with units and measurements and operations necessary for user input and output with units.
- **unsmear** [ğŸ“](./unsmear) [ğŸŒ](https://github.com/GerHobbelt/unsmear) -- converts precisely between timestamps in the timescale of [UTC with smeared leap seconds](https://developers.google.com/time/smear) and the unsmeared [TAI](https://en.wikipedia.org/wiki/International_Atomic_Time) and GPS timescales. This allows smeared time to be stored and distributed exclusively, then converted to and from other timescales in applications where the smear's 11.6 ppm frequency change is consequential. No parallel time distribution systems are required, nor is any mechanism necessary for a system to record what timescale its system clock is using. In other words, the smear is not a way of approximately smudging the clock; it is a defined, precise, and reversible conversion. Rather than having seconds of constant length and minutes with a variable number of seconds, there are always 60 seconds in a minute and the length of a second sometimes differs from those of TAI.
- **utf8proc** [ğŸ“](./utf8proc) [ğŸŒ](https://github.com/GerHobbelt/utf8proc) -- [utf8proc](http://juliastrings.github.io/utf8proc/) is a small, clean C library that provides Unicode normalization, case-folding, and other operations for data in the [UTF-8 encoding](http://en.wikipedia.org/wiki/UTF-8).
- **visible-url-detector** [ğŸ“](./visible-url-detector) [ğŸŒ](https://github.com/GerHobbelt/visible-url-detector) -- console app for listing active tab from browsers (Windows)
- **VSNASM** [ğŸ“](./VSNASM) [ğŸŒ](https://github.com/GerHobbelt/VSNASM) -- a set of build customisations that can be used within Visual Studio to compile assembly code using NASM. Visual Studio integration for the NASM assembler.
- **wcwidth9** [ğŸ“](./wcwidth9) [ğŸŒ](https://github.com/GerHobbelt/wcwidth9) -- platform independent, header only, `wcwidth` with full Unicode 9 wide character support.
- **WebView2Browser** [ğŸ“](./WebView2Browser) [ğŸŒ](https://github.com/GerHobbelt/WebView2Browser) -- a web browser built with the [Microsoft Edge WebView2](https://aka.ms/webview2) control. WebView2Browser is a sample Windows desktop application demonstrating the WebView2 control capabilities. It is built as a Win32 [Visual Studio 2019](https://visualstudio.microsoft.com/vs/) project and makes use of both C++ and JavaScript in the WebView2 environment to power its features.
- **WebView2Samples** [ğŸ“](./WebView2Samples) [ğŸŒ](https://github.com/GerHobbelt/WebView2Samples) -- contains getting started apps as well as sample apps that demonstrate the features and usage patterns of [WebView2](https://aka.ms/webview2). As we add more features to WebView2, we will regularly update our samples.
- **wil-Win32-Interface-Library** [ğŸ“](./wil-Win32-Interface-Library) [ğŸŒ](https://github.com/GerHobbelt/wil) -- The Windows Implementation Libraries (WIL) is a header-only C++ library created to make life easier for developers on Windows through readable type-safe C++ interfaces for common Windows coding patterns.
- **win-iconv** [ğŸ“](./win-iconv) [ğŸŒ](https://github.com/GerHobbelt/win-iconv) -- an `iconv` implementation using Win32 API to convert.
- **WinToast** [ğŸ“](./WinToast) [ğŸŒ](https://github.com/GerHobbelt/WinToast) -- a library which delivers a complete integration of the modern **toast notifications** of **Windows 8**, **Windows 10** and **Windows 11**.  Toast notifications allows your app to inform the users about relevant information and timely events that they should see and take action upon inside your app, such as a new instant message, a new friend request, breaking news, or a calendar event.
- **zxing-cpp** [ğŸ“](./zxing-cpp) [ğŸŒ](https://github.com/GerHobbelt/zxing-cpp) -- ZXing-C++ ("zebra crossing") is a multi-format linear/matrix (1D/2D) barcode image processing library implemented in C++. Supported formats include: UPC-A, UPC-E, EAN-8, EAN-13, Code 39, Code 128, QR Code, PDF417, DataMatrix, CodaBar, DataBar, ITF.
- ~~**binary_bakery** [ğŸŒ](https://github.com/s9w/binary_bakery) -- resource compiler-like tool: embed any data in your C/C++ application~~
  
  - **removed**; reason: we already have `bin2coff` from MuPDF, which serves this purpose well enough.












## sub-dependencies (libraries which are required by any of the above)

- **abseil-cpp** [ğŸ“](./abseil-cpp) [ğŸŒ](https://github.com/GerHobbelt/abseil-cpp) -- a collection of C++ code (compliant to C++11) designed to augment the C++ standard library.
- **boost** [ğŸ“](./boost) [ğŸŒ](https://github.com/GerHobbelt/boost) -- required by several other libraries in this collection
- **cairo** [ğŸ“](./cairo) [ğŸŒ](https://github.com/GerHobbelt/cairo) -- Cairo: Multi-platform 2D graphics library with support for multiple output devices. Cairo is designed to produce consistent output on all output media while taking advantage of display hardware acceleration when available. Currently supported output targets include the X Window System (via both Xlib and XCB), quartz, win32, and image buffers, as well as PDF, PostScript, and SVG file output. Experimental backends include OpenGL. Cairo is designed to produce consistent output on all output media while taking advantage of display hardware acceleration when available (for example, through the X Render Extension).
- **cairo-demos** [ğŸ“](./cairo-demos) [ğŸŒ](https://github.com/GerHobbelt/cairo-demos) -- several simple programs intended to demonstrate some of the features of the Cairo graphics library (http://cairographics.org).
- **colm** [ğŸ“](./colm) [ğŸŒ](https://github.com/GerHobbelt/colm) -- Colm (COmputer Language Machinery) is a programming language designed for the analysis and [transformation of computer languages](https://www.program-transformation.org/Transform/TransformationSystems). Colm is influenced primarily by [TXL](https://www.txl.ca/). Colm is not-your-typical-scripting-languageâ„¢: Colm's main contribution lies in the parsing method. Colm's parsing engine is generalized, but it also allows for the construction of arbitrary global data structures that can be queried during parsing. In other generalized methods, construction of global data requires some very careful consideration because of inherent concurrency in the parsing method. It is such a tricky task that it is often avoided altogether and the problem is deferred to a post-parse disambiguation of the parse forest.
- **fftw3** [ğŸ“](./fftw3) [ğŸŒ](https://github.com/GerHobbelt/fftw3) -- the FFTW library for computing Fourier transforms (version 3.x), maintained by the FFTW authors.
- **fontconfig** [ğŸ“](./fontconfig) [ğŸŒ](https://github.com/GerHobbelt/fontconfig) -- font configuration and customization library
- **gflags** [ğŸ“](./gflags) [ğŸŒ](https://github.com/GerHobbelt/gflags) -- google::flags library, used by other libs in this set.
- **glib2** [ğŸ“](./glib2) [ğŸŒ](https://github.com/GerHobbelt/glib) -- GLib is the low-level core library that forms the basis for projects such as GTK and GNOME.
- **highway** [ğŸ“](./highway) [ğŸŒ](https://github.com/GerHobbelt/highway) -- dependency of JpegXL
- **htmlstreamparser** [ğŸ“](./htmlstreamparser) [ğŸŒ](https://github.com/GerHobbelt/htmlstreamparser) -- used in a demo of zsync2
- **jemalloc** [ğŸ“](./jemalloc) [ğŸŒ](https://github.com/GerHobbelt/jemalloc) -- a general purpose malloc(3) implementation that emphasizes fragmentation avoidance and scalable concurrency support.  jemalloc first came into use as the FreeBSD libc allocator in 2005, and since then it has found its way into numerous applications that rely on its predictable behavior.  In 2010 jemalloc development efforts broadened to include developer support features such as heap profiling and extensive monitoring/tuning hooks.
- **libbf** [ğŸ“](./libbf) [ğŸŒ](https://github.com/GerHobbelt/libbf) -- a small library to handle arbitrary precision binary or decimal floating point numbers
- **libcpr** [ğŸ“](./libcpr) [ğŸŒ](https://github.com/GerHobbelt/cpr) -- wrapper library for cURL; used by zsync2
- **libdiagnostics** [ğŸ“](./libdiagnostics) [ğŸŒ](https://github.com/GerHobbelt/libdiagnostics) -- a C/C++ diagnostics logging library with support for writing HTML and store images and misc binary data to disk alongside. or when a mere logfile doesn't suffice.
- **libfolia** [ğŸ“](./libfolia) [ğŸŒ](https://github.com/GerHobbelt/libfolia) -- working with the Format for Linguistic Annotation (FoLiA). Provides a high-level API to read, manipulate, and create FoLiA documents.
- **libidn2** [ğŸ“](./libidn2) [ğŸŒ](https://github.com/GerHobbelt/libidn2) -- international domain name parsing
- **libsmile** [ğŸ“](./libsmile) [ğŸŒ](https://github.com/GerHobbelt/libsmile) -- C implementation of the Smile binary format (https://github.com/FasterXML/smile-format-specification).
- **mimalloc** [ğŸ“](./mimalloc) [ğŸŒ](https://github.com/GerHobbelt/mimalloc) -- a compact general purpose allocator with excellent performance.
- **nanosvg** [ğŸ“](./nanosvg) [ğŸŒ](https://github.com/GerHobbelt/nanosvg) -- a simple stupid single-header-file SVG parser. The output of the parser is a list of cubic bezier shapes. Suitable for anything from rendering scalable icons in your editor application to prototyping a game. NanoSVG supports a wide range of SVG features.
- **OpenSSL** [ğŸ“](./openssl) [ğŸŒ](https://github.com/GerHobbelt/openssl) -- also used by cURL et al, incidentally.
- **pango** [ğŸ“](./pango) [ğŸŒ](https://github.com/GerHobbelt/pango) -- a library for layout and rendering of text, with an emphasis on internationalization. Pango can be used anywhere that text layout is needed.
- **pcre** [ğŸ“](./pcre) [ğŸŒ](https://github.com/GerHobbelt/pcre) -- PCRE2 : Perl-Compatible Regular Expressions. The PCRE2 library is a set of C functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5. PCRE2 has its own native API, as well as a set of wrapper functions that correspond to the POSIX regular expression API. It comes in three forms, for processing 8-bit, 16-bit, or 32-bit code units, in either literal or UTF encoding.
- **protobuf** [ğŸ“](./protobuf) [ğŸŒ](https://github.com/GerHobbelt/protobuf) -- Protocol Buffers - Google's data interchange format that is a language-neutral, platform-neutral, extensible mechanism for serializing structured data.
  
  - **â˜¹discouragedğŸ¤§**; reason: relatively slow run-time and (in my opinion) rather ugly & convoluted approach at build time. Has too much of a Java/CorporateProgramming smell, which has not lessened over the years, unfortunately.

- **ragel** [ğŸ“](./ragel) [ğŸŒ](https://github.com/GerHobbelt/ragel) -- State Machine Compiler
- **re2c** [ğŸ“](./re2c) [ğŸŒ](https://github.com/GerHobbelt/re2c) -- a lexer generator for C/C++, Go and Rust. Its main goal is generating fast lexers: at least as fast as their reasonably optimized hand-coded counterparts. Instead of using traditional table-driven approach, re2c encodes the generated finite state automata directly in the form of conditional jumps and comparisons. The resulting programs are faster and often smaller than their table-driven analogues, and they are much easier to debug and understand. re2c applies quite a few optimizations in order to speed up and compress the generated code.  Another distinctive feature is its flexible interface: instead of assuming a fixed program template, re2c lets the programmer write most of the interface code and adapt the generated lexer to any particular environment.
- **scintilla** [ğŸ“](./scintilla) [ğŸŒ](https://github.com/GerHobbelt/scintilla) -- text editor (part of wxWidgets)
- **snmalloc** [ğŸ“](./snmalloc) [ğŸŒ](https://github.com/GerHobbelt/snmalloc) -- a high-performance allocator.
- **svg-charter** [ğŸ“](./svg-charter) [ğŸŒ](https://github.com/GerHobbelt/charter) -- SVG chart renderer
- **ticpp** [ğŸ“](./ticpp) [ğŸŒ](https://github.com/GerHobbelt/ticpp) -- TinyXML++: XML read/write (is part of wxFormbuilder).
- **tinyexpr** [ğŸ“](./tinyexpr) [ğŸŒ](https://github.com/GerHobbelt/tinyexpr) -- a very small recursive descent parser and evaluation engine for math expressions.
- **tlx** [ğŸ“](./tlx) [ğŸŒ](https://github.com/GerHobbelt/tlx) -- a collection of C++ helpers and extensions universally needed, but not found in the STL.
- **tsf** [ğŸ“](./tsf) [ğŸŒ](https://github.com/GerHobbelt/tsf) -- type-safe printf equivalent for C++ (used by the uberlog submodule)
- **uint128_t** [ğŸ“](./uint128_t) [ğŸŒ](https://github.com/GerHobbelt/uint128_t) -- an unsigned 128 bit integer type for C++.
- **winflexbison** [ğŸ“](./winflexbison) [ğŸŒ](https://github.com/GerHobbelt/winflexbison) -- Flex and Bison for Microsoft Windows :: a Windows port of Flex (the fast lexical analyser) and GNU Bison (parser generator). Both `win_flex` and `win_bison` are based on upstream sources but depend on system libraries only.
- **Imath** [ğŸŒ](https://github.com/AcademySoftwareFoundation/Imath) -- float16 support lib for OpenEXR format
- ~~**Catch2** [ğŸŒ](https://github.com/catchorg/Catch2)~~
  
  - **removed**; reason: we've decided to standardize on a single unittest library (which is well supported in Microsoft Visual Studio, including the Test Explorer view there); where necessary, we'll have to provide a translation layer instead when existing submodules use different test rigs originally.






---













# Libraries in this collection (All of the above, listed in alphabetical order)

- **1D-RGB-color-gradient** [ğŸ“](./1D-RGB-color-gradient) [ğŸŒ](https://github.com/GerHobbelt/1D-RGB-color-gradient) -- 1D (univariate) continous (smooth) [color gradients](https://en.wikipedia.org/wiki/Color_gradient) (colormaps) for gnuplot.
- **2D-color-gradient-or-Procedural-texture** [ğŸ“](./2D-color-gradient-or-Procedural-texture) [ğŸŒ](https://github.com/GerHobbelt/2D-color-gradient-or-Procedural-texture) -- 2D continous (smooth) [color gradients](https://en.wikipedia.org/wiki/Color_gradient) (colormaps) for gnuplot.
- **abseil-cpp** [ğŸ“](./abseil-cpp) [ğŸŒ](https://github.com/GerHobbelt/abseil-cpp) -- a collection of C++ code (compliant to C++11) designed to augment the C++ standard library.
- **adaptiveqf** [ğŸ“](./adaptiveqf) [ğŸŒ](https://github.com/GerHobbelt/adaptiveqf) -- [Adaptive Quotient Filter (AQF)](https://arxiv.org/abs/2107.02866) supports approximate membership testing and counting the occurrences of items in a data set. Like other AMQs, the AQF has a chance for false positives during queries. However, the AQF has the ability to adapt to false positives after they have occurred so they are not repeated. At the same time, the AQF maintains the benefits of a quotient filter, as it is small and fast, has good locality of reference, scales out of RAM to SSD, and supports deletions, counting, resizing, merging, and highly concurrent access.
- **ADE-graph-management** [ğŸ“](./ADE-graph-management) [ğŸŒ](https://github.com/GerHobbelt/ade) -- ADE Framework is a graph construction, manipulation, and processing framework.  ADE Framework is suitable for organizing data flow processing and execution.
- **AFLplusplus** [ğŸ“](./AFLplusplus) [ğŸŒ](https://github.com/GerHobbelt/AFLplusplus) -- American Fuzzy Lop plus plus (AFL++) is a superior fork to Google's AFL fuzzer - more speed, more and better mutations, more and better instrumentation, custom module support, etc.
- **agg** [ğŸ“](./agg) [ğŸŒ](https://github.com/GerHobbelt/agg) -- Anti-Grain Geometry library, written by Maxim Shemanarev in C++. It is an Open Source, 2D vector graphics library. Agg produces pixel images in memory from vectorial data. AGG doesn't depend on any graphic API or technology. Basically, you can think of AGG as of a rendering engine that produces pixel images in memory from some vectorial data.
- **aho_corasick** [ğŸ“](./aho_corasick) [ğŸŒ](https://github.com/GerHobbelt/aho_corasick) -- a header only implementation of the Aho-Corasick pattern search algorithm invented by Alfred V. Aho and Margaret J. Corasick. It is a very efficient dictionary matching algorithm that can locate all search patterns against in input text simultaneously in O(n + m), with space complexity O(m) (where n is the length of the input text, and m is the combined length of the search patterns).
- **amd-fftw** [ğŸ“](./amd-fftw) [ğŸŒ](https://github.com/GerHobbelt/amd-fftw) -- AOCL-FFTW is AMD optimized version of FFTW implementation targeted for AMD EPYC CPUs. It is developed on top of FFTW (version fftw-3.3.10). AOCL-FFTW achieves high performance as a result of its various optimizations involving improved SIMD Kernel functions, improved copy functions (cpy2d and cpy2d_pair used in rank-0 transform and buffering plan), improved 256-bit kernels selection by Planner and an optional in-place transpose for large problem sizes. AOCL-FFTW improves the performance of in-place MPI FFTs by employing a faster in-place MPI transpose function.
- **A-MNS_TemplateMatching** [ğŸ“](./A-MNS_TemplateMatching) [ğŸŒ](https://github.com/GerHobbelt/A-MNS_TemplateMatching) -- the official code for the PatternRecognition2020 paper: Fast and robust template matching with majority neighbour similarity and annulus projection transformation.
- **annoy** [ğŸ“](./annoy) [ğŸŒ](https://github.com/GerHobbelt/annoy) -- ANNOY (<b>A</b>pproximate <b>N</b>earest <b>N</b>eighbors <b>O</b>h <b>Y</b>eah) is a C++ library to search for points in space that are close to a given query point. It also creates large read-only file-based data structures that are `mmap`-ped into memory so that many processes may share the same data. ANNOY is almost as fast as the fastest libraries, but what really sets Annoy apart is: it has the ability to use static files as indexes, enabling you to share an index across processes. ANNOY also decouples creating indexes from loading them, so you can pass around indexes as files and map them into memory quickly. ANNOY tries to minimize its memory footprint: the indexes are quite small. This is useful when you want to find nearest neighbors using multiple CPU's. Spotify uses ANNOY for music recommendations.
- **ApprovalTestsCpp** [ğŸ“](./ApprovalTestsCpp) [ğŸŒ](https://github.com/GerHobbelt/ApprovalTests.cpp) -- Approval Tests for C++: also known as **Golden Master Tests** or **Snapshot Testing**, Approval Tests are an alternative to asserts.
- **arangodb** [ğŸ“](./arangodb) [ğŸŒ](https://github.com/GerHobbelt/arangodb) -- a scalable open-source multi-model database natively supporting graph, document and search. All supported data models & access patterns can be combined in queries allowing for maximal flexibility.
- **ArborX** [ğŸ“](./ArborX) [ğŸŒ](https://github.com/GerHobbelt/ArborX) -- a library designed to provide performance portable algorithms for geometric search, similarly to nanoflann and Boost Geometry.
- **archive-hocr-tools** [ğŸ“](./archive-hocr-tools) [ğŸŒ](https://github.com/GerHobbelt/archive-hocr-tools) -- a python package to ease hOCR parsing in a streaming manner.
- **argparse** [ğŸ“](./argparse) [ğŸŒ](https://github.com/GerHobbelt/argparse) -- simply include argparse.hpp and start parsing command-line arguments.
- **armadillo** [ğŸ“](./armadillo) [ğŸŒ](https://github.com/GerHobbelt/armadillo-code) -- C++ library for linear algebra & scientific computing
- **arrayfire** [ğŸ“](./arrayfire) [ğŸŒ](https://github.com/GerHobbelt/arrayfire) -- a general-purpose tensor library that simplifies the process of software development for the parallel architectures found in CPUs, GPUs, and other hardware acceleration devices. The library serves users in every technical computing market.
- **arrow** [ğŸ“](./arrow) [ğŸŒ](https://github.com/GerHobbelt/arrow) -- Apache Arrow is a development platform for in-memory analytics. It contains a set of technologies that enable big data systems to process and move data fast. The reference Arrow libraries contain many distinct software components:
  
  - Columnar vector and table-like containers (similar to data frames) supporting
    flat or nested types
  
  - Conversions to and from other in-memory data structures
  - Integration tests for verifying binary compatibility between the
    implementations (e.g. sending data from Java to C++)
  
  - IO interfaces to local and remote filesystems
  - Readers and writers for various widely-used file formats (such as Parquet, CSV)
  - Reference-counted off-heap buffer memory management, for zero-copy memory
    sharing and handling memory-mapped files
  
  - Self-describing binary wire formats (streaming and batch/file-like) for
    remote procedure calls (RPC) and interprocess communication (IPC)

- **asio** [ğŸ“](./asio) [ğŸŒ](https://github.com/GerHobbelt/asio) -- a cross-platform C++ library for network and low-level I/O programming that provides developers with a consistent asynchronous model using a modern C++ approach.
  
  Note: (older) Boost.Asio is also included in Boost.

- **asyncplusplus** [ğŸ“](./asyncplusplus) [ğŸŒ](https://github.com/GerHobbelt/asyncplusplus) -- Async++ is a lightweight concurrency framework for C++11.
- **asynqro** [ğŸ“](./asynqro) [ğŸŒ](https://github.com/GerHobbelt/asynqro) -- Futures and thread pool for C++: Asynqro gives developers a rich monadic Future API (inspired by Future API in Scala language), a clean API, refined task scheduling logic and is not tied to any framework.
- **AudioFile** [ğŸ“](./AudioFile) [ğŸŒ](https://github.com/GerHobbelt/AudioFile) -- a simple header-only C++ library for reading and writing audio files. (WAV, AIFF)
- **autodiff** [ğŸ“](./autodiff) [ğŸŒ](https://github.com/GerHobbelt/autodiff) -- a C++17 library that uses modern and advanced programming techniques to enable automatic computation of derivatives in an efficient, easy, and intuitive way.
- **avro** [ğŸ“](./avro) [ğŸŒ](https://github.com/GerHobbelt/avro) -- Apache Avroâ„¢ is a data serialization system.
- **awesome-c** [ğŸ“](./awesome-c) [ğŸŒ](https://github.com/GerHobbelt/awesome-c) -- a curated list of C good stuff.
- **Awesome-Document-Image-Rectification** [ğŸ“](./Awesome-Document-Image-Rectification) [ğŸŒ](https://github.com/GerHobbelt/Awesome-Document-Image-Rectification) -- a comprehensive list of awesome document image rectification methods based on deep learning.
- **Awesome-Image-Quality-Assessment** [ğŸ“](./Awesome-Image-Quality-Assessment) [ğŸŒ](https://github.com/GerHobbelt/Awesome-Image-Quality-Assessment) -- a comprehensive collection of IQA papers, datasets and codes. We also provide PyTorch implementations of mainstream metrics in [IQA-PyTorch](https://github.com/chaofengc/IQA-PyTorch)
- **b2xtranslator** [ğŸ“](./b2xtranslator) [ğŸŒ](https://github.com/GerHobbelt/b2xtranslator) -- .NET Core library to convert Microsoft Office binary files (doc, xls and ppt) to Open XML (docx, xlsx and pptx). You can use the Open XML SDK to mainpulate those.
- **backward-cpp** [ğŸ“](./backward-cpp) [ğŸŒ](https://github.com/GerHobbelt/backward-cpp) -- a beautiful stack trace pretty printer for C++. Backward supports pretty printed stack traces on GNU/Linux, macOS and Windows.
- **baobzi** [ğŸ“](./baobzi) [ğŸŒ](https://github.com/GerHobbelt/baobzi) -- an adaptive fast function approximator based on tree search. Word salad aside, `baobzi` is a tool to convert very CPU intensive function calculations into relatively cheap ones (at the cost of memory). This is similar to functions like `chebeval` in `MATLAB`, but can be significantly faster since the order of the polynomial fit can be much much lower to meet similar tolerances. It also isn't constrained for use only in `MATLAB`. Internally, `baobzi` represents your function by a grid of binary/quad/oct/N trees, where the leaves represent the function in some small sub-box of the function's domain with chebyshev polynomials. When you evaluate your function at a point with baobzi, it searches the tree for the box containing your point and evaluates using this approximant.
- **BaseMatrixOps** [ğŸ“](./BaseMatrixOps) [ğŸŒ](https://github.com/GerHobbelt/BaseMatrixOps) -- wrappers to C++ linear algebra libraries. No guarantees made about APIs or functionality.
- **basez** [ğŸ“](./basez) [ğŸŒ](https://github.com/GerHobbelt/basez) -- encode data into/decode data from base16, base32, base32hex, base64 or base64url stream per RFC 4648; MIME base64 Content-Transfer-Encoding per RFC 2045; or PEM Printable Encoding per RFC 1421.
- **BayerToRGB** [ğŸ“](./BayerToRGB) [ğŸŒ](https://github.com/GerHobbelt/BayerToRGB) -- a image processing demo project, which can do raw data interpolation and also scaling.
- **bbe** [ğŸ“](./bbe) [ğŸŒ](https://github.com/GerHobbelt/bbe) -- Binary block editor, i.e. kinda like `sed` for binary files
- **BBHash** [ğŸ“](./BBHash) [ğŸŒ](https://github.com/GerHobbelt/BBHash) -- Bloom-filter based minimal perfect hash function library.
  
  - **left-for-dead**; reason: has some GCC + Linux specific coding constructs; code isn't clean, which doesn't make my porting effort 'trustworthy'. Overall, if this is the alternative, we'll stick with `gperf`.

- **BCF-cuckoo-index** [ğŸ“](./BCF-cuckoo-index) [ğŸŒ](https://github.com/GerHobbelt/BCF) -- Better Choice Cuckoo Filter (BCF) is an efficient approximate set representation data structure. Different from the standard Cuckoo Filter (CF), BCF leverages the principle of the power of two choices to select the better candidate bucket during insertion. BCF reduces the average number of relocations of the state-of-the-art CF by 35%.
  
  - **left-for-dead**; reason: has some GCC + Linux specific coding constructs: intrinsics + Linux-only API calls, which increase the cost of porting.

- **bebop** [ğŸ“](./bebop) [ğŸŒ](https://github.com/GerHobbelt/bebop) -- an extremely simple, fast, efficient, cross-platform serialization format. Bebop is a schema-based binary serialization technology, similar to Protocol Buffers or MessagePack. In particular, Bebop tries to be a good fit for clientâ€“server or distributed web apps that need something faster, more concise, and more type-safe than JSON or MessagePack, while also avoiding some of the complexity of Protocol Buffers, FlatBuffers and the like.
- **BehaviorTree.CPP** [ğŸ“](./BehaviorTree.CPP) [ğŸŒ](https://github.com/GerHobbelt/BehaviorTree.CPP) -- this C++/17 library provides a framework to create BehaviorTrees. It was designed to be flexible, easy to use, reactive and fast. Even if our main use-case is __robotics__, you can use this library to build __AI for games__, or to replace Finite State Machines. BehaviorTree.CPP features asynchronous Actions, reactive behaviors, execute multiple Actions concurrently (orthogonality), XML-based DSL scripts which can be loaded at run-time, i.e. the morphology of the Trees is _not_ hard-coded.
- **better-enums** [ğŸ“](./better-enums) [ğŸŒ](https://github.com/GerHobbelt/better-enums) -- reflective compile-time enum library with clean syntax, in a single header file, and without dependencies. In C++11, *everything* can be used at compile time. You can convert your enums, loop over them, find their max, statically enforce conventions, and pass along the results as template arguments or to `constexpr` functions. All the reflection is available for your metaprogramming needs.
- **bhtsne--Barnes-Hut-t-SNE** [ğŸ“](./bhtsne--Barnes-Hut-t-SNE) [ğŸŒ](https://github.com/GerHobbelt/bhtsne) -- Barnes-Hut t-SNE
- **bibtex-robust-decoder** [ğŸ“](./bibtex-robust-decoder) [ğŸŒ](https://github.com/GerHobbelt/bibtex-robust-decoder) -- BibTeX parser which is robust: it will cope well with various BibTeX input errors which may be caused by manual entry of a BibTeX record.
- **bibtool** [ğŸ“](./bibtool) [ğŸŒ](https://github.com/GerHobbelt/bibtool) -- a tool for manipulating BibTeX data bases. BibTeX provides a mean to integrate citations into LaTeX documents. BibTool allows the manipulation of BibTeX files which goes beyond the possibilities -- and intentions -- of BibTeX.
- **bibutils** [ğŸ“](./bibutils) [ğŸŒ](https://github.com/GerHobbelt/bibutils) -- the `bibutils` set interconverts between various bibliography formats using a common MODS-format XML intermediate. For example, one can convert RIS-format files to Bibtex by doing two transformations: RIS->MODS->Bibtex. By using a common intermediate for N formats, only 2N programs are required and not NÂ²-N.
- **bin2cpp** [ğŸ“](./bin2cpp) [ğŸŒ](https://github.com/GerHobbelt/bin2cpp) -- a command line tool for embedding small files (like images, icons or raw data files) into a C++ executable.
- **binary2strings** [ğŸ“](./binary2strings) [ğŸŒ](https://github.com/GerHobbelt/binary2strings) -- a module to extract strings from binary blobs. Extracts ASCII, UTF8, and UCS-2 wide strings from binary data. Supports Unicode characters. This is designed to extract strings from binary content such as compiled executables.
- **binary_bakery** [ğŸ“](./binary_bakery) [ğŸŒ](https://github.com/GerHobbelt/binary_bakery) -- Binary bakery translates binary files (images, fonts etc.) into **C++ source code** and gives access to that data at compile- or runtime.
- **binary_search** [ğŸ“](./binary_search) [ğŸŒ](https://github.com/GerHobbelt/binary_search) -- includes both the most commonly used binary search variant, as first published by Hermann Bottenbruch in 1962, plus several novel variants with improved performance. The most notable variant, the monobound binary search, executes two to four times faster than the standard binary search on arrays smaller than 1 million 32 bit integers: Boundless Binary Search, Doubletapped Binary Search, Monobound Binary Search, Tripletapped Binary Search, Quaternary Binary Search, Monobound Interpolated Binary Search, Adaptive Binary Search.
- **binlog** [ğŸ“](./binlog) [ğŸŒ](https://github.com/GerHobbelt/binlog) -- a high performance C++ log library to produce structured binary logs.
- **Bi-Sent2Vec** [ğŸ“](./Bi-Sent2Vec) [ğŸŒ](https://github.com/GerHobbelt/Bi-Sent2Vec) -- provides cross-lingual numerical representations (features) for words, short texts, or sentences, which can be used as input to any machine learning task with applications geared towards cross-lingual word translation, cross-lingual sentence retrieval as well as cross-lingual downstream NLP tasks. The library is a cross-lingual extension of [Sent2Vec](https://github.com/epfml/sent2vec). Bi-Sent2Vec vectors are also well suited to monolingual tasks as indicated by a marked improvement in the monolingual quality of the word embeddings. (For more details, see [paper](https://arxiv.org/abs/1912.12481))
- **BitFunnel** [ğŸ“](./BitFunnel) [ğŸŒ](https://github.com/GerHobbelt/BitFunnel) -- the BitFunnel search index is used by [Bing's](http://www.bing.com) super-fresh, news, and media indexes. The algorithm is described in [BitFunnel: Revisiting Signatures for
- **bitrush-index** [ğŸ“](./bitrush-index) [ğŸŒ](https://github.com/GerHobbelt/bitrush-index) -- provides a serializable bitmap index able to index millions values/sec on a single thread. By default this library uses [ozbcbitmap] but if you want you can also use another compressed/uncrompressed bitmap. Only equality-queries (A = X) are supported.
- **bitsery** [ğŸ“](./bitsery) [ğŸŒ](https://github.com/GerHobbelt/bitsery) -- header only C++ binary serialization library, designed around the networking requirements for real-time data delivery, especially for games. All cross-platform requirements are enforced at compile time, so serialized data do not store any meta-data information and is as small as possible.
- **BLAKE3** [ğŸ“](./BLAKE3) [ğŸŒ](https://github.com/GerHobbelt/BLAKE3) -- cryptographic hash
- **blaze** [ğŸ“](./blaze) [ğŸŒ](https://github.com/GerHobbelt/blaze) -- a high-performance C++ math library for dense and sparse arithmetic. With its state-of-the-art *Smart Expression Template* implementation **Blaze** combines the elegance and ease of use of a domain-specific language with HPC-grade performance, making it one of the most intuitive and fastest C++ math libraries available.
- **blazingmq** [ğŸ“](./blazingmq) [ğŸŒ](https://github.com/GerHobbelt/blazingmq) -- BlazingMQ is a modern, High-Performance Message Queue, which focuses on efficiency, reliability, and a rich feature set for modern-day workflows. At its core, BlazingMQ provides durable, fault-tolerant, highly performant, and highly available queues, along with features like various message routing strategies (e.g., work queues, priority, fan-out, broadcast, etc.), compression, strong consistency, poison pill detection, etc.  Message queues generally provide a loosely-coupled, asynchronous communication channel ("queue") between application services (producers and consumers) that send messages to one another. You can think about it like a mailbox for communication between application programs, where 'producer' drops a message in a mailbox and 'consumer' picks it up at its own leisure. Messages placed into the queue are stored until the recipient retrieves and processes them. In other words, producer and consumer applications can temporally and spatially isolate themselves from each other by using a message queue to facilitate communication.
- **BlingFire** [ğŸ“](./BlingFire) [ğŸŒ](https://github.com/GerHobbelt/BlingFire) -- we are a team at Microsoft called Bling (Beyond Language Understanding), sharing our [FInite State machine and REgular expression manipulation library](https://github.com/microsoft/BlingFire) (FIRE). We use Fire for many linguistic operations inside Bing such as Tokenization, Multi-word expression matching, Unknown word-guessing, Stemming / Lemmatization just to mention a few.
  
  Fire can also be used to improve FastText: see [here](https://github.com/microsoft/BlingFire#8-example-of-reaching-99-accuracy-for-language-detection).
  
  Bling Fire Tokenizer provides state of the art performance for Natural Language text tokenization.

- **blis** [ğŸ“](./blis) [ğŸŒ](https://github.com/GerHobbelt/blis) -- BLIS is an award-winning portable software framework for instantiating high-performance BLAS-like dense linear algebra libraries. The framework was designed to isolate essential kernels of computation that, when optimized, immediately enable optimized implementations of most of its commonly used and computationally intensive operations. BLIS is written in [ISO C99](http://en.wikipedia.org/wiki/C99) and available under a [new/modified/3-clause BSD license](http://opensource.org/licenses/BSD-3-Clause). While BLIS exports a [new BLAS-like API](docs/BLISTypedAPI.md), it also includes a BLAS compatibility layer which gives application developers access to BLIS implementations via traditional [BLAS routine calls](http://www.netlib.org/lapack/lug/node145.html). An [object-based API](docs/BLISObjectAPI.md) unique to BLIS is also available.
- **blitsort** [ğŸ“](./blitsort) [ğŸŒ](https://github.com/GerHobbelt/blitsort) -- Blitsort is an in-place rotate quick/merge sort based on the stable out-of-place merge sort [quadsort](https://github.com/scandum/quadsort), stable out-of-place quicksort [fluxsort](https://github.com/scandum/fluxsort), and unstable in-place [crumsort](https://github.com/scandum/crumsort).
- **bloom** [ğŸ“](./bloom) [ğŸŒ](https://github.com/GerHobbelt/bloom) -- C++ Bloom Filter Library, which offers optimal parameter selection based on expected false positive rate, union, intersection and difference operations between bloom filters and compression of in-use table (increase of false positive probability vs space).
- **bolt** [ğŸ“](./bolt) [ğŸŒ](https://github.com/GerHobbelt/bolt) -- a deep learning library with high performance and heterogeneous flexibility.
- **boost** [ğŸ“](./boost) [ğŸŒ](https://github.com/GerHobbelt/boost) -- required by several other libraries in this collection
- **boost-url** [ğŸ“](./boost-url) [ğŸŒ](https://github.com/GerHobbelt/boost-url) -- a library for manipulating (RFC3986) Uniform Resource Identifiers (URIs) and Locators (URLs).
- **boringssl** [ğŸ“](./boringssl) [ğŸŒ](https://github.com/GerHobbelt/boringssl) -- BoringSSL is a fork of OpenSSL that is designed to meet Google's needs.
- **BoxFort** [ğŸ“](./BoxFort) [ğŸŒ](https://github.com/GerHobbelt/BoxFort) -- a simple, cross-platform sandboxing C library powering [Criterion](https://github.com/Snaipe/Criterion). BoxFort provides a simple API to run user code in isolated processes. The main goal of this project **is not** security, but portable code isolation -- if you want complete system isolation, consider using properly configured containers.
- **bplustree** [ğŸ“](./bplustree) [ğŸŒ](https://github.com/GerHobbelt/bplustree) -- a minimal B+Tree implementation for millions (even billions) of key-value storage based on POSIX.
- **breakpad** [ğŸ“](./breakpad) [ğŸŒ](https://github.com/GerHobbelt/breakpad) -- a set of client and server components which implement a crash-reporting system.
  
  - **left-for-dead**; reason: nice idea, but slightly too GCC specific. has some GCC + Linux specific coding constructs: intrinsics + Linux-only API calls, which increase the cost of porting.

- **brotli** [ğŸ“](./brotli) [ğŸŒ](https://github.com/GerHobbelt/brotli) -- compression
- **brown-cluster** [ğŸ“](./brown-cluster) [ğŸŒ](https://github.com/GerHobbelt/brown-cluster) -- the Brown hierarchical word clustering algorithm. Runs in $O(N C^2)$, where $N$ is the number of word types and $C$ is the number of clusters. Algorithm by Brown, et al.: Class-Based n-gram Models of Natural Language, http://acl.ldc.upenn.edu/J/J92/J92-4003.pdf
- **brunsli** [ğŸ“](./brunsli) [ğŸŒ](https://github.com/GerHobbelt/brunsli) -- a lossless JPEG repacking library. Brunsli allows for a 22% decrease in file size while allowing the original JPEG to be recovered byte-by-byte.
- **bustache** [ğŸ“](./bustache) [ğŸŒ](https://github.com/GerHobbelt/bustache) -- C++20 implementation of [{{ mustache }}](http://mustache.github.io/), compliant with [spec](https://github.com/mustache/spec) v1.1.3.
- **butteraugli** [ğŸ“](./butteraugli) [ğŸŒ](https://github.com/GerHobbelt/butteraugli) -- a tool for measuring perceived differences between images. Butteraugli is a project that estimates the psychovisual similarity of two images. It gives a score for the images that is reliable in the domain of barely noticeable differences. Butteraugli not only gives a scalar score, but also computes a spatial map of the level of differences. One of the main motivations for this project is the statistical differences in location and density of different color receptors, particularly the low density of blue cones in the fovea. Another motivation comes from more accurate modeling of ganglion cells, particularly the frequency space inhibition.
- **CacheLib** [ğŸ“](./CacheLib) [ğŸŒ](https://github.com/GerHobbelt/CacheLib) -- provides an in-process high performance caching mechanism, thread-safe API to build high throughput, low overhead caching services, with built-in ability to leverage DRAM and SSD caching transparently.
- **cachelot** [ğŸ“](./cachelot) [ğŸŒ](https://github.com/GerHobbelt/cachelot) -- is an LRU cache that works at the speed of light. The library works with a fixed pre-allocated memory. You tell the memory size and LRU cache is ready. Small metadata, up to 98% memory utilization.
- **caches** [ğŸ“](./caches) [ğŸŒ](https://github.com/GerHobbelt/caches) -- implements a simple thread-safe cache with several page replacement policies: LRU (Least Recently Used), FIFO (First-In/First-Out), LFU (Least Frequently Used)
- **caffe** [ğŸ“](./caffe) [ğŸŒ](https://github.com/GerHobbelt/caffe) -- a fast deep learning framework made with expression and modularity in mind, developed by Berkeley AI Research (BAIR)/The Berkeley Vision and Learning Center (BVLC).
  
  - **ho-hum**; reason: uses google protobuffers, CUDA SDK for the GPU access (at least that's how it looks from the header files reported missing by my compiler). Needs more effort before this can be used in the monolithic production builds.

- **cairo** [ğŸ“](./cairo) [ğŸŒ](https://github.com/GerHobbelt/cairo) -- Cairo: Multi-platform 2D graphics library with support for multiple output devices. Cairo is designed to produce consistent output on all output media while taking advantage of display hardware acceleration when available. Currently supported output targets include the X Window System (via both Xlib and XCB), quartz, win32, and image buffers, as well as PDF, PostScript, and SVG file output. Experimental backends include OpenGL. Cairo is designed to produce consistent output on all output media while taking advantage of display hardware acceleration when available (for example, through the X Render Extension).
- **cairo-demos** [ğŸ“](./cairo-demos) [ğŸŒ](https://github.com/GerHobbelt/cairo-demos) -- several simple programs intended to demonstrate some of the features of the Cairo graphics library (http://cairographics.org).
- **calibre** [ğŸ“](./calibre) [ğŸŒ](https://github.com/GerHobbelt/calibre) -- an e-book manager. It can view, convert, edit and catalog e-books in all of the major e-book formats. It can also talk to e-book reader devices. It can go out to the internet and fetch metadata for your books. It can download newspapers and convert them into e-books for convenient reading. It is cross platform, running on Linux, Windows and macOS.
- **capnproto** [ğŸ“](./capnproto) [ğŸŒ](https://github.com/GerHobbelt/capnproto) -- Cap'n Proto is an insanely fast data interchange format and capability-based RPC system. Think JSON, except binary. Or think [Protocol Buffers](https://github.com/google/protobuf), except faster.
- **Capture2Text** [ğŸ“](./Capture2Text) [ğŸŒ](https://github.com/GerHobbelt/Capture2Text) -- Linux CLI port of Capture2Text v4.5.1 (Ubuntu) - the OCR results from Capture2Text were generally better than standard Tesseract, so it seemed ideal to make this run on Linux.
- **capture-thread** [ğŸ“](./capture-thread) [ğŸŒ](https://github.com/GerHobbelt/capture-thread) -- framework for loggers, tracers, and mockers in multithreaded C++ programs. When developing C++ projects, [instrumentation][instrumentation] is frequently used to collect information from the system, inject information into the system, or both. The role of this information within the system rarely lines up with the actual structure of the project. This library is designed to handle all of these situations with minimal intrusion into your project, and without leaking details in your API. The **Capture Thread Library** is designed around the concept of thread-locality, which allows the sharing of static variables *only within the current thread*. Canonical static variables, on the other hand, are problematic due to ownership and thread-safety issues.
- **catboost** [ğŸ“](./catboost) [ğŸŒ](https://github.com/GerHobbelt/catboost) -- a fast, scalable, high performance Gradient Boosting on Decision Trees library, used for ranking, classification, regression and other machine learning tasks. Supports computation on CPU and GPU.
- **c-blosc2** [ğŸ“](./c-blosc2) [ğŸŒ](https://github.com/GerHobbelt/c-blosc2) -- a high performance compressor optimized for binary data (i.e. floating point numbers, integers and booleans), designed to transmit data to the processor cache faster than the traditional, non-compressed, direct memory fetch approach via a `memcpy()` OS call.
- **cctz** [ğŸ“](./cctz) [ğŸŒ](https://github.com/GerHobbelt/cctz) -- CCTZ contains two libraries that cooperate with `<chrono>` to give C++ programmers all the necessary tools for computing with dates, times, and time zones in a simple and correct manner.
- **ccv-nnc** [ğŸ“](./ccv-nnc) [ğŸŒ](https://github.com/GerHobbelt/ccv) -- C-based/Cached/Core Computer Vision Library. A Modern Computer Vision Library.
- **cdc-file-transfer** [ğŸ“](./cdc-file-transfer) [ğŸŒ](https://github.com/GerHobbelt/cdc-file-transfer) -- CDC File Transfer contains tools for syncing and streaming files from Windows to Windows or Linux. The tools are based on Content Defined Chunking (CDC), in particular [FastCDC](https://www.usenix.org/conference/atc16/technical-sessions/presentation/xia), to split up files into chunks.
- **cef-pdf** [ğŸ“](./cef-pdf) [ğŸŒ](https://github.com/GerHobbelt/cef-pdf) -- a command line utility (with embedded HTTP server as an optional mode) for creating PDF documents from HTML content. It uses Google Chrome browser's [Chromium Embedded Framework (CEF)](https://bitbucket.org/chromiumembedded/cef/overview) library for all it's internal work; loading urls, rendering HTML & CSS pages and PDF printing, therefore, it produces perfect, accurate, excellent quality PDF documents.
- **cel-cpp** [ğŸ“](./cel-cpp) [ğŸŒ](https://github.com/GerHobbelt/cel-cpp) -- C++ Implementations of the Common Expression Language. For background on the Common Expression Language see the cel-spec repo. Common Expression Language specification: the Common Expression Language (CEL) implements common semantics for expression evaluation, enabling different applications to more easily interoperate. Key Applications are (1) Security policy: organizations have complex infrastructure and need common tooling to reason about the system as a whole and (2) Protocols: expressions are a useful data type and require interoperability across programming languages and platforms.
- **cel-spec** [ğŸ“](./cel-spec) [ğŸŒ](https://github.com/GerHobbelt/cel-spec) -- Common Expression Language specification: the Common Expression Language (CEL) implements common semantics for expression evaluation, enabling different applications to more easily interoperate. Key Applications are (1) Security policy: organizations have complex infrastructure and need common tooling to reason about the system as a whole and (2) Protocols: expressions are a useful data type and require interoperability across programming languages and platforms.
- **cereal** [ğŸ“](./cereal) [ğŸŒ](https://github.com/GerHobbelt/cereal) -- C++11 serialization library
- **ceres-solver** [ğŸ“](./ceres-solver) [ğŸŒ](https://github.com/GerHobbelt/ceres-solver) -- a library for modeling and solving large, complicated optimization problems. It is a feature rich, mature and performant library which has been used in production at Google since 2010. Ceres Solver can solve two kinds of problems: (1) Non-linear Least Squares problems with bounds constraints, and (2) General unconstrained optimization problems.
- **cfgpath** [ğŸ“](./cfgpath) [ğŸŒ](https://github.com/GerHobbelt/cfgpath) -- cross platform methods for obtaining paths to configuration files
- **chewing_text_cud** [ğŸ“](./chewing_text_cud) [ğŸŒ](https://github.com/GerHobbelt/chewing_text_cud) -- a text processing / filtering library for use in NLP/search/content analysis research pipelines.
- **chibi-scheme** [ğŸ“](./chibi-scheme) [ğŸŒ](https://github.com/GerHobbelt/chibi-scheme) -- Chibi-Scheme is a very small library intended for use as an extension and scripting language in C programs.  In addition to support for lightweight VM-based threads, each VM itself runs in an isolated heap allowing multiple VMs to run simultaneously in different OS threads.
- **CHM-lib** [ğŸ“](./CHM-lib) [ğŸŒ](https://github.com/GerHobbelt/CHMLib) -- as I have several HTML pages stored in this format. See also MHTML: `mht-rip`
- **chromium-snss-parse** [ğŸ“](./chromium-snss-parse) [ğŸŒ](https://github.com/GerHobbelt/chromium-snss-parse) -- Chromium SNSS parse library parses Chromium's SNSS files, e.g. Current Session, Current Tabs, Last Session, Last Tabs and other files.
- **cilantro** [ğŸ“](./cilantro) [ğŸŒ](https://github.com/GerHobbelt/cilantro) -- a lean and fast C++ library for 2D/3D point cloud data processing, with emphasis given to the 3D case. It includes efficient implementations for a variety of common operations, providing a clean API and attempting to minimize the amount of boilerplate code. The library is extensively templated, enabling operations on data of arbitrary numerical type and dimensionality (where applicable) and featuring a modular/extensible design of the more complex procedures. At the same time, convenience aliases/wrappers for the most common cases are provided.
- **CImg** [ğŸ“](./CImg) [ğŸŒ](https://github.com/GerHobbelt/CImg) -- a **small** C++ toolkit for **image processing**.
- **citation-abbreviations** [ğŸ“](./citation-abbreviations) [ğŸŒ](https://github.com/GerHobbelt/abbreviations) -- Journal Title Abbreviations
- **citation-journals** [ğŸ“](./citation-journals) [ğŸŒ](https://github.com/GerHobbelt/journals) -- Tools and journal metadata for generating dependent CSL styles.
- **citation-styles** [ğŸ“](./citation-styles) [ğŸŒ](https://github.com/GerHobbelt/styles) -- the Citation Style Language (CSL) citation styles.
- **citeproc-js** [ğŸ“](./citeproc-js) [ğŸŒ](https://github.com/GerHobbelt/citeproc-js) -- a JavaScript implementation of the Citation Style Language (CSL) https://citeproc-js.readthedocs.io
- **civetweb** [ğŸ“](./civetweb) [ğŸŒ](https://github.com/GerHobbelt/civetweb) -- an easy to use, powerful, C (C/C++) embeddable web server with optional CGI, SSL and Lua support.
- **cjose** [ğŸ“](./cjose) [ğŸŒ](https://github.com/GerHobbelt/cjose) -- JOSE for C/C++
- **clBLAS** [ğŸ“](./clBLAS) [ğŸŒ](https://github.com/GerHobbelt/clBLAS) -- the OpenCLâ„¢ BLAS portion of OpenCL's `clMath`. The complete set of BLAS level 1, 2 & 3 routines is implemented. In addition to GPU devices, the library also supports running on CPU devices to facilitate debugging and multicore programming. The primary goal of `clBLAS` is to make it easier for developers to utilize the inherent performance and power efficiency benefits of heterogeneous computing. `clBLAS` interfaces do not hide nor wrap OpenCL interfaces, but rather leaves OpenCL state management to the control of the user to allow for maximum performance and flexibility. The clBLAS library does generate and enqueue optimized OpenCL kernels, relieving the user from the task of writing, optimizing and maintaining kernel code themselves.
- **CLBlast** [ğŸ“](./CLBlast) [ğŸŒ](https://github.com/GerHobbelt/CLBlast) -- the tuned OpenCL BLAS library. CLBlast is a modern, lightweight, performant and tunable OpenCL BLAS library written in C++11. It is designed to leverage the full performance potential of a wide variety of OpenCL devices from different vendors, including desktop and laptop GPUs, embedded GPUs, and other accelerators. CLBlast implements BLAS routines: basic linear algebra subprograms operating on vectors and matrices.
- **CLBlast-database** [ğŸ“](./CLBlast-database) [ğŸŒ](https://github.com/GerHobbelt/CLBlast-database) -- the full database of tuning results for the [CLBlast OpenCL BLAS library](https://github.com/CNugteren/CLBlast). Tuning results are obtained using CLBlast and the [CLTune auto-tuner](https://github.com/CNugteren/CLTune).
- **cld1-language-detect** [ğŸ“](./cld1-language-detect) [ğŸŒ](https://github.com/GerHobbelt/cld) -- the CLD (Compact Language Detection) library, extracted from the source code for Google's Chromium library. CLD1 probabilistically detects languages in Unicode UTF-8 text.
- **cld2-language-detect** [ğŸ“](./cld2-language-detect) [ğŸŒ](https://github.com/GerHobbelt/cld2) -- CLD2 probabilistically detects over 80 languages in Unicode UTF-8 text, either plain text or HTML/XML. For mixed-language input, CLD2 returns the top three languages found and their approximate percentages of the total text bytes.  Optionally, it also returns a vector of text spans with the language of each identified. The design target is web pages of at least 200 characters (about two sentences); CLD2 is not designed to do well on very short text.
- **cld3-language-detect** [ğŸ“](./cld3-language-detect) [ğŸŒ](https://github.com/GerHobbelt/cld3) -- CLD3 is a neural network model for language identification. The inference code extracts character ngrams from the input text and computes the fraction of times each of them appears. The model outputs BCP-47-style language codes, shown in the table below. For some languages, output is differentiated by script. Language and script names from Unicode CLDR.
- **cli11** [ğŸ“](./cli11) [ğŸŒ](https://github.com/GerHobbelt/CLI11) -- command line options parser
- **clipp** [ğŸ“](./clipp) [ğŸŒ](https://github.com/GerHobbelt/clipp) -- commandline parser
  
  - **left-for-dead**; reason: looks really nice, but MSVC coughs up some pretty-hard-to-diagnose compiler errors and warnings. The writer of this library is clearly better versed in writing C++ templating code than *me*, alas. Initial attempts to fix the issues left me in the dirt, humiliated, and reading up on the latest C++ *goodnesses* did not improve my success rate, alas.

- **Clipper2** [ğŸ“](./Clipper2) [ğŸŒ](https://github.com/GerHobbelt/Clipper2) -- a Polygon <a href="https://en.wikipedia.org/wiki/Clipping_(computer_graphics)">Clipping</a> and <a href="https://en.wikipedia.org/wiki/Parallel_curve">Offsetting</a> library.
- **clp** [ğŸ“](./clp) [ğŸŒ](https://github.com/GerHobbelt/clp) -- YScope's Compressed Log Processor (CLP) compresses your logs, and allows you to search the compressed logs without decompression. CLP supports both JSON logs and unstructured (i.e., free text) logs. It also supports real-time log compression within several logging libraries. CLP also includes purpose-built web interfaces for searching and viewing the compressed logs.
- **CLTune** [ğŸ“](./CLTune) [ğŸŒ](https://github.com/GerHobbelt/CLTune) -- automatic OpenCL kernel tuning for CLBlast: CLTune is a C++ library which can be used to automatically tune your OpenCL and CUDA kernels. The only thing you'll need to provide is a tuneable kernel and a list of allowed parameters and values.
- **Cmathtuts** [ğŸ“](./Cmathtuts) [ğŸŒ](https://github.com/GerHobbelt/Cmathtuts) -- a collection of linear algebra math tutorials in C for BLAS, LAPACK and other fundamental APIs. These include samples for BLAS, LAPACK, CLAPACK, LAPACKE, ATLAS, OpenBLAS ...
- **cmph-hasher** [ğŸ“](./cmph-hasher) [ğŸŒ](https://github.com/GerHobbelt/cmph) -- C Minimal Perfect Hashing Library for both small and (very) large hash sets.
- **CNTK** [ğŸ“](./CNTK) [ğŸŒ](https://github.com/GerHobbelt/CNTK) -- the Microsoft Cognitive Toolkit (https://cntk.ai) is a unified deep learning toolkit that describes neural networks as a series of computational steps via a directed graph. In this directed graph, leaf nodes represent input values or network parameters, while other nodes represent matrix operations upon their inputs. CNTK allows users to easily realize and combine popular model types such as feed-forward DNNs, convolutional nets (CNNs), and recurrent networks (RNNs/LSTMs). It implements stochastic gradient descent (SGD, error backpropagation) learning with automatic differentiation and parallelization across multiple GPUs and servers. CNTK has been available under an open-source license since April 2015. It is our hope that the community will take advantage of CNTK to share ideas more quickly through the exchange of open source working code.
- **colm** [ğŸ“](./colm) [ğŸŒ](https://github.com/GerHobbelt/colm) -- Colm (COmputer Language Machinery) is a programming language designed for the analysis and [transformation of computer languages](https://www.program-transformation.org/Transform/TransformationSystems). Colm is influenced primarily by [TXL](https://www.txl.ca/). Colm is not-your-typical-scripting-languageâ„¢: Colm's main contribution lies in the parsing method. Colm's parsing engine is generalized, but it also allows for the construction of arbitrary global data structures that can be queried during parsing. In other generalized methods, construction of global data requires some very careful consideration because of inherent concurrency in the parsing method. It is such a tricky task that it is often avoided altogether and the problem is deferred to a post-parse disambiguation of the parse forest.
- **colorm** [ğŸ“](./colorm) [ğŸŒ](https://github.com/GerHobbelt/colorm) -- ColorM is a C++11 header-only color conversion and manipulation library for [CSS colors](https://www.w3.org/TR/css-color-4/) with an API similar to [chroma.js](https://github.com/gka/chroma.js/)'s API.
- **ColorMagic** [ğŸ“](./ColorMagic) [ğŸŒ](https://github.com/GerHobbelt/ColorMagic) -- a C++ Library that allows manipulation and conversion of colors. Supports these Color Spaces: RGB/A, Grey/A, CMYK, HSV, HSL, XYZ, XYY, CieLUV, Lab. Supports adding, mixing, averaging and subtracting colors (optionally with weights), calculating color distances (Euclidean, CMC, CIELAB76, CIELAB94, CIELAB2000), creating color sets (Complementary, Triplet, Quartet, Quintet, Analogous, Complementary Split, Custom) & adjusting colors (Saturate, Desaturate, Lighten, Unlighten).
- **colormap-shaders** [ğŸ“](./colormap-shaders) [ğŸŒ](https://github.com/GerHobbelt/colormap-shaders) -- a collection of shaders to draw color maps.
- **ColorPaletteCodable** [ğŸ“](./ColorPaletteCodable) [ğŸŒ](https://github.com/GerHobbelt/ColorPaletteCodable) -- a color palette reader/editor/writer package for iOS, macOS, macCatalyst, tvOS, watchOS and Linux. Supports many palette formats, including Adobe Swatch Exchange (`.ase`), Adobe Photoshop Color Swatch (`.aco`), Adobe Color Table (`.act`) and Microsoft RIFF palette files (`.pal`)
- **ColorSpace** [ğŸ“](./ColorSpace) [ğŸŒ](https://github.com/GerHobbelt/ColorSpace) -- library for converting between color spaces and comparing colors.
- **color-util** [ğŸ“](./color-util) [ğŸŒ](https://github.com/GerHobbelt/color-util) -- a header-only C++11 library for handling colors, including color space converters between RGB, XYZ, Lab, etc. and color difference calculators such as CIEDE2000.
- **comdb2-bdb** [ğŸ“](./comdb2-bdb) [ğŸŒ](https://github.com/GerHobbelt/comdb2) -- a clustered RDBMS built on Optimistic Concurrency Control techniques. It provides multiple isolation levels, including Snapshot and Serializable Isolation.
- **compact_enc_det** [ğŸ“](./compact_enc_det) [ğŸŒ](https://github.com/GerHobbelt/compact_enc_det) -- Compact Encoding Detection (CED for short) is a library written in C++ that scans given raw bytes and detect the most likely text encoding.
- **completesearch** [ğŸ“](./completesearch) [ğŸŒ](https://github.com/GerHobbelt/completesearch) -- a fast and interactive search engine for *context-sensitive prefix search* on a given collection of documents. It does not only provide search results, like a regular search engine, but also completions for the last (maybe only partially typed) query word that lead to a hit.
- **concat** [ğŸ“](./concat) [ğŸŒ](https://github.com/GerHobbelt/concat) -- because string concatenation deserves one-liners in C++11 too. **concat** concatenates strings using optional separators, but also works with containers, tuples, other scalar types (including `nullptr`) and any mixes thereof. You can print/concatenate **arrays**, **containers**, **tuples**, **pairs** or other **stringstreams** in a uniform and concise manner.
- **concurrencpp** [ğŸ“](./concurrencpp) [ğŸŒ](https://github.com/GerHobbelt/concurrencpp) -- the C++ concurrency library: concurrencpp is a tasking library for C++ allowing developers to write highly concurrent applications easily and safely by using tasks, executors and coroutines.
- **concurrentqueue** [ğŸ“](./concurrentqueue) [ğŸŒ](https://github.com/GerHobbelt/concurrentqueue) -- moodycamel::ConcurrentQueue, an industrial-strength and fast multi-producer, multi-consumer lock-free concurrent queue for C++11.
- **config-cpp** [ğŸ“](./config-cpp) [ğŸŒ](https://github.com/GerHobbelt/config-cpp) -- a C++ Configuration library patterned after [`viper`](https://github.com/spf13/viper) package for golang.  It is designed to work within an application and handle configuration needs.
- **continuable** [ğŸ“](./continuable) [ğŸŒ](https://github.com/GerHobbelt/continuable) -- a C++14 library that provides full support for:
  
  * lazy async continuation chaining based on callbacks (**then**) and expression templates, callbacks are wrapped nicely as **promises**.
  * **no enforced type-erasure** which means we need **less heap allocations** than comparable libraries, strictly following the **"don't pay for what you don't use"** principle.
  * support for *all*, *any* and *sequential* connections between continuables through expressive operator overloads **&&**, **||** and **>>** as well as free functions **when_all**, **when_any** and **when_seq**.
  * asynchronous **error handling** through **exceptions**, **error codes** and **user defined types**.
  * syntactic sugar for instance: **partial invocation**, **tuple unpacking**, `co_await` support and **executors**.
  * **encapsuled from any runtime**, larger framework or executors makes it possible to use continuable even in smaller or esoteric usage scenarios.

- **coost** [ğŸ“](./coost) [ğŸŒ](https://github.com/GerHobbelt/coost) -- A tiny boost library in C++11. `coost` (formerly known as `cocoyaxi`) is an elegant and efficient cross-platform C++ base library, it is not as heavy as `boost`, but still provides enough powerful features.
- **cpp-btree** [ğŸ“](./cpp-btree) [ğŸŒ](https://github.com/GerHobbelt/cpp-btree) -- in-memory B+-tree: an alternative for the priority queue as we expect the queue to grow huge, given past experience with Qiqqa.
- **cppdap** [ğŸ“](./cppdap) [ğŸŒ](https://github.com/GerHobbelt/cppdap) -- a C++11 library (["SDK"](https://microsoft.github.io/debug-adapter-protocol/implementors/sdks/)) implementation of the [Debug Adapter Protocol](https://microsoft.github.io/debug-adapter-protocol/), providing an API for implementing a DAP client or server. `cppdap` provides C++ type-safe structures for the full [DAP specification](https://microsoft.github.io/debug-adapter-protocol/specification), and provides a simple way to add custom protocol messages.
- **cppflow** [ğŸ“](./cppflow) [ğŸŒ](https://github.com/GerHobbelt/cppflow) -- run TensorFlow models in c++ without Bazel, without TensorFlow installation and without compiling Tensorflow.
- **cpp-httplib** [ğŸ“](./cpp-httplib) [ğŸŒ](https://github.com/GerHobbelt/cpp-httplib) -- an extremely easy to setup C++11 cross platform HTTP/HTTPS library. 
  
  **NOTE**: This library uses 'blocking' socket I/O. If you are looking for a library with 'non-blocking' socket I/O, this is not the one that you want.

- **cpp-ipc** [ğŸ“](./cpp-ipc) [ğŸŒ](https://github.com/GerHobbelt/cpp-ipc) -- a high-performance inter-process communication using shared memory on Linux/Windows.
- **cppjieba** [ğŸ“](./cppjieba) [ğŸŒ](https://github.com/GerHobbelt/cppjieba) -- the C++ version of the Chinese "Jieba" project:
  
  - Supports loading a custom user dictionary, using the '|' separator when multipathing or the ';' separator for separate, multiple, dictionaries.
  - Supports 'utf8' encoding.
  - The project comes with a relatively complete unit test, and the stability of the core function Chinese word segmentation (utf8) has been tested by the online environment.

- **cpplocate** [ğŸ“](./cpplocate) [ğŸŒ](https://github.com/GerHobbelt/cpplocate) -- a cross-platform C++ library that provides tools for applications to locate their binary files and data assets, as well as those of dependent modules.
- **cpp-netlib** [ğŸ“](./cpp-netlib) [ğŸŒ](https://github.com/GerHobbelt/cpp-netlib) -- modern C++ network programming library: `cpp-netlib` is a collection of network-related routines/implementations geared towards providing a robust cross-platform networking library.
- **CppNumericalSolvers** [ğŸ“](./CppNumericalSolvers) [ğŸŒ](https://github.com/GerHobbelt/CppNumericalSolvers) -- a header-only C++17 BFGS / L-BFGS-B optimization library.
- **cpp_rest_sdk** [ğŸ“](./cpp_rest_sdk) [ğŸŒ](https://github.com/GerHobbelt/cpprestsdk) -- the C++ REST SDK is a Microsoft project for cloud-based client-server communication in native code using a modern asynchronous C++ API design. This project aims to help C++ developers connect to and interact with services.
- **cppsimhash** [ğŸ“](./cppsimhash) [ğŸŒ](https://github.com/GerHobbelt/cppsimhash) -- C++ simhash implementation for documents and an additional (prototype) simhash index for text documents. Simhash is a hashing technique that belongs to the LSH (Local Sensitive Hashing) algorithmic family. It was initially developed by Moses S. Charikar in 2002 and is described in detail in his [paper](http://www.cs.princeton.edu/courses/archive/spring04/cos598B/bib/CharikarEstim.pdf).
- **cpp-terminal** [ğŸ“](./cpp-terminal) [ğŸŒ](https://github.com/GerHobbelt/cpp-terminal) -- CPP-Terminal is a small C++ library for writing platform independent terminal-based applications. It follows the "Zero-overhead principle" and limits externally included files to the C++ STL. Being crossplatform we support Windows, Linux and MacOS and provide a unified API across all platforms. Our main features are consisting of Colors, Keyboard input, terminal resize handling, as well as other common terminal functionality. It's also possible to open a managed terminal from a windows GUI application.
- **cpptoml** [ğŸ“](./cpptoml) [ğŸŒ](https://github.com/GerHobbelt/cpptoml) -- a header-only library for parsing [TOML][toml] configuration files. This includes support for the new DateTime format, inline tables, multi-line basic and raw strings, digit separators, hexadecimal integers, octal integers, binary integers, and float special values.
- **cppzmq** [ğŸ“](./cppzmq) [ğŸŒ](https://github.com/GerHobbelt/cppzmq) -- header-only C++ binding for libzmq.
- **cpu_features** [ğŸ“](./cpu_features) [ğŸŒ](https://github.com/GerHobbelt/cpu_features) -- a cross-platform C library to retrieve CPU features (such as available instructions) at runtime.
- **cpuinfo** [ğŸ“](./cpuinfo) [ğŸŒ](https://github.com/GerHobbelt/cpuinfo) -- CPU & hardware info
- **cpython** [ğŸ“](./cpython) [ğŸŒ](https://github.com/GerHobbelt/cpython) -- Python version 3. Note: Building a complete Python installation requires the use of various additional third-party libraries, depending on your build platform and configure options.  Not all standard library modules are buildable or useable on all platforms.
- **cqf** [ğŸ“](./cqf) [ğŸŒ](https://github.com/GerHobbelt/cqf) -- [A General-Purpose Counting Filter: Counting Quotient Filter (CQF)](https://dl.acm.org/doi/10.1145/3035918.3035963) supports approximate membership testing and counting the occurrences of items in a data set. This general-purpose AMQ is small and fast, has good locality of reference, scales out of RAM to SSD, and supports deletions, counting (even on skewed data sets), resizing, merging, and highly concurrent access.
- **cr** [ğŸ“](./cr) [ğŸŒ](https://github.com/GerHobbelt/cr) -- a single file header-only live reload solution for C, written in C++: simple public API, 3 functions to use only (and another to export); works and tested on Linux, MacOSX and Windows; based on dynamic reloadable binary (.so/.dylib/.dll).
- **crc32c** [ğŸ“](./crc32c) [ğŸŒ](https://github.com/GerHobbelt/crc32c) -- a few CRC32C implementations under an umbrella that dispatches to a suitable implementation based on the host computer's hardware capabilities. CRC32C is specified as the CRC that uses the iSCSI polynomial in [RFC 3720](https://tools.ietf.org/html/rfc3720#section-12.1). The polynomial was introduced by G. Castagnoli, S. Braeuer and M. Herrmann. CRC32C is used in software such as Btrfs, ext4, Ceph and leveldb.
- **createprocess-windows** [ğŸ“](./createprocess-windows) [ğŸŒ](https://github.com/GerHobbelt/createprocess-windows) -- drive `CreateProcess` Win32 API
- **CRFpp** [ğŸ“](./CRFpp) [ğŸŒ](https://github.com/GerHobbelt/crfpp) -- CRF++ is a simple, customizable, and open source implementation of <a href="http://www.cis.upenn.edu/~pereira/papers/crf.pdf">Conditional Random Fields (CRFs)</a> for segmenting/labeling sequential data. CRF++ is designed for generic purpose and will be applied to a variety of NLP tasks, such as Named Entity Recognition, Information Extraction and Text Chunking.
- **crfsuite** [ğŸ“](./crfsuite) [ğŸŒ](https://github.com/GerHobbelt/crfsuite) -- an implementation of Conditional Random Fields (CRFs) for labeling sequential data.
- **CRFsuite-extended** [ğŸ“](./CRFsuite-extended) [ğŸŒ](https://github.com/GerHobbelt/CRFSuiteEx) -- a fork of [Naoaki Okazaki's](http://www.chokkan.org/) implementation of conditional random fields (CRFs).
- **Criterion** [ğŸ“](./Criterion) [ğŸŒ](https://github.com/GerHobbelt/Criterion) -- a dead-simple, yet extensible, C and C++ unit testing framework.
- **CRoaring** [ğŸ“](./CRoaring) [ğŸŒ](https://github.com/GerHobbelt/CRoaring) -- portable Roaring bitmaps in C (and C++). Bitsets, also called bitmaps, are commonly used as fast data structures. Unfortunately, they can use too much memory. To compensate, we often use compressed bitmaps. Roaring bitmaps are compressed bitmaps which tend to outperform conventional compressed bitmaps such as WAH, EWAH or Concise. They are used by several major systems such as Apache Lucene and derivative systems such as Solr and Elasticsearch, etc.. The CRoaring library is used in several systems such as Apache Doris.
- **crow** [ğŸ“](./crow) [ğŸŒ](https://github.com/GerHobbelt/crow) -- IPC / server framework. Crow is a very fast and easy to use C++ micro web framework (inspired by Python Flask).
  
  Interface looks nicer than `oatpp`...

- **crumsort** [ğŸ“](./crumsort) [ğŸŒ](https://github.com/GerHobbelt/crumsort) -- is a hybrid quicksort / mergesort algorithm. The sort is in-place, unstable, adaptive, branchless, and has exceptional performance.
- **cryptopp** [ğŸ“](./cryptopp) [ğŸŒ](https://github.com/GerHobbelt/cryptopp) -- crypto library
- **CryptSync** [ğŸ“](./CryptSync) [ğŸŒ](https://github.com/GerHobbelt/CryptSync) -- a small utility that synchronizes two folders while encrypting the contents in one folder. That means one of the two folders has all files unencrypted (the files you work with) and the other folder has all the files encrypted. This is best used together with cloud storage tools like OneDrive, DropBox or Google Drive.
- **csv-parser** [ğŸ“](./csv-parser) [ğŸŒ](https://github.com/GerHobbelt/csv-parser) -- Vince's CSV Parser: there's plenty of other CSV parsers in the wild, but I had a hard time finding what I wanted. Inspired by Python's `csv` module, I wanted a library with **simple, intuitive syntax**. Furthermore, I wanted support for special use cases such as calculating statistics on very large files. Thus, this library was created with these following goals in mind.
- **csvquote** [ğŸ“](./csvquote) [ğŸŒ](https://github.com/GerHobbelt/csvquote) -- smart and simple CSV processing on the command line. This program can be used at the start and end of a text processing pipeline so that regular unix command line tools can properly handle CSV data that contain commas and newlines inside quoted data fields. Without this program, embedded special characters would be incorrectly interpreted as separators when they are inside quoted data fields.
- **csync2** [ğŸ“](./csync2) [ğŸŒ](https://github.com/GerHobbelt/csync2) -- a cluster synchronization tool. It can be used to keep files on multiple hosts in a cluster in sync. Csync2 can handle complex setups with much more than just 2 hosts, handle file deletions and can detect conflicts.
- **CTCWordBeamSearch** [ğŸ“](./CTCWordBeamSearch) [ğŸŒ](https://github.com/GerHobbelt/CTCWordBeamSearch) -- Connectionist Temporal Classification (CTC) decoder with dictionary and Language Model (LM).
- **CTPL-Thread-Pool** [ğŸ“](./CTPL-Thread-Pool) [ğŸŒ](https://github.com/GerHobbelt/CTPL) -- Modern and efficient C++ Thread Pool Library. More specifically, there are some threads dedicated to the pool and a container of jobs. The jobs come to the pool dynamically. A job is fetched and deleted from the container when there is an idle thread. The job is then run on that thread.
- **ctsa** [ğŸ“](./ctsa) [ğŸŒ](https://github.com/GerHobbelt/ctsa) -- a Univariate Time Series Analysis and ARIMA Modeling Package in ANSI C: CTSA is a C software package for univariate time series analysis. ARIMA and Seasonal ARIMA models have been added as of 10/30/2014. 07/24/2020 Update: SARIMAX and Auto ARIMA added. Documentation will be added in the coming days. Software is still in beta stage and older ARIMA and SARIMA functions are now superseded by SARIMAX.
- **cuckoofilter** [ğŸ“](./cuckoofilter) [ğŸŒ](https://github.com/GerHobbelt/cuckoofilter) -- Cuckoo Filter is a Bloom filter replacement for approximated set-membership queries. While Bloom filters are well-known space-efficient data structures to serve queries like "if item x is in a set?", they do not support deletion. Their variances to enable deletion (like counting Bloom filters) usually require much more space. Cuckoo ï¬lters provide the ï¬‚exibility to add and remove items dynamically. A cuckoo filter is based on cuckoo hashing (and therefore named as cuckoo filter).  It is essentially a cuckoo hash table storing each key's fingerprint. Cuckoo hash tables can be highly compact, thus a cuckoo filter could use less space than conventional Bloom ï¬lters, for applications that require low false positive rates (< 3%).
- **cuckoo-index** [ğŸ“](./cuckoo-index) [ğŸŒ](https://github.com/GerHobbelt/cuckoo-index) -- Cuckoo Index (CI) is a lightweight secondary index structure that represents the many-to-many relationship between keys and partitions of columns in a highly space-efficient way. CI associates variable-sized fingerprints in a Cuckoo filter with compressed bitmaps indicating qualifying partitions. The problem of finding all partitions that possibly contain a given lookup key is traditionally solved by maintaining one filter (e.g., a Bloom filter) per partition that indexes all unique key values contained in this partition. To identify all partitions containing a key, we would need to probe all per-partition filters (which could be many). Depending on the storage medium, a false positive there can be very expensive. Furthermore, secondary columns typically contain many duplicates (also across partitions). Cuckoo Index (CI) addresses these drawbacks of per-partition filters. (It must know all keys at build time, though.)
- **cURL** [ğŸ“](../../thirdparty/curl) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-curl) -- the ubiquitous [libcurl](http://curl.haxx.se/libcurl).
- **curl-impersonate** [ğŸ“](./curl-impersonate) [ğŸŒ](https://github.com/GerHobbelt/curl-impersonate) -- a special build of [curl](https://github.com/curl/curl) that can impersonate the four major browsers: Chrome, Edge, Safari & Firefox. curl-impersonate is able to perform TLS and HTTP handshakes that are identical to that of a real browser.
- **curl-www** [ğŸ“](./curl-www) [ğŸŒ](https://github.com/GerHobbelt/curl-www) -- the curl.se web site contents.
- **CurvatureFilter** [ğŸ“](./CurvatureFilter) [ğŸŒ](https://github.com/GerHobbelt/CurvatureFilter) -- Curvature filters are efficient solvers for variational models. Traditional solvers, such as gradient descent or Euler Lagrange Equation, start at the total energy and use diffusion scheme to carry out the minimization. When the initial condition is the original image, the data fitting energy always increases while the regularization energy always reduces during the optimization, as illustrated in the below figure. Thus, regularization energy must be the dominant part since the total energy has to decrease. Therefore, **Curvature filters focus on minimizing the regularization term,** whose minimizers are already known. For example, if the regularization is Gaussian curvature, the developable surfaces minimize this energy. Therefore, in curvature filter, developable surfaces are used to approximate the data. **As long as the decreased amount in the regularization part is larger than the increased amount in the data fitting energy, the total energy is reduced.**
- **cvmatio** [ğŸ“](./cvmatio) [ğŸŒ](https://github.com/GerHobbelt/cvmatio) -- an open source Matlab v7 MAT file parser written in C++, giving users the ability to interact with binary MAT files in their own projects.
- **cv-VanishingPoint** [ğŸ“](./cv-VanishingPoint) [ğŸŒ](https://github.com/GerHobbelt/cv-VanishingPoint) -- detection of multiple finite/infinite vanishing points using MSAC.
- **CxImage** [ğŸ“](./CxImage) [ğŸŒ](https://github.com/GerHobbelt/CxImage) -- venerated library for reading and creating many image file formats.
- **cxxopts** [ğŸ“](./cxxopts) [ğŸŒ](https://github.com/GerHobbelt/cxxopts) -- a lightweight C++ option parser library, supporting the standard GNU style syntax for options.
- **cxxtest** [ğŸ“](./cxxtest) [ğŸŒ](https://github.com/GerHobbelt/cxxtest) -- a unit testing framework for C++ that is similar in spirit to JUnit, CppUnit, and xUnit. CxxTest is easy to use because it does not require precompiling a CxxTest testing library, it employs no advanced features of C++ (e.g. RTTI) and it supports a very flexible form of test discovery.
- **cxxtest_catch_2_gtest** [ğŸ“](./cxxtest_catch_2_gtest) [ğŸŒ](https://github.com/GerHobbelt/cxxtest_catch_2_gtest) -- quick & dirty converter from various test suites to googletest, i.e. allows us to use a single test framework, despite some libraries having been set up to use another, e.g. [Catch2](https://github.com/catchorg/Catch2).
- **Cysboard** [ğŸ“](./Cysboard) [ğŸŒ](https://github.com/GerHobbelt/Cysboard) -- a lightweight system monitor similar to `conky` but with html and css for themes.
- **darknet** [ğŸ“](./darknet) [ğŸŒ](https://github.com/GerHobbelt/darknet) -- Darknet is an open source neural network framework written in C and CUDA. It is fast, easy to install, and supports CPU and GPU computation.
- **dashing** [ğŸ“](./dashing) [ğŸŒ](https://github.com/GerHobbelt/dashing) -- dashing sketches and computes distances between fasta and fastq data. Our paper is available [here](https://www.biorxiv.org/content/10.1101/501726v2) as a preprint and [here](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1875-0) at Genome Biology.
- **datamash** [ğŸ“](./datamash) [ğŸŒ](https://github.com/GerHobbelt/datamash) -- GNU Datamash is a command-line program which performs basic numeric, textual and statistical operations on input textual data files. It is designed to be portable and reliable, and aid researchers to easily automate analysis pipelines, without writing code or even short scripts.
- **date** [ğŸ“](./date) [ğŸŒ](https://github.com/GerHobbelt/date) -- a combo of several separate C++11/C++14/C++17 libraries, all geared towards formatting and working with date and time stamps in human-centric formats.
- **datetimepp** [ğŸ“](./datetimepp) [ğŸŒ](https://github.com/GerHobbelt/datetimepp) -- datetime++ is an attempt to port [Python Datetime](https://docs.python.org/3/library/datetime.html) to C++. Finally easy datetime management in C++ !
- **dateutils** [ğŸ“](./dateutils) [ğŸŒ](https://github.com/GerHobbelt/dateutils) -- a bunch of tools that revolve around fiddling with dates and times on the command line with a strong focus on use cases that arise when dealing with large amounts of financial data.
- **DBoW2** [ğŸ“](./DBoW2) [ğŸŒ](https://github.com/GerHobbelt/DBoW2) -- a C++ library for indexing and converting images into a bag-of-word representation. It implements a hierarchical tree for approximating nearest neighbours in the image feature space and creating a visual vocabulary. DBoW2 also implements an image database with inverted and direct files to index images and enabling quick queries and feature comparisons.
- **DBow3** [ğŸ“](./DBow3) [ğŸŒ](https://github.com/GerHobbelt/DBow3) -- DBoW3 is an improved version of the DBow2 library, an open source C++ library for indexing and converting images into a bag-of-word representation. It implements a hierarchical tree for approximating nearest neighbours in the image feature space and creating a visual vocabulary. DBoW3 also implements an image database with inverted and direct files to index images and enabling quick queries and feature comparisons.
- **dbscan** [ğŸ“](./dbscan) [ğŸŒ](https://github.com/GerHobbelt/dbscan) -- Density-Based Spatial Clustering of Applications with Noise (DBSCAN) and Related Algorithms: a fast C++ (re)implementation of several density-based algorithms with a focus on the DBSCAN family for clustering spatial data. The package includes: DBSCAN, HDBSCAN, OPTICS/OPTICSXi, FOSC, Jarvis-Patrick clustering, LOF (Local outlier factor), GLOSH (Global-Local Outlier Score from Hierarchies), kd-tree based kNN search, Fixed-radius NN search
- **DCF-cuckoo-index** [ğŸ“](./DCF-cuckoo-index) [ğŸŒ](https://github.com/GerHobbelt/DCF) -- the Dynamic Cuckoo Filter (DCF) is an efficient approximate membership test data structure. Different from the classic Bloom filter and its variants, DCF is especially designed for highly dynamic datasets and supports extending and reducing its capacity. The DCF design is the first to achieve both reliable item deletion and flexibly extending/reducing for approximate set representation and membership testing. DCF outperforms the state-of-the-art DBF designs in both speed and memory consumption.
- **debugbreak** [ğŸ“](./debugbreak) [ğŸŒ](https://github.com/GerHobbelt/debugbreak) -- allows you to put breakpoints in your C/C++ code with a call to **`debug_break()`**.
- **decision-tree** [ğŸ“](./decision-tree) [ğŸŒ](https://github.com/GerHobbelt/decision-tree) -- a decision tree classifier. Decision trees are a simple machine learning algorithm that use a series of features of an observation to create a prediction of a target outcome class.
- **deepdetect** [ğŸ“](./deepdetect) [ğŸŒ](https://github.com/GerHobbelt/deepdetect) -- DeepDetect (https://www.deepdetect.com/) is a machine learning API and server written in C++11. It makes state of the art machine learning easy to work with and integrate into existing applications. It has support for both training and inference, with automatic conversion to embedded platforms with TensorRT (NVidia GPU) and NCNN (ARM CPU). It implements support for supervised and unsupervised deep learning of images, text, time series and other data, with focus on simplicity and ease of use, test and connection into existing applications. It supports classification, object detection, segmentation, regression, autoencoders, ... and it relies on external machine learning libraries through a very generic and flexible API.
- **delegate** [ğŸ“](./delegate) [ğŸŒ](https://github.com/GerHobbelt/delegate) -- an embedded friendly alternative to `std::function`. The main purpose is to store callable things such as free functions, member functions, and functors. Once stored, the delegate can be called without knowledge of the type of stored thing. The `delegate` guarantees no heap allocation and [is `trivially_copyable`](https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable). It will never throw exceptions itself. Intended use is as general callback storage (think function pointer analog). The price to pay is that the delegate only stores a pointer to referenced functor objects or objects to call member functions on. The user needs to handle the lifetime of a referred object. In addition, the delegation object has a smaller footprint compared to common `std::function` implementations, using only 2 pointers (free function pointer and void pointer). This is small enough so that a delegate will use small object optimization.
- **density** [ğŸ“](./density) [ğŸŒ](https://github.com/GerHobbelt/density) -- a superfast compression library. It is focused on high-speed compression, at the best ratio possible. **All three** of DENSITY's algorithms are currently at the **pareto frontier** of compression speed vs ratio (cf. [here](https://github.com/inikep/lzbench/blob/master/lzbench18_sorted.md) for an independent benchmark).
- **densityxx** [ğŸ“](./densityxx) [ğŸŒ](https://github.com/GerHobbelt/densityxx) -- the c++ version of `density`, which is a super fast compress library.
- **design-patterns-cpp** [ğŸ“](./design-patterns-cpp) [ğŸŒ](https://github.com/GerHobbelt/design-patterns-cpp) -- C++ Design Patterns
- **detect-character-encoding** [ğŸ“](./detect-character-encoding) [ğŸŒ](https://github.com/GerHobbelt/detect-character-encoding) -- detect character encoding using [ICU](http://site.icu-project.org).  **Tip:** If you donâ€™t need ICU in particular, consider using [ced](https://github.com/sonicdoe/ced), which is based on Googleâ€™s lighter [compact_enc_det](https://github.com/google/compact_enc_det) library.
- **DGM-CRF** [ğŸ“](./DGM-CRF) [ğŸŒ](https://github.com/GerHobbelt/DGM) -- DGM (Direct Graphical Models) is a cross-platform C++ library implementing various tasks in probabilistic graphical models with pairwise and complete (dense) dependencies. The library aims to be used for the Markov and Conditional Random Fields (MRF / CRF), Markov Chains, Bayesian Networks, _etc_.
- **diffutils** [ğŸ“](./diffutils) [ğŸŒ](https://github.com/GerHobbelt/diffutils) -- the GNU diff, diff3, sdiff, and cmp utilities. Their features are a superset of the Unix features and they are significantly faster.
- **Digital-Halftoning** [ğŸ“](./Digital-Halftoning) [ğŸŒ](https://github.com/GerHobbelt/Digital-Halftoning) -- code for several digital halftoning techniques: Bayers, Ulichney, Dot Diffusion, Floyd-Steinberg Error Diffusion
- **directorywatcher** [ğŸ“](./directorywatcher) [ğŸŒ](https://github.com/GerHobbelt/myoddweb.directorywatcher) -- a fast and reliable File/Directory watcher for C#/C++ to replace the current .NET `FileSystemWatcher` class.
- **dirent** [ğŸ“](./dirent) [ğŸŒ](https://github.com/GerHobbelt/dirent) -- POSIX `dirent.h` ported to MS Windows (Win32/Win64); used by several libraries.
- **DiskANN** [ğŸ“](./DiskANN) [ğŸŒ](https://github.com/GerHobbelt/DiskANN) -- DiskANN is a suite of scalable, accurate and cost-effective approximate nearest neighbor search algorithms for large-scale vector search that support real-time changes and simple filters.
- **djvulibre** [ğŸ“](./djvulibre) [ğŸŒ](https://github.com/GerHobbelt/djvulibre) -- DjVu (pronounced "dÃ©jÃ  vu") a set of compression technologies, a file format, and a software platform for the delivery over the Web of digital documents, scanned documents, and high resolution images.
- **dkm** [ğŸ“](./dkm) [ğŸŒ](https://github.com/GerHobbelt/dkm) -- a generic C++11 k-means clustering implementation. The algorithm is based on [Lloyds Algorithm](https://en.wikipedia.org/wiki/Lloyd%27s_algorithm) and uses the [kmeans++](https://en.wikipedia.org/wiki/K-means%2B%2B) initialization method.
- **dlfcn-win32** [ğŸ“](./dlfcn-win32) [ğŸŒ](https://github.com/GerHobbelt/dlfcn-win32) -- an implementation of `dlfcn` for Windows. `dlfcn` is a set of functions that allows runtime dynamic library loading. It is standardized in the POSIX. Windows also provide similar routines, but not in a POSIX-compatible way. This library attempts to implement a wrapper around the Windows functions to make programs written for POSIX that use dlfcn work in Windows without any modifications.
- **dlib** [ğŸ“](./dlib) [ğŸŒ](https://github.com/GerHobbelt/dlib) -- machine learning algorithms
- **DocLayNet** [ğŸ“](./DocLayNet) [ğŸŒ](https://github.com/GerHobbelt/DocLayNet) -- DocLayNet provides page-by-page layout segmentation ground-truth using bounding-boxes for 11 distinct class labels on 80863 unique pages from 6 document categories. It provides several unique features compared to related work such as PubLayNet or DocBank, e.g. *Human Annotation*: DocLayNet is hand-annotated by well-trained experts, providing a gold-standard in layout segmentation through human recognition and interpretation of each page layout.
- **doctest** [ğŸ“](./doctest) [ğŸŒ](https://github.com/GerHobbelt/doctest) -- a C++ testing framework, by far the fastest both in compile times (by [**orders of magnitude**](doc/markdown/benchmarks.md)) and runtime compared to other feature-rich alternatives.
- **docxBox** [ğŸ“](./docxBox) [ğŸŒ](https://github.com/GerHobbelt/docxBox) -- CLI tool for Word DOCX templating and analysis.
- **doh** [ğŸ“](./doh) [ğŸŒ](https://github.com/GerHobbelt/doh) -- a libcurl-using application that resolves a host name using DNS-over-HTTPS (DoH).
- **doxa** [ğŸ“](./doxa) [ğŸŒ](https://github.com/GerHobbelt/Doxa) -- Î”oxa Binarization Framework (Î”BF) is an image binarization framework which focuses primarily on local adaptive thresholding algorithms, aimed at providing the building blocks one might use to advance the state of handwritten manuscript binarization.
  
  Supported Algorithms:
  
  * Otsu - "A threshold selection method from gray-level histograms", 1979.
  * Bernsen - "Dynamic thresholding of gray-level images", 1986.
  * Niblack - "An Introduction to Digital Image Processing", 1986.
  * Sauvola - "Adaptive document image binarization", 1999.
  * Wolf - "Extraction and Recognition of Artificial Text in Multimedia Documents", 2003.
  * Gatos - "Adaptive degraded document image binarization", 2005. (Partial)
  * NICK - "Comparison of Niblack inspired Binarization methods for ancient documents", 2009.
  * Su - "Binarization of Historical Document Images Using the Local Maximum and Minimum", 2010.
  * T.R. Singh - "A New local Adaptive Thresholding Technique in Binarization", 2011.
  * Bataineh - "An adaptive local binarization method for document images based on a novel thresholding method and dynamic windows", 2011. (unreproducible)
  * ISauvola - "ISauvola: Improved Sauvolaâ€™s Algorithm for Document Image Binarization", 2016.
  * WAN - "Binarization of Document Image Using Optimum Threshold Modification", 2018.
  
  Optimizations:
  
  * Shafait - "Efficient Implementation of Local Adaptive Thresholding Techniques Using Integral Images", 2008.
  * Petty - An algorithm for efficiently calculating the min and max of a local window.  Unpublished, 2019.
  * Chan - "Memory-efficient and fast implementation of local adaptive binarization methods", 2019.
  
  Performance Metrics:
  
  * Overall Accuracy
  * F-Measure
  * Peak Signal-To-Noise Ratio (PSNR)
  * Negative Rate Metric (NRM)
  * Matthews Correlation Coefficient (MCC)
  * Distance-Reciprocal Distortion Measure (DRDM) - "An Objective Distortion Measure for Binary Document Images Based on Human Visual Perception", 2002.
  
  Native Image Support:
  
  * Portable Any-Map: PBM (P4), 8-bit PGM (P5), PPM (P6), PAM (P7)

- **doxygen-awesome-css** [ğŸ“](./doxygen-awesome-css) [ğŸŒ](https://github.com/GerHobbelt/doxygen-awesome-css) -- a custom **CSS theme for Doxygen HTML-documentation** with lots of customization parameters.
- **DP_means** [ğŸ“](./DP_means) [ğŸŒ](https://github.com/GerHobbelt/DP_means) -- Dirichlet Process K-means is a bayesian non-parametric extension of the K-means algorithm based on small variance assymptotics (SVA) approximation of the Dirichlet Process Mixture Model.  B. Kulis and M. Jordan, "Revisiting k-means: New Algorithms via Bayesian Nonparametrics"
- **dr_libs** [ğŸ“](./dr_libs) [ğŸŒ](https://github.com/GerHobbelt/dr_libs) -- single file audio decoding libraries for C and C++ (FLAC, MP3, WAV)
- **drogon** [ğŸ“](./drogon) [ğŸŒ](https://github.com/GerHobbelt/drogon) -- a C++14/17-based HTTP application framework to easily build various types of web application server programs.
- **dtl-diff-template-library** [ğŸ“](./dtl-diff-template-library) [ğŸŒ](https://github.com/GerHobbelt/dtl) -- `dtl` is the diff template library written in C++.
- **dtoa-benchmark** [ğŸ“](./dtoa-benchmark) [ğŸŒ](https://github.com/GerHobbelt/dtoa-benchmark) -- This benchmark evaluates the performance of conversion from double precision IEEE-754 floating point (double) to ASCII string.
- **duckdb** [ğŸ“](./duckdb) [ğŸŒ](https://github.com/GerHobbelt/duckdb) -- DuckDB is a high-performance analytical database system. It is designed to be fast, reliable, portable, and easy to use. DuckDB provides a rich SQL dialect, with support far beyond basic SQL. DuckDB supports arbitrary and nested correlated subqueries, window functions, collations, complex types (arrays, structs), and more.
- **duktape** [ğŸ“](./duktape) [ğŸŒ](https://github.com/GerHobbelt/duktape) -- [Duktape](http://duktape.org/) is an **embeddable Javascript** engine, with a focus on **portability** and **compact** footprint. Duktape is ECMAScript E5/E5.1 compliant, with some semantics updated from ES2015+, with partial support for ECMAScript 2015 (E6) and ECMAScript 2016 (E7), ES2015 TypedArray, Node.js Buffer bindings and comes with a built-in debugger.
- **dynet** [ğŸ“](./dynet) [ğŸŒ](https://github.com/GerHobbelt/dynet) -- The Dynamic Neural Network Toolkit. DyNet is a neural network library developed by Carnegie Mellon University and many others. It is written in C++ (with bindings in Python) and is designed to be efficient when run on either CPU or GPU, and to work well with networks that have dynamic structures that change for every training instance. For example, these kinds of networks are particularly important in natural language processing tasks, and DyNet has been used to build state-of-the-art systems for syntactic parsing, machine translation, morphological inflection, and many other application areas.
- **easyexif** [ğŸ“](./easyexif) [ğŸŒ](https://github.com/GerHobbelt/easyexif) -- EasyEXIF is a tiny, lightweight C++ library that parses basic (EXIF) information out of JPEG files. It uses only the std::string library and is otherwise pure C++. You pass it the binary contents of a JPEG file, and it parses several of the most important EXIF fields for you.
- **easyloggingpp** [ğŸ“](./easyloggingpp) [ğŸŒ](https://github.com/GerHobbelt/easyloggingpp) -- Easylogging++ is single header efficient logging library for C++ applications. It is extremely powerful, highly extendable and configurable to user's requirements. It provides ability to write your own _sinks_ (via a feature referred as `LogDispatchCallback`).
- **EasyOCR** [ğŸ“](./EasyOCR) [ğŸŒ](https://github.com/GerHobbelt/EasyOCR) -- ready-to-use OCR with 80+ [supported languages](https://www.jaided.ai/easyocr) and all popular writing scripts including: Latin, Chinese, Arabic, Devanagari, Cyrillic, etc.
- **EasyOCR-cpp** [ğŸ“](./EasyOCR-cpp) [ğŸŒ](https://github.com/GerHobbelt/EasyOCR-cpp) -- custom C++ implementation of [EasyOCR](https://github.com/JaidedAI/EasyOCR). This C++ project implements the pre/post processing to run a OCR pipeline consisting of a text detector [CRAFT](https://arxiv.org/abs/1904.01941), and a CRNN based text recognizer. Unlike the EasyOCR python which is API based, this repo provides a set of classes to show how you can integrate OCR in any C++ program for maximum flexibility.
- **ecal** [ğŸ“](./ecal) [ğŸŒ](https://github.com/GerHobbelt/ecal) -- the *enhanced Communication Abstraction Layer* (*eCAL*) is a middleware that enables scalable, high performance interprocess communication on a single computer node or between different nodes in a computer network. eCAL uses a publish-subscribe pattern to automatically connect different nodes in the network. eCAL automatically chooses the best available data transport mechanism for each link:
  
  - Shared memory for local communication (incredible fast!)
  - UDP for network communication

- **ECMA262** [ğŸ“](./ECMA262) [ğŸŒ](https://github.com/GerHobbelt/ecma262) -- ECMAScript :: the source for the current draft of ECMA-262, the ECMAScriptÂ® Language Specification.
- **edit-distance** [ğŸ“](./edit-distance) [ğŸŒ](https://github.com/GerHobbelt/editdistance) -- a fast implementation of the edit distance (Levenshtein distance). The algorithm used in this library is proposed by _Heikki HyyrÃ¶, "Explaining and extending the bit-parallel approximate string matching algorithm of Myers", (2001) <http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.19.7158&rep=rep1&type=pdf>_.
- **efftw** [ğŸ“](./efftw) [ğŸŒ](https://github.com/GerHobbelt/efftw) -- Eigen-FFTW is a modern C++20 wrapper library around [FFTW](http://www.fftw.org) for [Eigen](https://eigen.tuxfamily.org/index.php?title=Main_Page).
- **efsw** [ğŸ“](./efsw) [ğŸŒ](https://github.com/GerHobbelt/efsw) -- cross-platform file system watcher and notifier
- **EigenRand** [ğŸ“](./EigenRand) [ğŸŒ](https://github.com/GerHobbelt/EigenRand) -- EigenRand: The Fastest C++11-compatible random distribution generator for Eigen. EigenRand is a header-only library for [Eigen](http://eigen.tuxfamily.org/index.php?title=Main_Page), providing vectorized random number engines and vectorized random distribution generators.  Since the classic Random functions of Eigen rely on an old C function `rand()`, there is no way to control random numbers and no guarantee for quality of generated numbers. In addition, Eigen's Random is slow because `rand()` is hard to vectorize. EigenRand provides a variety of random distribution functions similar to C++11 standard's random functions, which can be vectorized and easily integrated into Eigen's expressions of Matrix and Array. You can get 5~10 times speed by just replacing old Eigen's Random or unvectorizable c++11 random number generators with EigenRand.
- **emphf-hash** [ğŸ“](./emphf-hash) [ğŸŒ](https://github.com/GerHobbelt/emphf) -- an efficient external-memory algorithm for the construction of minimal perfect hash functions for large-scale key sets, focusing on speed and low memory usage (2.61 N bits plus a small constant factor).
- **enca** [ğŸ“](./enca) [ğŸŒ](https://github.com/GerHobbelt/enca) -- Enca (Extremely Naive Charset Analyser) consists of two main components: `libenca`, an encoding detection library, and `enca`, a command line frontend, integrating libenca and several charset conversion libraries and tools (GNU `recode`, UNIX98 `iconv`, perl `Unicode::Map`, `cstocs`).
- **enkiTS-TaskScheduler** [ğŸ“](./enkiTS-TaskScheduler) [ğŸŒ](https://github.com/GerHobbelt/enkiTS) -- a permissively licensed C++11 Task Scheduler for creating parallel programs. The primary goal of enkiTS is to help developers create programs which handle both data and task level parallelism to utilize the full performance of multicore CPUs, whilst being lightweight (only a small amount of code) and easy to use.
  
  Features:
  
    - Braided parallelism - can issue tasks from another task as well as from the thread which created the Task System, and has a simple task interface for both data and task parallelism.
    - Can pin tasks to a given thread - can schedule a task which will only be run on the specified thread.
    - Can register external threads to use with enkiTS
    - Can set task priorities - Up to 5 task priorities can be configured via define ENKITS_TASK_PRIORITIES_NUM (defaults to 3). Higher priority tasks are run before lower priority ones.
    - Can wait for pinned tasks - useful for creating IO threads which do no other work.
    - Completion Actions - can perform an action on task completion. This avoids the expensive action of adding the task to the scheduler, and can be used to safely delete a completed task.
    - Dependencies - can set dependencies between tasks.
    - Fast, then scalable - designed for consumer devices first, so performance on a low number of threads is important, followed by scalability.
    - Lightweight
    - Up-front Allocation friendly - designed for zero allocations during scheduling.

- **ensmallen** [ğŸ“](./ensmallen) [ğŸŒ](https://github.com/GerHobbelt/ensmallen) -- a high-quality C++ library for non-linear numerical optimization. `ensmallen` provides many types of optimizers that can be used for virtually any numerical optimization task. This includes gradient descent techniques, gradient-free optimizers, and constrained optimization. Examples include L-BFGS, SGD, CMAES and Simulated Annealing.
- **epeg** [ğŸ“](./epeg) [ğŸŒ](https://github.com/GerHobbelt/epeg) -- an IMMENSELY FAST JPEG thumbnailer library API. It's a convenience library API to using libjpeg to load JPEG images destined to be turned into thumbnails of the original, saving information with these thumbnails, retreiving it and managing to load the image ready for scaling with the minimum of fuss and CPU overhead.
- **EtwExplorer** [ğŸ“](./EtwExplorer) [ğŸŒ](https://github.com/GerHobbelt/EtwExplorer) -- View ETW Provider metadata. Event Tracing for Windows (ETW) is a logging facility built into the Windows OS. Modern providers register a manifest that describes all the events they support, with their properties. Classic providers register a MOF instead.
- **eventpp** [ğŸ“](./eventpp) [ğŸŒ](https://github.com/GerHobbelt/eventpp) -- a C++ event library for callbacks, event dispatcher, and event queue. With eventpp you can easily implement signal and slot mechanism, publisher and subscriber pattern, or observer pattern.
- **everything-curl** [ğŸ“](./everything-curl) [ğŸŒ](https://github.com/GerHobbelt/everything-curl) -- *Everything curl* is an extensive guide for all things curl. The project, the command-line tool, the library, how everything started and how it came to be the useful tool it is today. It explains how we work on developing it further, what it takes to use it, how you can contribute with code or bug reports and why millions of existing users use it.
- **EWAHBoolArray** [ğŸ“](./EWAHBoolArray) [ğŸŒ](https://github.com/GerHobbelt/EWAHBoolArray) -- a C++ compressed bitset data structure (also called bitset or bit vector). It supports several word sizes by a template parameter (16-bit, 32-bit, 64-bit). You should expect the 64-bit word-size to provide better performance, but higher memory usage, while a 32-bit word-size might compress a bit better, at the expense of some performance.
- **exiv2** [ğŸ“](./exiv2) [ğŸŒ](https://github.com/GerHobbelt/exiv2) -- a C++ library and a command-line utility to read, write, delete and modify Exif, IPTC, XMP and ICC image metadata.
- **ex-leptonica-freetype-harfbuzz** [ğŸ“](./ex-leptonica-freetype-harfbuzz) [ğŸŒ](https://github.com/GerHobbelt/ex-leptonica-freetype-harfbuzz) -- a simple sample application to get from zero to rendering unicode text using harfbuzz to do the text layout, freetype for the underlying font magic and some trivial code for the anti-aliased font rasterization.
- **expected** [ğŸ“](./expected) [ğŸŒ](https://github.com/GerHobbelt/expected) -- a C++ single header implementation of `std::expected` with functional-style extensions. [`std::expected`](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0323r3.pdf) is proposed as the preferred way to represent object which will either have an expected value, or an unexpected value giving information about why something failed. Unfortunately, chaining together many computations which may fail can be verbose, as error-checking code will be mixed in with the actual programming logic. This implementation provides a number of utilities to make coding with `expected` cleaner.
- **expected-lite** [ğŸ“](./expected-lite) [ğŸŒ](https://github.com/GerHobbelt/expected-lite) -- a single-file header-only library to represent value objects that either contain a valid value or an error. The library is a partly implementation of the proposal for [`std::expected`](https://en.cppreference.com/w/cpp/utility/expected) for use with C++11 and later.
- **exprtk** [ğŸ“](./exprtk) [ğŸŒ](https://github.com/GerHobbelt/exprtk) -- C++ Mathematical Expression Toolkit Library is a simple to use, easy to integrate and extremely efficient run-time mathematical expression parsing and evaluation engine. The parsing engine supports numerous forms of functional and logic processing semantics and is easily extensible.
- **Extensible-Storage-Engine** [ğŸ“](./Extensible-Storage-Engine) [ğŸŒ](https://github.com/GerHobbelt/Extensible-Storage-Engine) -- ESE is an embedded / ISAM-based database engine, that provides rudimentary table and indexed access. However the library provides many other strongly layered and thus reusable sub-facilities as well: A Synchronization / Locking library, a Data-structures / STL-like library, an OS-abstraction layer, and a Cache Manager, as well as the full-blown database engine itself.
- **extract** [ğŸ“](../../thirdparty/extract) [ğŸŒ](https://github.com/GerHobbelt/thirdparty_extract) -- clone of git://git.ghostscript.com/extract.git
- **eytzinger** [ğŸ“](./eytzinger) [ğŸŒ](https://github.com/GerHobbelt/eytzinger) -- `fixed_eytzinger_map` is a free implementation of Eytzingerâ€™s layout, in a form of an STL-like generic associative container, broadly compatible with a well-established access patterns. An Eytzinger map, or BFS(breadth-first search) map, places elements in a lookup order, which leads to a better memory locality. In practice, such container can outperform searching in sorted arrays, like `boost::flat_map`, due to less cache misses made in a lookup process. In comparison with RB-based trees, like `std::map`, lookup in Eytzinger map can be multiple times faster. Some comparison graphs are [given here](https://kazakov.life/2017/03/06/cache-friendly-associative-container/).
- **faiss** [ğŸ“](./faiss) [ğŸŒ](https://github.com/GerHobbelt/faiss) -- a library for efficient similarity search and clustering of dense vectors. It contains algorithms that search in sets of vectors of any size, up to ones that possibly do not fit in RAM. It also contains supporting code for evaluation and parameter tuning. Faiss is written in C++ with complete wrappers for Python/numpy. Some of the most useful algorithms are implemented on the GPU. It is developed primarily at Facebook AI Research.
- **falconn** [ğŸ“](./falconn) [ğŸŒ](https://github.com/GerHobbelt/FALCONN) -- FALCONN (FAst Lookups of Cosine and Other Nearest Neighbors) is a library with algorithms for the nearest neighbor search problem. The algorithms in FALCONN are based on [Locality-Sensitive Hashing](https://en.wikipedia.org/wiki/Locality-sensitive_hashing) (LSH), which is a popular class of methods for nearest neighbor search in high-dimensional spaces. The goal of FALCONN is to provide very efficient and well-tested implementations of LSH-based data structures.  Currently, FALCONN supports two LSH families for the [cosine similarity](https://en.wikipedia.org/wiki/Cosine_similarity): hyperplane LSH and cross polytope LSH. Both hash families are implemented with multi-probe LSH in order to minimize memory usage. Moreover, FALCONN is optimized for both dense and sparse data. Despite being designed for the cosine similarity, FALCONN can often be used for nearest neighbor search under the Euclidean distance or a maximum inner product search.
- **farmhash** [ğŸ“](./farmhash) [ğŸŒ](https://github.com/GerHobbelt/farmhash) -- FarmHash, a family of hash functions. FarmHash provides hash functions for strings and other data.  The functions mix the input bits thoroughly but are not suitable for cryptography.
- **farver-OKlab** [ğŸ“](./farver-OKlab) [ğŸŒ](https://github.com/GerHobbelt/farver) -- provides very fast, vectorised functions for conversion of colours between different colour spaces, colour comparisons (distance between colours), encoding/decoding, and channel manipulation in colour strings.
- **fastapprox** [ğŸ“](./fastapprox) [ğŸŒ](https://github.com/GerHobbelt/fastapprox) -- approximate and vectorized versions of common mathematical functions (e.g. exponential, logarithm, and power, lgamma and digamma, cosh, sinh, tanh, cos, sin, tan, sigmoid and erf, Lambert W)
- **fastBPE** [ğŸ“](./fastBPE) [ğŸŒ](https://github.com/GerHobbelt/fastBPE) -- text tokenization / ngrams
- **fast_double_parser** [ğŸ“](./fast_double_parser) [ğŸŒ](https://github.com/GerHobbelt/fast_double_parser) -- 4x faster than `strtod()`. Unless you need support for [RFC 7159](https://tools.ietf.org/html/rfc7159) (JSON standard), we encourage users to adopt [fast_float](https://github.com/fastfloat/fast_float) library instead. It has more functionality. Fast function to parse ASCII strings containing decimal numbers into double-precision (binary64) floating-point values.  That is, given the string "1.0e10", it should return a 64-bit floating-point value equal to 10000000000. We do not sacrifice accuracy. The function will match exactly (down the smallest bit) the result of a standard function like `strtod`.
- **fastfilter_cpp** [ğŸ“](./fastfilter_cpp) [ğŸŒ](https://github.com/GerHobbelt/fastfilter_cpp) -- Fast Filter: Fast approximate membership filter implementations (C++, research library)
- **fast_float** [ğŸ“](./fast_float) [ğŸŒ](https://github.com/GerHobbelt/fast_float) -- fast and exact implementation of the C++ `from_chars` functions for float and double types: 4x faster than `strtod`
- **FastGlobbing** [ğŸ“](./FastGlobbing) [ğŸŒ](https://github.com/GerHobbelt/FastGlobbing) -- a Fast String Matching with Wildcards, Globs, and Gitignore-Style Globs. Wildcard string matching and globbing isnâ€™t as trivial as it may seem at first.  In fact, mistakes in the past resulted in serious vulnerabilities such as denial of service due to exponential blow-up in execution time. This fast non-recursive algorithm performs safe gitignore-style wildcard matching.  Implementations in C, C++, Java, Javascript and Python are included.
- **fastgron** [ğŸ“](./fastgron) [ğŸŒ](https://github.com/GerHobbelt/fastgron) -- `fastgron` makes JSON greppable super fast! `fastgron` transforms JSON into discrete assignments to make it easier to grep for what you want and see the absolute 'path' to it. It eases the exploration of APIs that return large blobs of JSON but lack documentation.
- **fasthashing** [ğŸ“](./fasthashing) [ğŸŒ](https://github.com/GerHobbelt/fasthashing) -- a few very fast (almost) strongly universal hash functions over 32-bit strings, as described by the paper:  Owen Kaser and Daniel Lemire, Strongly universal string hashing is fast, Computer Journal (2014) 57 (11): 1624-1638. http://arxiv.org/abs/1202.4961
- **fast-hex** [ğŸ“](./fast-hex) [ğŸŒ](https://github.com/GerHobbelt/fast-hex) -- a fast, SIMD (vectorized) hex string encoder/decoder.
- **fast-kmeans** [ğŸ“](./fast-kmeans) [ğŸŒ](https://github.com/GerHobbelt/fast-kmeans) -- this Fast K-means Clustering Toolkit is a testbed for comparing variants of Lloyd's k-means clustering algorithm.  It includes implementations of several algorithms that accelerate the algorithm by avoiding unnecessary distance calculations.
- **fast-lzma2** [ğŸ“](./fast-lzma2) [ğŸŒ](https://github.com/GerHobbelt/fast-lzma2) -- the __Fast LZMA2 Library__ is a lossless high-ratio data compression library based on Igor Pavlov's LZMA2 codec from 7-zip. Binaries of 7-Zip forks which use the algorithm are available in the [7-Zip-FL2 project](https://github.com/conor42/7-Zip-FL2/releases/), the [7-Zip-zstd project](https://github.com/mcmilk/7-Zip-zstd/releases/), and the active fork of [p7zip](https://github.com/szcnick/p7zip/releases/). The library is also embedded in a fork of XZ Utils, named [FXZ Utils](https://github.com/conor42/fxz).
- **fastops** [ğŸ“](./fastops) [ğŸŒ](https://github.com/GerHobbelt/fastops) -- vector operations library, which enables acceleration of bulk calls of certain math functions on AVX and AVX2 hardware. Currently supported operations are exp, log, sigmoid and tanh. The library itself implements operations using AVX and AVX2, but will work on any hardware with at least SSE2 support.
- **fast_pfor** [ğŸ“](./fast_pfor) [ğŸŒ](https://github.com/GerHobbelt/FastPFor) -- a research library with integer compression schemes. It is broadly applicable to the compression of arrays of 32-bit integers where most integers are small. The library seeks to exploit SIMD instructions (SSE) whenever possible.
- **fastPRNG** [ğŸ“](./fastPRNG) [ğŸŒ](https://github.com/GerHobbelt/fastPRNG) -- a single header-only FAST 32/64 bit PRNG (pseudo-random generator), highly optimized to obtain faster code from compilers, it's based on **xoshiro** / **xoroshiro** ([**Blackman/Vigna**](http://prng.di.unimi.it/)), **xorshift** and other [**Marsaglia**](https://en.wikipedia.org/wiki/George_Marsaglia) algorithms.
- **fastrange** [ğŸ“](./fastrange) [ğŸŒ](https://github.com/GerHobbelt/fastrange) -- a fast alternative to the modulo reduction. [It has accelerated some operations in Google's Tensorflow by 10% to 20%](https://github.com/tensorflow/tensorflow/commit/a47a300185026fe7829990def9113bf3a5109fed). Further reading : http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/ See also: Daniel Lemire, [Fast Random Integer Generation in an Interval](https://arxiv.org/abs/1805.10941), ACM Transactions on Modeling and Computer Simulation, January 2019 Article No. 3 https://doi.org/10.1145/3230636
- **FastString** [ğŸ“](./FastString) [ğŸŒ](https://github.com/GerHobbelt/FastString) -- fast, in stack, fixed size string implementation with **constexpr noexcept** constructors and accessors. **FastString** improves **memory locality and latency** of strings by avoiding heap allocations.
- **fastText** [ğŸ“](./fastText) [ğŸŒ](https://github.com/GerHobbelt/fastText) -- [fastText](https://fasttext.cc/) is a library for efficient learning of word representations and sentence classification. Includes language detection feeatures.
- **fatal** [ğŸ“](./fatal) [ğŸŒ](https://github.com/GerHobbelt/fatal) -- Fatal (Facebook Template Library) is a library for fast prototyping software in modern C++. It provides facilities heavily based on template meta-programming, while keeping most of the complexity under-the-hood, to enhance the expressive power of C++. Fatal also provides lessons on how to write meta-programs, as well as on how to make the best use of the library, starting at beginner levels.
- **faup** [ğŸ“](./faup) [ğŸŒ](https://github.com/GerHobbelt/faup) -- **Faup** stands for Finally An Url Parser and is a library and command line tool to parse URLs and normalize fields with two constraints: (1) work with real-life urls (resilient to badly formated ones), and (2) be fast: no allocation for string parsing and read characters only once.
- **fbow** [ğŸ“](./fbow) [ğŸŒ](https://github.com/GerHobbelt/fbow) -- FBOW (Fast Bag of Words) is an extremmely optimized version of the DBow2/DBow3 libraries. The library is highly optimized to speed up the Bag of Words creation using  AVX,SSE and MMX instructions. In loading a vocabulary, fbow is ~80x faster than DBOW2 (see tests directory and try). In transforming an image into a bag of words using on machines with AVX instructions, it is ~6.4x faster.
- **fCWT** [ğŸ“](./fCWT) [ğŸŒ](https://github.com/GerHobbelt/fCWT) -- the fast Continuous Wavelet Transform (fCWT) is a highly optimized C++ library for very fast calculation of the CWT in C++, Matlab, and Python. **fCWT has been featured on the January 2022 cover of NATURE Computational Science**. In this article, fCWT is compared against eight competitor algorithms, tested on noise resistance and validated on synthetic electroencephalography and in vivo extracellular local field potential data.
- **ffht** [ğŸ“](./ffht) [ğŸŒ](https://github.com/GerHobbelt/FFHT) -- FFHT (Fast Fast Hadamard Transform) is a library that provides a heavily optimized C99 implementation of the Fast Hadamard Transform. FFHT also provides a thin Python wrapper that allows to perform the Fast Hadamard Transform on one-dimensional [NumPy](http://www.numpy.org/) arrays. The Hadamard Transform is a linear orthogonal map defined on real vectors whose length is a _power of two_. For the precise definition, see the [Wikipedia entry](https://en.wikipedia.org/wiki/Hadamard_transform). The Hadamard Transform has been recently used a lot in various machine learning and numerical algorithms. FFHT uses [AVX](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions) to speed up the computation.
- **FFME** [ğŸ“](./FFME) [ğŸŒ](https://github.com/GerHobbelt/FFME) -- key points detection (OpenCV). This method is a SIFT-like one, but specifically designed for egomotion computation. The key idea is that it avoids some of the steps SIFT gives, so that it runs faster, at the cost of not being so robust against scaling. The good news is that in egomotion estimation the scaling is not so critical as in registration applications, where SIFT should be selected.
- **FFmpeg** [ğŸ“](./FFmpeg) [ğŸŒ](https://github.com/GerHobbelt/FFmpeg) -- a collection of libraries and tools to process multimedia content such as audio, video, subtitles and related metadata.
- **ffts** [ğŸ“](./ffts) [ğŸŒ](https://github.com/GerHobbelt/ffts) -- FFTS -- The Fastest Fourier Transform in the South.
- **fftw3** [ğŸ“](./fftw3) [ğŸŒ](https://github.com/GerHobbelt/fftw3) -- the FFTW library for computing Fourier transforms (version 3.x), maintained by the FFTW authors.
- **FiberTaskingLib** [ğŸ“](./FiberTaskingLib) [ğŸŒ](https://github.com/GerHobbelt/FiberTaskingLib) -- a library for enabling task-based multi-threading. It allows execution of task graphs with arbitrary dependencies. Dependencies are represented as atomic counters. Under the covers, the task graph is executed using fibers, which in turn, are run on a pool of worker threads (one thread per CPU core). This allows the scheduler to wait on dependencies without task chaining or context switches.
- **fifo_map** [ğŸ“](./fifo_map) [ğŸŒ](https://github.com/GerHobbelt/fifo_map) -- a FIFO-ordered associative container for C++. It has the same interface as `std::map`, it can be used as drop-in replacement.
- **figcone** [ğŸ“](./figcone) [ğŸŒ](https://github.com/GerHobbelt/figcone) -- a C++17 / C++20 library, providing a convenient declarative interface for configuration parsers and built-in support for reading `JSON`, `YAML`, `TOML`, `XML`, `INI` and `shoal` config files.
- **figtree** [ğŸ“](./figtree) [ğŸŒ](https://github.com/GerHobbelt/figtree) -- FIGTree is a library that provides a C/C++ and MATLAB interface for speeding up the computation of the Gauss Transform.
- **file** [ğŸ“](./file) [ğŸŒ](https://github.com/GerHobbelt/file) -- `file` filetype recognizer tool & mimemagic
- **filecopyex3** [ğŸ“](./filecopyex3) [ğŸŒ](https://github.com/GerHobbelt/filecopyex3) -- a FAR plugin designed to bring to life all kinds of perverted fantasies on the topic of file copying, each of which will speed up the process by 5% :smile:. At the moment, it has implemented the main features that are sometimes quite lacking in standard copiers.
- **filesystem** [ğŸ“](./filesystem) [ğŸŒ](https://github.com/GerHobbelt/filesystem) -- a header-only single-file `std::filesystem` compatible helper library, based on the C++17 and C++20 specs, but implemented for C++11, C++14, C++17 or C++20 (tightly following the C++17 standard with very few documented exceptions). It is of course in its own namespace `ghc::filesystem` to not interfere with a regular `std::filesystem` should you use it in a mixed C++17 environment (which is possible).
- **FIt-SNE** [ğŸ“](./FIt-SNE) [ğŸŒ](https://github.com/GerHobbelt/FIt-SNE) -- FFT-accelerated implementation of t-Stochastic Neighborhood Embedding ([t-SNE](https://lvdmaaten.github.io/tsne/)), which is a highly successful method for dimensionality reduction and visualization of high dimensional datasets.  A popular [implementation](https://github.com/lvdmaaten/bhtsne) of t-SNE uses the Barnes-Hut algorithm to approximate the gradient at each iteration of gradient descent.
- **fityk** [ğŸ“](./fityk) [ğŸŒ](https://github.com/GerHobbelt/fityk) -- a program for nonlinear fitting of analytical functions (especially peak-shaped) to data (usually experimental data). To put it differently, it is primarily peak fitting software, but can handle other types of functions as well. Apart from the actual fitting, the program helps with data processing and provides ergonomic graphical interface (and also command line interface and scripting API -- but if the program is popular in some fields, it's thanks to its graphical interface). It is reportedly__ used in crystallography, chromatography, photoluminescence and photoelectron spectroscopy, infrared and Raman spectroscopy, to name but a few. Fityk offers various nonlinear fitting methods, simple background subtraction and other manipulations to the dataset, easy placement of peaks and changing of peak parameters, support for analysis of series of datasets, automation of common tasks with scripts, and much more.
- **flac** [ğŸ“](./flac) [ğŸŒ](https://github.com/GerHobbelt/flac) -- a software that can reduce the amount of storage space needed to store digital audio signals without needing to remove information in doing so. The files read and produced by this software are called FLAC files. As these files (which follow the [FLAC format](https://xiph.org/flac/format.html)) can be read from and written to by other software as well, this software is often referred to as the FLAC reference implementation.
- **flann** [ğŸ“](./flann) [ğŸŒ](https://github.com/GerHobbelt/flann) -- FLANN (Fast Library for Approximate Nearest Neighbors) is a library for performing fast approximate nearest neighbor searches in high dimensional spaces. It contains a collection of algorithms we found to work best for nearest neighbor search and a system for automatically choosing the best algorithm and optimum parameters depending on the dataset.
- **flare-floss** [ğŸ“](./flare-floss) [ğŸŒ](https://github.com/GerHobbelt/flare-floss) -- the FLARE Obfuscated String Solver (FLOSS, formerly FireEye Labs Obfuscated String Solver) uses advanced static analysis techniques to automatically extract and deobfuscate all strings from malware binaries. You can use it just like `strings.exe` to enhance the basic static analysis of unknown binaries.
- **flashlight** [ğŸ“](./flashlight) [ğŸŒ](https://github.com/GerHobbelt/flashlight) -- a fast, flexible machine learning library written entirely in C++ from the Facebook AI Research and the creators of Torch, TensorFlow, Eigen and Deep Speech, with an emphasis on efficiency and scale.
- **flat_hash_map** [ğŸ“](./flat_hash_map) [ğŸŒ](https://github.com/GerHobbelt/flat_hash_map) -- a very fast hashtable.
- **flat.hpp** [ğŸ“](./flat.hpp) [ğŸŒ](https://github.com/GerHobbelt/flat.hpp) -- a library of flat vector-like based associative containers.
- **flatton-offline** [ğŸ“](./flatton-offline) [ğŸŒ](https://github.com/GerHobbelt/flatton-offline) -- Flatton-Offline is an utility that allows you to quickly "flatten" an inked comics page. You pass in a png image with line art and Flatton fills each white area with a random color. It then grows each area so that it bleeds under the line art, touching the other neighboring areas. It is derived from the online utility which you can find [here](https://www.ayalpinkus.nl/Flatton.html).
- **flinng** [ğŸ“](./flinng) [ğŸŒ](https://github.com/GerHobbelt/FLINNG) -- Filters to Identify Near-Neighbor Groups (FLINNG) is a near neighbor search algorithm outlined in the paper [Practical Near Neighbor Search via Group Testing](https://arxiv.org/pdf/2106.11565.pdf).
- **flip** [ğŸ“](./flip) [ğŸŒ](https://github.com/GerHobbelt/flip) -- êŸ»LIP: A Tool for Visualizing and Communicating Errors in Rendered Images, implements the [LDR-êŸ»LIP](https://research.nvidia.com/publication/2020-07_FLIP) and [HDR-êŸ»LIP](https://research.nvidia.com/publication/2021-05_HDR-FLIP) image error metrics.
- **fluent-bit** [ğŸ“](./fluent-bit) [ğŸŒ](https://github.com/GerHobbelt/fluent-bit) -- [Fluent Bit](http://fluentbit.io) is a fast Log Processor and Forwarder for Linux, Windows, Embedded Linux, MacOS and BSD family operating systems. It's part of the Graduated [Fluentd](http://fluentd.org) Ecosystem and a [CNCF](https://cncf.io) sub-project. Fluent Bit allows to collect log events or metrics from different sources, process them and deliver them to different backends such as [Fluentd](http://fluentd.org), Elasticsearch, Splunk, DataDog, Kafka, New Relic, Azure services, AWS services, Google services, NATS, InfluxDB or any custom HTTP end-point.
- **fluxsort** [ğŸ“](./fluxsort) [ğŸŒ](https://github.com/GerHobbelt/fluxsort) -- is a stable quicksort / mergesort hybrid algorithm. The sort is stable, adaptive, branchless, and has exceptional performance.
- **fmath** [ğŸ“](./fmath) [ğŸŒ](https://github.com/GerHobbelt/fmath) -- fast approximate function of exponential function exp and log: includes `fmath::log`, `fmath::exp`, `fmath::expd`.
- **fmem** [ğŸ“](./fmem) [ğŸŒ](https://github.com/GerHobbelt/fmem) -- a cross-platform library for opening memory-backed libc streams (a la UNIX `fmemopen()`).
- **fmemopen_windows** [ğŸ“](./fmemopen_windows) [ğŸŒ](https://github.com/GerHobbelt/fmemopen_windows) -- provides **FILE\*** handler based on memory backend for fread,fwrite etc. just like `fmemopen` on linux, but now on MS Windows.
- **FM-fast-match** [ğŸ“](./FM-fast-match) [ğŸŒ](https://github.com/GerHobbelt/FAsT-Match) -- FAsT-Match: a port of the Fast Affine Template Matching algorithm (Simon Korman, Daniel Reichman, Gilad Tsur, Shai Avidan, CVPR 2013, Portland)
- **fmt** [ğŸ“](./fmt) [ğŸŒ](https://github.com/GerHobbelt/fmt) -- advanced C++ data-to-text formatter. The modern answer to classic `printf()`.
- **fmtlog** [ğŸ“](./fmtlog) [ğŸŒ](https://github.com/GerHobbelt/fmtlog) -- a performant fmtlib-style logging library with latency in nanoseconds (i.e. using fmt library format).
- **fnmatch** [ğŸ“](./fnmatch) [ğŸŒ](https://github.com/GerHobbelt/fnmatch) -- match a filename string or a pathname using POSIX wildcards.
- **folly** [ğŸ“](./folly) [ğŸŒ](https://github.com/GerHobbelt/folly) -- Folly (acronymed loosely after Facebook Open Source Library) is a library of C++14 components designed with practicality and efficiency in mind. **Folly contains a variety of core library components used extensively at Facebook**. In particular, it's often a dependency of Facebook's other open source C++ efforts and place where those projects can share code.
- **fontbm** [ğŸ“](./fontbm) [ğŸŒ](https://github.com/GerHobbelt/fontbm) -- [BMFont](http://www.angelcode.com/products/bmfont/) compatible, cross-platform (Linux/macOS/Windows) command line bitmap font generator (FreeType2 based render).
- **fontconfig** [ğŸ“](./fontconfig) [ğŸŒ](https://github.com/GerHobbelt/fontconfig) -- font configuration and customization library
- **fontview** [ğŸ“](./fontview) [ğŸŒ](https://github.com/GerHobbelt/fontview) -- â€œFontViewâ€ is a little demo app that shows the contents of a font file. It opens `*.ttf`, `*.otf`, `*.ttc`, `*.otc`, `*.pfa`, and `*.pfb` files. To render text, FontView uses the open-source libraries [FreeType](https://www.freetype.org/), [HarfBuzz](https://www.freedesktop.org/wiki/Software/HarfBuzz/), and [Raqm](http://host-oman.github.io/libraqm/).
- **fph-table** [ğŸ“](./fph-table) [ğŸŒ](https://github.com/GerHobbelt/fph-table) -- the Flash Perfect Hash (FPH) library is a modern C++/17 implementation of a dynamic [perfect hash](https://en.wikipedia.org/wiki/Perfect_hash_function) table (no collisions for the hash), which makes the hash map/set extremely fast for lookup operations. We provide four container classes `fph::DynamicFphSet`,`fph::DynamicFphMap`,`fph::MetaFphSet` and `fph::MetaFphMap`. The APIs of these four classes are almost the same as those of `std::unordered_set` and `std::unordered_map`.
- **fpng** [ğŸ“](./fpng) [ğŸŒ](https://github.com/GerHobbelt/fpng) -- a very fast C++ .PNG image reader/writer for 24/32bpp images. fpng was written to see just how fast you can write .PNG's without sacrificing too much compression. The files written by fpng conform to the [PNG standard](https://www.w3.org/TR/PNG/), are readable using any PNG decoder, and load or validate successfully using libpng, wuffs, lodepng, stb_image, and [pngcheck](http://www.libpng.org/pub/png/apps/pngcheck.html). PNG files written using fpng can also be read using fpng faster than other PNG libraries, due to its explicit use of [Length-Limited Prefix Codes](https://create.stephan-brumme.com/length-limited-prefix-codes/) and an [optimized decoder](https://fastcompression.blogspot.com/2015/10/huffman-revisited-part-4-multi-bytes.html) that exploits the properties of these codes.
- **FreeFileSync** [ğŸ“](./FreeFileSync) [ğŸŒ](https://github.com/GerHobbelt/FreeFileSync) -- a folder comparison and synchronization application that creates and manages backup copies of all your important files. Instead of copying every file every time, FreeFileSync determines the differences between a source and a target folder and transfers only the minimum amount of data needed. FreeFileSync is available for Windows, macOS, and Linux.
- **freeglut** [ğŸ“](../../thirdparty/freeglut) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-freeglut) -- Freeglut, the Free OpenGL Utility Toolkit, is meant to be a free alternative to Mark Kilgard's GLUT library. In short, freeglut can be used by OpenGL programs to perform those tasks which would normally require platform-specific code. Tasks like creating a window, creating an OpenGL context and binding it to the window, and processing input events. Freeglut provides a concise and elegant API to handle those tasks, in a platform-independent manner, keeping the application simple and portable.
- **freetype** [ğŸ“](../../thirdparty/freetype) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-freetype2) -- FreeType is a freely available software library to render fonts.
- **fribidi** [ğŸ“](./fribidi) [ğŸŒ](https://github.com/GerHobbelt/fribidi) -- GNU FriBidi: the Free Implementation of the [Unicode Bidirectional Algorithm]. One of the missing links stopping the penetration of free software in Middle East is the lack of support for the Arabic and Hebrew alphabets. In order to have proper Arabic and Hebrew support, the bidi algorithm needs to be implemented. It is our hope that this library will stimulate more free software in the Middle Eastern countries.
- **friso** [ğŸ“](./friso) [ğŸŒ](https://github.com/GerHobbelt/friso) -- high performance Chinese tokenizer with both GBK and UTF-8 charset support based on MMSEG algorithm.
- **frozen** [ğŸ“](./frozen) [ğŸŒ](https://github.com/GerHobbelt/frozen) -- provides 0 cost initialization for immutable containers, fixed-size containers, and various algorithms.
- **fsst** [ğŸ“](./fsst) [ğŸŒ](https://github.com/GerHobbelt/fsst) -- Fast Static Symbol Table (FSST): fast text compression that allows random access. See also the PVLDB paper https://github.com/cwida/fsst/raw/master/fsstcompression.pdf. FSST is a compression scheme focused on string/text data: it can compress strings from distributions with many different values (i.e. where dictionary compression will not work well). It allows *random-access* to compressed data: it is not block-based, so individual strings can be decompressed without touching the surrounding data in a compressed block. When compared to e.g. LZ4 (which is block-based), FSST further achieves similar decompression speed and compression speed, and better compression ratio. FSST encodes strings using a symbol table -- but it works on pieces of the string, as it maps "symbols" (1-8 byte sequences) onto "codes" (single-bytes). FSST can also represent a byte as an exception (255 followed by the original byte). Hence, compression transforms a sequence of bytes into a (supposedly shorter) sequence of codes or escaped bytes. These shorter byte-sequences could be seen as strings again and fit in whatever your program is that manipulates strings. An optional 0-terminated mode (like, C-strings) is also supported.
- **fswatch** [ğŸ“](./fswatch) [ğŸŒ](https://github.com/GerHobbelt/fswatch) -- a cross-platform file change monitor that receives notifications when the contents of the specified files or directories are modified.
- **fuzzy-match** [ğŸ“](./fuzzy-match) [ğŸŒ](https://github.com/GerHobbelt/fuzzy-match) -- `FuzzyMatch-cli` is a commandline utility allowing to compile FuzzyMatch indexes and use them to lookup fuzzy matches. Okapi BM25 prefiltering is available on branch [`bm25`](https://github.com/SYSTRAN/fuzzy-match/tree/bm25).
- **fxt** [ğŸ“](./fxt) [ğŸŒ](https://github.com/GerHobbelt/fxt) -- a large scale feature extraction tool for text-based machine learning.
- **g2o** [ğŸ“](./g2o) [ğŸŒ](https://github.com/GerHobbelt/g2o) -- General Graph Optimization (G2O)is a C++ framework for optimizing graph-based nonlinear error functions. g2o has been designed to be easily extensible to a wide range of problems and a new problem typically can be specified in a few lines of code. The current implementation provides solutions to several variants of SLAM and BA.
- **g3log** [ğŸ“](./g3log) [ğŸŒ](https://github.com/GerHobbelt/g3log) -- G3log is an asynchronous logger with three main features: 
  
  1. Intuitive `LOG(...)` API
  2. `Design-by-contract` `CHECK(...)` functionality
  3. Fatal crash handling for graceful shutdown of the logged process without loosing any log details up to the point of the crash.

- **gbenchmark** [ğŸ“](./gbenchmark) [ğŸŒ](https://github.com/GerHobbelt/benchmark) -- a library to benchmark code snippets, similar to unit tests.
- **gcem** [ğŸ“](./gcem) [ğŸŒ](https://github.com/GerHobbelt/gcem) -- GCE-Math (**G**eneralized **C**onstant **E**xpression Math) is a templated C++ library enabling compile-time computation of mathematical functions.
- **gdbm** [ğŸ“](./gdbm) [ğŸŒ](https://github.com/GerHobbelt/gdbm) -- GNU dbm is a set of NoSQL database routines that use extendable hashing and works similar to the standard UNIX `dbm` routines.
- **gegl** [ğŸ“](./gegl) [ğŸŒ](https://github.com/GerHobbelt/gegl) -- *GEGL* (Generic Graphics Library) is a data flow based image processing framework, providing floating point processing and non-destructive image processing capabilities to [GNU Image Manipulation Program](http://www.gimp.org/) and other projects. With GEGL you chain together processing operations to represent the desired image processing pipeline. GEGL provides operations for image loading and storing, color adjustments, GIMPs artistic filters and more forms of image processing GEGL can be used on the command-line with the same syntax that can be used for creating processing flows interactively with text from GIMP using gegl-graph.
- **gencolormap** [ğŸ“](./gencolormap) [ğŸŒ](https://github.com/GerHobbelt/gencolormap) -- generate color maps for visualization. A variety of methods for sequential, diverging, and qualitative maps is available.
- **genieclust** [ğŸ“](./genieclust) [ğŸŒ](https://github.com/GerHobbelt/genieclust) -- a faster and more powerful version of *Genie* (Fast and Robust Hierarchical Clustering with Noise Point Detection) â€“ a robust and outlier resistant clustering algorithm (see Gagolewski, Bartoszuk, Cena, 2016).
- **getopt** [ğŸ“](./getopt) [ğŸŒ](https://github.com/GerHobbelt/getopt_port) -- an original implementation of `getopt` and `getopt_long` with limited GNU extensions. Provided under the BSD license, to allow non-GPL projects to use `getopt`-style command-line parsing.
- **gettext** [ğŸ“](./gettext) [ğŸŒ](https://github.com/GerHobbelt/gettext) -- the GNU gettext package.  It is interesting for authors or maintainers of other packages or programs which they want to see internationalized.  As one step the handling of messages in different languages should be implemented.  For this task GNU gettext provides the needed tools and library functions. It is also interesting for translators, because GNU gettext provides the 'msgmerge' program, which prepares a message catalog before a translation update.
- **gflags** [ğŸ“](./gflags) [ğŸŒ](https://github.com/GerHobbelt/gflags) -- google::flags library, used by other libs in this set.
- **gibbs-lda** [ğŸ“](./gibbs-lda) [ğŸŒ](https://github.com/GerHobbelt/gibbs-lda) -- modified GibbsLDA++: A C/C++ Implementation of Latent Dirichlet Allocation by by Xuan-Hieu Phan and Cam-Tu Nguyen.
- **giflib-turbo** [ğŸ“](./giflib-turbo) [ğŸŒ](https://github.com/GerHobbelt/giflib-turbo) -- GIFLIB-Turbo is a faster drop-in replacement for GIFLIB. The original GIF codecs were written for a much different world and took great pains to use as little memory as possible and to accommodate a slow and unreliable input stream of data. Those constraints are no longer a problem for the vast majority of users and they were hurting the performance. Another feature holding back the performance of the original GIFLIB was that the original codec was designed to work with image data a line at a time and used a separate LZW dictionary to manage the strings of repeating symbols. My codec uses the output image as the dictionary; this allows much faster 'unwinding' of the codes since they are all stored in the right direction to just be copied to the new location.
- **glaze** [ğŸ“](./glaze) [ğŸŒ](https://github.com/GerHobbelt/glaze) -- one of the fastest JSON libraries in the world. Glaze reads and writes from object memory, simplifying interfaces and offering incredible performance. Glaze also supports [BEVE](https://github.com/beve-org/beve) (binary efficient versatile encoding), CSV (comma separated value) and Binary data through the same API for maximum performance
- **glfw** [ğŸ“](./glfw) [ğŸŒ](https://github.com/GerHobbelt/glfw) -- GLFW is an Open Source, multi-platform library for OpenGL, OpenGL ES and Vulkan application development.  It provides a simple, platform-independent API for creating windows, contexts and surfaces, reading input, handling events, etc.
- **glib2** [ğŸ“](./glib2) [ğŸŒ](https://github.com/GerHobbelt/glib) -- GLib is the low-level core library that forms the basis for projects such as GTK and GNOME.
- **glm** [ğŸ“](./glm) [ğŸŒ](https://github.com/GerHobbelt/glm) -- [OpenGL Mathematics](http://glm.g-truc.net/) (*GLM*) is a header only C++ mathematics library for graphics software based on the [OpenGL Shading Language (GLSL) specifications](https://www.opengl.org/registry/doc/GLSLangSpec.4.50.diff.pdf). *GLM* provides classes and functions designed and implemented with the same naming conventions and functionality than *GLSL* so that anyone who knows *GLSL*, can use *GLM* as well in C++.
- **glob** [ğŸ“](./glob) [ğŸŒ](https://github.com/GerHobbelt/glob) -- directory scanner
- **glog** [ğŸ“](./glog) [ğŸŒ](https://github.com/GerHobbelt/glog) -- Google Logging is a C++98 library that implements application-level logging. The library provides logging APIs based on C++-style streams and various helper macros.
- **glyph_name** [ğŸ“](./glyph_name) [ğŸŒ](https://github.com/GerHobbelt/glyph_name) -- a library for computing Unicode sequences from glyph names according to the Adobe Glyph Naming convention: https://github.com/adobe-type-tools/agl-specification
- **gmic** [ğŸ“](./gmic) [ğŸŒ](https://github.com/GerHobbelt/gmic) -- a Full-Featured Open-Source Framework for Image Processing. It provides several different **[user interfaces](https://en.wikipedia.org/wiki/User_interface)** to convert/manipulate/filter/visualize **generic image datasets**, ranging from _1d scalar signals_ to _3d+t sequences of multi-spectral volumetric images_, hence including _2d color images_.
- **gmic-community** [ğŸ“](./gmic-community) [ğŸŒ](https://github.com/GerHobbelt/gmic-community) -- community contributions for the GMIC Full-Featured Open-Source Framework for Image Processing. It provides several different **[user interfaces](https://en.wikipedia.org/wiki/User_interface)** to convert/manipulate/filter/visualize **generic image datasets**, ranging from _1d scalar signals_ to _3d+t sequences of multi-spectral volumetric images_, hence including _2d color images_.
- **GMM-HMM-kMeans** [ğŸ“](./GMM-HMM-kMeans) [ğŸŒ](https://github.com/GerHobbelt/KMeans-GMM-HMM) -- HMM based on KMeans and GMM
- **GMMreg** [ğŸ“](./GMMreg) [ğŸŒ](https://github.com/GerHobbelt/Project_gmmreg) -- implementations of the robust point set registration framework described in the paper "[Robust Point Set Registration Using Gaussian Mixture Models](https://github.com/bing-jian/gmmreg/blob/master/gmmreg_PAMI_preprint.pdf)", Bing Jian and Baba C. Vemuri, IEEE Transactions on Pattern Analysis and Machine Intelligence, 2011, 33(8), pp. 1633-1645. An earlier conference version of this work, "A Robust Algorithm for Point Set Registration Using Mixture of Gaussians, Bing Jian and Baba C. Vemuri.", appeared in the proceedings of ICCV'05.
- **gmt** [ğŸ“](./gmt) [ğŸŒ](https://github.com/GerHobbelt/gmt) -- GMT (Generic Mapping Tools) is an open source collection of about 100 command-line tools for manipulating geographic and Cartesian data sets (including filtering, trend fitting, gridding, projecting, etc.) and producing high-quality illustrations ranging from simple x-y plots via contour maps to artificially illuminated surfaces, 3D perspective views and animations. The GMT supplements add another 50 more specialized and discipline-specific tools. GMT supports over 30 map projections and transformations and requires support data such as [GSHHG](http://www.soest.hawaii.edu/pwessel/gshhg/) coastlines, rivers, and political boundaries and optionally [DCW](http://www.soest.hawaii.edu/pwessel/dcw) country polygons.
- **gnuplot** [ğŸ“](./gnuplot) [ğŸŒ](https://github.com/GerHobbelt/gnuplot) -- the Gnuplot Plotting Utility is a command-line driven interactive function plotting utility for linux, OSX, MSWin, VMS, and many other platforms. Gnuplot handles both curves (2 dimensions) and surfaces (3 dimensions). Surfaces can be plotted as a mesh fitting the specified function, floating in the 3-d coordinate space, or as a contour plot on the x-y plane. For 2-d plots, there are also many plot styles including lines, points, boxes, heat maps, stacked histograms, and contoured projections of 3D data. Graphs may be labeled with arbitrary labels and arrows, axis labels, a title, date and time, and a key.  The interface includes command-line editing and history on most platforms.
- **gnuplot_i** [ğŸ“](./gnuplot_i) [ğŸŒ](https://github.com/GerHobbelt/gnuplot_i) -- gnuplot C interface library enables developers to create [gnuplots](http://www.gnuplot.info/) directly from their C programs.
- **gnuplot-palettes** [ğŸ“](./gnuplot-palettes) [ğŸŒ](https://github.com/GerHobbelt/gnuplot-palettes) -- color palettes for gnuplot.
- **GoldFish-CBOR** [ğŸ“](./GoldFish-CBOR) [ğŸŒ](https://github.com/GerHobbelt/GoldFish) -- a fast JSON and CBOR streaming library, without using memory. GoldFish can parse and generate very large [JSON](http://json.org) or [CBOR](http://cbor.io) documents. It has some similarities to a [SAX](https://en.wikipedia.org/wiki/Simple_API_for_XML) parser, but doesn't use an event driven API, instead the user of the GoldFish interface is in control. GoldFish intends to be the easiest and one of the fastest JSON and CBOR streaming parser and serializer to use.
- **google-diff-match-patch** [ğŸ“](./google-diff-match-patch) [ğŸŒ](https://github.com/GerHobbelt/diff-match-patch) -- Diff, Match and Patch offers robust algorithms to perform the operations required for synchronizing plain text.
  
  1. Diff:
     * Compare two blocks of plain text and efficiently return a list of differences.
  2. Match:
     * Given a search string, find its best fuzzy match in a block of plain text. Weighted for both accuracy and location.
  3. Patch:
     * Apply a list of patches onto plain text. Use best-effort to apply patch even when the underlying text doesn't match.
  
  Originally built in 2006 to power Google Docs.

- **google::marl** [ğŸ“](./google-marl) [ğŸŒ](https://github.com/GerHobbelt/marl) -- a hybrid thread / fiber task scheduler written in C++ 11. Marl uses a combination of fibers and threads to allow efficient execution of tasks that can block, while keeping a fixed number of hardware threads.
- **googletest** [ğŸ“](./googletest) [ğŸŒ](https://github.com/GerHobbelt/googletest) -- unit test framework: see the [GoogleTest User's Guide](https://google.github.io/googletest/) for documentation. We recommend starting with the [GoogleTest Primer](https://google.github.io/googletest/primer.html).
  
  Features:
  
  * An [xUnit](https://en.wikipedia.org/wiki/XUnit) test framework.
  * Test discovery.
  * A rich set of assertions.
  * User-defined assertions.
  * Death tests.
  * Fatal and non-fatal failures.
  * Value-parameterized tests.
  * Type-parameterized tests.
  * Various options for running the tests.
  * XML test report generation.

- **gperf-hash** [ğŸ“](./gperf-hash) [ğŸŒ](https://github.com/GerHobbelt/gperf) -- This is GNU gperf, a program that generates C/C++ perfect hash functions for sets of key words.
- **GQ-gumbo-css-selectors** [ğŸ“](./GQ-gumbo-css-selectors) [ğŸŒ](https://github.com/GerHobbelt/GQ) -- GQ is a CSS Selector Engine for [Gumbo Parser](https://github.com/google/gumbo-parser) written in C++11. Using Gumbo Parser as a backend, GQ can parse input HTML and allow users to select and modify elements in the parsed document with CSS Selectors and the provided simple, but powerful mutation API.
- **gram_savitzky_golay** [ğŸ“](./gram_savitzky_golay) [ğŸŒ](https://github.com/GerHobbelt/gram_savitzky_golay) -- Savitzky-Golay filtering based on Gram polynomials, as described in [General Least-Squares Smoothing and Differentiation by the Convolution (Savitzky-Golay) Method](http://pubs.acs.org/doi/pdf/10.1021/ac00205a007)
- **GraphBLAS** [ğŸ“](./GraphBLAS) [ğŸŒ](https://github.com/GerHobbelt/GraphBLAS) -- SuiteSparse:GraphBLAS is a complete implementation of the GraphBLAS standard, which defines a set of sparse matrix operations on an extended algebra of semirings using an almost unlimited variety of operators and types.  When applied to sparse adjacency matrices, these algebraic operations are equivalent to computations on graphs.  GraphBLAS provides a powerful and expressive framework for creating graph algorithms based on the elegant mathematics of sparse matrix operations on a semiring.
- **graph-coloring** [ğŸ“](./graph-coloring) [ğŸŒ](https://github.com/GerHobbelt/graph-coloring) -- a C++ Graph Coloring Package. This project has two primary uses:
  
  * As an executable for finding the chromatic number for an input graph (in edge list or edge matrix format)
  * As a library for finding the particular coloring of an input graph (represented as a `map<string,vector<string>>` edge list)

- **GraphicsMagick** [ğŸ“](./GraphicsMagick) [ğŸŒ](https://github.com/GerHobbelt/graphicsmagick) -- provides a comprehensive collection of utilities, programming interfaces, and GUIs, to support file format conversion, image processing, and 2D vector rendering. GraphicsMagick is originally based on ImageMagick from ImageMagick Studio (which was originally written by John Cristy at Dupont). The goal of GraphicsMagick is to provide the highest quality product possible while encouraging open and active participation from all interested developers.
- **graphit** [ğŸ“](./graphit) [ğŸŒ](https://github.com/GerHobbelt/graphit) -- a High-Performance Domain Specific Language for Graph Analytics.
- **grok-jpeg2000** [ğŸ“](./grok-jpeg2000) [ğŸŒ](https://github.com/GerHobbelt/grok) -- World's Leading Open Source JPEG 2000 Codec
  
  Features:
  
  * support for new **High Throughput JPEG 2000 (HTJ2K)** standard
  * fast random-access sub-image decoding using `TLM` and `PLT` markers
  * full encode/decode support for `ICC` colour profiles
  * full encode/decode support for `XML`,`IPTC`, `XMP` and `EXIF` meta-data
  * full encode/decode support for `monochrome`, `sRGB`, `palette`, `YCC`, `extended YCC`, `CIELab` and `CMYK` colour spaces
  * full encode/decode support for `JPEG`,`PNG`,`BMP`,`TIFF`,`RAW`,`PNM` and `PAM` image formats
  * full encode/decode support for 1-16 bit precision images

- **groonga** [ğŸ“](./groonga) [ğŸŒ](https://github.com/GerHobbelt/groonga) -- an open-source fulltext search engine and column store.
- **GSL** [ğŸ“](./GSL) [ğŸŒ](https://github.com/GerHobbelt/GSL) -- the Guidelines Support Library (GSL) contains functions and types that are suggested for use by the [C++ Core Guidelines](https://github.com/isocpp/CppCoreGuidelines) maintained by the [Standard C++ Foundation](https://isocpp.org). This repo contains Microsoft's implementation of GSL.
- **gtn** [ğŸ“](./gtn) [ğŸŒ](https://github.com/GerHobbelt/gtn) -- GTN (Automatic Differentiation with WFSTs) is a framework for automatic differentiation with weighted finite-state transducers. The goal of GTN is to make adding and experimenting with structure in learning algorithms much simpler. This structure is encoded as weighted automata, either acceptors (WFSAs) or transducers (WFSTs). With `gtn` you can dynamically construct complex graphs from operations on simpler graphs. Automatic differentiation gives gradients with respect to any input or intermediate graph with a single call to `gtn.backward`.
- **gtsam** [ğŸ“](./gtsam) [ğŸŒ](https://github.com/GerHobbelt/gtsam) -- Georgia Tech Smoothing and Mapping Library (GTSAM) is a C++ library that implements smoothing and mapping (SAM) in robotics and vision, using Factor Graphs and Bayes Networks as the underlying computing paradigm rather than sparse matrices.
- **guetzli** [ğŸ“](./guetzli) [ğŸŒ](https://github.com/GerHobbelt/guetzli) -- a JPEG encoder that aims for excellent compression density at high visual quality. Guetzli-generated images are typically 20-30% smaller than images of equivalent quality generated by libjpeg. Guetzli generates only sequential (nonprogressive) JPEGs due to faster decompression speeds they offer.
- **guile** [ğŸ“](./guile) [ğŸŒ](https://github.com/GerHobbelt/guile) -- Guile is Project GNU's extension language library. Guile is an implementation of the Scheme programming language, packaged as a library that can be linked into applications to give them their own extension language.  Guile supports other languages as well, giving users of Guile-based applications a choice of languages.
- **gumbo-libxml** [ğŸ“](./gumbo-libxml) [ğŸŒ](https://github.com/GerHobbelt/gumbo-libxml) -- LibXML2 bindings for the Gumbo HTML5 parser: this provides a libxml2 API on top of the Gumbo parser.  It lets you use a modern parser - Gumbo now passes all html5lib tests, including the template tag, and should be fully conformant with the HTML5 spec - with the full ecosystem of libxml tools, including XPath, tree modification, DTD validation, etc.
- **gumbo-parser** [ğŸ“](../../thirdparty/gumbo-parser) [ğŸŒ](https://github.com/GerHobbelt/gumbo-parser) -- HTML parser
- **gumbo_pp** [ğŸ“](./gumbo_pp) [ğŸŒ](https://github.com/GerHobbelt/gumbo_pp) -- a C++ wrapper over Gumbo that provides a higher level query mechanism.
- **gumbo-query** [ğŸ“](./gumbo-query) [ğŸŒ](https://github.com/GerHobbelt/gumbo-query) -- HTML DOM access in C/C++
- **h5cpp** [ğŸ“](./h5cpp) [ğŸŒ](https://github.com/GerHobbelt/h5cpp) -- easy to use HDF5 C++ templates for Serial and Paralel HDF5. Hierarchical Data Format HDF5 is prevalent in high performance scientific computing, sits directly on top of sequential or parallel file systems, providing block and stream operations on standardized or custom binary/text objects. Scientific computing platforms come with the necessary libraries to read write HDF5 dataset. H5CPP simplifies interactions with popular linear algebra libraries, provides compiler assisted seamless object persistence, Standard Template Library support and comes equipped with a novel error handling architecture.
  
  - **in-purgatory**; reason: see the `HDF5` entry below. But advertises to be an interface between OpenCV, Eigen, etc. at the same time...

- **Hackers-Delight** [ğŸ“](./Hackers-Delight) [ğŸŒ](https://github.com/GerHobbelt/Hackers-Delight) -- the code to accompany the book Hacker's Delight 2nd Edition by Henry S Warren, Jr.  The original package can be found at http://www.hackersdelight.org/
- **half** [ğŸ“](./half) [ğŸŒ](https://github.com/GerHobbelt/half) -- IEEE 754-based half-precision floating point library forked from http://half.sourceforge.net/. This is a C++ header-only library to provide an IEEE 754 conformant 16-bit half-precision floating-point type along with corresponding arithmetic operators, type conversions and common mathematical functions. It aims for both efficiency and ease of use, trying to accurately mimic the behaviour of the built-in floating-point types at the best performance possible.
- **harbour-core** [ğŸ“](./harbour-core) [ğŸŒ](https://github.com/GerHobbelt/core) -- Harbour is the free software implementation of a multi-platform, multi-threading, object-oriented, scriptable programming language, backward compatible with Clipper/xBase. Harbour consists of a compiler and runtime libraries with multiple UI and database backends, its own make system and a large collection of libraries and interfaces to many popular APIs.
- **harfbuzz** [ğŸ“](../../thirdparty/harfbuzz) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-harfbuzz) -- a text shaping engine. It primarily supports [OpenType][1], but also [Apple Advanced Typography][2].
- **HashMap** [ğŸ“](./HashMap) [ğŸŒ](https://github.com/GerHobbelt/HashMap) -- a hash table mostly compatible with the C++11 *std::unordered_map* interface, but with much higher performance for many workloads. This hash table uses open addressing with linear probing and backshift deletion. Open addressing and linear probing minimizes memory allocations and achieves high cache efficiency. Backshift deletion keeps performance high for delete heavy workloads by not clobbering the hash table with tombestones.
- **hdbscan** [ğŸ“](./hdbscan) [ğŸŒ](https://github.com/GerHobbelt/hdbscan) -- a fast parallel implementation for HDBSCAN* [[1]](https://dl.acm.org/doi/10.1145/2733381) (hierarchical DBSCAN). The implementation stems from our parallel algorithms [[2]](https://arxiv.org/pdf/2104.01126.pdf) developed at MIT, and presented at SIGMOD 2021. Our approach is based on generating a well-separated pair decomposition followed by using Kruskal's minimum spanning tree algorithm and bichromatic closest pair computations. We also give a new parallel divide-and-conquer algorithm for computing the dendrogram, which are used in visualizing clusters of different scale that arise for HDBSCAN*.
- **hdbscan-cpp** [ğŸ“](./hdbscan-cpp) [ğŸŒ](https://github.com/GerHobbelt/hdbscan-cpp) -- Fast and Efficient Implementation of HDBSCAN in C++ using STL. HDBSCAN - Hierarchical Density-Based Spatial Clustering of Applications with Noise. Performs DBSCAN over varying epsilon values and integrates the result to find a clustering that gives the best stability over epsilon. This allows HDBSCAN to find clusters of varying densities (unlike DBSCAN), and be more robust to parameter selection. In practice this means that HDBSCAN returns a good clustering straight away with little or no parameter tuning -- and the primary parameter, minimum cluster size, is intuitive and easy to select. HDBSCAN is ideal for exploratory data analysis; it's a fast and robust algorithm that you can trust to return meaningful clusters (if there are any).
- **HDiffPatch** [ğŸ“](./HDiffPatch) [ğŸŒ](https://github.com/GerHobbelt/HDiffPatch) -- a library and command-line tools for Diff & Patch between binary files or directories(folders); cross-platform; runs fast; create small delta/differential; support large files and limit memory requires when diff & patch.
- **hedley** [ğŸ“](./hedley) [ğŸŒ](https://github.com/GerHobbelt/hedley) -- a C/C++ header file designed to smooth over some platform-specific annoyances.
- **hescape** [ğŸ“](./hescape) [ğŸŒ](https://github.com/GerHobbelt/hescape) -- a C library for fast HTML escape using SSE instruction, `pcmpestri`. Hescape provides only one API, `hesc_escape_html()`.
- **highway** [ğŸ“](./highway) [ğŸŒ](https://github.com/GerHobbelt/highway) -- dependency of JpegXL
- **highwayhash** [ğŸ“](./highwayhash) [ğŸŒ](https://github.com/GerHobbelt/highwayhash) -- Fast strong hash functions: SipHash/HighwayHash
- **hikyuu** [ğŸ“](./hikyuu) [ğŸŒ](https://github.com/GerHobbelt/hikyuu) -- Hikyuu Quant Framework is an open source quantitative trading research framework based on C++/Python, which is used for strategy analysis and backtesting. Its core idea is based on the current mature systematic trading method, which abstracts the entire systematic trading into judging strategies based on market environment, system effective conditions, signal indicators, stop loss/take profit strategies, fund management strategies, profit target strategies, slippage There are seven components of the price difference algorithm. You can build the strategy asset library of these components separately, and freely combine them in actual research to observe the effectiveness, stability of the system and the effect of a single type of strategy.
- **hilbert_curves** [ğŸ“](./hilbert_curves) [ğŸŒ](https://github.com/GerHobbelt/hilbert_curves) -- the world's fastest implementations of 2D and 3D hilbert curve functions.
- **hilbert_hpp** [ğŸ“](./hilbert_hpp) [ğŸŒ](https://github.com/GerHobbelt/hilbert_hpp) -- contains two implementations of the hilbert curve encoding & decoding algorithm described by John Skilling in his paper "Programming the Hilbert Curve".
- **hmm-scalable** [ğŸ“](./hmm-scalable) [ğŸŒ](https://github.com/GerHobbelt/hmm-scalable) -- a Tool for fitting Hidden Markov Models models at scale. In particular, it is targeting a specific kind of HMM used in education called Bayesian Knowledge Tracing (BKT) model.
- **hmm-stoch** [ğŸ“](./hmm-stoch) [ğŸŒ](https://github.com/GerHobbelt/StochHMM) -- StochHMM - A Flexible hidden Markov model application and C++ library that implements HMM from simple text files.   It implements traditional HMM algorithms in addition to providing additional flexibility.  The additional flexibility is achieved by allowing researchers to integrate additional data sources and application code into the HMM framework.
- **hnswlib** [ğŸ“](./hnswlib) [ğŸŒ](https://github.com/GerHobbelt/hnswlib) -- fast approximate nearest neighbor search. Header-only C++ HNSW implementation with python bindings.
- **hocr-fileformat** [ğŸ“](./hocr-fileformat) [ğŸŒ](https://github.com/GerHobbelt/ocr-fileformat) -- tools to alidate and transform between OCR file formats (hOCR, ALTO, PAGE, FineReader)
- **hocr-spec** [ğŸ“](./hocr-spec) [ğŸŒ](https://github.com/GerHobbelt/hocr-spec) -- the [hOCR](https://en.wikipedia.org/wiki/HOCR) Embedded OCR Workflow and Output Format specification originally written by [Thomas Breuel](https://github.com/tmbdev).
- **hocr-tools** [ğŸ“](./hocr-tools) [ğŸŒ](https://github.com/GerHobbelt/hocr-tools) -- a [Public Specification](http://hocr.info) and tools for the hOCR Format.
  
  hOCR is a format for representing OCR output, including layout information, character confidences, bounding boxes, and style information. It embeds this information invisibly in standard HTML. By building on standard HTML, it automatically inherits well-defined support for most scripts, languages, and common layout options. Furthermore, unlike previous OCR formats, the recognized text and OCR-related information co-exist in the same file and survives editing and manipulation. hOCR markup is independent of the presentation.

- **honggfuzz** [ğŸ“](./honggfuzz) [ğŸŒ](https://github.com/GerHobbelt/honggfuzz) -- a security oriented, feedback-driven, evolutionary, easy-to-use fuzzer with interesting analysis options.
- **hopscotch-map** [ğŸ“](./hopscotch-map) [ğŸŒ](https://github.com/GerHobbelt/hopscotch-map) -- a C++ implementation of a fast hash map and hash set using hopscotch hashing and open-addressing to resolve collisions. It is a cache-friendly data structure offering better performances than `std::unordered_map` in most cases and is closely similar to `google::dense_hash_map` while using less memory and providing more functionalities.
- **horsejs** [ğŸ“](./horsejs) [ğŸŒ](https://github.com/GerHobbelt/horsejs) -- a framework similar to Electron. Unlike Electron, it has no built-in Node.js, but directly uses C++ to provide most of Electron's capabilities, such as accessing files using JavaScript, opening dialog boxes, creating new windows, etc. Since there is no Node.js, HorseJs runs faster, uses less memory, and is more stable.
- **houdini** [ğŸ“](./houdini) [ğŸŒ](https://github.com/GerHobbelt/houdini) -- Houdini - The Escapist: is zero-dependency and modular. Houdini is a simple API for escaping text for the web. And unescaping it. HTML escaping follows the OWASP suggestion. All other entities are left as-is. HTML unescaping is fully RFC-compliant. Yes, that's the 253 different entities for you, and decimal/hex code point specifiers. URI escaping and unescaping is fully RFC-compliant. URL escaping and unescaping is the same as generic URIs, but spaces are changed to `+`.
- **hsluv-c** [ğŸ“](./hsluv-c) [ğŸŒ](https://github.com/GerHobbelt/hsluv-c) -- HSLuv (revision 4) is a human-friendly alternative to HSL. HSLuv is very similar to CIELUV, a color space designed for perceptual uniformity based on human experiments. When accessed by polar coordinates, it becomes functionally similar to HSL with a single problem: its chroma component doesn't fit into a specific range. HSLuv extends CIELUV with a new saturation component that allows you to span all the available chroma as a neat percentage.
- **hsluv-color-gradient** [ğŸ“](./hsluv-color-gradient) [ğŸŒ](https://github.com/GerHobbelt/hsluv-color-gradient) -- 1D discrete and continous perceptually uniform ordered color gradients rendered in [HSL](https://www.hsluv.org/)
- **html2openxml** [ğŸ“](./html2openxml) [ğŸŒ](https://github.com/GerHobbelt/html2openxml) -- Html2OpenXml is a small .NET library that converts simple or advanced HTML to plain OpenXml components (docx).
- **html5lib-tests** [ğŸ“](./html5lib-tests) [ğŸŒ](https://github.com/GerHobbelt/html5lib-tests) -- testsuite data for html5lib, including the de-facto standard HTML parsing tests.
- **htmlstreamparser** [ğŸ“](./htmlstreamparser) [ğŸŒ](https://github.com/GerHobbelt/htmlstreamparser) -- used in a demo of zsync2
- **http-parser** [ğŸ“](./http-parser) [ğŸŒ](https://github.com/GerHobbelt/http-parser) -- a parser for HTTP messages written in C. It parses both requests and responses. The parser is designed to be used in performance HTTP applications. It does not make any syscalls nor allocations, it does not buffer data, it can be interrupted at anytime. Depending on your architecture, it only requires about 40 bytes of data per message stream (in a web server that is per connection).
- **hunspell** [ğŸ“](./hunspell) [ğŸŒ](https://github.com/GerHobbelt/hunspell) -- a free spell checker and morphological analyzer library and command-line tool, designed for quick and high quality spell checking and correcting for languages with word-level writing system, including languages with rich morphology, complex word compounding and character encoding.
- **hunspell-dictionaries** [ğŸ“](./hunspell-dictionaries) [ğŸŒ](https://github.com/GerHobbelt/dictionaries) -- Collection of normalized and installable [hunspell][] dictionaries.
- **hunspell-hyphen** [ğŸ“](./hunspell-hyphen) [ğŸŒ](https://github.com/GerHobbelt/hyphen) -- hyphenation library to use converted TeX hyphenation patterns with hunspell.
- **hydraquill** [ğŸ“](./hydraquill) [ğŸŒ](https://github.com/GerHobbelt/hydraquill) -- Hydraquill is a simple helper library preparing a selection of Noto fonts for use with a library like Freetype. Our list only contains the regular-weight variable-width sans-serif fonts, which results in 74MiB of raw data for full unicode coverage. The whole package however shrinks down to only 16MiB when compressed with zstd, which is why an archive in this format will be prepared when building examples (the library includes a zstd decoder and is able to unpack it at runtime). The library also provides a way to confirm the existence of unpacked font files and to verify their integrity using sha256 checksums.
- **hyperscan** [ğŸ“](./hyperscan) [ğŸŒ](https://github.com/GerHobbelt/hyperscan) -- Hyperscan is a high-performance multiple regex matching library.
- **hypertextcpp** [ğŸ“](./hypertextcpp) [ğŸŒ](https://github.com/GerHobbelt/hypertextcpp) -- string/text template engine & source-to-source compiler.
- **iceberghashtable** [ğŸ“](./iceberghashtable) [ğŸŒ](https://github.com/GerHobbelt/iceberghashtable) -- [IcebergDB: High Performance Hash Tables Through Stability and Low Associativity](https://arxiv.org/abs/2210.04068) is a fast, concurrent, and resizeable hash table implementation. It supports insertions, deletions and queries for 64-bit keys and values.
- **iceoryx** [ğŸ“](./iceoryx) [ğŸŒ](https://github.com/GerHobbelt/iceoryx) -- true zero-copy inter-process-communication. iceoryx is an inter-process-communication (IPC) middleware for various operating systems (currently we support Linux, macOS, QNX, FreeBSD and Windows 10). It has its origins in the automotive industry, where large amounts of data have to be transferred between different processes when it comes to driver assistance or automated driving systems. However, the efficient communication mechanisms can also be applied to a wider range of use cases, e.g. in the field of robotics or game development.
- **icer_compression** [ğŸ“](./icer_compression) [ğŸŒ](https://github.com/GerHobbelt/icer_compression) -- implements the NASA ICER image compression algorithm as a C library. Said compression algorithm is a progressive, wavelet-based image compression algorithm designed to be resistant to data loss, making it suitable for use as the image compression algorithm when encoding images to be transmitted over unreliable delivery channels, such as those in satellite radio communications.
- **IconFontCppHeaders** [ğŸ“](./IconFontCppHeaders) [ğŸŒ](https://github.com/GerHobbelt/IconFontCppHeaders) -- provides C and C++ headers, among others, for icon fonts Font Awesome, Fork Awesome, Google Material Design, Pictogrammers Material Design icons, Kenney game icons, Fontaudio, Codicons and Lucide. Useful in UI applications such as ones built in Dear ImGui.
- **id3-tagparser** [ğŸ“](./id3-tagparser) [ğŸŒ](https://github.com/GerHobbelt/tagparser) -- a C++ library for reading and writing MP4 (iTunes), ID3, Vorbis, Opus, FLAC and Matroska tags.
- **IdGenerator** [ğŸ“](./IdGenerator) [ğŸŒ](https://github.com/GerHobbelt/IdGenerator) -- a digital ID generator using the snowflake algorithm, developed in response to the performance problems that often occur. Example use is when you, as an architecture designer, want to solve the problem of unique database primary keys, especially in multi-database distributed systems. You want the primary key of the data table to use the least storage space, while the index speed and the Select, Insert, and Update queries are fast. Meanwhile there may be more than 50 application instances, and each concurrent request can reach 10W/s. You do not want to rely on the auto-increment operation of redis to obtain continuous primary key IDs, because continuous IDs pose business data security risks.
- **ifopt** [ğŸ“](./ifopt) [ğŸŒ](https://github.com/GerHobbelt/ifopt) -- a modern, light-weight, [Eigen]-based C++ interface to Nonlinear Programming solvers, such as Ipopt and Snopt.
- **ikd-Tree** [ğŸ“](./ikd-Tree) [ğŸŒ](https://github.com/GerHobbelt/ikd-Tree) -- an incremental k-d tree designed for robotic applications. The ikd-Tree incrementally updates a k-d tree with new coming points only, leading to much lower computation time than existing static k-d trees. Besides point-wise operations, the ikd-Tree supports several features such as box-wise operations and down-sampling that are practically useful in robotic applications.
- **imagedistance** [ğŸ“](./imagedistance) [ğŸŒ](https://github.com/GerHobbelt/imagedistance) -- given two images, calculate their distance in several criteria.
- **imagehash** [ğŸ“](./imagehash) [ğŸŒ](https://github.com/GerHobbelt/imagehash) -- an image hashing library written in Python. ImageHash supports Average hashing, Perceptual hashing, Difference hashing, Wavelet hashing, HSV color hashing (colorhash) and Crop-resistant hashing. The image hash algorithms (average, perceptual, difference, wavelet) analyse the image structure on luminance (without color information). The color hash algorithm analyses the color distribution and black & gray fractions (without position information).
- **ImageMagick** [ğŸ“](./ImageMagick) [ğŸŒ](https://github.com/GerHobbelt/ImageMagick) -- [ImageMagickÂ®](https://imagemagick.org/) can create, edit, compose, or convert digital images. It can read and write images in a variety of formats (over 200) including PNG, JPEG, GIF, WebP, HEIC, SVG, PDF, DPX, EXR, and TIFF. ImageMagick can resize, flip, mirror, rotate, distort, shear and transform images, adjust image colors, apply various special effects, or draw text, lines, polygons, ellipses, and BÃ©zier curves.
- **Imath** [ğŸ“](./Imath) [ğŸŒ](https://github.com/GerHobbelt/Imath) -- a basic, light-weight, and efficient C++ representation of 2D and 3D vectors and matrices and other simple but useful mathematical objects, functions, and data types common in computer graphics applications, including the â€œhalfâ€ 16-bit floating-point type.
- **IMGUR5K-Handwriting-Dataset** [ğŸ“](./IMGUR5K-Handwriting-Dataset) [ğŸŒ](https://github.com/GerHobbelt/IMGUR5K-Handwriting-Dataset) -- the IMGUR5K Handwriting Dataset for OCR/image preprocessing benchmarks.
- **indicators** [ğŸ“](./indicators) [ğŸŒ](https://github.com/GerHobbelt/indicators) -- thread-safe progress bars and spinners for console applications.
- **InferenceHelper** [ğŸ“](./InferenceHelper) [ğŸŒ](https://github.com/GerHobbelt/InferenceHelper) -- a wrapper of deep learning frameworks especially for inference. This class provides a common interface to use various deep learnig frameworks, so that you can use the same application code.
- **infoware** [ğŸ“](./infoware) [ğŸŒ](https://github.com/GerHobbelt/infoware) -- C++ Library for pulling system and hardware information, without hitting the command line.
- **InversePerspectiveMapping** [ğŸ“](./InversePerspectiveMapping) [ğŸŒ](https://github.com/GerHobbelt/InversePerspectiveMapping) -- C++ class for the computation of plane-to-plane homographies, aka bird's-eye view or IPM, particularly relevant in the field of Advanced Driver Assistance Systems.
- **iODBC** [ğŸ“](./iODBC) [ğŸŒ](https://github.com/GerHobbelt/iODBC) -- the iODBC Driver Manager provides you with everything you need to develop ODBC-compliant applications under Unix without having to pay royalties to other parties. An ODBC driver is still needed to affect your connection architecture. You may build a driver with the iODBC components or obtain an ODBC driver from a commercial vendor.
- **ion-c** [ğŸ“](./ion-c) [ğŸŒ](https://github.com/GerHobbelt/ion-c) -- a C implementation of the [Ion data notation](http://amzn.github.io/ion-docs). Amazon Ion is a richly-typed, self-describing, hierarchical data serialization format offering interchangeable binary and text representations. The text format (a superset of JSON) is easy to read and author, supporting rapid prototyping. The binary representation is efficient to store, transmit, and skip-scan parse. The rich type system provides unambiguous semantics for long-term preservation of data which can survive multiple generations of software evolution.
- **ipa-dict** [ğŸ“](./ipa-dict) [ğŸŒ](https://github.com/GerHobbelt/ipa-dict) -- Monolingual wordlists with pronunciation information in IPA aims to provide a series of dictionaries consisting of wordlists with accompanying phonemic pronunciation information in International Phonetic Alphabet (IPA) transcription for as many words as possible in as many languages / dialects / variants as possible. The dictionary data is available in a number of human- and machine-readable formats, in order to make it as useful as possible for various other applications.
- **Ipopt** [ğŸ“](./Ipopt) [ğŸŒ](https://github.com/GerHobbelt/Ipopt) -- Ipopt (Interior Point OPTimizer, pronounced eye-pea-Opt) is a software package for large-scale [nonlinear optimization](http://wiki.mcs.anl.gov/NEOS/index.php/Nonlinear_Programming_FAQ). It is designed to find (local) solutions of mathematical optimization problems.
- **iresearch** [ğŸ“](./iresearch) [ğŸŒ](https://github.com/GerHobbelt/iresearch) -- the IResearch search engine is meant to be treated as a standalone index that is capable of both indexing and storing individual values verbatim. Indexed data is treated on a per-version/per-revision basis, i.e. existing data version/revision is never modified and updates/removals are treated as new versions/revisions of the said data. This allows for trivial multi-threaded read/write operations on the index. The index exposes its data processing functionality via a multi-threaded 'writer' interface that treats each document abstraction as a collection of fields to index and/or store. The index exposes its data retrieval functionality via 'reader' interface that returns records from an index matching a specified query. The queries themselves are constructed query trees built directly using the query building blocks available in the API. The querying infrastructure provides the capability of ordering the result set by one or more ranking/scoring implementations. The ranking/scoring implementation logic is plugin-based and lazy-initialized during runtime as needed, allowing for addition of custom ranking/scoring logic without the need to even recompile the IResearch library.
- **itcl** [ğŸ“](./itcl) [ğŸŒ](https://github.com/GerHobbelt/itcl) -- Itcl is an object oriented extension for Tcl.
- **ITK** [ğŸ“](./ITK) [ğŸŒ](https://github.com/GerHobbelt/ITK) -- The Insight Toolkit (ITK) is an open-source, cross-platform toolkit for N-dimensional scientific image processing, segmentation, and registration. Segmentation is the process of identifying and classifying data found in a digitally sampled representation. Typically the sampled representation is an image acquired from such medical instrumentation as CT or MRI scanners. Registration is the task of aligning or developing correspondences between data. For example, in the medical environment, a CT scan may be aligned with a MRI scan in order to combine the information contained in both.
- **itpp** [ğŸ“](./itpp) [ğŸŒ](https://github.com/GerHobbelt/itpp) -- IT++ is a C++ library of mathematical, signal processing and communication classes and functions. Its main use is in simulation of communication systems and for performing research in the area of communications. The kernel of the library consists of generic vector and matrix classes, and a set of accompanying routines. Such a kernel makes IT++ similar to MATLAB or GNU Octave. The IT++ library originates from the former department of Information Theory at the Chalmers University of Technology, Gothenburg, Sweden.
- **ivf-hnsw** [ğŸ“](./ivf-hnsw) [ğŸŒ](https://github.com/GerHobbelt/ivf-hnsw) -- Revisiting the Inverted Indices for Billion-Scale Approximate Nearest Neighbors. This is the code for the current state-of-the-art billion-scale nearest neighbor search system presented in the paper: [Revisiting the Inverted Indices for Billion-Scale Approximate Nearest Neighbors](http://openaccess.thecvf.com/content_ECCV_2018/html/Dmitry_Baranchuk_Revisiting_the_Inverted_ECCV_2018_paper.html) (Dmitry Baranchuk, Artem Babenko, Yury Malkov).
- **JabRef-abbreviations** [ğŸ“](./JabRef-abbreviations) [ğŸŒ](https://github.com/GerHobbelt/jabref-abbreviations) -- Jabref journal name abbreviations: some journal require you to use the abbreviated names for journals. If you have to change this manually, it's quite cumbersome to do. Luckily there exist tools to help. [Jabref](http://jabref.sourceforge.net) is open source bibliography reference manager. It has an option to abbreviate journal names. However, when it comes to Physics journals, the internal list is far from complete.
  
  The original list of abbreviations is located at [ISI](https://images.webofknowledge.com/WOK46/help/WOS/A_abrvjt.html).

- **JabRef-Browser-Extension** [ğŸ“](./JabRef-Browser-Extension) [ğŸŒ](https://github.com/GerHobbelt/JabRef-Browser-Extension) -- a browser extension for users of the bibliographic reference manager [JabRef](https://www.jabref.org/). It automatically identifies and extracts bibliographic information on websites and sends them to JabRef with one click. When you find an interesting article through Google Scholar, the arXiv or journal websites, this browser extension allows you to add those references to JabRef. Even links to accompanying PDFs are sent to JabRef, where those documents can easily be downloaded, renamed and placed in the correct folder. [A wide range of publisher sites, library catalogs and databases are supported](https://www.zotero.org/support/translators).
- **JamSpell** [ğŸ“](./JamSpell) [ğŸŒ](https://github.com/GerHobbelt/JamSpell) -- a spell checking library, which considers words surroundings (context) for better correction (**accuracy**) and is **fast** (near 5K words per second)
- **jasper** [ğŸ“](./jasper) [ğŸŒ](https://github.com/GerHobbelt/jasper) -- JasPer Image Processing/Coding Tool Kit
- **javascript-serialization-benchmark** [ğŸ“](./javascript-serialization-benchmark) [ğŸŒ](https://github.com/GerHobbelt/javascript-serialization-benchmark) -- a binary serialization comparison tool in JavaScript (Protocol Buffer, Avro, BSON, etc.). This is a comparison and benchmark of various binary serialization formats and libraries used in JavaScript as of 2020-07-28.
- **jbig2dec** [ğŸ“](../../thirdparty/jbig2dec) [ğŸŒ](https://github.com/GerHobbelt/jbig2dec) -- a decoder library and example utility implementing the JBIG2 bi-level image compression spec. Also known as ITU T.88 and ISO IEC 14492, and included by reference in Adobe's PDF version 1.4 and later.
- **jbig2enc** [ğŸ“](./jbig2enc) [ğŸŒ](https://github.com/GerHobbelt/jbig2enc) -- an encoder for JBIG2. JBIG2 encodes bi-level (1 bpp) images using a number of clever tricks to get better compression than G4. This encoder can:
  
  * Generate JBIG2 files, or fragments for embedding in PDFs
  * Generic region encoding
  * Perform symbol extraction, classification and text region coding
  * Perform refinement coding and,
  * Compress multipage documents
  
  It uses the Leptonica library.

- **jemalloc** [ğŸ“](./jemalloc) [ğŸŒ](https://github.com/GerHobbelt/jemalloc) -- a general purpose malloc(3) implementation that emphasizes fragmentation avoidance and scalable concurrency support.  jemalloc first came into use as the FreeBSD libc allocator in 2005, and since then it has found its way into numerous applications that rely on its predictable behavior.  In 2010 jemalloc development efforts broadened to include developer support features such as heap profiling and extensive monitoring/tuning hooks.
- **jerryscript** [ğŸ“](./jerryscript) [ğŸŒ](https://github.com/GerHobbelt/jerryscript) -- [JerryScript](https://github.com/jerryscript-project/jerryscript/) is a lightweight JavaScript engine for resource-constrained devices such as microcontrollers. It can run on devices with less than 64 KB of RAM and less than 200 KB of flash memory.
  
  Key characteristics of JerryScript:
  
  * Full ECMAScript 5.1 standard compliance
  * 160K binary size when compiled for ARM Thumb-2
  * Heavily optimized for low memory consumption
  * Written in C99 for maximum portability
  * Snapshot support for precompiling JavaScript source code to byte code
  * Mature C API, easy to embed in applications
  
  Additional information can be found at the [project page](http://jerryscript.net) and [Wiki](https://github.com/jerryscript-project/jerryscript/wiki).

- **jimtcl** [ğŸ“](./jimtcl) [ğŸŒ](https://github.com/GerHobbelt/jimtcl) -- the Jim Interpreter is a small-footprint implementation of the Tcl programming language written from scratch. Currently Jim Tcl is very feature complete with an extensive test suite (see the tests directory). There are some Tcl commands and features which are not implemented (and likely never will be), including traces and Tk. However, Jim Tcl offers a number of both Tcl8.5 and Tcl8.6 features ({*}, dict, lassign, tailcall and optional UTF-8 support) and some unique features. These unique features include [lambda] with garbage collection, a general GC/references system, arrays as syntax sugar for [dict]tionaries, object-based I/O and more. Other common features of the Tcl programming language are present, like the "everything is a string" behaviour, implemented internally as dual ported objects to ensure that the execution time does not reflect the semantic of the language :)
- **jpeg2dct** [ğŸ“](./jpeg2dct) [ğŸŒ](https://github.com/GerHobbelt/jpeg2dct) -- Faster Neural Networks Straight from JPEG: jpeg2dct subroutines -- this module is useful for reproducing results presented in the paper [Faster Neural Networks Straight from JPEG](https://openreview.net/forum?id=S1ry6Y1vG) (ICLR workshop 2018).
- **jpeginfo** [ğŸ“](../../thirdparty/jpeginfo) [ğŸŒ](https://github.com/GerHobbelt/jpeginfo) -- prints information and tests integrity of JPEG/JFIF files.
- **jpegview** [ğŸ“](./jpegview) [ğŸŒ](https://github.com/GerHobbelt/jpegview) -- JPEGView is a lean, fast and highly configurable image viewer/editor with a minimal GUI.
- **JPEG-XL** [ğŸ“](./jpeg-xl) [ğŸŒ](https://github.com/GerHobbelt/jpeg-xl) -- JPEG XL reference implementation (encoder and decoder), called `libjxl`. JPEG XL was standardized in 2022 as [ISO/IEC 18181](https://jpeg.org/jpegxl/workplan.html). The [core codestream](doc/format_overview.md#codestream-features) is specified in 18181-1, the [file format](doc/format_overview.md#file-format-features) in 18181-2. [Decoder conformance](https://github.com/libjxl/conformance) is defined in 18181-3, and 18181-4 is the [reference software](https://github.com/libjxl/libjxl).
- **jq** [ğŸ“](./jq) [ğŸŒ](https://github.com/GerHobbelt/jq) -- a lightweight and flexible command-line JSON processor.
- **json** [ğŸ“](./json) [ğŸŒ](https://github.com/GerHobbelt/nlohmann-json) -- N. Lohmann's JSON for Modern C++.
- **jsoncons** [ğŸ“](./jsoncons) [ğŸŒ](https://github.com/GerHobbelt/jsoncons) -- a C++, header-only library for constructing [JSON](http://www.json.org) and JSON-like data formats such as [CBOR](http://cbor.io/). Compared to other JSON libraries, jsoncons has been designed to handle very large JSON texts. At its heart are SAX-style parsers and serializers. It supports reading an entire JSON text in memory in a variant-like structure. But it also supports efficient access to the underlying data using StAX-style pull parsing and push serializing. It supports incremental parsing into a user's preferred form, using information about user types provided by specializations of `json_type_traits`.
- **jsoncpp** [ğŸ“](./jsoncpp) [ğŸŒ](https://github.com/GerHobbelt/jsoncpp) -- JsonCpp is a C++ library that allows manipulating JSON values, including serialization and deserialization to and from strings. It can also preserve existing comment in unserialization/serialization steps, making it a convenient format to store user input files.
- **json-jansson** [ğŸ“](./json-jansson) [ğŸŒ](https://github.com/GerHobbelt/jansson) -- _Jansson_ is a C library for encoding, decoding and manipulating JSON data.
- **jtc** [ğŸ“](./jtc) [ğŸŒ](https://github.com/GerHobbelt/jtc) -- `jtc` stand for: **_JSON transformational chains_** (used to be _JSON test console_) and is a cli tool to extract, manipulate and transform source JSON, offering powerful ways to select one or multiple elements from a source JSON and apply various actions on the selected elements at once (wrap selected elements into a new JSON, filter in/out, sort elements, update elements, insert new elements, remove, copy, move, compare, transform, swap around and many other operations).
- **kahypar** [ğŸ“](./kahypar) [ğŸŒ](https://github.com/GerHobbelt/kahypar) -- KaHyPar (Karlsruhe Hypergraph Partitioning) is a multilevel hypergraph partitioning framework providing direct k-way and recursive bisection based partitioning algorithms that compute solutions of very high quality.
- **kalman-cpp** [ğŸ“](./kalman-cpp) [ğŸŒ](https://github.com/GerHobbelt/kalman-cpp) -- Kalman filter and extended Kalman filter implementation in C++. Implements Kalman, Extended Kalman, Second-order extended Kalman and Unscented Kalman filters.
- **kann** [ğŸ“](./kann) [ğŸŒ](https://github.com/GerHobbelt/kann) -- KANN is a standalone and lightweight library in C for constructing and training small to medium artificial neural networks such as multi-layer perceptrons (MLP), convolutional neural networks (CNN) and recurrent neural networks (RNN), including LSTM and GRU. It implements graph-based reverse-mode automatic differentiation and allows to build topologically complex neural networks with recurrence, shared weights and multiple inputs/outputs/costs. In comparison to mainstream deep learning frameworks such as TensorFlow, KANN is not as scalable, but it is close in flexibility, has a much smaller code base and only depends on the standard C library. In comparison to other lightweight frameworks such as tiny-dnn, KANN is still smaller, times faster and much more versatile, supporting RNN, VAE and non-standard neural networks that may fail these lightweight frameworks. KANN could be potentially useful when you want to experiment small to medium neural networks in C/C++, to deploy no-so-large models without worrying about dependency hell, or to learn the internals of deep learning libraries.
- **KDSPDSetup** [ğŸ“](./KDSPDSetup) [ğŸŒ](https://github.com/GerHobbelt/KDSPDSetup) -- a minimal reimplementation of the unmaintained [spdlog_setup](https://github.com/guangie88/spdlog_setup) library for modern C++ projects.
- **kfr** [ğŸ“](./kfr) [ğŸŒ](https://github.com/GerHobbelt/kfr) -- an open source C++ DSP framework that contains high performance building blocks for DSP, audio, scientific and other applications.
- **kgraph** [ğŸ“](./kgraph) [ğŸŒ](https://github.com/GerHobbelt/kgraph) -- a library for k-nearest neighbor (k-NN) graph construction and online k-NN search using a k-NN Graph as index. KGraph implements heuristic algorithms that are extremely generic and fast. KGraph works on abstract objects. The only assumption it makes is that a similarity score can be computed on any pair of objects, with a user-provided function.
- **kissfft** [ğŸ“](./kissfft) [ğŸŒ](https://github.com/GerHobbelt/kissfft) -- KISS FFT - a mixed-radix Fast Fourier Transform based up on the principle, "Keep It Simple, Stupid."
- **kiwi** [ğŸ“](./kiwi) [ğŸŒ](https://github.com/GerHobbelt/kiwi) -- Kiwi is an efficient C++ implementation of the Cassowary constraint solving algorithm. Kiwi is an implementation of the algorithm based on the `seminal Cassowary paper <https://constraints.cs.washington.edu/solvers/cassowary-tochi.pdf>`_. It is *not* a refactoring of the original C++ solver. Kiwi has been designed from the ground up to be lightweight and fast. Kiwi ranges from 10x to 500x faster than the original Cassowary solver with typical use cases gaining a 40x improvement. Memory savings are consistently > 5x.
- **klib** [ğŸ“](./klib) [ğŸŒ](https://github.com/GerHobbelt/klib) -- Klib is a standalone and lightweight C library. Most components are independent of external libraries, except the standard C library, and independent of each other. To use a component of this library, you only need to copy a couple of files to your source code tree without worrying about library dependencies. Klib strives for efficiency and a small memory footprint. Some components, such as khash.h, kbtree.h, ksort.h and kvec.h, are among the most efficient implementations of similar algorithms or data structures in all programming languages, in terms of both speed and memory use.
- **K-Medoids-Clustering** [ğŸ“](./K-Medoids-Clustering) [ğŸŒ](https://github.com/GerHobbelt/K-Medoids-Clustering) -- K-medoids is a clustering algorithm related to K-means. In contrast to the K-means algorithm, K-medoids chooses datapoints as centers of the clusters. There are eight combinations of Initialization, Assignment and Update algorithms to achieve the best results in the given dataset. Also Clara algorithm approach is implemented.
- **knusperli** [ğŸ“](./knusperli) [ğŸŒ](https://github.com/GerHobbelt/knusperli) -- Knusperli reduces blocking artifacts in decoded JPEG images by interpreting quantized DCT coefficients in the image data as an interval, rather than a fixed value, and choosing the value from that interval that minimizes discontinuities at block boundaries.
- **koan** [ğŸ“](./koan) [ğŸŒ](https://github.com/GerHobbelt/koan) -- a `word2vec` negative sampling implementation with correct CBOW update. kÅan only depends on Eigen.
  
  Although continuous bag of word (CBOW) embeddings can be trained more quickly than skipgram (SG) embeddings, it is a common belief that SG embeddings tend to perform better in practice. This was observed by the original authors of Word2Vec [1] and also in subsequent work [2].  However, we found that popular implementations of word2vec with negative sampling such as [word2vec](https://github.com/tmikolov/word2vec/) and [gensim](https://github.com/RaRe-Technologies/gensim/) do not implement the CBOW update correctly, thus potentially leading to misconceptions about the performance of CBOW embeddings when trained correctly.

- **krabsETW** [ğŸ“](./krabsETW) [ğŸŒ](https://github.com/GerHobbelt/krabsetw) -- a C++ library that simplifies interacting with ETW. It allows for any number of traces and providers to be enabled and for client code to register for event notifications from these traces.
- **krita** [ğŸ“](./krita) [ğŸŒ](https://github.com/GerHobbelt/krita) -- a free and open source digital painting application. It is for artists who want to create professional work from start to end. Krita is used by comic book artists, illustrators, concept artists, matte and texture painters and in the digital VFX industry.
- **L1Flattening** [ğŸ“](./L1Flattening) [ğŸŒ](https://github.com/GerHobbelt/L1Flattening) -- L1 image flattening is the code for our 2015 SIGGRAPH paper *An L1 Image Transform for Edge-Preserving Smoothing and Scene-Level Intrinsic Decomposition*. If you use this code, please cite our paper.
- **langdata_LSTM** [ğŸ“](../../thirdparty/langdata_LSTM) [ğŸŒ](https://github.com/GerHobbelt/langdata_lstm) -- tesseract data
- **lapack** [ğŸ“](./lapack) [ğŸŒ](https://github.com/GerHobbelt/lapack) -- [CBLAS](http://www.netlib.org/blas/) + [LAPACK](http://www.netlib.org/lapack/index.html) optimized linear algebra libs
- **LBFGS-Lite** [ğŸ“](./LBFGS-Lite) [ğŸŒ](https://github.com/GerHobbelt/LBFGS-Lite) -- a header-only L-BFGS unconstrained optimizer.
- **lcms2** [ğŸ“](../../thirdparty/lcms2) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-lcms2) -- `lcms2mt` is a thread-safe fork of `lcms` (a.k.a. Little CMS). Little CMS intends to be a small-footprint color management engine, with special focus on accuracy and performance. It uses the International Color Consortium standard (ICC), which is the modern standard when regarding to color management. The ICC specification is widely used and is referred to in many International and other de-facto standards. It was approved as an International Standard, ISO 15076-1, in 2005. Little CMS is a **full implementation** of ICC specification 4.3, it fully supports all kind of V2 and V4 profiles, including abstract, devicelink and named color profiles.
- **lda** [ğŸ“](./lda) [ğŸŒ](https://github.com/GerHobbelt/lda-c) -- variational EM for latent Dirichlet allocation (LDA), David Blei et al
- **lda-3-variants** [ğŸ“](./lda-3-variants) [ğŸŒ](https://github.com/GerHobbelt/LDA) -- three modified open source versions of LDA with collapsed Gibbs Sampling: GibbsLDA++, ompi-lda and online_twitter_lda.
- **lda-bigartm** [ğŸ“](./lda-bigartm) [ğŸŒ](https://github.com/GerHobbelt/bigartm) -- BigARTM is a powerful tool for topic modeling based on a novel technique called Additive Regularization of Topic Models. This technique effectively builds multi-objective models by adding the weighted sums of regularizers to the optimization criterion. BigARTM is known to combine well very different objectives, including sparsing, smoothing, topics decorrelation and many others. Such combination of regularizers significantly improves several quality measures at once almost without any loss of the perplexity.
- **lda-Familia** [ğŸ“](./lda-Familia) [ğŸŒ](https://github.com/GerHobbelt/Familia) -- Familia: A Configurable Topic Modeling Framework for Industrial Text Engineering (Di Jiang and Yuanfeng Song and Rongzhong Lian and Siqi Bao and Jinhua Peng and Huang He and Hua Wu) (2018)
- **LDCF-hash** [ğŸ“](./LDCF-hash) [ğŸŒ](https://github.com/GerHobbelt/LDCF) -- The Logarithmic Dynamic Cuckoo Filter (LDCF) is an efficient approximate membership test data structure for dynamic big data sets. LDCF uses a novel multi-level tree structure and reduces the worst insertion and membership testing time from O(N) to O(1), while simultaneously reducing the memory cost of DCF as the cardinality of the set increases.
- **learnopencv** [ğŸ“](./learnopencv) [ğŸŒ](https://github.com/GerHobbelt/learnopencv) -- contains code for Computer Vision, Deep learning, and AI research articles shared on our blog [LearnOpenCV.com](https://www.LearnOpenCV.com).
- **leptonica** [ğŸ“](../../thirdparty/leptonica) [ğŸŒ](https://github.com/GerHobbelt/leptonica) -- supports many operations that are useful on images.
  
  Features:
  
  * Rasterop (aka bitblt)
  * Affine transforms (scaling, translation, rotation, shear) on images of arbitrary pixel depth
  * Projective and bilinear transforms
  * Binary and grayscale morphology, rank order filters, and convolution
  * Seedfill and connected components
  * Image transformations with changes in pixel depth, both at the same scale and with scale change
  * Pixelwise masking, blending, enhancement, arithmetic ops, etc.
  
  Documentation:
  
  - **LeptonicaDocsSite** [ğŸ“](./LeptonicaDocsSite) [ğŸŒ](https://github.com/GerHobbelt/LeptonicaDocsSite) -- unofficial Reference Documentation for the Leptonica image processing library ([www.leptonica.org](http://www.leptonica.org)).
  - **UnofficialLeptDocs** [ğŸ“](./UnofficialLeptDocs) [ğŸŒ](https://github.com/GerHobbelt/UnofficialLeptDocs) -- unofficial Sphinx-generated documentation for the Leptonica image processing library.

- **LeptonicaDocsSite** [ğŸ“](./LeptonicaDocsSite) [ğŸŒ](https://github.com/GerHobbelt/LeptonicaDocsSite) -- unofficial Reference Documentation for the Leptonica image processing library ([www.leptonica.org](http://www.leptonica.org)).
- **leptonica-hillshade** [ğŸ“](./leptonica-hillshade) [ğŸŒ](https://github.com/GerHobbelt/leptonica-hillshade) -- apply hillshade elevation/shadow render to leptonica PIX & FPIX
- **lerc** [ğŸ“](./lerc) [ğŸŒ](https://github.com/GerHobbelt/lerc) -- LERC (Limited Error Raster Compression) is an open-source image or raster format which supports rapid encoding and decoding for any pixel type (not just RGB or Byte). Users set the maximum compression error per pixel while encoding, so the precision of the original input image is preserved (within user defined error bounds).
- **lexbor** [ğŸ“](./lexbor) [ğŸŒ](https://github.com/GerHobbelt/lexbor) -- fast HTML5 fully-conformant HTML + CSS parser.
- **libaco** [ğŸ“](./libaco) [ğŸŒ](https://github.com/GerHobbelt/libaco) -- a blazing fast and lightweight C asymmetric coroutine library ğŸ’ â›…ğŸš€â›…ğŸŒ Along with the implementation of a production-ready C coroutine library, it has detailed documentation about how to implement a fastest and correct coroutine library, includes a strict mathematical proof. It has no more than 700 LOC but has the full functionality which you may want from a coroutine library. (The phrase "fastest" here means the fastest context switching implementation which complies to the Sys V ABI of Intel386 or AMD64.)
- **libahocorasick** [ğŸ“](./libahocorasick) [ğŸŒ](https://github.com/GerHobbelt/pyahocorasick) -- a fast and memory efficient library for exact or approximate multi-pattern string search meaning that you can find multiple key strings occurrences at once in some input text.  The strings "index" can be built ahead of time and saved (as a pickle) to disk to reload and reuse later.  The library provides an `ahocorasick` Python module that you can use as a plain dict-like Trie or convert a Trie to an automaton for efficient Aho-Corasick search.
- **libalg** [ğŸ“](./libalg) [ğŸŒ](https://github.com/GerHobbelt/alglib) -- the mathematical *ALGLIB* library for C++.
- **libaom** [ğŸ“](./libaom) [ğŸŒ](https://github.com/GerHobbelt/libaom) -- AV1 Codec Library
- **libarchive** [ğŸ“](./libarchive) [ğŸŒ](https://github.com/GerHobbelt/libarchive) -- a portable, efficient C library that can read and write streaming archives in a variety of formats. It also includes implementations of the common `tar`, `cpio`, and `zcat` command-line tools that use the libarchive library.
- **libascii** [ğŸ“](./libascii) [ğŸŒ](https://github.com/GerHobbelt/libascii) -- C/C++ header files carrying the ASCII, Z-modem, etc. control codes as named definitions.
- **libase** [ğŸ“](./libase) [ğŸŒ](https://github.com/GerHobbelt/libase) -- a tiny library for interpreting the Adobe Swatch Exchange (`.ase`) file format for color palettes since Adobe Creative Suite 3.
- **libass** [ğŸ“](./libass) [ğŸŒ](https://github.com/GerHobbelt/libass) -- `libass` is a portable subtitle renderer for the ASS/SSA (Advanced Substation Alpha/Substation Alpha) subtitle format.
- **libassert** [ğŸ“](./libassert) [ğŸŒ](https://github.com/GerHobbelt/libassert) -- the most over-engineered and overpowered C++ assertion library.
- **libavif** [ğŸ“](./libavif) [ğŸŒ](https://github.com/GerHobbelt/libavif) -- a friendly, portable C implementation of the AV1 Image File Format, as described here: <https://aomediacodec.github.io/av1-avif/>
- **libbf** [ğŸ“](./libbf) [ğŸŒ](https://github.com/GerHobbelt/libbf) -- a small library to handle arbitrary precision binary or decimal floating point numbers
- **libbloom** [ğŸ“](./libbloom) [ğŸŒ](https://github.com/GerHobbelt/bloomd) -- a high-performance C server, exposing bloom filters and operations over them. The rate of false positives can be tuned to meet application demands, but reducing the error rate rapidly increases the amount of memory required for the representation. Example: Bloom filters enable you to represent 1MM items with a false positive rate of 0.1% in 2.4MB of RAM.
- **libbloomfilters** [ğŸ“](./libbloomfilters) [ğŸŒ](https://github.com/GerHobbelt/libbloomfilters) -- **libbf** is a C++11 library which implements various Bloom filters, including:
  
  - A^2
  - Basic
  - Bitwise
  - Counting
  - Spectral MI
  - Spectral RM
  - Stable

- **libcbor** [ğŸ“](./libcbor) [ğŸŒ](https://github.com/GerHobbelt/libcbor) -- a C library for parsing and generating [CBOR](https://tools.ietf.org/html/rfc7049), the general-purpose schema-less binary data format.
- **libchaos** [ğŸ“](./libchaos) [ğŸŒ](https://github.com/GerHobbelt/libchaos) -- *Advanced library for randomization, hashing and statistical analysis (devoted to [chaos machines](https://en.wikipedia.org/wiki/Chaos_machine))* written to help with the development of software for scientific research. Project goal is to *implement & analyze* various algorithms for randomization and hashing, while maintaining simplicity and security, making them suitable for use in your own code. Popular tools like [TestU01](http://simul.iro.umontreal.ca/testu01/tu01.html), [Dieharder](https://www.phy.duke.edu/~rgb/General/dieharder.php) and [Hashdeep](https://github.com/jessek/hashdeep) are obsolete or their development has been stopped. Libchaos aims to replace them.
- **libchardet** [ğŸ“](./libchardet) [ğŸŒ](https://github.com/GerHobbelt/libchardet) -- is based on Mozilla Universal Charset Detector library and, detects the character set used to encode data.
- **libchiaroscuramente** [ğŸ“](./libchiaroscuramente) [ğŸŒ](https://github.com/GerHobbelt/libchiaroscuramente) -- a collection of C/C++ functions (components) to help improving / enhancing your images for various purposes (e.g. helping an OCR engine detect and recognize the text in the page scan image)
- **libchopshop** [ğŸ“](./libchopshop) [ğŸŒ](https://github.com/GerHobbelt/libchopshop) -- NLP/text processing with automated stop word detection and stemmer-based filtering. This library / toolkit is engineered to be able to provide **both** of the (often more or less disparate) n-gram token streams / vectors required for (1) initializing / training FTS databases, neural nets, etc. and (2) executing effective queries / matches on these engines.
- **libclip** [ğŸ“](./libclip) [ğŸŒ](https://github.com/GerHobbelt/clip) -- a library to copy/retrieve content to/from the clipboard/pasteboard.
- **libclipboard** [ğŸ“](./libclipboard) [ğŸŒ](https://github.com/GerHobbelt/libclipboard) -- a lightweight cross-platform clipboard library.
- **libcluster** [ğŸ“](./libcluster) [ğŸŒ](https://github.com/GerHobbelt/libcluster) -- implements various algorithms with variational Bayes learning procedures and efficient cluster splitting heuristics, including the Variational Dirichlet Process (VDP), the Bayesian Gaussian Mixture Model, the Grouped Mixtures Clustering (GMC) model and more clustering algorithms based on diagonal Gaussian, and Exponential distributions.
- **libcmime** [ğŸ“](./libcmime) [ğŸŒ](https://github.com/GerHobbelt/libcmime) -- MIME extract/insert/encode/decode: use for MHTML support
- **libcnl** [ğŸ“](./libcnl) [ğŸŒ](https://github.com/GerHobbelt/cnl) -- The Compositional Numeric Library (CNL) is a C++ library of fixed-precision numeric classes which enhance integers to deliver safer, simpler, cheaper arithmetic types. CNL is particularly well-suited to: (1) compute on energy-constrained environments where FPUs are absent or costly; (2) compute on energy-intensive environments where arithmetic is the bottleneck such as simulations, machine learning applications and DSPs; and (3) domains such as finance where precision is essential.
- **libconfig** [ğŸ“](./libconfig) [ğŸŒ](https://github.com/GerHobbelt/libconfig) -- generic config (file) reader/writer
- **libcopp** [ğŸ“](./libcopp) [ğŸŒ](https://github.com/GerHobbelt/libcopp) -- cross-platform coroutine library in C++
- **libcppjieba** [ğŸ“](./libcppjieba) [ğŸŒ](https://github.com/GerHobbelt/libcppjieba) -- source code extracted from the [CppJieba] project to form a separate project, making it easier to understand and use.
- **libcpr** [ğŸ“](./libcpr) [ğŸŒ](https://github.com/GerHobbelt/cpr) -- wrapper library for cURL. C++ Requests is a simple wrapper around [libcurl](http://curl.haxx.se/libcurl) inspired by the excellent [Python Requests](https://github.com/kennethreitz/requests) project. Despite its name, libcurl's easy interface is anything but, and making mistakes misusing it is a common source of error and frustration. Using the more expressive language facilities of C++11, this library captures the essence of making network calls into a few concise idioms.
- **libcpuid** [ğŸ“](./libcpuid) [ğŸŒ](https://github.com/GerHobbelt/libcpuid) -- CPU & hardware info
- **libCRCpp** [ğŸ“](./libCRCpp) [ğŸŒ](https://github.com/GerHobbelt/CRCpp) -- easy to use and fast C++ CRC library.
- **libCSD** [ğŸ“](./libCSD) [ğŸŒ](https://github.com/GerHobbelt/libCSD) -- a C++ library providing some different techniques for managing string dictionaries in compressed space. These approaches are inspired on the paper: "Compressed String Dictionaries", Nieves R. Brisaboa, Rodrigo CÃ¡novas, Francisco Claude, Miguel A. MartÃ­nez-Prieto, and Gonzalo Navarro, 10th Symposium on Experimental Algorithms (SEA'2011), p.136-147, 2011.
- **libcsp** [ğŸ“](./libcsp) [ğŸŒ](https://github.com/GerHobbelt/libcsp) -- a concurrency C library 10x faster than Golang, influenced by the CSP model.
- **libcsv2** [ğŸ“](./libcsv2) [ğŸŒ](https://github.com/GerHobbelt/csv2) -- CSV file format reader/writer library.
- **libcuckoo** [ğŸ“](./libcuckoo) [ğŸŒ](https://github.com/GerHobbelt/libcuckoo) -- provides a high-performance, compact hash table that allows multiple concurrent reader and writer threads.
- **libcyaml** [ğŸ“](./libcyaml) [ğŸŒ](https://github.com/GerHobbelt/libcyaml) -- a C library for reading and writing structured YAML documents. The fundamental idea behind CYAML is to allow applications to construct schemas which describe both the permissible structure of the YAML documents to read/write, and the C data structure(s) in which the loaded data is arranged in memory.
- **libCZMQ** [ğŸ“](./libCZMQ) [ğŸŒ](https://github.com/GerHobbelt/czmq) -- High-level C binding for Ã˜MQ. (http://czmq.zeromq.org/)
- **libde265** [ğŸ“](./libde265) [ğŸŒ](https://github.com/GerHobbelt/libde265) -- libde265 is an open source implementation of the h.265 video codec. It is written from scratch and has a plain C API to enable a simple integration into other software. libde265 supports WPP and tile-based multithreading and includes SSE optimizations. The decoder includes all features of the Main profile and correctly decodes almost all conformance streams (see [[wiki page](https://github.com/strukturag/libde265/wiki/Decoder-conformance)]).
- **libdeflate** [ğŸ“](./libdeflate) [ğŸŒ](https://github.com/GerHobbelt/libdeflate) -- heavily optimized library for DEFLATE/zlib/gzip compression and decompression.
- **libdiagnostics** [ğŸ“](./libdiagnostics) [ğŸŒ](https://github.com/GerHobbelt/libdiagnostics) -- a C/C++ diagnostics logging library with support for writing HTML and store images and misc binary data to disk alongside. or when a mere logfile doesn't suffice.
- **libdi-dependency-injection** [ğŸ“](./libdi-dependency-injection) [ğŸŒ](https://github.com/GerHobbelt/di) -- \[Boost::ext\].DI :: your C++14 **one header only** Dependency Injection library with no dependencies
- **libdip** [ğŸ“](./libdip) [ğŸŒ](https://github.com/GerHobbelt/diplib) -- **[*DIPlib*](https://diplib.org/diplib-docs/)** is a C++ library for quantitative image analysis.
- **libdist** [ğŸ“](./libdist) [ğŸŒ](https://github.com/GerHobbelt/distlib) -- string distance related functions (Damerau-Levenshtein, Jaro-Winkler, longest common substring & subsequence) implemented as SQLite run-time loadable extension, with UTF-8 support.
- **libdivide** [ğŸ“](./libdivide) [ğŸŒ](https://github.com/GerHobbelt/libdivide) -- libdivide.h is a header-only C/C++ library for optimizing integer division. Integer division is one of the slowest instructions on most CPUs e.g. on current x64 CPUs a 64-bit integer division has a latency of up to 90 clock cycles whereas a multiplication has a latency of only 3 clock cycles. `libdivide` allows you to replace expensive integer divsion instructions by a sequence of shift, add and multiply instructions that will calculate the integer division much faster.
- **libdivsufsort** [ğŸ“](./libdivsufsort) [ğŸŒ](https://github.com/GerHobbelt/libdivsufsort) -- a software library that implements a lightweight suffix array construction algorithm.
- **libdtm** [ğŸ“](./libdtm) [ğŸŒ](https://github.com/GerHobbelt/dtm) -- LibDTM (Dynamic Topic Models and the Document Influence Model) implements topics that change over time (Dynamic Topic Models) and a model of how individual documents predict that change. This code is the result of work by David M. Blei and Sean M. Gerrish.
- **libeigen** [ğŸ“](./libeigen) [ğŸŒ](https://github.com/GerHobbelt/eigen-git-mirror) -- a C++ template library for linear algebra: matrices, vectors, numerical solvers, and related algorithms.
- **libeternaltimestamp** [ğŸ“](./libeternaltimestamp) [ğŸŒ](https://github.com/GerHobbelt/libeternaltimestamp) -- provide/encode/decode 64-bit integer timestamps which can encode *any* date/time in the lifetime of our planet from before the Big Bang up to about 3000 AD in the future.
- **libevent** [ğŸ“](./libevent) [ğŸŒ](https://github.com/GerHobbelt/libevent) -- _libevent_ is meant to replace the event loop found in event driven network servers.
  
  Currently, _libevent_ supports _[/dev/poll](http://download.oracle.com/docs/cd/E19253-01/816-5177/6mbbc4g9n/index.html)_, _[kqueue(2)](http://www.freebsd.org/cgi/man.cgi?query=kqueue&apropos=0&sektion=0&format=html)_, _[event ports](http://developers.sun.com/solaris/articles/event_completion.html)_, [POSIX _select(2)_](http://manpages.debian.net/cgi-bin/man.cgi?query=select), [Windows _select()_](http://msdn.microsoft.com/en-us/library/ms740141(v=vs.85).aspx), [_poll(2)_](http://manpages.debian.net/cgi-bin/man.cgi?query=poll), and _[epoll(4)](http://www.xmailserver.org/linux-patches/epoll.txt)_. The internal event mechanism is completely independent of the exposed event API, and a simple update of libevent can provide new functionality without having to redesign the applications. As a result, _Libevent_ allows for portable application development and provides the most scalable event notification mechanism available on an operating system. Libevent can also be used for multi-threaded applications, either by isolating each `event_base` so that only a single thread accesses it, or by locked access to a single shared `event_base`. _Libevent_ should compile on Linux, *BSD, Mac OS X, Solaris, Windows, and more.
  
  Libevent additionally provides a sophisticated framework for buffered network IO, with support for sockets, filters, rate-limiting, SSL, zero-copy file transmission, and IOCP. Libevent includes support for several useful protocols, including DNS, HTTP, and a minimal RPC framework.

- **libevt** [ğŸ“](./libevt) [ğŸŒ](https://github.com/GerHobbelt/libevt) -- a library to access the Windows Event Log (EVT) format.
- **libexpat** [ğŸ“](./libexpat) [ğŸŒ](https://github.com/GerHobbelt/libexpat) -- XML read/write
- **libfann** [ğŸ“](./libfann) [ğŸŒ](https://github.com/GerHobbelt/fann) -- FANN: Fast Artificial Neural Network Library, a free open source neural network library, which implements multilayer artificial neural networks in C with support for both fully connected and sparsely connected networks. Cross-platform execution in both fixed and floating point are supported. It includes a framework for easy handling of training data sets. It is easy to use, versatile, well documented, and fast.
- **libffi** [ğŸ“](./libffi) [ğŸŒ](https://github.com/GerHobbelt/libffi) -- provides a portable, high level programming interface to various calling conventions. This allows a programmer to call any function specified by a call interface description at run time.
- **libfolia** [ğŸ“](./libfolia) [ğŸŒ](https://github.com/GerHobbelt/libfolia) -- working with the Format for Linguistic Annotation (FoLiA). Provides a high-level API to read, manipulate, and create FoLiA documents.
- **libfort** [ğŸ“](./libfort) [ğŸŒ](https://github.com/GerHobbelt/libfort) -- a simple crossplatform library to create formatted text tables.
- **libfyaml** [ğŸ“](./libfyaml) [ğŸŒ](https://github.com/GerHobbelt/libfyaml) -- a fancy 1.2 YAML and JSON parser/writer. Fully feature complete YAML parser and emitter, supporting the latest YAML spec and passing the full YAML testsuite. It is designed to be very efficient, avoiding copies of data, and has no artificial limits like the 1024 character limit for implicit keys.
- **libgateY** [ğŸ“](./libgateY) [ğŸŒ](https://github.com/GerHobbelt/libgateY) -- Use a web browser to easily visualize data from your C++ program and control itâ€™s behaviour. libgateY allows you to add variables shared between the native C++ code and the javascript code.
- **libgd** [ğŸ“](./libgd) [ğŸŒ](https://github.com/GerHobbelt/libgd) -- GD is a library for the dynamic creation of images by programmers. GD has support for: WebP, JPEG, PNG, AVIF, HEIF, TIFF, BMP, GIF, TGA, WBMP, XPM.
- **libgif** [ğŸ“](./libgif) [ğŸŒ](https://github.com/GerHobbelt/libgif) -- a library for manipulating GIF files.
- **libgnurx** [ğŸ“](./libgnurx) [ğŸŒ](https://github.com/GerHobbelt/libgnurx) -- the POSIX regex functionality from glibc extracted into a separate library, for Win32.
- **libgrape-lite** [ğŸ“](./libgrape-lite) [ğŸŒ](https://github.com/GerHobbelt/libgrape-lite) -- a C++ library from Alibaba for parallel graph processing (GRAPE). It differs from prior systems in its ability to parallelize sequential graph algorithms as a whole by following the PIE programming model from GRAPE. Sequential algorithms can be easily "plugged into" `libgrape-lite` with only minor changes and get parallelized to handle large graphs efficiently. `libgrape-lite` is designed to be highly efficient and flexible, to cope with the scale, variety and complexity of real-life graph applications.
- **libharry** [ğŸ“](./libharry) [ğŸŒ](https://github.com/GerHobbelt/harry) -- Harry - A Tool for Measuring String Similarity. The tool supports several common distance and kernel functions for strings as well as some excotic similarity measures.  The focus of Harry lies on implicit similarity measures, that is, comparison functions that do not give rise to an explicit vector space.  Examples of such similarity measures are the Levenshtein distance, the Jaro-Winkler distance or the spectrum kernel.
- **libheif** [ğŸ“](./libheif) [ğŸŒ](https://github.com/GerHobbelt/heif) -- High Efficiency Image File Format (HEIF) :: a visual media container format standardized by the Moving Picture Experts Group (MPEG) for storage and sharing of images and image sequences. It is based on the well-known ISO Base Media File Format (ISOBMFF) standard. HEIF Reader/Writer Engine is an implementation of HEIF standard in order to demonstrate its powerful features and capabilities.
- **libheif-alt** [ğŸ“](./libheif-alt) [ğŸŒ](https://github.com/GerHobbelt/libheif) -- an ISO/IEC 23008-12:2017 HEIF and AVIF (AV1 Image File Format) file format decoder and encoder. HEIF and AVIF are new image file formats employing HEVC (h.265) or AV1 image coding, respectively, for the best compression ratios currently possible.
- **libhilbert** [ğŸ“](./libhilbert) [ğŸŒ](https://github.com/GerHobbelt/libhilbert) -- an implementation of the Chenyang, Hong, Nengchao 2008 IEEE N-dimensional Hilber mapping algorithm. The Hilbert generating genes are statically compiled into the library, thus producing a rather large executable size.  This library support the forward and backward mapping algorithms from  R_N -> R_1 and R_1 -> R_N. The library is used straigth forwardly and for guidance and documentation, see hilbertKey.h.
- **libhog** [ğŸ“](./libhog) [ğŸŒ](https://github.com/GerHobbelt/libhog) -- `hog` a.k.a. `hound` - fetch the (PDF,EPUB,HTML) document you seek using maximum effort: `hog` is a tool for fetching *files* from the internet, specifically PDFs. Intended to be used where you browse the 'Net and decide you want to download a given PDF from any site: this can be done through the browser itself, but is sometimes convoluted or neigh impossible (ftp links require another tool, PDFs stored at servers which report as having their SSL certificates *expired* are a hassle to get through for the user-in-a-hurry, etc. etc.) and `hog` is meant to cope with all these.
- **libicns** [ğŸ“](./libicns) [ğŸŒ](https://github.com/GerHobbelt/libicns) -- a library for manipulation of the Mac OS `icns` resource format, also known as the IconFamily resource type. It can read and write files from the Mac OS X icns format, as well as read from Mac OS resource files and macbinary encoded Mac OS resource forks.
- **libiconv** [ğŸ“](./libiconv) [ğŸŒ](https://github.com/GerHobbelt/libiconv-win-build) -- provides conversion between many platform, language or country dependent character encodings to & from Unicode. This library provides an `iconv()` implementation, for use on systems which don't have one, or whose implementation cannot convert from/to Unicode. It provides support for the encodings: European languages (ASCII, ISO-8859-{1,2,3,4,5,7,9,10,13,14,15,16}, KOI8-R, KOI8-U, KOI8-RU, CP{1250,1251,1252,1253,1254,1257}, CP{850,866,1131}, Mac{Roman,CentralEurope,Iceland,Croatian,Romania}, Mac{Cyrillic,Ukraine,Greek,Turkish}, Macintosh), Semitic languages (ISO-8859-{6,8}, CP{1255,1256}, CP862, Mac{Hebrew,Arabic}), Japanese (EUC-JP, SHIFT_JIS, CP932, ISO-2022-JP, ISO-2022-JP-2, ISO-2022-JP-1, ISO-2022-JP-MS), Chinese (EUC-CN, HZ, GBK, CP936, GB18030, EUC-TW, BIG5, CP950, BIG5-HKSCS, BIG5-HKSCS:2004, BIG5-HKSCS:2001, BIG5-HKSCS:1999, ISO-2022-CN, ISO-2022-CN-EXT), Korean (EUC-KR, CP949, ISO-2022-KR, JOHAB), Armenian (ARMSCII-8), Georgian (Georgian-Academy, Georgian-PS), Tajik (KOI8-T), Kazakh (PT154, RK1048), Thai (ISO-8859-11, TIS-620, CP874, MacThai), Laotian (MuleLao-1, CP1133), Vietnamese (VISCII, TCVN, CP1258), Platform specifics (HP-ROMAN8, NEXTSTEP), Full Unicode (UTF-8, UCS-2, UCS-2BE, UCS-2LE, UCS-4, UCS-4BE, UCS-4LE, UTF-16, UTF-16BE, UTF-16LE, UTF-32, UTF-32BE, UTF-32LE, UTF-7, C99, JAVA, UCS-2-INTERNAL, UCS-4-INTERNAL). It also provides support for a few extra encodings: European languages (CP{437,737,775,852,853,855,857,858,860,861,863,865,869,1125}), Semitic languages (CP864), Japanese (EUC-JISX0213, Shift_JISX0213, ISO-2022-JP-3), Chinese (BIG5-2003), Turkmen (TDS565), Platform specifics (ATARIST, RISCOS-LATIN1). It has also some limited support for transliteration, i.e. when a character cannot be represented in the target character set, it can be approximated through one or several similarly looking characters.
- **libics** [ğŸ“](./libics) [ğŸŒ](https://github.com/GerHobbelt/libics) -- the reference library for ICS (Image Cytometry Standard), an open standard for writing images of any dimensionality and data type to file, together with associated information regarding the recording equipment or recorded subject.
  
  ICS stands for Image Cytometry Standard, and was first proposed in: P. Dean, L. Mascio, D. Ow, D. Sudar, J. Mullikin, "Propsed standard for image cytometry data files", Cytometry, n.11, pp.561-569, 1990. 
  
  It writes 2 files, one is the header, with an '.ics' extension, and the other is the actual image data (with an '.ids' extension.)
  
  ICS version 2.0 extends this standard to allow for a more versatile placement of the image data. It can now be placed either in the same '.ics' file or inbedded in any other file, by specifying the file name and the byte offset for the data.
  
  The advantage of ICS over other open standards such as TIFF is that it allows data of any type and dimensionality to be stored. A TIFF file can contain a collection of 2D images; it's up to the user to determine how these relate to each other. An ICS file can contain, for exmaple, a 5D image in which the 4th dimension is the light frequency and the 5th time. Also, all of the information regarding the microscope settings (or whatever instument was used to acquire the image) and the sample preparation can be included in the file.

- **libidn2** [ğŸ“](./libidn2) [ğŸŒ](https://github.com/GerHobbelt/libidn2) -- international domain name parsing
- **libimagequant** [ğŸ“](./libimagequant) [ğŸŒ](https://github.com/GerHobbelt/libimagequant) -- Palette quantization library that powers `pngquant` and other PNG optimizers. `libimagequant` converts RGBA images to palette-based 8-bit indexed images, including alpha component. It's ideal for generating tiny PNG images and nice-looking GIFs. Image encoding/decoding isn't handled by the library itself, bring your own encoder.
- **libinsane** [ğŸ“](./libinsane) [ğŸŒ](https://github.com/GerHobbelt/libinsane) -- *the* library to access scanners on both Linux and Windows.
- **libInterpolate** [ğŸ“](./libInterpolate) [ğŸŒ](https://github.com/GerHobbelt/libInterpolate) -- a C++ interpolation library, which provides classes to perform various types of 1D and 2D function interpolation (linear, spline, etc.).
- **libintrinsics** [ğŸ“](./libintrinsics) [ğŸŒ](https://github.com/GerHobbelt/libintrinsics) -- C/C++ compiler / CPU intrinsics for bit ops and various other math.
- **libirwls** [ğŸ“](./libirwls) [ğŸŒ](https://github.com/GerHobbelt/LIBIRWLS) -- LIBIRWLS is an integrated library that incorporates a parallel implementation of the Iterative Re-Weighted Least Squares (IRWLS) procedure, an alternative to quadratic programming (QP), for training of Support Vector Machines (SVMs). Although there are several methods for SVM training, the number of parallel libraries is very reduced. In particular, this library contains solutions to solve either full or budgeted SVMs making use of shared memory parallelization techniques: (1) a parallel SVM training procedure based on the IRWLS algorithm, (2) a parallel budgeted SVMs solver based on the IRWLS algorithm.
- **libjpeg** [ğŸ“](../../thirdparty/libjpeg) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-libjpeg) -- the Independent JPEG Group's JPEG software
- **libjpegqs** [ğŸ“](./libjpegqs) [ğŸŒ](https://github.com/GerHobbelt/libjpegqs) -- JPEG Quant Smooth tries to recreate lost precision of DCT coefficients based on quantization table from jpeg image. You may not notice jpeg artifacts on the screen without zooming in, but you may notice them after printing. Also, when editing compressed images, artifacts can accumulate, but if you use this program before editing - the result will be better.
- **libjpeg-turbo** [ğŸ“](./libjpeg-turbo) [ğŸŒ](https://github.com/GerHobbelt/libjpeg-turbo) -- a JPEG image codec that uses SIMD instructions to accelerate baseline JPEG compression and decompression on x86, x86-64, Arm, PowerPC, and MIPS systems, as well as progressive JPEG compression on x86, x86-64, and Arm systems.  On such systems, libjpeg-turbo is generally 2-6x as fast as libjpeg, all else being equal.  On other types of systems, libjpeg-turbo can still outperform libjpeg by a significant amount, by virtue of its highly-optimized Huffman coding routines.  In many cases, the performance of libjpeg-turbo rivals that of proprietary high-speed JPEG codecs.
- **libkdtree** [ğŸ“](./libkdtree) [ğŸŒ](https://github.com/GerHobbelt/libkdtree) -- libkdtree++ is a C++ template container implementation of k-dimensional space sorting, using a kd-tree.
- **libkra** [ğŸ“](./libkra) [ğŸŒ](https://github.com/GerHobbelt/libkra) -- a C++ library for importing Krita's KRA & KRZ formatted documents.
- **liblbfgs** [ğŸ“](./liblbfgs) [ğŸŒ](https://github.com/GerHobbelt/liblbfgs) -- libLBFGS: C library of limited-memory BFGS (L-BFGS), a C port of the implementation of Limited-memory Broyden-Fletcher-Goldfarb-Shanno (L-BFGS) method written by Jorge Nocedal. The original FORTRAN source code is available at: http://www.ece.northwestern.edu/~nocedal/lbfgs.html
- **liblinear** [ğŸ“](./liblinear) [ğŸŒ](https://github.com/GerHobbelt/liblinear) -- a simple package for solving large-scale regularized linear classification, regression and outlier detection.
- **libmdbx** [ğŸ“](./libmdbx) [ğŸŒ](https://github.com/GerHobbelt/libmdbx) -- one of the fastest embeddable key-value ACID database without WAL. `libmdbx` surpasses the legendary LMDB in terms of reliability, features and performance.
- **libmetalink** [ğŸ“](./libmetalink) [ğŸŒ](https://github.com/GerHobbelt/libmetalink) -- a library to read Metalink XML download description format. It supports both [_Metalink version 3_](http://www.metalinker.org/Metalink_3.0_Spec.pdf) and [_Metalink version 4 (RFC 5854)_](https://tools.ietf.org/html/rfc5854).
- **libmio** [ğŸ“](./libmio) [ğŸŒ](https://github.com/GerHobbelt/mio) -- An easy to use header-only cross-platform C++11 memory mapping library. `mio` has been created with the goal to be easily includable (i.e. no dependencies) in any C++ project that needs memory mapped file IO without the need to pull in Boost.
- **libmlpp** [ğŸ“](./libmlpp) [ğŸŒ](https://github.com/GerHobbelt/MLPP) -- ML++ :: The intent with this machine-learning library is for it to act as a crossroad between low-level developers and machine learning engineers.
- **libmobi** [ğŸ“](./libmobi) [ğŸŒ](https://github.com/GerHobbelt/libmobi) -- a library for handling Mobipocket/Kindle (MOBI) ebook format documents.
- **libmodbus** [ğŸ“](./libmodbus) [ğŸŒ](https://github.com/GerHobbelt/libmodbus) -- a groovy modbus library to send/receive data with a device which respects the Modbus protocol. This library can use a serial port or an Ethernet connection. The functions included in the library have been derived from the Modicon Modbus Protocol Reference Guide which can be obtained from [www.modbus.org](http://www.modbus.org).
- **lib_nas_lockfile** [ğŸ“](./lib_nas_lockfile) [ğŸŒ](https://github.com/GerHobbelt/lib_nas_lockfile) -- lockfile management on NAS and other disparate network filesystem storage. To be combined with SQLite to create a proper Qiqqa Sync operation.
- **libngt-ann** [ğŸ“](./libngt-ann) [ğŸŒ](https://github.com/GerHobbelt/NGT) -- Yahoo's Neighborhood Graph and Tree for Indexing High-dimensional Data. NGT provides commands and a library for performing high-speed approximate nearest neighbor searches against a large volume of data (several million to several 10 million items of data) in high dimensional vector data space (several ten to several thousand dimensions).
- **libnop** [ğŸ“](./libnop) [ğŸŒ](https://github.com/GerHobbelt/libnop) -- libnop (C++ Native Object Protocols) is a header-only library for serializing and deserializing C++ data types without external code generators or runtime support libraries. The only mandatory requirement is a compiler that supports the C++14 standard.
- **liboauth2** [ğŸ“](./liboauth2) [ğŸŒ](https://github.com/GerHobbelt/liboauth2) -- a library to build C-based OAuth 2.x and OpenID Connect servers and clients e.g. web-server plugins; extends cjose into OAuth 2.x and OpenID Connect specific claims, secrets, and hashes; adds OAuth 2.x and OpenID Connect protocols by abstracting HTTP requests and responses from web server implementation specifics.
- **libocca** [ğŸ“](./libocca) [ğŸŒ](https://github.com/GerHobbelt/occa) -- a portable and vendor neutral framework for parallel programming on heterogeneous platforms. The OCCA API provides unified models for heterogeneous programming concepts&mdash;such as a device, memory, or kernel&mdash;while the OCCA Kernel Language (OKL) enables the creation of portable device kernels using a directive-based extension to the C-language.
- **libpano13** [ğŸ“](./libpano13) [ğŸŒ](https://github.com/GerHobbelt/libpano13) -- the pano13 library, part of the Panorama Tools by Helmut Dersch of the University of Applied Sciences Furtwangen.
- **libparameters** [ğŸ“](./libparameters) [ğŸŒ](https://github.com/GerHobbelt/libparameters) -- use C++ runtime configurable typed parameters as if they were native types, while you can track read/write access/usage of each in your code sections for improved diagnostics of your application's behaviour. Used in enhanced tesseract, f.e.
- **libpathutils** [ğŸ“](./libpathutils) [ğŸŒ](https://github.com/GerHobbelt/libpathutils) -- cross-platform filesystem path utility functions
- **libpillowfight** [ğŸ“](./libpillowfight) [ğŸŒ](https://github.com/GerHobbelt/libpillowfight) -- simple C Library containing various image processing algorithms. 
  
  Available algorithms:
  
  - ACE (Automatic Color Equalization; Parallelized implementation)
  - Canny edge detection
  - Compare: Compare two images (grayscale) and makes the pixels that are different really visible (red).
  - Gaussian blur
  - Scan borders: Tries to detect the borders of a page in an image coming from a scanner.
  - Sobel operator
  - SWT (Stroke Width Transformation)
  - [Unpaper](https://github.com/Flameeyes/unpaper)'s algorithms
    
    - Blackfilter
    - Blurfilter
    - Border
    - Grayfilter
    - Masks
    - Noisefilter

- **libpinyin** [ğŸ“](./libpinyin) [ğŸŒ](https://github.com/GerHobbelt/libpinyin) -- the libpinyin project aims to provide the algorithms core for intelligent sentence-based Chinese pinyin input methods.
- **libpipeline** [ğŸ“](./libpipeline) [ğŸŒ](https://github.com/GerHobbelt/libpipeline) -- libpipeline, a pipeline manipulation library for setting up and running pipelines of processes, without needing to involve shell command-line parsing which is often error-prone and insecure.  This alleviates programmers of the need to laboriously construct pipelines using lower-level primitives such as fork(2) and execve(2).
- **libpmemobj-cpp** [ğŸ“](./libpmemobj-cpp) [ğŸŒ](https://github.com/GerHobbelt/libpmemobj-cpp) -- a C++ binding for **libpmemobj** (a library which is a part of [PMDK collection](https://github.com/pmem/pmdk)).
- **libpng** [ğŸ“](../../thirdparty/libpng) [ğŸŒ](https://github.com/GerHobbelt/libpng) -- LIBPNG: Portable Network Graphics support, official libpng repository.
- **libpopcnt** [ğŸ“](./libpopcnt) [ğŸŒ](https://github.com/GerHobbelt/libpopcnt) -- a header-only C/C++ library for counting the number of 1 bits (bit population count) in an array as quickly as possible using specialized CPU instructions.
- **libpostal** [ğŸ“](./libpostal) [ğŸŒ](https://github.com/GerHobbelt/libpostal) -- a C library for parsing/normalizing street addresses around the world using statistical NLP and open data. The goal of this project is to understand location-based strings in every language, everywhere.
- **libprecog** [ğŸ“](./libprecog) [ğŸŒ](https://github.com/GerHobbelt/PRLib) -- PRLib - Pre-Recognition Library. The main aim of the library is to prepare images for OCR (text recogntion). Image processing can really help to improve recognition quality.
- **libprecog-data** [ğŸ“](./libprecog-data) [ğŸŒ](https://github.com/GerHobbelt/libprecog-data) -- `PRLib` (a.k.a. `libprecog`) test data.
- **libprecog-manuals** [ğŸ“](./libprecog-manuals) [ğŸŒ](https://github.com/GerHobbelt/libprecog-manuals) -- `PRLib` (a.k.a. `libprecog`) related papers.
- **libpsd** [ğŸ“](./libpsd) [ğŸŒ](https://github.com/GerHobbelt/libpsd) -- a library for Adobe Photoshop `.psd` file's decoding and rendering.
- **libpsl** [ğŸ“](./libpsl) [ğŸŒ](https://github.com/GerHobbelt/libpsl) -- handles the *Public Suffix List* (a collection of Top Level Domains (TLDs) suffixes, e.g. `.com`, `.net`, *Country Top Level Domains* (ccTLDs) like `.de` and `.cn` and *[Brand Top Level Domains](https://icannwiki.org/Brand_TLD)* like `.apple` and `.google`. Can be used to:
  
  - avoid privacy-leaking "super domain" certificates ([see post from Jeffry Walton](https://lists.gnu.org/archive/html/bug-wget/2014-03/msg00093.html))
  - avoid privacy-leaking "supercookies"
  - domain highlighting parts of the domain in a user interface
  - sorting domain lists by site

- **libq** [ğŸ“](./libq) [ğŸŒ](https://github.com/GerHobbelt/q) -- A platform-independent promise library for C++, implementing asynchronous continuations.
- **libqrencode** [ğŸ“](./libqrencode) [ğŸŒ](https://github.com/GerHobbelt/libqrencode) -- generate QRcodes from anything (e.g. URLs). `libqrencode` is a fast and compact library for encoding data in a QR Code, a 2D symbology that can be scanned by handy terminals such as a smartphone. The capacity of QR Code is up to 7000 digits or 4000 characters and has high robustness. `libqrencode` supports QR Code model 2, described in JIS (Japanese Industrial Standards) X0510:2004 or ISO/IEC 18004. Most of features in the specification are implemented: Numeric, alphabet, Japanese kanji (Shift-JIS) or any 8 bit code, Optimized encoding of a string, Structured-append of symbols, Micro QR Code (experimental).
- **libquill** [ğŸ“](./libquill) [ğŸŒ](https://github.com/GerHobbelt/quill) -- a cross-platform low latency logging library based on C++14.
- **libraqm** [ğŸ“](./libraqm) [ğŸŒ](https://github.com/GerHobbelt/libraqm) -- a small library that encapsulates the logic for complex text layout and provides a convenient API.
- **librs232** [ğŸ“](./librs232) [ğŸŒ](https://github.com/GerHobbelt/librs232) -- multiplatform library for serial communications over RS-232 (serial port).
- **librsync** [ğŸ“](./librsync) [ğŸŒ](https://github.com/GerHobbelt/librsync) -- a library for calculating and applying network deltas. librsync encapsulates the core algorithms of the rsync protocol, which help with efficient calculation of the differences between two files. The rsync algorithm is different from most differencing algorithms because it does not require the presence of the two files to calculate the delta.  Instead, it requires a set of checksums of each block of one file, which together form a signature for that file.  Blocks at any position in the other file which have the same checksum are likely to be identical, and whatever remains is the difference. This algorithm transfers the differences between two files without needing both files on the same system.
- **libscanf** [ğŸ“](./libscanf) [ğŸŒ](https://github.com/GerHobbelt/scnlib) -- a modern C++ library for replacing `scanf` and `std::istream`. This library attempts to move us ever so closer to replacing `iostream`s and C stdio altogether. It's faster than `iostream` (see Benchmarks) and type-safe, unlike `scanf`. Think [{fmt}](https://github.com/fmtlib/fmt) but in the other direction.
- **libserialport** [ğŸ“](./libserialport) [ğŸŒ](https://github.com/GerHobbelt/libserialport) -- a cross-platform library for accessing serial ports. libserialport is a minimal library written in C that is intended to take care of the OS-specific details when writing software that uses serial ports.
- **libshmcache** [ğŸ“](./libshmcache) [ğŸŒ](https://github.com/GerHobbelt/libshmcache) -- a local share memory cache for multi processes. it is a high performance library because read mechanism is lockless. libshmcache is 100+ times faster than a remote interface such as redis.
- **libsigcplusplus** [ğŸ“](./libsigcplusplus) [ğŸŒ](https://github.com/GerHobbelt/libsigcplusplus) -- libsigc++ : The Typesafe Callback Framework for C++. It allows you to define signals and to connect those signals to any callback function, either global or a member function, regardless of whether it is static or virtual.
- **libsiridb** [ğŸ“](./libsiridb) [ğŸŒ](https://github.com/GerHobbelt/libsiridb) -- SiriDB Connector C (libsiridb) is a library which can be used to communicate with [SiriDB](https://github.com/transceptor-technology/siridb-server) using the C program language. This library contains useful functions but does not handle the connection itself.
- **libsl3** [ğŸ“](./libsl3) [ğŸŒ](https://github.com/GerHobbelt/libsl3) -- a C++ interface for SQLite 3.x. libsl3 is designed to enable comfortable and efficient communication with a SQLite database based on its natural language, which is SQL.
- **libsmile** [ğŸ“](./libsmile) [ğŸŒ](https://github.com/GerHobbelt/libsmile) -- C implementation of the Smile binary format (https://github.com/FasterXML/smile-format-specification).
- **libsndfile** [ğŸ“](./libsndfile) [ğŸŒ](https://github.com/GerHobbelt/libsndfile) -- a C library for reading and writing files containing sampled audio data, e.g. Ogg, Vorbis and FLAC.
- **libsptag** [ğŸ“](./libsptag) [ğŸŒ](https://github.com/GerHobbelt/SPTAG) -- a library for fast approximate nearest neighbor search.  SPTAG (Space Partition Tree And Graph) is a library for large scale vector approximate nearest neighbor search scenario released by [Microsoft Research (MSR)](https://www.msra.cn/) and [Microsoft Bing](http://bing.com).
- **libsql** [ğŸ“](./libsql) [ğŸŒ](https://github.com/GerHobbelt/libsql) -- libSQL is an open source, open contribution fork of SQLite. We aim to evolve it to suit many more use cases than SQLite was originally designed for, and plan to use third-party OSS code wherever it makes sense.
  
  SQLite has solidified its place in modern technology stacks, embedded in nearly any computing device you can think of. Its open source nature and public domain availability make it a popular choice for modification to meet specific use cases.
  But despite having its code available, SQLite famously doesn't accept external contributors, so community improvements cannot be widely enjoyed.
  There have been other forks in the past, but they all focus on a specific technical difference. We aim to be a community where people can contribute from many different angles and motivations.
  We want to see a world where everyone can benefit from all of the great ideas and hard work that the SQLite community contributes back to the codebase.

- **libsqlfs** [ğŸ“](./libsqlfs) [ğŸŒ](https://github.com/GerHobbelt/libsqlfs) -- a POSIX style file system on top of an SQLite database.  It allows applications to have access to a full read/write file system in a single file, complete with its own file hierarchy and name space.  This is useful for applications which needs structured storage, such as embedding documents within documents, or management of configuration data or preferences.
- **libstb** [ğŸ“](./libstb) [ğŸŒ](https://github.com/GerHobbelt/stb) -- single-file public domain (or MIT licensed) libraries for C/C++.
- **libstemmer** [ğŸ“](./libstemmer) [ğŸŒ](https://github.com/GerHobbelt/libstemmer) -- SnowBall stemmer for many languages.
- **libsvm** [ğŸ“](./libsvm) [ğŸŒ](https://github.com/GerHobbelt/libsvm) -- a simple, easy-to-use, and efficient software for SVM classification and regression. It solves C-SVM classification, nu-SVM classification, one-class-SVM, epsilon-SVM regression, and nu-SVM regression. It also provides an automatic model selection tool for C-SVM classification.
- **libtextcat** [ğŸ“](./libtextcat) [ğŸŒ](https://github.com/GerHobbelt/libtextcat) -- text language detection
- **libtiff** [ğŸ“](../../thirdparty/libtiff) [ğŸŒ](https://github.com/GerHobbelt/libtiff) -- TIFF Software Distribution
- **libtuv** [ğŸ“](./libtuv) [ğŸŒ](https://github.com/GerHobbelt/libtuv) -- a multi-platform tiny event library refactored from `libuv` source for IoT and embedded systems.
- **libucl** [ğŸ“](./libucl) [ğŸŒ](https://github.com/GerHobbelt/libucl) -- the configuration language called UCL - Universal Configuration Language.  UCL is heavily infused by nginx configuration as the example of a convenient configuration system. However, UCL is fully compatible with JSON format and is able to parse json files.
- **libunibreak** [ğŸ“](./libunibreak) [ğŸŒ](https://github.com/GerHobbelt/libunibreak) -- an implementation of the line breaking and word breaking algorithms as described in (Unicode Standard Annex 14)[http://www.unicode.org/reports/tr14/] and (Unicode Standard Annex 29)[http://www.unicode.org/reports/tr29/].
- **libunifex** [ğŸ“](./libunifex) [ğŸŒ](https://github.com/GerHobbelt/libunifex) -- a prototype implementation of the C++ sender/receiver async programming model that is currently being considered for standardisation. This project contains implementations of the following: Schedulers, Timers, Asynchronous I/O, Algorithms that encapsulate certain concurrency patterns, Async streams, Cancellation, Coroutine integration.
- **libusb** [ğŸ“](./libusb) [ğŸŒ](https://github.com/GerHobbelt/libusb) -- a library for USB device access from Linux, macOS, Windows, OpenBSD/NetBSD, Solaris userspace, etc.; libusb is abstracted internally in such a way that it can hopefully be ported to other operating systems.
- **libuv** [ğŸ“](./libuv) [ğŸŒ](https://github.com/GerHobbelt/libuv) -- a multi-platform support library with a focus on asynchronous I/O.
  
  Feature highlights:
  
  * Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
  * Asynchronous TCP and UDP sockets
  * Asynchronous DNS resolution
  * Asynchronous file and file system operations
  * File system events
  * ANSI escape code controlled TTY
  * IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
  * Child processes
  * Thread pool
  * Signal handling
  * High resolution clock
  * Threading and synchronization primitives

- **libvips** [ğŸ“](./libvips) [ğŸŒ](https://github.com/GerHobbelt/libvips) -- a demand-driven, horizontally threaded image processing library which has around 300 operations covering arithmetic, histograms, convolution, morphological operations, frequency filtering, colour, resampling, statistics and others. It supports a large range of numeric types, from 8-bit int to 128-bit complex. Images can have any number of bands. It supports a good range of image formats, including JPEG, JPEG2000, JPEG-XL, TIFF, PNG, WebP, HEIC, AVIF, FITS, Matlab, OpenEXR, PDF, SVG, HDR, PPM / PGM / PFM, CSV, GIF, Analyze, NIfTI, DeepZoom, and OpenSlide. It can also load images via ImageMagick or GraphicsMagick, letting it work with formats like DICOM.
- **libvrb** [ğŸ“](./libvrb) [ğŸŒ](https://github.com/GerHobbelt/vrb) -- implements a ring buffer, also known as a character FIFO or circular buffer, with a special property that any data present in the buffer, as well as any empty space, are always seen as a single contiguous extent by the calling program.  This is implemented with virtual memory mapping by creating a mirror image of the buffer contents at the memory location in the virtual address space immediately after the main buffer location.  This allows the mirror image to always be seen without doing any copying of data.
- **libwarc** [ğŸ“](./libwarc) [ğŸŒ](https://github.com/GerHobbelt/libwarc) -- C++ library to parse WARC files. WARC is the official storage format of the Internet Archive for storing scraped content. WARC format used: http://bibnum.bnf.fr/WARC/WARC_ISO_28500_version1_latestdraft.pdf
- **libwebp** [ğŸ“](./libwebp) [ğŸŒ](https://github.com/GerHobbelt/libwebp) -- a library to encode and decode images in WebP format.
- **libwebsocketpp** [ğŸ“](./libwebsocketpp) [ğŸŒ](https://github.com/GerHobbelt/websocketpp) -- WebSocket++ is a header only C++ library that implements RFC6455 The WebSocket Protocol.
- **libwebsockets** [ğŸ“](./libwebsockets) [ğŸŒ](https://github.com/GerHobbelt/libwebsockets) -- a simple-to-use C library providing client and server for HTTP/1, HTTP/2, WebSockets, MQTT and other protocols. It supports a lot of lightweight ancilliary implementations for things like JSON, CBOR, JOSE, COSE. It's very gregarious when it comes to event loop sharing, supporting libuv, libevent, libev, sdevent, glib and uloop, as well as custom event libs.
- **libwil** [ğŸ“](./libwil) [ğŸŒ](https://github.com/GerHobbelt/wil) -- The Windows Implementation Libraries (WIL) is a header-only C++ library created to make life easier for developers on Windows through readable type-safe C++ interfaces for common Windows coding patterns.
- **libwildmatch** [ğŸ“](./libwildmatch) [ğŸŒ](https://github.com/GerHobbelt/wildmatch) -- wildmatch is a BSD-licensed C/C++ library for git/rsync-style pattern matching.
- **libxbr-standalone** [ğŸ“](./libxbr-standalone) [ğŸŒ](https://github.com/GerHobbelt/libxbr-standalone) -- this standalone XBR/hqx Library implements the xBR pixel art scaling filter developed by Hyllian, and now also the hqx filter developed by Maxim Stepin. Original source for the xBR implementation: http://git.videolan.org/gitweb.cgi/ffmpeg.git/?p=ffmpeg.git;a=blob;f=libavfilter/vf_xbr.c;h=5c14565b3a03f66f1e0296623dc91373aeac1ed0;hb=HEAD
- **libxcam** [ğŸ“](./libxcam) [ğŸŒ](https://github.com/GerHobbelt/libxcam) -- libXCam is a project for extended camera features and focus on image quality improvement and video analysis. There are lots features supported in image pre-processing, image post-processing and smart analysis. This library makes GPU/CPU/ISP working together to improve image quality. OpenCL is used to improve performance in different platforms.
- **libxml2** [ğŸ“](./libxml2) [ğŸŒ](https://github.com/GerHobbelt/libxml2) -- [libxml](http://xmlsoft.org/): XML read/write
- **libxo** [ğŸ“](./libxo) [ğŸŒ](https://github.com/GerHobbelt/libxo) -- `libxo` allows an application to generate text, XML, JSON, and HTML output using a common set of function calls (rather than the application using old skool `printf()`).  The application decides at run time which output style should be produced.
- **libxslt** [ğŸ“](./libxslt) [ğŸŒ](https://github.com/GerHobbelt/libxslt) -- XSLT support for libxml2 (XML toolkit from the GNOME project)
- **libyaml** [ğŸ“](./libyaml) [ğŸŒ](https://github.com/GerHobbelt/libyaml) -- YAML
- **libyaml-examples** [ğŸ“](./libyaml-examples) [ğŸŒ](https://github.com/GerHobbelt/libyaml-examples) -- a small set of C language example programs to demonstrate how to use the [libyaml library](http://pyyaml.org/wiki/LibYAML).
- **libzint** [ğŸ“](./libzint) [ğŸŒ](https://github.com/GerHobbelt/libzint) -- Zint is a suite of programs to allow easy encoding of data in any of the wide range of public domain barcode standards.
- **libzip** [ğŸ“](./libzip) [ğŸŒ](https://github.com/GerHobbelt/libzip) -- a C library for reading, creating, and modifying zip and zip64 archives.
- **libzmq** [ğŸ“](./libzmq) [ğŸŒ](https://github.com/GerHobbelt/libzmq) -- ZeroMQ core engine in C++, implements [ZMTP/3.1](https://zguide.zeromq.org/).
- **libzopfli** [ğŸ“](./libzopfli) [ğŸŒ](https://github.com/GerHobbelt/zopfli) -- Zopfli Compression Algorithm is a compression library programmed in C to perform very good, but slow, deflate or zlib compression.
- **LightGBM** [ğŸ“](./LightGBM) [ğŸŒ](https://github.com/GerHobbelt/LightGBM) -- LightGBM (Light Gradient Boosting Machine) is a gradient boosting framework that uses tree based learning algorithms. It is designed to be distributed and efficient with the following advantages:
  
  - Better accuracy.
  - Capable of handling large-scale data.
  - Faster training speed and higher efficiency.
  - Lower memory usage.
  - Support of parallel, distributed, and GPU learning.

- **LightLDA** [ğŸ“](./LightLDA) [ğŸŒ](https://github.com/GerHobbelt/LightLDA) -- a distributed system for large scale topic modeling. It implements a distributed sampler that enables very large data sizes and models. LightLDA improves sampling throughput and convergence speed via a fast O(1) metropolis-Hastings algorithm, and allows small cluster to tackle very large data and model sizes through model scheduling and data parallelism architecture. LightLDA is implemented with C++ for performance consideration.
- **Lightning.NET** [ğŸ“](./Lightning.NET) [ğŸŒ](https://github.com/GerHobbelt/Lightning.NET) -- .NET library for OpenLDAP's LMDB key-value store
- **ligra-graph** [ğŸ“](./ligra-graph) [ğŸŒ](https://github.com/GerHobbelt/ligra) -- LIGRA: a Lightweight Graph Processing Framework for Shared Memory; works on both uncompressed and compressed graphs and hypergraphs.
- **linecook** [ğŸ“](./linecook) [ğŸŒ](https://github.com/GerHobbelt/linecook) -- a C library for editing the command line, much like the [readline](https://tiswww.cwru.edu/php/chet/readline/readline.html) library used in <b>bash</b> and <b>gdb</b>.
- **line_detector** [ğŸ“](./line_detector) [ğŸŒ](https://github.com/GerHobbelt/line_detector) -- line segment detector ([lsd](http://www.ipol.im/pub/art/2012/gjmr-lsd/)) &. edge drawing line detector (edl) &. hough line detector (standard &. probabilistic) for detection.
- **linenoise** [ğŸ“](./linenoise) [ğŸŒ](https://github.com/GerHobbelt/linenoise) -- `readline` simile for REPL/interactive runs in a CLI
- **lizard** [ğŸ“](./lizard) [ğŸŒ](https://github.com/GerHobbelt/lizard) -- efficient compression with very fast decompression. Lizard (formerly LZ5) is a lossless compression algorithm which contains 4 compression methods:
  
  - fastLZ4 : compression levels -10...-19 are designed to give better decompression speed than [LZ4] i.e. over 2000 MB/s
  - fastLZ4 + Huffman : compression levels -30...-39 add Huffman coding to fastLZ4
  - LIZv1 : compression levels -20...-29 are designed to give better ratio than [LZ4] keeping 75% decompression speed
  - LIZv1 + Huffman : compression levels -40...-49 give the best ratio (comparable to [zlib] and low levels of [zstd]/[brotli]) at decompression speed of 1000 MB/s

- **LLhttp-parser** [ğŸ“](./LLhttp-parser) [ğŸŒ](https://github.com/GerHobbelt/llhttp) -- a port and replacement of [http_parser](https://github.com/nodejs/http-parser) to TypeScript. [llparse](https://github.com/nodejs/llparse) is used to generate the output C source file, which could be compiled and linked with the embedder's program (like Node.js).
- **lmdb** [ğŸ“](./lmdb) [ğŸŒ](https://github.com/GerHobbelt/lmdb) -- OpenLDAP [LMDB](http://www.lmdb.tech/doc/index.html) is an outrageously fast key/value store with semantics that make it highly interesting for many applications.  Of specific note, besides speed, is the full support for transactions and good read/write concurrency.  LMDB is also famed for its robustness **when used correctly**.
- **lmdb-safe** [ğŸ“](./lmdb-safe) [ğŸŒ](https://github.com/GerHobbelt/lmdb-safe) -- A safe modern & performant C++ wrapper of LMDB. LMDB is an outrageously fast key/value store with semantics that make it highly interesting for many applications. Of specific note, besides speed, is the full support for transactions and good read/write concurrency. LMDB is also famed for its robustness.. **when used correctly**. The design of LMDB is elegant and simple, which aids both the performance and stability. The downside of this elegant design is a nontrivial set of rules that need to be followed to not break things. In other words, LMDB delivers great things but only if you use it exactly right. This is by conscious design. The `lmdb-safe` library aims to deliver the full LMDB performance while programmatically making sure the LMDB semantics are adhered to, with very limited overhead.
- **lmdb.spreads.net** [ğŸ“](./lmdb.spreads.net) [ğŸŒ](https://github.com/GerHobbelt/Spreads.LMDB) -- Low-level zero-overhead and [the fastest](https://github.com/Spreads/Spreads.LMDB/commit/4085dde649ef9ebb64310f2627299762dd62d5ce) LMDB .NET wrapper with some additional native methods useful for [Spreads](https://github.com/Spreads/).
- **lmdb-store** [ğŸ“](./lmdb-store) [ğŸŒ](https://github.com/GerHobbelt/lmdb-store) -- an ultra-fast NodeJS interface to LMDB; probably the fastest and most efficient NodeJS key-value/database interface that exists for full storage and retrieval of structured JS data (objects, arrays, etc.) in a true persisted, scalable, [ACID compliant](https://en.wikipedia.org/wiki/ACID) database. It provides a simple interface for interacting with LMDB.
- **lmdbxx** [ğŸ“](./lmdbxx) [ğŸŒ](https://github.com/GerHobbelt/lmdbxx) -- lmdb++: a comprehensive C++11 wrapper for the LMDB embedded database library, offering both an error-checked procedural interface and an object-oriented resource interface with RAII semantics.
- **lmfit** [ğŸ“](./lmfit) [ğŸŒ](https://github.com/GerHobbelt/lmfit) -- least squares fitting Files Levenberg-Marquardt least squares minimization and curve fitting. To minimize arbitrary user-provided functions, or to fit user-provided data. No need to provide derivatives.
- **LMW-tree** [ğŸ“](./LMW-tree) [ğŸŒ](https://github.com/GerHobbelt/LMW-tree) -- LMW-tree: learning m-way tree is a generic template library written in C++ that implements several algorithms that use the m-way nearest neighbor tree structure to store their data. See the related [PhD thesis](http://eprints.qut.edu.au/75862/) for more details on m-way nn trees. The algorithms are primarily focussed on computationally efficient clustering. Clustering is an unsupervised machine learning process that finds interesting patterns in data. It places similar items into clusters and dissimilar items into different clusters. The data structures and algorithms can also be used for nearest neighbor search, supervised learning and other machine learning applications. The package includes EM-tree, K-tree, k-means, TSVQ, repeated k-means, clustering, random projections, random indexing, hashing, bit signatures. See the related [PhD thesis](http://eprints.qut.edu.au/75862/) for more details these algorithms and representations.
- **lnav** [ğŸ“](./lnav) [ğŸŒ](https://github.com/GerHobbelt/lnav) -- the Log File Navigator, **lnav** for short, is an advanced log file viewer for the small-scale.  It is a terminal application that can understand your log files and make it easy for you to find problems with little to no setup.
- **local_adaptive_binarization** [ğŸ“](./local_adaptive_binarization) [ğŸŒ](https://github.com/GerHobbelt/local_adaptive_binarization) -- uses an improved contrast maximization version of Niblack/Sauvola et al's method to binarize document images. It is also able to perform the more classical Niblack as well as Sauvola et al. methods. Details can be found in the [ICPR 2002 paper](file:///Users/chris/www/prof/publications/index.html#icpr2002v).
- **localmemcache** [ğŸ“](./localmemcache) [ğŸŒ](https://github.com/GerHobbelt/localmemcache) -- a key-value database and library that provides an interface similar to `memcached` but for accessing local data instead of remote data.  It's based on mmap()'ed shared memory for maximum speed. It supports persistence, also making it a fast alternative to GDBM and Berkeley DB.
- **lockfree** [ğŸ“](./lockfree) [ğŸŒ](https://github.com/GerHobbelt/lockfree) -- a collection of lock-free data structures written in standard C++11 and suitable for all platforms - from deeply embedded to HPC.
- **loguru** [ğŸ“](./loguru) [ğŸŒ](https://github.com/GerHobbelt/loguru) -- a lightweight and flexible C++ logging library.
- **loki** [ğŸ“](./loki) [ğŸŒ](https://github.com/GerHobbelt/loki) -- Grafana Loki: like Prometheus, but for logs. Loki is a horizontally-scalable, highly-available, multi-tenant log aggregation system inspired by [Prometheus](https://prometheus.io/). It is designed to be very cost effective and easy to operate. It does not index the contents of the logs, but rather a set of labels for each log stream.
- **lol** [ğŸ“](./lol) [ğŸŒ](https://github.com/GerHobbelt/lol) -- the header-only part of the Lol (Math) Engine framework.
- **lolremez** [ğŸ“](./lolremez) [ğŸŒ](https://github.com/GerHobbelt/lolremez) -- LolRemez is a Remez algorithm implementation to approximate functions using polynomials.
- **lru_cache** [ğŸ“](./lru_cache) [ğŸŒ](https://github.com/GerHobbelt/lru_cache) -- LRU cache is a fast, header-only, generic C++ 17 [LRU cache][1] library, with customizable backend.
- **lrucache11** [ğŸ“](./lrucache11) [ğŸŒ](https://github.com/GerHobbelt/lrucache11) -- A header only C++11 LRU Cache template class that allows you to define key, value and optionally the `Map` type. uses a double linked list and a `std::unordered_map` style container to provide fast insert, delete and update No dependencies other than the C++ standard library.
- **lshbox** [ğŸ“](./lshbox) [ğŸŒ](https://github.com/GerHobbelt/LSHBOX) -- a C++ Toolbox of Locality-Sensitive Hashing for Large Scale Image Retrieval. Locality-Sensitive Hashing (LSH) is an efficient method for large scale image retrieval, and it achieves great performance in approximate nearest neighborhood searching.
  
  LSHBOX is a simple but robust C++ toolbox that provides several LSH algrithms, in addition, it can be integrated into Python and MATLAB languages. The following LSH algrithms have been implemented in LSHBOX, they are:
  
  * LSH Based on Random Bits Sampling
  * Random Hyperplane Hashing
  * LSH Based on Thresholding
  * LSH Based on p-Stable Distributions
  * [Spectral Hashing](http://www.cs.huji.ac.il/~yweiss/SpectralHashing/) (SH)
  * [Iterative Quantization](http://www.unc.edu/~yunchao/itq.htm) (ITQ)
  * Double-Bit Quantization Hashing (DBQ)
  * K-means Based Double-Bit Quantization Hashing (KDBQ)

- **LSWMS** [ğŸ“](./LSWMS) [ğŸŒ](https://github.com/GerHobbelt/LSWMS) -- LSWMS  (Line Segment detection using Weighted Mean-Shift): line segment detection with OpenCV, originally published by Marcos Nieto Doncel.
- **lterpalettefinder** [ğŸ“](./lterpalettefinder) [ğŸŒ](https://github.com/GerHobbelt/lterpalettefinder) -- extract Color Palettes from Photos and Pick Official LTER Palettes. The goal of `lterpalettefinder` is to provide high quality color palettes derived from photos at Long Term Ecological Research (LTER) sites. This allows users to create beautiful graphics that have close visual ties to photos from the places where data were collected. This package also allows users to generate their own palettes from any photo (PNG, JPEG, TIFF, or HEIC) if the current palettes in the function do not meet their needs. For more information on the LTER Network, check out [our website](https://lternet.edu/)!
- **luple** [ğŸ“](./luple) [ğŸŒ](https://github.com/GerHobbelt/luple) -- provides C++ Type Loophole, luple, nuple, C++ String Interning, Struct Reader. Luple is a tuple-like data structure. Its primary advantage is that it's very thin and also non-recursive (uses multiple inheritance). std::tuple is usually implemented as a single inheritance hierarchy and as a result its layout can vary between compilers. Also it stores data in reverse order. Luple is built on multiple inheritance and its layout is consistent among compilers. It has the same layout as a non-virtual flat data structure with the same data members (formally luple is not a POD and we should keep that in mind when we reinterpret\_cast it). Luple can be used in constexpr functions if its data members are of literal type.   nuple extends luple and allows giving names to data members.   Struct Reader can detect and create a type list of the data member types of a flat data structure if they are literal, non-const/non-reference types. So, it's a form of primitive RTTI.
- **lz4** [ğŸ“](./lz4) [ğŸŒ](https://github.com/GerHobbelt/lz4) -- LZ4 is lossless compression algorithm, providing compression speed > 500 MB/s per core, scalable with multi-cores CPU. It features an extremely fast decoder, with speed in multiple GB/s per core, typically reaching RAM speed limits on multi-core systems.
- **lzbench** [ğŸ“](./lzbench) [ğŸŒ](https://github.com/GerHobbelt/lzbench) -- an in-memory benchmark of open-source LZ77/LZSS/LZMA compressors. It joins all compressors into a single exe.
- **lzham_codec** [ğŸ“](./lzham_codec) [ğŸŒ](https://github.com/GerHobbelt/lzham_codec) -- LZHAM is a lossless data compression codec, with a compression ratio similar to LZMA but with 1.5x-8x faster decompression speed.
- **LZMA-Vizualizer** [ğŸ“](./LZMA-Vizualizer) [ğŸŒ](https://github.com/GerHobbelt/LZMA-Vizualizer) -- visualises per-byte perplexity of the compressed data in an LZMA file.
- **mace** [ğŸ“](./mace) [ğŸŒ](https://github.com/GerHobbelt/mace) -- **Mobile AI Compute Engine** (or **MACE** for short) is a deep learning inference framework optimized for mobile heterogeneous computing on Android, iOS, Linux and Windows devices. The design focuses on the following
- **magic_enum** [ğŸ“](./magic_enum) [ğŸŒ](https://github.com/GerHobbelt/magic_enum) -- Header-only C++17 library provides static reflection for enums; works with any enum type without any macro or boilerplate code.
- **magsac** [ğŸ“](./magsac) [ğŸŒ](https://github.com/GerHobbelt/magsac) -- (MAGSAC++ had been included in OpenCV) the MAGSAC and MAGSAC++ algorithms for robust model fitting without using a single inlier-outlier threshold.
- **mammut** [ğŸ“](./mammut) [ğŸŒ](https://github.com/GerHobbelt/mammut) -- provides an object oriented abstraction of architectural features normally exposed by means of `sysfs` files or CPU registries. It also provides the possibility to manage remote machines by using a client server mechanism.
- **manticore-columnar** [ğŸ“](./manticore-columnar) [ğŸŒ](https://github.com/GerHobbelt/columnar) -- Manticore Columnar Library is a column-oriented storage and secondary indexing library, aiming to provide **decent performance with low memory footprint at big data volume**. When used in combination with [Manticore Search](https://github.com/manticoresoftware/manticoresearch) it can be beneficial for those looking for:
  
  1. log analytics including rich free text search capabities (which is missing in e.g. [Clickhouse](https://github.com/ClickHouse/ClickHouse) - great tool for metrics analytics)
  2. faster / low resource consumption log/metrics analytics. Since the library and Manticore Search are both written in C++ with low optimizations in mind, in many cases the performance / RAM consumption is better than in Lucene / SOLR / Elasticsearch
  3. running log / metric analytics in docker / kubernetes. Manticore Search + the library can work with as little as 30 megabytes of RAM which Elasticsearch / Clickhouse can't. It also starts in less than a second or a few seconds in the worst case. Since the overhead is so little you can afford having more nodes of Manticore Search + the library than Elasticsearch. More nodes and quicker start means higher high availability and agility.
  4. powerful SQL for logs/metrics analytics and everything else [Manticore Search](https://github.com/manticoresoftware/manticoresearch) can give you

- **manticore-plugins** [ğŸ“](./manticore-plugins) [ğŸŒ](https://github.com/GerHobbelt/manticore-plugins) -- Manticore Search plugins and UDFs (user defined functions) -- Manticore Search can be extended with help of plugins and custom functions (aka user defined functions or UDFs).
- **manticoresearch** [ğŸ“](./manticoresearch) [ğŸŒ](https://github.com/GerHobbelt/manticoresearch) -- Manticore Search is an easy to use open source fast database for search. Good alternative for Elasticsearch. What distinguishes it from other solutions is:
  
  * It's very fast and therefore more cost-efficient than alternatives, for example Manticore is:
  * Modern MPP architecture and smart query parallelization capabilities allow to fully utilize all your CPU cores to **lower response time** as much as possible, when needed.
  * Powerful and fast full-text search which **works fine for small and big datasets**
  * Traditional **row-wise storage** for small, medium and big size datasets
  * **Columnar storage** support via the [Manticore Columnar Library](https://github.com/manticoresoftware/columnar/) for bigger datasets (much bigger than can fit in RAM)
  * Easy to use secondary indexes (you don't need to create them manually)
  * Cost-based optimizer for search queries
  * SQL-first: Manticore's **native syntax is SQL**. It speaks SQL over HTTP and uses the MySQL protocol (you can use your preferred MySQL client)
  * **JSON over HTTP**: to provide a more programmatic way to manage your data and schemas, Manticore provides a HTTP JSON protocol
  * Written fully in C++: **starts fast, doesn't take much RAM**, and low-level optimizations provide good performance
  * **Real-time inserts**: after an INSERT is made, the document is accessible immediately
  * [Interactive courses](https://play.manticoresearch.com/) for **easier learning**
  * **Built-in replication and load balancing**
  * **Can sync** from MySQL/PostgreSQL/ODBC/xml/csv out of the box
  * Not fully ACID-compliant, but **supports transactions and binlog** for safe writes

- **many-stop-words** [ğŸ“](./many-stop-words) [ğŸŒ](https://github.com/GerHobbelt/many-stop-words) -- Many Stop Words is a simple Python package that provides a single function for loading sets of stop words for different languages.
- **mapreduce** [ğŸ“](./mapreduce) [ğŸŒ](https://github.com/GerHobbelt/mapreduce) -- the MapReduce-MPI (MR-MPI) library. MapReduce is the operation popularized by Google for computing on large distributed data sets.  See the Wikipedia entry on MapReduce for an overview of what a MapReduce is. The MR-MPI library is a simple, portable implementation of MapReduce that runs on any serial desktop machine or large parallel machine using MPI message passing.
- **marian** [ğŸ“](./marian) [ğŸŒ](https://github.com/GerHobbelt/marian) -- an efficient Neural Machine Translation framework written in pure C++ with minimal dependencies.
- **MariGold.OpenXHTML** [ğŸ“](./MariGold.OpenXHTML) [ğŸŒ](https://github.com/GerHobbelt/MariGold.OpenXHTML) -- a wrapper library for Open XML SDK to convert HTML documents into Open XML word documents. It has simply encapsulated the complexity of Open XML yet exposes the properties of Open XML for manipulation.
- **math-atlas** [ğŸ“](./math-atlas) [ğŸŒ](https://github.com/GerHobbelt/math-atlas) -- The ATLAS (Automatically Tuned Linear Algebra Software) project is an ongoing research effort focusing on applying empirical techniques in order to provide portable performance, delivering an efficient BLAS implementation, as well as a few routines from LAPACK.
- **mathtoolbox** [ğŸ“](./mathtoolbox) [ğŸŒ](https://github.com/GerHobbelt/mathtoolbox) -- mathematical tools (interpolation, dimensionality reduction, optimization, etc.) written in C++11 and [Eigen](http://eigen.tuxfamily.org/).
- **matplotplusplus** [ğŸ“](./matplotplusplus) [ğŸŒ](https://github.com/GerHobbelt/matplotplusplus) -- **Matplot++** is a graphics library for data visualization that provides interactive plotting, means for exporting plots in high-quality formats for scientific publications, a compact syntax consistent with similar libraries, dozens of plot categories with specialized algorithms, multiple coding styles, and supports generic backends.
- **mcmc** [ğŸ“](./mcmc) [ğŸŒ](https://github.com/GerHobbelt/mcmc) -- Monte Carlo
- **mcmc-jags** [ğŸ“](./mcmc-jags) [ğŸŒ](https://github.com/GerHobbelt/mcmc-jags) -- JAGS (Just Another Gibbs Sampler), a program for analysis of Bayesian Graphical models by Gibbs Sampling.
- **mcmd** [ğŸ“](./mcmd) [ğŸŒ](https://github.com/GerHobbelt/mcmd) -- MCMD (M-Command): a set of commands for handling large scale CSV data. **MCMD** (called as M-Command) is a set of commands that are developed for the purpose of high-speed processing of large-scale structured tabular data in CSV format. It is possible to efficiently process large scale data with hundred millions row of records on a standard PC.
- **mecab** [ğŸ“](./mecab) [ğŸŒ](https://github.com/GerHobbelt/mecab) -- MeCab (Yet Another Part-of-Speech and Morphological Analyzer) is a high-performance morphological analysis engine, designed to be independent of languages, dictionaries, and corpora, using Conditional Random Fields ((CRF)[http://www.cis.upenn.edu/~pereira/papers/crf.pdf]) to estimate the parameters.
- **mechascribe** [ğŸ“](./mechascribe) [ğŸŒ](https://github.com/GerHobbelt/mechascribe) -- a text rendering abstraction trying to support as much scripts as possible by combining the best publicly available libraries. Features support for complex text layout (using the `raqm` library), feature-complete rendering (using Freetype), very fast software rendering, modern 2-step CPU+GPU rendering, simplified distribution of the Noto fonts for extensive unicode coverage and completely independent font fallback management. The first step to supporting as much scripts as possible consists in gathering a set of fonts covering all the required glyphs. The Noto fonts were created by Google to solve this exact issue. The complete collection weights more than 1.5GiB, but keeping only the regular-weight variable-width sans-serif variants makes it only 74MiB. Zstd compression can help us reduce its size even further: using its most aggressive parameters, our set can be made to fit a 16MiB file. While the compression takes quite some time even on a powerful computer, the resulting archive still unpacks almost instantaneously.
- **MegEngine** [ğŸ“](./MegEngine) [ğŸŒ](https://github.com/GerHobbelt/MegEngine) -- MegEngine is a fast, scalable, and user friendly deep learning framework with 3 key features: (1) Unified framework for both training and inference, (2) The lowest hardware requirements and (3) Inference efficiently on all platforms.
- **memory** [ğŸ“](./memory) [ğŸŒ](https://github.com/GerHobbelt/memory) -- the C++ STL allocator model has various flaws. For example, they are fixed to a certain type, because they are almost necessarily required to be templates. So you can't easily share a single allocator for multiple types. In addition, you can only get a copy from the containers and not the original allocator object. At least with C++11 they are allowed to be stateful and so can be made object not instance based. But still, the model has many flaws. Over the course of the years many solutions have been proposed, for example [EASTL]. This library is another. But instead of trying to change the STL, it works with the current implementation.
- **merror** [ğŸ“](./merror) [ğŸŒ](https://github.com/GerHobbelt/merror) -- **MError** C++ Macro Error Handling Library is a library for error handling in C++ without exceptions. It requires C++17 and only works for gcc or clang compilers.
- **mesh-allocator** [ğŸ“](./mesh-allocator) [ğŸŒ](https://github.com/GerHobbelt/Mesh) -- Mesh: Compacting Memory Management for C/C++ -- Mesh is a drop in replacement for [malloc(3)](http://man7.org/linux/man-pages/man3/malloc.3.html) that can transparently recover from memory fragmentation without any changes to application code. Mesh is described in detail in a [paper (PDF)](https://github.com/plasma-umass/Mesh/raw/master/mesh-pldi19-powers.pdf) that appeared at PLDI 2019.
- **messagebox-windows** [ğŸ“](./messagebox-windows) [ğŸŒ](https://github.com/GerHobbelt/messagebox-windows) -- drive `MessageBox` and `MessageBeep` Win32 APIs
- **metalink-cli** [ğŸ“](./metalink-cli) [ğŸŒ](https://github.com/GerHobbelt/command) -- a small program which generates a metalink record on `stdout` for every file given on the commandline and using the mirror list from `stdin`.
- **metalink-mini-downloader** [ğŸ“](./metalink-mini-downloader) [ğŸŒ](https://github.com/GerHobbelt/mini-downloader) -- a small metalink downloader written in C++, using boost, libcurl and expat. It can either be compiled so that it downloads a specific file and then (optionally) launches it or be compiled into a "downloader template", which can later be used to create a custom downloader by replacing text strings inside the executable (they are marked in a special way, to make this easy).
- **MetBrewer** [ğŸ“](./MetBrewer) [ğŸŒ](https://github.com/GerHobbelt/MetBrewer) -- palettes inspired by works at the Metropolitan Museum of Art in New York. Pieces selected come from various time periods, regions, and mediums.
- **mht-rip** [ğŸ“](./mht-rip) [ğŸŒ](https://github.com/GerHobbelt/mht-rip) -- as I have several HTML pages stored in this MHTML format. See also CHM: `CHM-lib`
- **MicroPather** [ğŸ“](./MicroPather) [ğŸŒ](https://github.com/GerHobbelt/MicroPather) -- a path finder and A* solver (astar or a-star) written in platform independent C++ that can be easily integrated into existing code. MicroPather focuses on being a path finding engine for video games but is a generic A* solver.
- **microsoft-performance-toolkit-sdk** [ğŸ“](./microsoft-performance-toolkit-sdk) [ğŸŒ](https://github.com/GerHobbelt/microsoft-performance-toolkit-sdk) -- The Microsoft Performance Toolkit is a collection of cross-platform tools developers can use to create and extend performance analysis applications. It serves as the runtime of the Windows Performance Analyzer, a Windows program included in the Windows Performance Toolkit. By using the Microsoft Performance Toolkit SDK, Windows Performance Analyzer - or any performance analysis application - can be configured to process and display performance data from arbitrary sources.
- **midas** [ğŸ“](./midas) [ğŸŒ](https://github.com/GerHobbelt/MIDAS) -- C++ implementation of:
  
  - [MIDAS: Microcluster-Based Detector of Anomalies in Edge Streams](https://arxiv.org/pdf/1911.04464.pdf). *Siddharth Bhatia, Bryan Hooi, Minji Yoon, Kijung Shin, Christos Faloutsos*. AAAI 2020.
  - [Real-time Streaming Anomaly Detection in Dynamic Graphs](https://arxiv.org/pdf/2009.08452.pdf). *Siddharth Bhatia, Rui Liu, Bryan Hooi, Minji Yoon, Kijung Shin, Christos Faloutsos*. TKDD 2022.

- **mimalloc** [ğŸ“](./mimalloc) [ğŸŒ](https://github.com/GerHobbelt/mimalloc) -- a compact general purpose allocator with excellent performance.
- **mime-mega** [ğŸ“](./mime-mega) [ğŸŒ](https://github.com/GerHobbelt/MegaMimes) -- MIME extract/insert/encode/decode: use for MHTML support
- **mimetic** [ğŸ“](./mimetic) [ğŸŒ](https://github.com/GerHobbelt/mimetic) -- MIME: use for MHTML support
- **minhash_clustering** [ğŸ“](./minhash_clustering) [ğŸŒ](https://github.com/GerHobbelt/minhash_clustering) -- this program is for clustering protein conserved regions using MinWise Independent Hashing. The code uses MRMPI library for MapReduce in C/C++ and constitutes of two major parts.
- **minifb** [ğŸ“](./minifb) [ğŸŒ](https://github.com/GerHobbelt/minifb) -- MiniFB (Mini FrameBuffer) is a small cross platform library that makes it easy to render (32-bit) pixels in a window.
- **minimp3** [ğŸ“](./minimp3) [ğŸŒ](https://github.com/GerHobbelt/minimp3) -- a minimalistic, single-header library for decoding MP3. minimp3 is designed to be small, fast (with SSE and NEON support), and accurate (ISO conformant).
- **miniscript** [ğŸ“](./miniscript) [ğŸŒ](https://github.com/GerHobbelt/miniscript) -- the [MiniScript scripting language](http://miniscript.org).
- **minizip-ng** [ğŸ“](./minizip-ng) [ğŸŒ](https://github.com/GerHobbelt/minizip-ng) -- a zip manipulation library written in C that is supported on Windows, macOS, and Linux. Minizip was originally developed by [Gilles Vollant](https://www.winimage.com/zLibDll/minizip.html) in 1998. It was first included in the zlib distribution as an additional code contribution starting in zlib 1.1.2. Since that time, it has been continually improved upon and contributed to by many people. The original [project](https://github.com/madler/zlib/tree/master/contrib/minizip) can still be found in the zlib distribution that is maintained by Mark Adler.
- **mipp** [ğŸ“](./mipp) [ğŸŒ](https://github.com/GerHobbelt/MIPP) -- MyIntrinsics++ (MIPP): a portable wrapper for vector intrinsic functions (SIMD) written in C++11. It works for SSE, AVX, AVX-512 and ARM NEON (32-bit and 64-bit) instructions. MIPP wrapper supports simple/double precision floating-point numbers and also signed integer arithmetic (64-bit, 32-bit, 16-bit and 8-bit). With the MIPP wrapper you do not need to write a specific intrinsic code anymore. Just use provided functions and the wrapper will automatically generate the right intrisic calls for your specific architecture.
- **MITIE-nlp** [ğŸ“](./MITIE-nlp) [ğŸŒ](https://github.com/GerHobbelt/MITIE) -- provides state-of-the-art information extraction tools. Includes tools for performing [named entity extraction](http://blog.dlib.net/2014/04/mitie-completely-free-and-state-of-art.html) and [binary relation detection](http://blog.dlib.net/2014/07/mitie-v02-released-now-includes-python.html) as well as tools for training custom extractors and relation detectors.  MITIE is built on top of [dlib](http://dlib.net), a high-performance machine-learning library, MITIE makes use of several state-of-the-art techniques including the use of distributional word embeddings and Structural Support Vector Machines.
- **mitlm** [ğŸ“](./mitlm) [ğŸŒ](https://github.com/GerHobbelt/mitlm) -- the MIT Language Modeling Toolkit (MITLM) toolkit is a set of tools designed for the efficient estimation of statistical n-gram language models involving iterative parameter estimation.  It achieves much of its efficiency through the use of a compact vector representation of n-grams.
- **mlinterp** [ğŸ“](./mlinterp) [ğŸŒ](https://github.com/GerHobbelt/mlinterp) -- a fast C++ routine for linear interpolation in arbitrary dimensions (i.e., multilinear interpolation).
- **mlpack** [ğŸ“](./mlpack) [ğŸŒ](https://github.com/GerHobbelt/mlpack) -- an intuitive, fast, and flexible C++ machine learning library, meant to be a machine learning analog to LAPACK, aiming to implement a wide array of machine learning methods and functions as a "swiss army knife" for machine learning researchers.
- **mmc** [ğŸ“](./mmc) [ğŸŒ](https://github.com/GerHobbelt/mmc) -- Monte Carlo
- **mmkv** [ğŸ“](./mmkv) [ğŸŒ](https://github.com/GerHobbelt/MMKV) -- an **efficient**, **small**, **easy-to-use** mobile key-value storage framework used in the WeChat application. It's currently available on **Android**, **iOS/macOS**, **Win32** and **POSIX**.
- **MNN** [ğŸ“](./MNN) [ğŸŒ](https://github.com/GerHobbelt/MNN) -- a highly efficient and lightweight deep learning framework. It supports inference and training of deep learning models, and has industry leading performance for inference and training on-device. At present, MNN has been integrated in more than 30 apps of Alibaba Inc, such as Taobao, Tmall, Youku, Dingtalk, Xianyu and etc., covering more than 70 usage scenarios such as live broadcast, short video capture, search recommendation, product searching by image, interactive marketing, equity distribution, security risk control. In addition, MNN is also used on embedded devices, such as IoT. Inside Alibaba, [MNN](https://mp.weixin.qq.com/s/5I1ISpx8lQqvCS8tGd6EJw) works as the basic module of the compute container in the [Walle](https://mp.weixin.qq.com/s/qpeCETty0BqqNJV9CMJafA) System, the first end-to-end, general-purpose, and large-scale production system for device-cloud collaborative machine learning, which has been published in the top system conference OSDIâ€™22.
- **modbus-esp8266** [ğŸ“](./modbus-esp8266) [ğŸŒ](https://github.com/GerHobbelt/modbus-esp8266) -- a Modbus Library for Arduino. Supports ModbusRTU, ModbusTCP and ModbusTCP Security.
- **ModernCppStarter** [ğŸ“](./ModernCppStarter) [ğŸŒ](https://github.com/GerHobbelt/ModernCppStarter) -- for setting up a new C++ project, providing a significant amount of preparation and boilerplate code, even more so for modern C++ projects with tests, executables and continuous integration. This template is the result of learnings from many previous projects and should help reduce the work required to setup up a modern C++ project.
- **monolith** [ğŸ“](./monolith) [ğŸŒ](https://github.com/GerHobbelt/monolith) -- a monorepo with several optimization projects.
  
  One of the highlights is a state-of-the-art scheduler using column generation, which significantly outperforms all other optimizers at [schedulingbenchmarks.org](http://www.schedulingbenchmarks.org/). **Try it in the browser (wasm) [here](https://www.strandmark.net/wasm/shift_scheduling_colgen_page.html)!**
  
  Implements the algorithm described in [_First-order Linear Programming in a Column Generation-Based Heuristic Approach to the Nurse Rostering Problem_](https://www.strandmark.net/papers/first-order-scheduling.pdf) (2020) [doi link](https://doi.org/10.1016/j.cor.2020.104945).
  
  The `minimum::linear::colgen` module contains code for solving scheduling problems. It significantly outperforms all other optimizers at [schedulingbenchmarks.org](http://www.schedulingbenchmarks.org/).
  
  Some of the reasons it is fast:
  
  - It uses a first-order LP solver based on papers by Chambolle and Pock.
  - The pricing problem uses highly optimized dynamic programming in a DAG (in `minimum::algorithms`).
  - The [Ryan-Foster rule](https://strandmark.wordpress.com/2018/01/24/visualizing-the-ryan-foster-rule/) is used to iteratively work towards an integer solution. There is no time to branch and bound for big problems.

- **morton_filter** [ğŸ“](./morton_filter) [ğŸŒ](https://github.com/GerHobbelt/morton_filter) -- a [Morton filter](https://www.vldb.org/pvldb/vol11/p1041-breslow.pdf) -- a new approximate set membership data structure. A Morton filter is a modified cuckoo filter that is optimized for bandwidth-constrained systems. Morton filters use additional computation in order to reduce their off-chip memory traffic. Like a cuckoo filter, a Morton filter supports insertions, deletions, and lookup operations. It additionally adds high-throughput self-resizing, a feature of quotient filters, which allows a Morton filter to increase its capacity solely by leveraging its internal representation. This capability is in contrast to existing vanilla cuckoo filter implementations, which are static and thus require using a backing data structure that contains the full set of items to resize the filter. Morton filters can also be configured to use less memory than a cuckoo filter for the same error rate while simultaneously delivering insertion, deletion, and lookup throughputs that are, respectively, up to 15.5x, 1.3x, and 2.5x higher than a cuckoo filter. Morton filters in contrast to vanilla cuckoo filters do not require a power of two number of buckets but rather only a number that is a multiple of two. They also use fewer bits per item than a Bloom filter when the target false positive rate is less than around 1% to 3%.
- **mosquitto** [ğŸ“](./mosquitto) [ğŸŒ](https://github.com/GerHobbelt/mosquitto) -- Eclipse Mosquitto is an open source implementation of a server for version 5.0, 3.1.1, and 3.1 of the MQTT protocol. It also includes a C and C++ client library, and the `mosquitto_pub` and `mosquitto_sub` utilities for publishing and subscribing.
- **mozjpeg** [ğŸ“](./mozjpeg) [ğŸŒ](https://github.com/GerHobbelt/mozjpeg) -- the Mozilla JPEG Encoder Project improves JPEG compression efficiency achieving higher visual quality and smaller file sizes at the same time. It is compatible with the JPEG standard, and the vast majority of the world's deployed JPEG decoders. MozJPEG is a patch for [libjpeg-turbo](https://github.com/libjpeg-turbo/libjpeg-turbo).
- **MPMCQueue** [ğŸ“](./MPMCQueue) [ğŸŒ](https://github.com/GerHobbelt/MPMCQueue) -- a bounded multi-producer multi-consumer concurrent queue written in C++11.
- **mrpt** [ğŸ“](./mrpt) [ğŸŒ](https://github.com/GerHobbelt/mrpt) -- MRPT is a lightweight and easy-to-use library for approximate nearest neighbor search with random projection. The index building has an integrated hyperparameter tuning algorithm, so the only hyperparameter required to construct the index is the target recall level! According to [our experiments](https://github.com/ejaasaari/mrpt-comparison/) MRPT is one of the fastest libraries for approximate nearest neighbor search.
  
  In the offline phase of the algorithm MRPT indexes the data with a collection of *random projection trees*. In the online phase the index structure allows us to answer queries in superior time. A detailed description of the algorithm with the time and space complexities, and the aforementioned comparisons can be found in [our article](https://www.cs.helsinki.fi/u/ttonteri/pub/bigdata2016.pdf) that was published in IEEE International Conference on Big Data 2016.
  
  The algorithm for automatic hyperparameter tuning is described in detail in our new article that will be presented in Pacific-Asia Conference on Knowledge Discovery and Data Mining 2019 ([arxiv preprint](https://arxiv.org/abs/1812.07484)).

- **ms_cpp_client_telemetry** [ğŸ“](./ms_cpp_client_telemetry) [ğŸŒ](https://github.com/GerHobbelt/cpp_client_telemetry) -- 1DS C/C++ SDK enables cross-platform telemetry collection from various Microsoft products. It enables data / telemetry upload to Collector++. 1DS (One Data Strategy), also known as One Observability, is a cross-org initiative with five teams across the company coming together to unify multiple telemetry efforts at Microsoft. Collector++ is the externally-facing destination end-point where telemetry data is uploaded to that subsequently routes the data to Microsoft internal data pipeline.
- **mujs** [ğŸ“](../../thirdparty/mujs) [ğŸŒ](https://github.com/GerHobbelt/mujs) -- a lightweight ES5 Javascript interpreter designed for embedding in other software to extend them with scripting capabilities.
- **Multicore-TSNE** [ğŸ“](./Multicore-TSNE) [ğŸŒ](https://github.com/GerHobbelt/Multicore-TSNE) -- Multicore t-SNE is a multicore modification of [Barnes-Hut t-SNE](https://github.com/lvdmaaten/bhtsne) by L. Van der Maaten with Python CFFI-based wrappers. This code also works **faster than sklearn.TSNE** on 1 core (as of version 0.18).
- **MultipartEncoder** [ğŸ“](./MultipartEncoder) [ğŸŒ](https://github.com/GerHobbelt/MultipartEncoder) -- a C++ implementation of encoding multipart/form-data. You may find the asynchronous http-client, i.e. [cpprestsdk](https://github.com/Microsoft/cpprestsdk), does not support posting a multipart/form-data request. This MultipartEncoder is a work around to generate the body content of multipart/form-data format, so that then you can use a cpp HTTP-client, which is not limited to cpprestsdk, to post a multipart/form-data request by setting the encoded body content.
- **multiverso** [ğŸ“](./multiverso) [ğŸŒ](https://github.com/GerHobbelt/Multiverso) -- a parameter server based framework for training machine learning models on big data with numbers of machines. It is currently a standard C++ library and provides a series of friendly programming interfaces. Now machine learning researchers and practitioners do not need to worry about the system routine issues such as distributed model storage and operation, inter-process and inter-thread communication, multi-threading management, and so on. Instead, they are able to focus on the core machine learning logics: data, model, and training.
- **MuPDF itself**  [ğŸ“](../../) [ğŸŒ](https://github.com/GerHobbelt/mupdf) -- this MuPDF fork is geared towards use with [Qiqqa (document and citation manager)](https://github.com/jimmejardine/qiqqa-open-source/). It is based on [the original MuPDF work done by Artifex](https://artifex.com/products/mupdf/), _closely tracks the developments overthere_ and augments the codebase with other C/C++ based tools, which are useful in and around the Qiqqa document processes, such as
  
  * text extraction
  * metadata extraction (including annotations)
  * OCR (_text recognition_ as an required extension of _text extraction_ when you have image-based PDFs, which happens quite often in the wild)
  * Qiqqa database support (SQLite I/O; we do include the generic SQLite tools as well to "open up" the Qiqqa _core components_ for advanced usage and users who wish to perform custom actions on the collected and managed data)

- **mutable_rank_select** [ğŸ“](./mutable_rank_select) [ğŸŒ](https://github.com/GerHobbelt/mutable_rank_select) -- Rank/Select Queries over Mutable Bitmaps. Given a *mutable* bitmap `B[0..u)` where `n` bits are set, the *rank/select problem* asks for a data structure built from `B` that supports `rank(i)` (the number of bits set in `B[0..i]`, for 0 â‰¤ i < u), `select(i)` (the position of the i-th bit set, for 0 â‰¤ i < n), `flip(i)` (toggles `B[i]`, for 0 â‰¤ i < u) and `access(i)` (return `B[i]`, for 0 â‰¤ i < u). The input bitmap is partitioned into blocks and a tree index is built over them. The tree index implemented in the library is an optimized b-ary Segment-Tree with SIMD AVX2/AVX-512 instructions. You can test a block size of 256 or 512 bits, and various rank/select algorithms for the blocks such as broadword techniques, CPU intrinsics, and SIMD instructions.
- **mxnet** [ğŸ“](./mxnet) [ğŸŒ](https://github.com/GerHobbelt/mxnet) -- Apache MXNet is a deep learning framework designed for both *efficiency* and *flexibility*. It allows you to ***mix*** [symbolic and imperative programming](https://mxnet.apache.org/api/architecture/program_model) to ***maximize*** efficiency and productivity.
- **mydumper** [ğŸ“](./mydumper) [ğŸŒ](https://github.com/GerHobbelt/mydumper) -- a MySQL Logical Backup Tool. It has 2 tools:
  
  * `mydumper` which is responsible to export a consistent backup of MySQL databases
  * `myloader` reads the backup from mydumper, connects the to destination database and imports the backup.

- **mysql-connector-cpp** [ğŸ“](./mysql-connector-cpp) [ğŸŒ](https://github.com/GerHobbelt/mysql-connector-cpp) -- MySQL Connector/C++ is a release of MySQL Connector/C++, [the C++ interface](https://dev.mysql.com/doc/dev/connector-cpp/8.0/) for communicating with MySQL servers.
- **n2-kNN** [ğŸ“](./n2-kNN) [ğŸŒ](https://github.com/GerHobbelt/n2) -- N2: Lightweight approximate **N**\ earest **N**\ eighbor algorithm library. N2 stands for two N's, which comes from \'Approximate ``N``\ earest ``N``\ eighbor Algorithm\'. Before N2, there has been other great approximate nearest neighbor libraries such as `Annoy` and `NMSLIB`. However, each of them had different strengths and weaknesses regarding usability, performance, etc. N2 has been developed aiming to bring the strengths of existing aKNN libraries and supplement their weaknesses.
- **nameof** [ğŸ“](./nameof) [ğŸŒ](https://github.com/GerHobbelt/nameof) -- header-only C++17 library providing nameof macros and functions to simply obtain the name of a variable, type, function, macro, and enum.
- **nanodbc** [ğŸ“](./nanodbc) [ğŸŒ](https://github.com/GerHobbelt/nanodbc) -- a small C++ wrapper for the native C ODBC API.
- **nanoflann** [ğŸ“](./nanoflann) [ğŸŒ](https://github.com/GerHobbelt/nanoflann) -- a C++11 header-only library for building KD-Trees of datasets with different topologies: R^2, R^3 (point clouds), SO(2) and SO(3) (2D and 3D rotation groups). No support for approximate NN is provided. This library is a fork of the `flann` library by Marius Muja and David G. Lowe, and born as a child project of `MRPT`.
- **nanoflann_dbscan** [ğŸ“](./nanoflann_dbscan) [ğŸŒ](https://github.com/GerHobbelt/nanoflann_dbscan) -- a fast C++ implementation of the Density-Based Spatial Clustering of Applications with Noise (DBSCAN) algorithm.
- **nanogui** [ğŸ“](./nanogui) [ğŸŒ](https://github.com/GerHobbelt/nanogui) -- NanoGUI is a minimalistic cross-platform widget library for OpenGL 3+, GLES 2/3, and Metal. It supports automatic layout generation, stateful C++ lambdas callbacks, a variety of useful widget types and Retina-capable rendering on Apple devices thanks to NanoVG_ by Mikko Mononen.
- **NanoLog** [ğŸ“](./NanoLog) [ğŸŒ](https://github.com/GerHobbelt/NanoLog) -- an extremely performant nanosecond scale logging system for C++ that exposes a simple printf-like API and achieves over 80 million logs/second at a median latency of just over 7 nanoseconds.
- **nanomsg-nng** [ğŸ“](./nanomsg-nng) [ğŸŒ](https://github.com/GerHobbelt/nng) -- a rewrite of the Scalability Protocols library known as https://github.com/nanomsg/nanomsg[libnanomsg], which adds significant new capabilities, while retaining compatibility with the original. NNG is a lightweight, broker-less library, offering a simple API to solve common recurring messaging problems, such as publish/subscribe, RPC-style request/reply, or service discovery.
- **nano-signal-slot** [ğŸ“](./nano-signal-slot) [ğŸŒ](https://github.com/GerHobbelt/nano-signal-slot) -- pure C++17 Signals and Slots (observer pattern)
- **nanosvg** [ğŸ“](./nanosvg) [ğŸŒ](https://github.com/GerHobbelt/nanosvg) -- a simple stupid single-header-file SVG parser. The output of the parser is a list of cubic bezier shapes. Suitable for anything from rendering scalable icons in your editor application to prototyping a game. NanoSVG supports a wide range of SVG features.
- **nanovg-qjs** [ğŸ“](./nanovg-qjs) [ğŸŒ](https://github.com/GerHobbelt/nanovg-qjs) -- QuickJS binding for nanovg
- **nativefiledialog-extended** [ğŸ“](./nativefiledialog-extended) [ğŸŒ](https://github.com/GerHobbelt/nativefiledialog-extended) -- a small C library with that portably invokes native file open, folder select and file save dialogs.  Write dialog code once and have it pop up native dialogs on all supported platforms.  Avoid linking large dependencies like wxWidgets and Qt.
- **ncnn** [ğŸ“](./ncnn) [ğŸŒ](https://github.com/GerHobbelt/ncnn) -- high-performance neural network inference computing framework optimized for mobile platforms (i.e. small footprint)
- **nedtries** [ğŸ“](./nedtries) [ğŸŒ](https://github.com/GerHobbelt/nedtries) -- an in-place bitwise binary Fredkin trie algorithm which allows for near constant time insertions, deletions, finds, closest fit finds and iteration. On modern hardware it is approximately 50-100% faster than red-black binary trees, it handily beats even the venerable O(1) hash table for less than 3000 objects and it is barely slower than the hash table for 10000 objects. Past 10000 objects you probably ought to use a hash table though, and if you need nearest fit rather than close fit then red-black trees are still optimal.
- **netdata** [ğŸ“](./netdata) [ğŸŒ](https://github.com/GerHobbelt/netdata) -- <a href="https://www.netdata.cloud">Netdata</a> collects metrics per second and presents them in beautiful low-latency dashboards. It is designed to run on all of your physical and virtual servers, cloud deployments, Kubernetes clusters, and edge/IoT devices, to monitor your systems, containers, and applications. It scales nicely from just a single server to thousands of servers, even in complex multi/mixed/hybrid cloud environments, and given enough disk space it can keep your metrics for years.
- **netpbm** [ğŸ“](./netpbm) [ğŸŒ](https://github.com/GerHobbelt/netpbm-mirror) -- a toolkit for manipulation of graphic images, including conversion of images between a variety of different formats.  There are over 300 separate tools in the package including converters for about 100 graphics formats.  Examples of the sort of image manipulation we're talking about are: Shrinking an image by 10%; Cutting the top half off of an image; Making a mirror image; Creating a sequence of images that fade from one image to another, etc.
- **neutralinoJS** [ğŸ“](./neutralinoJS) [ğŸŒ](https://github.com/GerHobbelt/neutralinojs) -- a lightweight and portable desktop application development framework. It lets you develop lightweight cross-platform desktop applications using JavaScript, HTML and CSS. Neutralinojs offers a lightweight SDK which is an alternative for Electron and NW.js. Neutralinojs doesn't bundle Chromium and uses the existing web browser library in the operating system. Neutralinojs implements a WebSocket connection for native operations and embeds a static web server to serve the web content. Also, it offers a built-in [JavaScript client library](https://github.com/neutralinojs/neutralino.js) for developers.
- **neutralinoJS-CLI** [ğŸ“](./neutralinoJS-CLI) [ğŸŒ](https://github.com/GerHobbelt/neutralinojs-cli) -- The official CLI of Neutralinojs.
- **newlisp** [ğŸ“](./newlisp) [ğŸŒ](https://github.com/GerHobbelt/newlisp) -- newLISP is a LISP-like scripting language for doing things you typically do with scripting languages: programming for the internet, system administration, text processing, gluing other programs together, etc. newLISP is a scripting LISP for people who are fascinated by LISP's beauty and power of expression, but who need it stripped down to easy-to-learn essentials. newLISP is LISP reborn as a scripting language: pragmatic and casual, simple to learn without requiring you to know advanced computer science concepts. Like any good scripting language, newLISP is quick to get into and gets the job done without fuss. newLISP has a very fast startup time, is small on resources like disk space and memory and has a deep, practical API with functions for networking, statistics, machine learning, regular expressions, multiprocessing and distributed computing built right into it, not added as a second thought in external modules.
- **nfft** [ğŸ“](./nfft) [ğŸŒ](https://github.com/GerHobbelt/nfft) -- Nonequispaced FFT (NFFT) is a software library, written in C, for computing non-equispaced fast Fourier transforms and related variations.
- **nghttp3** [ğŸ“](./nghttp3) [ğŸŒ](https://github.com/GerHobbelt/nghttp3) -- an implementation of `RFC 9114 <https://datatracker.ietf.org/doc/html/rfc9114>`_ HTTP/3 mapping over QUIC and `RFC 9204 <https://datatracker.ietf.org/doc/html/rfc9204>`_ QPACK in C.
- **ngrams-weighted** [ğŸ“](./ngrams-weighted) [ğŸŒ](https://github.com/GerHobbelt/ngweight) -- implements the method to compute N-gram IDF weights for all valid word N-grams in the given corpus (document set).
- **ngtcp2** [ğŸ“](./ngtcp2) [ğŸŒ](https://github.com/GerHobbelt/ngtcp2) -- ngtcp2 project is an effort to implement `RFC9000 <https://datatracker.ietf.org/doc/html/rfc9000>`_ QUIC protocol.
- **NiuTrans.NMT** [ğŸ“](./NiuTrans.NMT) [ğŸŒ](https://github.com/GerHobbelt/NiuTrans.NMT) -- a lightweight and efficient Transformer-based neural machine translation system. Its main features are:
  
  - Few dependencies. It is implemented with pure C++, and all dependencies are optional.
  - Flexible running modes. The system can run with various systems and devices (Linux vs. Windows, CPUs vs. GPUs, and FP32 vs. FP16, etc.).
  - Framework agnostic. It supports various models trained with other tools, e.g., fairseq models.
  - High efficiency. It is heavily optimized for fast decoding, see [our WMT paper](https://arxiv.org/pdf/2109.08003.pdf) for more details.

- **nlopt** [ğŸ“](./nlopt) [ğŸŒ](https://github.com/GerHobbelt/nlopt) -- a library for nonlinear local and global optimization, for functions with and without gradient information.  It is designed as a simple, unified interface and packaging of several free/open-source nonlinear optimization libraries.
- **nlopt-util** [ğŸ“](./nlopt-util) [ğŸŒ](https://github.com/GerHobbelt/nlopt-util) -- a single-header utility library for calling NLopt optimization in a single line using Eigen::VectorXd.
- **nmslib** [ğŸ“](./nmslib) [ğŸŒ](https://github.com/GerHobbelt/nmslib) -- Non-Metric Space Library (NMSLIB) is an efficient cross-platform similarity search library and a toolkit for evaluation of similarity search methods. The core-library does not have any third-party dependencies. It has been gaining popularity recently. In particular, it has become a part of Amazon Elasticsearch Service. The goal of the project is to create an effective and comprehensive toolkit for searching in generic and non-metric spaces. Even though the library contains a variety of metric-space access methods, our main focus is on generic and approximate search methods, in particular, on methods for non-metric spaces. NMSLIB is possibly the first library with a principled support for non-metric space searching.
- **nodesoup** [ğŸ“](./nodesoup) [ğŸŒ](https://github.com/GerHobbelt/nodesoup) -- delivers graph untangling: a force-directed graph layout simulates forces to give motion to vertices and arrange them in a way that is visually pleasing and/or reveals structure. The Fruchterman-Reingold algorithm assigns a repelling force to vertices pair of the graph, effectively pushing apart vertices so they don't overlap, and a attraction force between each adjacent vertices pair, thus dragging closer connected vertices. The forces attenuate when the vertices get respectively further apart or closer, and a global temperature also serves as a simulated annealing, capping the maximum vertex displacement at each iteration. As the forces between each component and the temperature gradually diminish, the layout stabilizes.  Another method, the Kamada Kawai algorithm, relies on the simulation of springs between each vertex, which strength is determined by the length of the shortest path between both vertices. The potential energy of each vertex, i.e. the sum of the energy of all its springs, is then computed. The goal being to reduce the global energy of the layout, each vertex is moved step-by-step until its potential energy is considered low-enough, using a Newton-Raphson algorithm.
- **notcurses** [ğŸ“](./notcurses) [ğŸŒ](https://github.com/GerHobbelt/notcurses) -- a library facilitating complex TUIs on modern terminal emulators, supporting vivid colors, multimedia, threads, and Unicode to the maximum degree possible. Things can be done with Notcurses that simply can't be done with NCURSES. It is furthermore fast as shit. What it is not: a source-compatible X/Open Curses implementation, nor a replacement for NCURSES on existing systems.
- **npoi** [ğŸ“](./npoi) [ğŸŒ](https://github.com/GerHobbelt/npoi) -- a .NET library that can read/write Office formats without Microsoft Office installed. No COM+, no interop. With NPOI, you can read/write Office 2003/2007 files very easily.
- **nsis** [ğŸ“](./nsis) [ğŸŒ](https://github.com/GerHobbelt/nsis) -- **Unofficial** "Nullsoft Scriptable Install System" (NSIS) builds
- **NSISDotNetChecker** [ğŸ“](./NSISDotNetChecker) [ğŸŒ](https://github.com/GerHobbelt/NsisDotNetChecker) -- .NET Framework Checker NSIS plugin, used to detect if the required .NET Framework is installed and if it is not - plugin will download and install the required package. The plugin's C++ source code is based on the [work of Aaron Stebner](http://blogs.msdn.com/b/astebner/archive/2009/06/16/9763379.aspx).
- **NSISFileCheck** [ğŸ“](./NSISFileCheck) [ğŸŒ](https://github.com/GerHobbelt/nsisfilecheck) -- NSIS FileCheck is a [NSIS (Nullsoft Scriptable Install System)](https://en.wikipedia.org/wiki/Nullsoft_Scriptable_Install_System) plugin that enables:
  
  - Calculating a file's hash (SHA1, SHA2)
  - Obtaining a file's string version info
  - Verifying a file's Authenticode code signature (including details)

- **NSISMultiUser** [ğŸ“](./NSISMultiUser) [ğŸŒ](https://github.com/GerHobbelt/NsisMultiUser) -- NSIS Multi User Plugin allows "per-user" (no admin required) and "per-machine" (asks elevation *only when necessary*) installations. This plugin was inspired by [MultiUser.nsh (by Joost Verburg)](http://nsis.sourceforge.net/Docs/MultiUser/Readme.html), but supports a lot of new features and is easier to use.
- **nsis-nscurl** [ğŸ“](./nsis-nscurl) [ğŸŒ](https://github.com/GerHobbelt/nsis-nscurl) -- NScurl is a NSIS (Nullsoft Scriptable Install System) plugin with advanced HTTP/HTTPS capabilities. It's implemented on top of [libcurl](https://curl.haxx.se/libcurl/) with [OpenSSL](https://www.openssl.org/) as SSL backend.
- **NSIS-OBSInstallerUtils** [ğŸ“](./NSIS-OBSInstallerUtils) [ğŸŒ](https://github.com/GerHobbelt/OBSInstallerUtils) -- designed to be used with NSIS (Unicode version). It provides the following features:
  
  ```
  OBSInstallerUtils::IsProcessRunning
  OBSInstallerUtils::IsDLLLoaded
  OBSInstallerUtils::AddInUseFileCheck
  OBSInstallerUtils::ResetInUseFileChecks
  OBSInstallerUtils::GetAppNameForInUseFiles
  OBSInstallerUtils::KillProcess
  OBSInstallerUtils::AddAllApplicationPackages
  ```

- **nsis-stdutils** [ğŸ“](./nsis-stdutils) [ğŸŒ](https://github.com/GerHobbelt/stdutils) -- StdUtils plug-in for NSIS
- **nsync** [ğŸ“](./nsync) [ğŸŒ](https://github.com/GerHobbelt/nsync) -- a C library that exports various synchronization primitives. `nsync` may be desirable in place of `pthread` primitives in some cases:  (1) nsync locks are reader-writer locks (but are as efficient as mutexes).  (2) nsync locks and condition variables occupy only two words each.  (3) nsync works on Unix-like systems and Windows.  It should be portable to other platforms straightforwardly.  (4) nsync provides conditional critical sections.  These fill the same role as condition variables, but are usually easier to use, and in most common cases are comparable in speed.  They can be easier to use in two ways:  (A) it's not necessary to surround the "wait" operation in a while loop; instead the condition is passed to the call as a function and arbitrary pointer argument.  (B) it's not necessary to wake or signal explicitly when the condition(s) become true; they are checked automatically. The primary downsides are:  (A) they are not available in most other common synchronization APIs, and so they may be unfamiliar (even though they date back to the 1960s), and (B) if threads routinely wait on many distinct, false conditions associated with the same lock, they may be slower than condition variables. In this case, clients can use condition variables in the normal way; conditional critical sections and condition variables can be used with the same lock.  (5) nsync waits can be cancelled via an object passed to the wait calls, unlike the pthread model in which threads are cancelled.  This difference can be useful if the computation needs multiple threads, or if cancellation affects only sub-operations within a larger operation by the thread.
- **numero** [ğŸ“](./numero) [ğŸŒ](https://github.com/GerHobbelt/numero) -- a library which parses/extracts a decimal number, either integer or floating-point, either in scientific notation or not, from the given input string. It uses the thousands and decimal separator symbols given in the conversion options. It also provides methods for the inverse operation, i.e. converting a value to a (English) human-readable text, e.g. "one thousand and twenty four" for `1024`.
- **nuspell** [ğŸ“](./nuspell) [ğŸŒ](https://github.com/GerHobbelt/nuspell) -- a fast and safe spelling checker software program. It is designed for languages with rich morphology and complex word compounding. Nuspell is written in modern C++ and it supports Hunspell dictionaries.
- **ocreval** [ğŸ“](./ocreval) [ğŸŒ](https://github.com/GerHobbelt/ocreval) -- `ocreval` contains 17 tools for measuring the performance of and experimenting with OCR output. `ocreval` is a modern port of the [ISRI Analytic Tools for OCR Evaluation](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.216.9427&rep=rep1&type=pdf), with UTF-8 support and other improvements.
- **ocr_eval_tools** [ğŸ“](./ocr_eval_tools) [ğŸŒ](https://github.com/GerHobbelt/ocr_eval_tools) -- toolkit to help evaluate / benchmark tesseract OCR performance.
- **OfficeIMO** [ğŸ“](./OfficeIMO) [ğŸŒ](https://github.com/GerHobbelt/OfficeIMO) -- fast and easy to use cross-platform .NET library that creates or modifies Microsoft Word (.docx) files without installing any software. Underneath it uses OpenXML SDK but heavily simplifies it.
- **ogdf** [ğŸ“](./ogdf) [ğŸŒ](https://github.com/GerHobbelt/ogdf) -- OGDF stands both for **O**pen **G**raph **D**rawing **F**ramework (the original name) and **O**pen **G**raph algorithms and **D**ata structures **F**ramework. OGDF is a self-contained C++ library for graph algorithms, in particular for (but not restricted to) automatic graph drawing. It offers sophisticated algorithms and data structures to use within your own applications or scientific projects.
- **oidn-OpenImageDenoise** [ğŸ“](./oidn-OpenImageDenoise) [ğŸŒ](https://github.com/GerHobbelt/oidn) -- IntelÂ® Open Image Denoise is an open source library of high-performance, high-quality denoising filters for images rendered with ray tracing.
- **olena** [ğŸ“](./olena) [ğŸŒ](https://github.com/GerHobbelt/olena) -- a platform dedicated to image processing.  At the moment it is mainly composed of a C++ library: Milena.  This library features many tools to easily perform image processing tasks.  Its main characteristic is its genericity: it allows to write an algorithm once and run it over many kinds of images (gray scale, color, 1D, 2D, 3D, ...).
- **omaha** [ğŸ“](./omaha) [ğŸŒ](https://github.com/GerHobbelt/omaha) -- Omaha is the open-source version of Google Update, a program to install requested software and keep it up to date.  The Google-branded version of Omaha is used to support software patching (both background updating, and on-demand update checks) for Google Chrome, Earth, and a variety of other Google products on Windows 7, 8, and 10.
- **oneDNN** [ğŸ“](./oneDNN) [ğŸŒ](https://github.com/GerHobbelt/oneDNN) -- oneAPI Deep Neural Network Library (oneDNN) is an open-source cross-platform performance library of basic building blocks for deep learning applications. oneDNN is intended for deep learning applications and framework developers interested in improving application performance on CPUs and GPUs.
- **oneTBB** [ğŸ“](./oneTBB) [ğŸŒ](https://github.com/GerHobbelt/oneTBB) -- Intel's Thread Building Blocks library: used with OpenImageIO, ...
- **online-hnsw** [ğŸ“](./online-hnsw) [ğŸŒ](https://github.com/GerHobbelt/online-hnsw) -- Online HNSW: an implementation of the HNSW index for approximate nearest neighbors search for C++14, that supports incremental insertion and removal of elements.
- **onnxruntime** [ğŸ“](./onnxruntime) [ğŸŒ](https://github.com/GerHobbelt/onnxruntime) -- a cross-platform inference and training machine-learning accelerator. **ONNX Runtime inference** can enable faster customer experiences and lower costs, supporting models from deep learning frameworks such as PyTorch and TensorFlow/Keras as well as classical machine learning libraries such as scikit-learn, LightGBM, XGBoost, etc. ONNX Runtime is compatible with different hardware, drivers, and operating systems, and provides optimal performance by leveraging hardware accelerators where applicable alongside graph optimizations and transforms. [Learn more &rarr;](https://www.onnxruntime.ai/docs/#onnx-runtime-for-inferencing)
- **onnxruntime-extensions** [ğŸ“](./onnxruntime-extensions) [ğŸŒ](https://github.com/GerHobbelt/onnxruntime-extensions) -- a library that extends the capability of the ONNX models and inference with ONNX Runtime, via ONNX Runtime Custom Operator ABIs. It includes a set of [ONNX Runtime Custom Operator](https://onnxruntime.ai/docs/reference/operators/add-custom-op.html) to support the common pre- and post-processing operators for vision, text, and nlp models. The basic workflow is to enhance a ONNX model firstly and then do the model inference with ONNX Runtime and ONNXRuntime-Extensions package.
- **onnxruntime-genai** [ğŸ“](./onnxruntime-genai) [ğŸŒ](https://github.com/GerHobbelt/onnxruntime-genai) -- generative AI: run Llama, Phi, Gemma, Mistral with ONNX Runtime. This API gives you an easy, flexible and performant way of running LLMs on any device. It implements the generative AI loop for ONNX models, including pre and post processing, inference with ONNX Runtime, logits processing, search and sampling, and KV cache management.
- **oof** [ğŸ“](./oof) [ğŸŒ](https://github.com/GerHobbelt/oof) -- OOF (omnipotent output friend) is a single C++20 header that wraps so-called [Virtual Terminal sequences](https://docs.microsoft.com/en-us/windows/console/console-virtual-terminal-sequences) (sometimes also confusingly called ["escape codes"](https://en.wikipedia.org/wiki/ANSI_escape_code)) in a convenient way, enabling console applications using OOF to be far more capable than usual: complete control over position, color and other properties of written characters.
- **openalpr** [ğŸ“](./openalpr) [ğŸŒ](https://github.com/GerHobbelt/openalpr) -- OpenALPR is an open source *Automatic License Plate Recognition* library written in C++.  The library analyzes images and video streams to identify license plates.  The output is the text representation of any license plate characters.
- **OpenBLAS** [ğŸ“](./OpenBLAS) [ğŸŒ](https://github.com/GerHobbelt/OpenBLAS) -- an optimized BLAS (Basic Linear Algebra Subprograms) library based on GotoBLAS2 1.13 BSD version.
- **OpenCL-CTS** [ğŸ“](./OpenCL-CTS) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-CTS) -- the OpenCL Conformance Test Suite (CTS) for all versions of the Khronos [OpenCL](https://www.khronos.org/opencl/) standard.
- **OpenCL-Headers** [ğŸ“](./OpenCL-Headers) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-Headers) -- C language headers for the OpenCL API.
- **OpenCL-SDK** [ğŸ“](./OpenCL-SDK) [ğŸŒ](https://github.com/GerHobbelt/OpenCL-SDK) -- the Khronos OpenCL SDK. It brings together all the components needed to develop OpenCL applications.
- **OpenColorIO** [ğŸ“](./OpenColorIO) [ğŸŒ](https://github.com/GerHobbelt/OpenColorIO) -- OpenColorIO (OCIO) is a complete color management solution geared towards motion picture production with an emphasis on visual effects and computer animation. OCIO provides a straightforward and consistent user experience across all supporting applications while allowing for sophisticated back-end configuration options suitable for high-end production usage. OCIO is compatible with the Academy Color Encoding Specification (ACES) and is LUT-format agnostic, supporting many popular formats.
- **OpenCP** [ğŸ“](./OpenCP) [ğŸŒ](https://github.com/GerHobbelt/OpenCP) -- a library for computational photography.
- **opencv** [ğŸ“](./opencv) [ğŸŒ](https://github.com/GerHobbelt/opencv) -- OpenCV: Open Source Computer Vision Library
- **opencv_contrib** [ğŸ“](./opencv_contrib) [ğŸŒ](https://github.com/GerHobbelt/opencv_contrib) -- OpenCV's extra modules. This is where you'll find new, bleeding edge OpenCV module development.
- **opencv_extra** [ğŸ“](./opencv_extra) [ğŸŒ](https://github.com/GerHobbelt/opencv_extra) -- extra data for OpenCV: Open Source Computer Vision Library
- **OpenEXR** [ğŸ“](./OpenEXR) [ğŸŒ](https://github.com/GerHobbelt/openexr) -- a high dynamic-range (HDR) image file format developed by Industrial Light & Magic (ILM) for use in computer imaging applications. OpenEXR is a lossless format for multi-layered images. Professional use. (I've used it before; nice file format.)
- **openexr-images** [ğŸ“](./openexr-images) [ğŸŒ](https://github.com/GerHobbelt/openexr-images) -- collection of images associated with the OpenEXR distribution.
- **OpenFST** [ğŸ“](./OpenFST) [ğŸŒ](https://github.com/GerHobbelt/openfst) -- a library for constructing, combining, optimizing, and searching weighted finite-state transducers (FSTs). Weighted finite-state transducers are automata where each transition has an input label, an output label, and a weight. The more familiar finite-state acceptor is represented as a transducer with each transition's input and output label equal. Finite-state acceptors are used to represent sets of strings (specifically, regular or rational sets); finite-state transducers are used to represent binary relations between pairs of strings (specifically, rational transductions). The weights can be used to represent the cost of taking a particular transition. FSTs have key applications in speech recognition and synthesis, machine translation, optical character recognition, pattern matching, string processing, machine learning, information extraction and retrieval among others. Often a weighted transducer is used to represent a probabilistic model (e.g., an n-gram model, pronunciation model). FSTs can be optimized by determinization and minimization, models can be applied to hypothesis sets (also represented as automata) or cascaded by finite-state composition, and the best results can be selected by shortest-path algorithms.
- **OpenFST-utils** [ğŸ“](./OpenFST-utils) [ğŸŒ](https://github.com/GerHobbelt/openfst-utils) -- a set of useful programs for manipulating Finite State Transducer with the OpenFst library.
- **OpenImageIO** [ğŸ“](./oiio) [ğŸŒ](https://github.com/GerHobbelt/oiio) -- Reading, writing, and processing images in a wide variety of file formats, using a format-agnostic API, aimed at VFX applications.
  
  Also includes:
  
  - an ImageCache class that transparently manages a cache so that it can access truly vast amounts of image data (tens of thousands of image files totaling multiple TB) very efficiently using only a tiny amount (tens of megabytes at most) of runtime memory.
  - ImageBuf and ImageBufAlgo functions, which constitute a simple class for storing and manipulating whole images in memory, plus a collection of the most useful computations you might want to do involving those images, including many image processing operations.
  
  The primary target audience for OIIO is VFX studios and developers of tools such as renderers, compositors, viewers, and other image-related software you'd find in a production pipeline.

- **openjpeg** [ğŸ“](../../thirdparty/openjpeg) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-openjpeg) -- OPENJPEG Library and Applications -- OpenJPEG is an open-source JPEG 2000 codec written in C language. It has been developed in order to promote the use of [JPEG 2000](http://www.jpeg.org/jpeg2000), a still-image compression standard from the Joint Photographic Experts Group ([JPEG](http://www.jpeg.org)).  Since April 2015, it is officially recognized by ISO/IEC and ITU-T as a [JPEG 2000 Reference Software](http://www.itu.int/rec/T-REC-T.804-201504-I!Amd2).
- **openlibm** [ğŸ“](./openlibm) [ğŸŒ](https://github.com/GerHobbelt/openlibm) -- [OpenLibm](https://openlibm.org/) is an effort to have a high quality, portable, standalone C mathematical library ([`libm`](http://en.wikipedia.org/wiki/libm)). The project was born out of a need to have a good `libm` for the [Julia programming language](http://www.julialang.org) that worked consistently across compilers and operating systems, and in 32-bit and 64-bit environments.
- **OpenNN** [ğŸ“](./OpenNN) [ğŸŒ](https://github.com/GerHobbelt/opennn) -- a software library written in C++ for advanced analytics. It implements neural networks, the most successful machine learning method. The main advantage of OpenNN is its high performance. This library outstands in terms of execution speed and memory allocation. It is constantly optimized and parallelized in order to maximize its efficiency.
- **openpbs** [ğŸ“](./openpbs) [ğŸŒ](https://github.com/GerHobbelt/openpbs) -- in May 2020, OpenPBS became the new name for the PBS Professional Open Source Project. OpenPBSÂ® software optimizes job scheduling and workload management in high-performance computing (HPC) environments â€“ clusters, clouds, and supercomputers â€“ improving system efficiency and peopleâ€™s productivity.  Built by HPC people for HPC people, OpenPBS is fast, scalable, secure, and resilient, and supports all modern infrastructure, middleware, and applications.
- **OpenSSL** [ğŸ“](./openssl) [ğŸŒ](https://github.com/GerHobbelt/openssl) -- OpenSSL is a robust, commercial-grade, full-featured Open Source Toolkit for the Transport Layer Security (TLS) protocol formerly known as the Secure Sockets Layer (SSL) protocol. The protocol implementation is based on a full-strength general purpose cryptographic library, which can also be used stand-alone.
- **opentelemetry-cpp** [ğŸ“](./opentelemetry-cpp) [ğŸŒ](https://github.com/GerHobbelt/opentelemetry-cpp) -- The OpenTelemetry C++ Client
- **opentelemetry-cpp-contrib** [ğŸ“](./opentelemetry-cpp-contrib) [ğŸŒ](https://github.com/GerHobbelt/opentelemetry-cpp-contrib) -- OpenTelemetry C++ Contrib repository which contains set of components extending functionality of the OpenTelemetry SDK. Instrumentation libraries, exporters, and other components can find their home here.
- **open-vcdiff** [ğŸ“](./open-vcdiff) [ğŸŒ](https://github.com/GerHobbelt/open-vcdiff) -- an encoder and decoder for the VCDIFF format, as described in [RFC 3284](http://www.ietf.org/rfc/rfc3284.txt): The VCDIFF Generic Differencing and Compression Data Format.
- **openvino** [ğŸ“](./openvino) [ğŸŒ](https://github.com/GerHobbelt/openvino) -- OpenVINOâ„¢ is an open-source toolkit for optimizing and deploying AI inference, includind several components: namely [Model Optimizer], [OpenVINOâ„¢ Runtime], [Post-Training Optimization Tool], as well as CPU, GPU, GNA, multi device and heterogeneous plugins to accelerate deep learning inference on IntelÂ® CPUs and IntelÂ® Processor Graphics. It supports pre-trained models from [Open Model Zoo], along with 100+ open source and public models in popular formats such as TensorFlow, ONNX, PaddlePaddle, MXNet, Caffe, Kaldi.
- **Open-XML-SDK** [ğŸ“](./Open-XML-SDK) [ğŸŒ](https://github.com/GerHobbelt/Open-XML-SDK) -- the Microsoft Open XML SDK (.NET) provides tools for working with Office Word, Excel, and PowerPoint documents.
- **oppat** [ğŸ“](./oppat) [ğŸŒ](https://github.com/GerHobbelt/oppat) -- Open Power/Performance Analysis Tool (OPPAT) is a cross-OS, cross-architecture Power and Performance Analysis Tool. cross-OS: supports Windows ETW trace files and Linux/Android perf/trace-cmd trace files. cross-architecture: supports Intel and ARM chips hardware events (using perf and/or PCM).
- **optim** [ğŸ“](./optim) [ğŸŒ](https://github.com/GerHobbelt/optim) -- OptimLib is a lightweight C++ library of numerical optimization methods for nonlinear functions. Features a C++11/14/17 library of local and global optimization algorithms, as well as root finding techniques, derivative-free optimization using advanced, parallelized metaheuristic methods and constrained optimization routines to handle simple box constraints, as well as systems of nonlinear constraints.
- **OptimizationTemplateLibrary** [ğŸ“](./OptimizationTemplateLibrary) [ğŸŒ](https://github.com/GerHobbelt/O-T-L) -- Optimization Template Library (OTL)
- **opus** [ğŸ“](./opus) [ğŸŒ](https://github.com/GerHobbelt/opus) -- an audio codec for interactive speech and audio transmission over the Internet. Opus can handle a wide range of interactive audio applications, including Voice over IP, videoconferencing, in-game  chat, and even remote live music performances. It can scale from low bit-rate narrowband speech to very high quality stereo music.
- **ormpp** [ğŸ“](./ormpp) [ğŸŒ](https://github.com/GerHobbelt/ormpp) -- modern C++ ORM, C++17, support mysql, postgresql, sqlite.
- **or-tools** [ğŸ“](./or-tools) [ğŸŒ](https://github.com/GerHobbelt/or-tools) -- Google Optimization Tools (a.k.a., OR-Tools) is an open-source, fast and portable software suite for solving combinatorial optimization problems. The suite includes a constraint programming solver, a linear programming solver and various graph algorithms.
- **osqp** [ğŸ“](./osqp) [ğŸŒ](https://github.com/GerHobbelt/osqp) -- the Operator Splitting Quadratic Program Solver.
- **osqp-cpp** [ğŸ“](./osqp-cpp) [ğŸŒ](https://github.com/GerHobbelt/osqp-cpp) -- a C++ wrapper for [OSQP](https://github.com/oxfordcontrol/osqp), an [ADMM](http://stanford.edu/~boyd/admm.html)-based solver for [quadratic programming](https://en.wikipedia.org/wiki/Quadratic_programming). Compared with OSQP's native C interface, the wrapper provides a more convenient input format using Eigen sparse matrices and handles the lifetime of the `OSQPWorkspace` struct. This package has similar functionality to [osqp-eigen](https://github.com/robotology/osqp-eigen).
- **osqp-eigen** [ğŸ“](./osqp-eigen) [ğŸŒ](https://github.com/GerHobbelt/osqp-eigen) -- a simple C++ wrapper for [osqp](http://osqp.readthedocs.io/en/latest/index.html) library.
- **osquery** [ğŸ“](./osquery) [ğŸŒ](https://github.com/GerHobbelt/osquery) -- a SQL powered operating system instrumentation, monitoring, and analytics framework. `osquery` exposes an operating system as a high-performance relational database.  This allows you to write SQL-based queries to explore operating system data.  With osquery, SQL tables represent abstract concepts such as running processes, loaded kernel modules, open network connections, browser plugins, hardware events or file hashes.
- **OTB** [ğŸ“](./OTB) [ğŸŒ](https://github.com/GerHobbelt/OTB) -- Orfeo ToolBox (OTB) is an open-source project for state-of-the-art remote sensing. Built on the shoulders of the open-source geospatial community, it can process high resolution optical, multispectral and radar images at the terabyte scale. A wide variety of applications are available: from ortho-rectification or pansharpening, all the way to classification, SAR processing, and much more!
- **otl** [ğŸ“](./otl) [ğŸŒ](https://github.com/GerHobbelt/otl) -- Oracle Template Library (STL-like wrapper for SQL DB queries; supports many databases besides Oracle)
- **owl** [ğŸ“](./owl) [ğŸŒ](https://github.com/GerHobbelt/owl) -- Owl Lisp is a functional dialect of the Scheme programming language. It is mainly based on the applicative subset of the R7RS standard.
- **OZBCBitmap** [ğŸ“](./OZBCBitmap) [ğŸŒ](https://github.com/GerHobbelt/OZBCBitmap) -- OZBC provides an efficent compressed bitmap to create bitmap indexes on high-cardinality columns. Bitmap indexes have traditionally been considered to work well for low-cardinality columns, which have a modest number of distinct values. The simplest and most common method of bitmap indexing on attribute A with K cardinality associates a bitmap with every attribute value V then the Vth bitmap rapresent the predicate A=V. This approach ensures an efficient solution for performing search but on high-cardinality attributes the size of the bitmap index increase dramatically. OZBC is a run-length-encoded hybrid compressed bitmap designed exclusively to create a bitmap indexes on L cardinality attributes where L>=16 and provide bitwise logical operations in running time complexity proportianl to the compressed bitmap size.
- **p7zip** [ğŸ“](./p7zip) [ğŸŒ](https://github.com/GerHobbelt/p7zip) -- p7zip-zstd = 7zip with extensions, including major modern codecs such as Brotli, Fast LZMA2, LZ4, LZ5, Lizard and Zstd.
- **PaddleClas** [ğŸ“](./PaddleClas) [ğŸŒ](https://github.com/GerHobbelt/PaddleClas) -- an image classification and image recognition toolset for industry and academia, helping users train better computer vision models and apply them in real scenarios, based onÂ [PaddlePaddle](https://github.com/paddlepaddle/paddle).
- **PaddleDetection** [ğŸ“](./PaddleDetection) [ğŸŒ](https://github.com/GerHobbelt/PaddleDetection) -- a Highly Efficient Development Toolkit for Object Detection based onÂ [PaddlePaddle](https://github.com/paddlepaddle/paddle).
- **Paddle-Lite** [ğŸ“](./Paddle-Lite) [ğŸŒ](https://github.com/GerHobbelt/Paddle-Lite) -- an updated version of Paddle-Mobile, an open-open source deep learning framework designed to make it easy to perform inference on mobile, embeded, and IoT devices. It is compatible with PaddlePaddle and pre-trained models from other sources.
- **PaddleNLP** [ğŸ“](./PaddleNLP) [ğŸŒ](https://github.com/GerHobbelt/PaddleNLP) -- a NLP library that is both **easy to use** and **powerful**. It aggregates high-quality pretrained models in the industry and provides a **plug-and-play** development experience, covering a model library for various NLP scenarios. With practical examples from industry practices, PaddleNLP can meet the needs of developers who require **flexible customization**.
- **PaddleOCR** [ğŸ“](./PaddleOCR) [ğŸŒ](https://github.com/GerHobbelt/PaddleOCR) -- PaddleOCR aims to create multilingual, awesome, leading, and practical OCR tools that help users train better models and apply them into practice.
- **PaddlePaddle** [ğŸ“](./PaddlePaddle) [ğŸŒ](https://github.com/GerHobbelt/Paddle) -- the first independent R&D deep learning platform in China. It is an industrial platform with advanced technologies and rich features that cover core deep learning frameworks, basic model libraries, end-to-end development kits, tools & components as well as service platforms. PaddlePaddle is originated from industrial practices with dedication and commitments to industrialization. It has been widely adopted by a wide range of sectors including manufacturing, agriculture, enterprise service, and so on while serving more than 4.7 million developers, 180,000 companies and generating 560,000 models. With such advantages, PaddlePaddle has helped an increasing number of partners commercialize AI.
- **pagerank** [ğŸ“](./pagerank) [ğŸŒ](https://github.com/GerHobbelt/pagerank) -- a [pagerank](http://www.ams.org/samplings/feature-column/fcarc-pagerank) implementation in C++ able to handle very big graphs.
- **paintingReorganize** [ğŸ“](./paintingReorganize) [ğŸŒ](https://github.com/GerHobbelt/paintingReorganize) -- color palatte extraction demo, based on PCA.
- **palanteer** [ğŸ“](./palanteer) [ğŸŒ](https://github.com/GerHobbelt/palanteer) -- Visual Python and C++ nanosecond profiler, logger, tests enabler: a set of lean and efficient tools to improve the quality of software, for C++ and Python programs.
- **palmtree** [ğŸ“](./palmtree) [ğŸŒ](https://github.com/GerHobbelt/palmtree) -- concurrent lock free B+Tree
- **pango** [ğŸ“](./pango) [ğŸŒ](https://github.com/GerHobbelt/pango) -- a library for layout and rendering of text, with an emphasis on internationalization. Pango can be used anywhere that text layout is needed.
- **papis-zotero** [ğŸ“](./papis-zotero) [ğŸŒ](https://github.com/GerHobbelt/papis-zotero) -- Zotero compatiblity scripts for papis. Includes a script that decodes the zotero.sqlite sqlite file that zotero uses to manage documents and creates papis Documents out of it. This script will retrieve the documents from zotero (be it pdf documents or something else) and important information like tags.
- **parallel-hashmap** [ğŸ“](./parallel-hashmap) [ğŸŒ](https://github.com/GerHobbelt/parallel-hashmap) -- a set of hash map implementations, as well as a btree alternative to std::map and std::set
- **paramonte** [ğŸ“](./paramonte) [ğŸŒ](https://github.com/GerHobbelt/paramonte) -- ParaMonte (Plain Powerful Parallel Monte Carlo Library) is a serial/parallel library of Monte Carlo routines for sampling mathematical objective functions of arbitrary-dimensions, in particular, the posterior distributions of Bayesian models in data science, Machine Learning, and scientific inference, with the design goal of unifying the **automation** (of Monte Carlo simulations), **user-friendliness** (of the library), **accessibility** (from multiple programming environments), **high-performance** (at runtime), and **scalability** (across many parallel processors).
- **pcg-cpp-random** [ğŸ“](./pcg-cpp-random) [ğŸŒ](https://github.com/GerHobbelt/pcg-cpp) -- a C++ implementation of the PCG family of random number generators, which are fast, statistically excellent, and offer a number of useful features.
- **pcg-c-random** [ğŸ“](./pcg-c-random) [ğŸŒ](https://github.com/GerHobbelt/pcg-c) -- a C implementation of the PCG family of random number generators, which are fast, statistically excellent, and offer a number of useful features.
- **pcl** [ğŸ“](./pcl) [ğŸŒ](https://github.com/GerHobbelt/pcl) -- the Point Cloud Library (PCL) is a standalone, large scale, open project for 2D/3D image and point cloud processing.
- **pcm** [ğŸ“](./pcm) [ğŸŒ](https://github.com/GerHobbelt/pcm) -- Intel&reg; Performance Counter Monitor (Intel&reg; PCM) is an application programming interface (API) and a set of tools based on the API to monitor performance and energy metrics of Intel&reg; Core&trade;, Xeon&reg;, Atom&trade; and Xeon Phi&trade; processors. PCM works on Linux, Windows, Mac OS X, FreeBSD, DragonFlyBSD and ChromeOS operating systems.
- **pcre** [ğŸ“](./pcre) [ğŸŒ](https://github.com/GerHobbelt/pcre) -- PCRE2 : Perl-Compatible Regular Expressions. The PCRE2 library is a set of C functions that implement regular expression pattern matching using the same syntax and semantics as Perl 5. PCRE2 has its own native API, as well as a set of wrapper functions that correspond to the POSIX regular expression API. It comes in three forms, for processing 8-bit, 16-bit, or 32-bit code units, in either literal or UTF encoding.
- **pdf2htmlEX** [ğŸ“](./pdf2htmlEX) [ğŸŒ](https://github.com/GerHobbelt/pdf2htmlEX) -- convert PDF to HTML without losing text or format.
- **PDFGen** [ğŸ“](./PDFGen) [ğŸŒ](https://github.com/GerHobbelt/PDFGen) -- a simple PDF Creation/Generation library, contained in a single C-file with header and no external library dependencies. Useful for embedding into other programs that require rudimentary PDF output.
- **pdfgrep** [ğŸ“](./pdfgrep) [ğŸŒ](https://github.com/GerHobbelt/pdfgrep) -- a tool to search text in PDF files. It works similarly to *grep*.
- **pdfium** [ğŸ“](./pdfium) [ğŸŒ](https://github.com/GerHobbelt/pdfium) -- the PDF library used by the Chromium project.
- **pdiff** [ğŸ“](./pdiff) [ğŸŒ](https://github.com/GerHobbelt/pdiff) -- perceptualdiff (pdiff): a program that compares two images using a perceptually based image metric.
- **pecos** [ğŸ“](./pecos) [ğŸŒ](https://github.com/GerHobbelt/pecos) -- PECOS (Predictions for Enormous and Correlated Output Spaces) is a versatile and modular machine learning (ML) framework for fast learning and inference on problems with large output spaces, such as extreme multi-label ranking (XMR) and large-scale retrieval. PECOS' design is intentionally agnostic to the specific nature of the inputs and outputs as it is envisioned to be a general-purpose framework for multiple distinct applications. Given an input, PECOS identifies a small set (10-100) of relevant outputs from amongst an extremely large (~100MM) candidate set and ranks these outputs in terms of relevance.
- **PEGTL** [ğŸ“](./PEGTL) [ğŸŒ](https://github.com/GerHobbelt/PEGTL) -- the Parsing Expression Grammar Template Library (PEGTL) is a zero-dependency C++ header-only parser combinator library for creating parsers according to a [Parsing Expression Grammar](http://en.wikipedia.org/wiki/Parsing_expression_grammar) (PEG).
- **pelikan** [ğŸ“](./pelikan) [ğŸŒ](https://github.com/GerHobbelt/pelikan) -- Pelikan is Twitter's unified cache backend.
- **percona-server** [ğŸ“](./percona-server) [ğŸŒ](https://github.com/GerHobbelt/percona-server) -- Percona Server for MySQL is a free, fully compatible, enhanced, and open source drop-in replacement for any MySQL database. It provides superior performance, scalability, and instrumentation.
- **pevents** [ğŸ“](./pevents) [ğŸŒ](https://github.com/GerHobbelt/pevents) -- Win32 events for *nix/POSIX platforms, built on top of `pthreads`. `pevents` provides most of the functionality of both manual- and auto-reset events on Windows, most-notably including simultaneous waits on multiple events (Ã  la `WaitForMultipleObjects`). `pevents` also doubles as a thin, sane wrapper for `CreateEvent()` & co. on Windows, meaning you can use `pevents` directly in your cross-platform code without `#ifdef`s for Windows/pthreads. While POSIX condition variables (pthread_cond_t) and WIN32 events both provide the essential building blocks of the synchronization primitives required to write multithreaded code with signaling, the nature of the differences between the two have lent their way towards creating different synchronization and multithreaded-programming paradigms. The only features not included are only named events and support for security attributes. To the author's best knowledge, this is the only implementation of WIN32 events available for Linux and other posix platforms that provides support for simultaneously waiting on multiple events. Depending on your needs, we've been told that pevents may be used as a lightweight alternative to libuv/libev while still allowing your code to embrace asynchronous event handling with ease.
- **pfp-cst** [ğŸ“](./pfp-cst) [ğŸŒ](https://github.com/GerHobbelt/pfp-cst) -- Prefix-Free Parsing Compressed Suffix Tree is a compressed suffix tree, built on the prefix-free parsing of the text. If you use the PFP-CST in your research, please cite: Christina Boucher, OndÅ™ej Cvacho, Travis Gagie, Jan Holub, Giovanni Manzini, Gonzalo Navarro, and Massimiliano Rossi . *"PFP Compressed Suffix Tree"*, In Proc. of the SIAM Symposium onAlgorithm Engineering and Experiments (ALENEX21), pp. 60-72. (2021).
- **PGM-index** [ğŸ“](./PGM-index) [ğŸŒ](https://github.com/GerHobbelt/PGM-index) -- the Piecewise Geometric Model index (PGM-index) is a data structure that enables fast lookup, predecessor, range searches and updates in arrays of billions of items using orders of magnitude less space than traditional indexes while providing the same worst-case query time guarantees.
- **pg_similarity** [ğŸ“](./pg_similarity) [ğŸŒ](https://github.com/GerHobbelt/pg_similarity) -- **pg\_similarity** is an extension to support similarity queries on [PostgreSQL](http://www.postgresql.org/). The implementation is tightly integrated in the RDBMS in the sense that it defines operators so instead of the traditional operators (`=` and `<>`) you can use `~~~` and `~!~` (any of these operators represents a similarity function).
- **pHash** [ğŸ“](./pHash) [ğŸŒ](https://github.com/GerHobbelt/pHash) -- the open source perceptual hash library. Potential applications include copyright protection, similarity search for media files, or even digital forensics. For example, YouTube could maintain a database of hashes that have been submitted by the major movie producers of movies to which they hold the copyright. If a user then uploads the same video to YouTube, the hash will be almost identical, and it can be flagged as a possible copyright violation. The audio hash could be used to automatically tag MP3 files with proper ID3 information, while the text hash could be used for plagiarism detection.
- **phash-gpl** [ğŸ“](./phash-gpl) [ğŸŒ](https://github.com/GerHobbelt/phash-gpl) -- pHash&trade; Perceptual Hashing Library is a collection of perceptual hashing algorithms for image, audo, video and text media.
- **phf-hash** [ğŸ“](./phf-hash) [ğŸŒ](https://github.com/GerHobbelt/phf) -- a simple implementation of the CHD perfect hash algorithm. CHD can generate perfect hash functions for very large key sets -- on the order of millions of keys -- in a very short time.
- **photino.native** [ğŸ“](./photino.native) [ğŸŒ](https://github.com/GerHobbelt/photino.Native) -- a lightweight open-source framework for building native, cross-platform desktop applications with Web UI technology. Photino enables developers to use fast, natively compiled languages like C#, C++, Java and more. Photino uses the OSs built-in WebKit-based browser control for Windows, macOS and Linux. Photino is the lightest cross-platform framework.
- **PhotonLibOS** [ğŸ“](./PhotonLibOS) [ğŸŒ](https://github.com/GerHobbelt/PhotonLibOS) -- a high-efficiency LibOS framework, based on a set of carefully selected C++ libs. The role of LibOS is to connect user apps and the kernel. Photon's API is as consistent as possible with C++ std and glibc semantics. This flattens the learning curve for lib users and brings convenience when migrating legacy codebases. Photon's runtime is driven by a coroutine lib. Out tests show that it has the best I/O performance in the open source world by the year of 2022, even among different programing languages.
- **picoc** [ğŸ“](./picoc) [ğŸŒ](https://github.com/GerHobbelt/picoc) -- PicoC is a very small C interpreter for scripting. It was originally written as a script language for a UAV's on-board flight system. It's also very suitable for other robotic, embedded and non-embedded applications. The core C source code is around 3500 lines of code. It's not intended to be a complete implementation of ISO C but it has all the essentials.
- **picohttpparser** [ğŸ“](./picohttpparser) [ğŸŒ](https://github.com/GerHobbelt/picohttpparser) -- PicoHTTPParser is a tiny, primitive, fast HTTP request/response parser. Unlike most parsers, it is stateless and does not allocate memory by itself. All it does is accept pointer to buffer and the output structure, and setups the pointers in the latter to point at the necessary portions of the buffer.
- **pico_tree** [ğŸ“](./pico_tree) [ğŸŒ](https://github.com/GerHobbelt/pico_tree) -- a C++ header only library for fast nearest neighbor searches and range searches using a KdTree.
- **pikchr** [ğŸ“](./pikchr) [ğŸŒ](https://github.com/GerHobbelt/pikchr) -- Pikchr (pronounced like "picture") is a [PIC][1]-like markup language for diagrams in technical documentation.  Pikchr is designed to be embedded in [fenced code blocks][2] of Markdown (or in similar mechanisms in other markup languages) to provide a convenient means of showing diagrams.
- **Pillow** [ğŸ“](./Pillow) [ğŸŒ](https://github.com/GerHobbelt/Pillow) -- the friendly PIL (Python Imaging Library) fork by [Jeffrey A. Clark (Alex) and contributors](https://github.com/python-pillow/Pillow/graphs/contributors). PIL is the Python Imaging Library by Fredrik Lundh and Contributors. This library provides extensive file format support, an efficient internal representation, and fairly powerful image processing capabilities.
- **pillow-resize** [ğŸ“](./pillow-resize) [ğŸŒ](https://github.com/GerHobbelt/pillow-resize) -- a C++ porting of the resize method from the [Pillow](https://github.com/python-pillow/Pillow) python library. It is written in C++ using [OpenCV](https://opencv.org/) for matrix support. The main difference with respect to the [`resize`](https://docs.opencv.org/4.5.2/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d) method of OpenCV is the use of an anti aliasing filter, that is missing in OpenCV and could introduce some artifacts, in particular with strong down-sampling.
- **pinyin** [ğŸ“](./pinyin) [ğŸŒ](https://github.com/GerHobbelt/pinyin) -- pÄ«nyÄ«n is a tool for converting Chinese characters to *pinyin*. It can be used for Chinese phonetic notation, sorting, and retrieval.
- **pipes** [ğŸ“](./pipes) [ğŸŒ](https://github.com/GerHobbelt/pipes) -- Pipes are small components for writing expressive code when working on collections. Pipes chain together into a pipeline that receives data from a source, operates on that data, and send the results to a destination. This is a header-only library, implemented in C++14.
- **piposort** [ğŸ“](./piposort) [ğŸŒ](https://github.com/GerHobbelt/piposort) -- a stable top-down adaptive branchless merge sort named piposort. It is intended as a simplified [quadsort](https://github.com/scandum/quadsort) with reduced adaptivity, but a great reduction in lines of code and overall complexity. The name stands for ping-pong.
- **pisa** [ğŸ“](./pisa) [ğŸŒ](https://github.com/GerHobbelt/pisa) -- a text search engine able to run on large-scale collections of documents. It allows researchers to experiment with state-of-the-art techniques, allowing an ideal environment for rapid development. PISA is a text search engine, though the "PISA Project" is a set of tools that help experiment with indexing and query processing. Given a text collection, PISA can build an inverted index over this corpus, allowing the corpus to be searched. The inverted index, put simply, is an efficient data structure that represents the document corpus by storing a list of documents for each unique term (see here). At query time, PISA stores its index in main memory for rapid retrieval.
- **pisa_formatter** [ğŸ“](./pisa_formatter) [ğŸŒ](https://github.com/GerHobbelt/pisa_formatter) -- converts list of documents to the [pisa-engine](https://github.com/pisa-engine/pisa) binary format: {.docs, .freqs, .sizes}. Its input should be a text file where each line is a document.  Each document starts with the document name (which should not have whitespaces) followed by a list of ascii terms separated by whitespaces which define the document. This also generates a binary .terms file which has the information to convert from term to index and is used by the query_transformer executable. This file stores all the unique terms from all the documents.
- **pixman** [ğŸ“](./pixman) [ğŸŒ](https://github.com/GerHobbelt/pixman) -- a library that provides low-level pixel manipulation features such as image compositing and trapezoid rasterization.
- **pke** [ğŸ“](./pke) [ğŸŒ](https://github.com/GerHobbelt/pke) -- python keyphrase extraction (PKE) is an open source python-based **keyphrase extraction** toolkit. It provides an end-to-end keyphrase extraction pipeline in which each component can be easily modified or extended to develop new models. `pke` also allows for easy benchmarking of state-of-the-art keyphrase extraction models, and ships with supervised models trained on the [SemEval-2010 dataset](http://aclweb.org/anthology/S10-1004).
- **PlatformFolders** [ğŸ“](./PlatformFolders) [ğŸŒ](https://github.com/GerHobbelt/PlatformFolders) -- a C++ library to look for directories like `My Documents`, `~/.config`, `%APPDATA%`, etc. so that you do not need to write platform-specific code.
- **plf_nanotimer** [ğŸ“](./plf_nanotimer) [ğŸŒ](https://github.com/GerHobbelt/plf_nanotimer) -- high precision cross-platform performance timer
- **pmdk** [ğŸ“](./pmdk) [ğŸŒ](https://github.com/GerHobbelt/pmdk) -- the **Persistent Memory Development Kit (PMDK)** is a collection of libraries and tools for System Administrators and Application Developers to simplify managing and accessing persistent memory devices.
- **pmdk-tests** [ğŸ“](./pmdk-tests) [ğŸŒ](https://github.com/GerHobbelt/pmdk-tests) -- tests for [Persistent Memory Development Kit](https://github.com/pmem/pmdk)
- **pmemkv** [ğŸ“](./pmemkv) [ğŸŒ](https://github.com/GerHobbelt/pmemkv) -- `pmemkv` is a local/embedded key-value datastore optimized for persistent memory. Rather than being tied to a single language or backing implementation, `pmemkv` provides different options for language bindings and storage engines.
- **pmemkv-bench** [ğŸ“](./pmemkv-bench) [ğŸŒ](https://github.com/GerHobbelt/pmemkv-bench) -- benchmark for [libpmemkv](https://github.com/pmem/pmemkv/) and its underlying libraries, based on [leveldb's db_bench](https://github.com/google/leveldb). The `pmemkv_bench` utility provides some standard read, write & remove benchmarks. It's based on the `db_bench` utility included with LevelDB and RocksDB, although the list of supported parameters is slightly different.
- **pmt-png-tools** [ğŸ“](./pmt-png-tools) [ğŸŒ](https://github.com/GerHobbelt/pmt) -- pngcrush and other PNG and MNG tools
- **PNWColors** [ğŸ“](./PNWColors) [ğŸŒ](https://github.com/GerHobbelt/PNWColors) -- Four years spent in the most beautiful place in the world, immortalized in an R color palette package. May the colors of Washington State and the Pacific Northwest live on in our presentation figures forever.  Palettes are pulled from photos I took in some of the dreamiest, most colorful, PNW-iest places I know.
- **poco** [ğŸ“](./poco) [ğŸŒ](https://github.com/GerHobbelt/poco) -- POCO (Portable Components) C++ Libraries are a collection of C++ class libraries, conceptually similar to the Java Class Library or the .NET Framework, focused on solutions to frequently-encountered practical problems.
- **podofo** [ğŸ“](./podofo) [ğŸŒ](https://github.com/GerHobbelt/podofo) -- a library to work with the PDF file format and includes also a few tools. The name comes from the first two letters of PDF (<b>Po</b>rtable <b>Do</b>cument <b>Fo</b>rmat). The PoDoFo library is a free portable C++ library which includes classes to parse a PDF file and modify its contents into memory. The changes can be written back to disk easily. PoDoFo is designed to avoid loading large PDF objects into memory until they are required and can write large streams immediately to disk, so it is possible to manipulate quite large files with it.
- **poisson_blend** [ğŸ“](./poisson_blend) [ğŸŒ](https://github.com/GerHobbelt/poisson_blend) -- a simple, readable implementation of Poisson Blending, that demonstrates the concepts explained in [my article](https://erkaman.github.io/posts/poisson_blending.html), seamlessly blending a source image and a target image, at some specified pixel location.
- **polatory** [ğŸ“](./polatory) [ğŸŒ](https://github.com/GerHobbelt/polatory) -- a fast and memory-efficient framework for RBF (radial basis function) interpolation. Polatory can perform kriging prediction via RBF interpolation (dual kriging). Although different terminologies are used, both methods produce the same results.
- **poplar-trie** [ğŸ“](./poplar-trie) [ğŸŒ](https://github.com/GerHobbelt/poplar-trie) -- a C++17 library of a memory-efficient associative array whose keys are strings. The data structure is based on a dynamic path-decomposed trie (DynPDT) described in the paper, Shunsuke Kanda, Dominik KÃ¶ppl, Yasuo Tabei, Kazuhiro Morita, and Masao Fuketa: [Dynamic Path-decomposed Tries](https://arxiv.org/abs/1906.06015), *ACM Journal of Experimental Algorithmics (JEA)*, *25*(1): 1â€“28, 2020. Poplar-trie is a memory-efficient updatable associative array implementation which maps key strings to values of any type like `std::map<std::string,anytype>`. DynPDT is composed of two structures: dynamic trie and node label map (NLM) structures.
- **poppler** [ğŸ“](./poppler) [ğŸŒ](https://github.com/GerHobbelt/poppler) -- Poppler is a library for rendering PDF files, and examining or modifying their structure.  Poppler originally came from the XPDF sources.
- **portable_concurrency-std-future** [ğŸ“](./portable_concurrency-std-future) [ğŸŒ](https://github.com/GerHobbelt/portable_concurrency) -- Portable implementation of future/promise API in C++. `std::future` done right.
- **portable-memory-mapping** [ğŸ“](./portable-memory-mapping) [ğŸŒ](https://github.com/GerHobbelt/portable-memory-mapping) -- portable Memory Mapping C++ Class (Windows/Linux)
- **portable-snippets** [ğŸ“](./portable-snippets) [ğŸŒ](https://github.com/GerHobbelt/portable-snippets) -- a collection of public domain (CC0) code snippets written in C for performing various common tasks which are typically OS, architecture, and/or compiler-dependent.  Basically, our goal is to move those annoying preprocessor conditionals from your code to ours.
- **preprocess-corpuses** [ğŸ“](./preprocess-corpuses) [ğŸŒ](https://github.com/GerHobbelt/preprocess) -- Pipelines for preprocessing corpora.
- **prio_queue** [ğŸ“](./prio_queue) [ğŸŒ](https://github.com/GerHobbelt/prio_queue) -- a cache friendly priority queue, done as a B-heap.
- **probminhash** [ğŸ“](./probminhash) [ğŸŒ](https://github.com/GerHobbelt/probminhash) -- a class of Locality-Sensitive Hash Algorithms for the (Probability) Jaccard Similarity
- **promise-cpp** [ğŸ“](./promise-cpp) [ğŸŒ](https://github.com/GerHobbelt/promise-cpp) -- advanced C++ promise/A+ library in Javascript style
- **promise-hpp** [ğŸ“](./promise-hpp) [ğŸŒ](https://github.com/GerHobbelt/promise.hpp) -- C++ asynchronous promises like a Promises/A+
- **protobuf** [ğŸ“](./protobuf) [ğŸŒ](https://github.com/GerHobbelt/protobuf) -- Protocol Buffers - Google's data interchange format that is a language-neutral, platform-neutral, extensible mechanism for serializing structured data.
  
  - **â˜¹discouragedğŸ¤§**; reason: relatively slow run-time and (in my opinion) rather ugly & convoluted approach at build time. Has too much of a Java/CorporateProgramming smell, which has not lessened over the years, unfortunately.

- **proxygen** [ğŸ“](./proxygen) [ğŸŒ](https://github.com/GerHobbelt/proxygen) -- the core C++ HTTP abstractions used at Facebook. Internally, it is used as the basis for building many HTTP servers, proxies, and clients, focusing on the common HTTP abstractions and our simple HTTPServer framework. The framework supports HTTP/1.1, SPDY/3, SPDY/3.1, HTTP/2, and HTTP/3.
- **prvhash** [ğŸ“](./prvhash) [ğŸŒ](https://github.com/GerHobbelt/prvhash) -- PRVHASH is a hash function that generates a [uniform pseudo-random number sequence](https://en.wikipedia.org/wiki/Pseudorandom_number_generator) derived from the message. PRVHASH is conceptually similar (in the sense of using a pseudo-random number sequence as a hash) to [`keccak`](https://en.wikipedia.org/wiki/SHA-3) and [`RadioGatun`](https://en.wikipedia.org/wiki/RadioGat%C3%BAn) schemes, but is a completely different implementation of such concept. PRVHASH is both a ["randomness extractor"](https://en.wikipedia.org/wiki/Randomness_extractor) and an "extendable-output function" (XOF).
- **psd_sdk** [ğŸ“](./psd_sdk) [ğŸŒ](https://github.com/GerHobbelt/psd_sdk) -- a C++ library that directly reads Photoshop PSD files. The library supports:
  
  * Groups
  * Nested layers
  * Smart Objects
  * User and vector masks
  * Transparency masks and additional alpha channels
  * 8-bit, 16-bit, and 32-bit data in grayscale and RGB color mode
  * All compression types known to Photoshop
  
  Additionally, limited export functionality is also supported.

- **pthreadpool** [ğŸ“](./pthreadpool) [ğŸŒ](https://github.com/GerHobbelt/pthreadpool) -- pthreadpool is a portable and efficient thread pool implementation. It provides similar functionality to `#pragma omp parallel for`, but with additional features.
- **pthread-win32** [ğŸ“](./pthread-win32) [ğŸŒ](https://github.com/GerHobbelt/pthread-win32) -- `pthread` for MS Windows
- **puffinn** [ğŸ“](./puffinn) [ğŸŒ](https://github.com/GerHobbelt/puffinn) -- PUFFINN - Parameterless and Universal Fast FInding of Nearest Neighbors - is an easily configurable library for finding the approximate nearest neighbors of arbitrary points. It also supports the identification of the closest pairs in the dataset. The only necessary parameters are the allowed space usage and the recall. Each near neighbor is guaranteed to be found with the probability given by the recall, regardless of the difficulty of the query.  Under the hood PUFFINN uses Locality Sensitive Hashing with an adaptive query mechanism. This means that the algorithm works for any similarity measure where a Locality Sensitive Hash family exists. Currently Cosine similarity is supported using SimHash or cross-polytope LSH and Jaccard similarity is supported using MinHash.
- **pybind11** [ğŸ“](./pybind11) [ğŸŒ](https://github.com/GerHobbelt/pybind11) -- a lightweight header-only library that exposes C++ types in Python and vice versa, mainly to create Python bindings of existing C++ code.
- **pyclustering** [ğŸ“](./pyclustering) [ğŸŒ](https://github.com/GerHobbelt/pyclustering) -- a Python, C++ data mining library (clustering algorithm, oscillatory networks, neural networks). The library provides Python and C++ implementations (C++ pyclustering library) of each algorithm or model.
- **pyglass** [ğŸ“](./pyglass) [ğŸŒ](https://github.com/GerHobbelt/pyglass) -- a library for fast inference of graph index for approximate similarity search.
  
  - It's high performant.
  - No third-party library dependencies, does not rely on OpenBLAS / MKL or any other computing framework.
  - Sophisticated memory management and data structure design, very low memory footprint.
  - Supports multiple graph algorithms, like [**HNSW**](https://github.com/nmslib/hnswlib) and [**NSG**](https://github.com/ZJULearning/nsg).
  - Supports multiple hardware platforms, like **X86** and **ARM**. Support for **GPU** is on the way

- **pylene** [ğŸ“](./pylene) [ğŸŒ](https://github.com/GerHobbelt/pylene) -- Pylene is a fork of [Olena/Milena](http://www.lrde.epita.fr/olena), an image processing library targeting genericity and efficiency. It provided mostly Mathematical Morphology building blocs for image processing pipelines.
- **pytorch** [ğŸ“](./pytorch) [ğŸŒ](https://github.com/GerHobbelt/pytorch) -- PyTorch library in C++
- **pytorch_cluster** [ğŸ“](./pytorch_cluster) [ğŸŒ](https://github.com/GerHobbelt/pytorch_cluster) -- a small extension library of highly optimized graph cluster algorithms for the use in [PyTorch](http://pytorch.org/), supporting: 
  
  * **Graclus** from Dhillon *et al.*: [Weighted Graph Cuts without Eigenvectors: A Multilevel Approach](http://www.cs.utexas.edu/users/inderjit/public_papers/multilevel_pami.pdf) (PAMI 2007)
  * **Voxel Grid Pooling** from, *e.g.*, Simonovsky and Komodakis: [Dynamic Edge-Conditioned Filters in Convolutional Neural Networks on Graphs](https://arxiv.org/abs/1704.02901) (CVPR 2017)
  * **Iterative Farthest Point Sampling** from, *e.g.* Qi *et al.*: [PointNet++: Deep Hierarchical Feature Learning on Point Sets in a Metric Space](https://arxiv.org/abs/1706.02413) (NIPS 2017)
  * **k-NN** and **Radius** graph generation
  * Clustering based on **Nearest** points
  * **Random Walk Sampling** from, *e.g.*, Grover and Leskovec: [node2vec: Scalable Feature Learning for Networks](https://arxiv.org/abs/1607.00653) (KDD 2016)

- **pytorch_cpp_demo** [ğŸ“](./pytorch_cpp_demo) [ğŸŒ](https://github.com/GerHobbelt/pytorch_cpp) -- Deep Learning sample programs of PyTorch written in C++.
- **QALSH** [ğŸ“](./QALSH) [ğŸŒ](https://github.com/GerHobbelt/QALSH) -- QALSH: Query-Aware Locality-Sensitive Hashing, is a package for the problem of Nearest Neighbor Search (NNS) over high-dimensional Euclidean spaces. Given a set of data points and a query, the problem of NNS aims to find the nearest data point to the query. It is a very fundamental probelm and has wide applications in many data mining and machine learning tasks. This package provides the external memory implementations (disk-based) of QALSH and QALSH<sup>+</sup> for *c*-Approximate Nearest Neighbor Search (c-ANNS) under *l<sub>p</sub>* norm, where *0 < p â©½ 2*. The internel memory version can be found [here](https://github.com/HuangQiang/QALSH_Mem).
- **QALSH_Mem** [ğŸ“](./QALSH_Mem) [ğŸŒ](https://github.com/GerHobbelt/QALSH_Mem) -- Memory Version of QALSH: **QALSH_Mem** is a package for the problem of Nearest Neighbor Search (NNS). Given a set of data points and a query, the problem of NNS aims to find the nearest data point to the query. It has wide applications in many data mining and machine learning tasks. This package provides the internal memory implementations of two LSH schemes QALSH and QALSH<sup>+</sup> for *c*-Approximate Nearest Neighbor Search (c-ANNS) under *l<sub>p</sub>* norm, where *0 < p â©½ 2*. The external version of QALSH and QALSH<sup>+</sup> can be found [here](https://github.com/HuangQiang/QALSH).
- **QCBOR** [ğŸ“](./QCBOR) [ğŸŒ](https://github.com/GerHobbelt/QCBOR) -- a powerful, commercial-quality CBOR encoder/decoder that implements these RFCs:
  
  * [RFC7049](https://tools.ietf.org/html/rfc7049) The previous CBOR standard. Replaced by RFC 8949.
  * [RFC8742](https://tools.ietf.org/html/rfc8742) CBOR Sequences
  * [RFC8943](https://tools.ietf.org/html/rfc8943) CBOR Dates
  * [RFC8949](https://tools.ietf.org/html/rfc8949) The CBOR Standard. (Everything except sorting of encoded maps)

- **qHilbert** [ğŸ“](./qHilbert) [ğŸŒ](https://github.com/GerHobbelt/qHilbert) -- a vectorized speedup of Hilbert curve generation using SIMD intrinsics. A hilbert curve is a space filling self-similar curve that provides a mapping between 2D space to 1D, and 1D to 2D space while preserving locality between mappings. Hilbert curves split a finite 2D space into recursive quadrants(similar to a [full quad-tree](https://en.wikipedia.org/wiki/Quadtree)) and traverse each quadrant in recursive "U" shapes at each iteration such that every quadrant gets fully visited before moving onto the next one. qHilbert is an attempt at a vectorized speedup of mapping multiple linear 1D indices into planar 2D points in parallel that is based on the Butz Algorithm's utilization of Gray code.
- **qjs-ffi** [ğŸ“](./qjs-ffi) [ğŸŒ](https://github.com/GerHobbelt/qjs-ffi) -- a simple interface to FFI from QuickJS.
- **qjs-modules** [ğŸ“](./qjs-modules) [ğŸŒ](https://github.com/GerHobbelt/qjs-modules) -- some modules for QuickJS.
- **qjs-opencv** [ğŸ“](./qjs-opencv) [ğŸŒ](https://github.com/GerHobbelt/qjs-opencv) -- OpenCV bindings for QuickJS (https://bellard.org/quickjs/)
- **qjs-sqlite3** [ğŸ“](./qjs-sqlite3) [ğŸŒ](https://github.com/GerHobbelt/qjs-sqlite3) -- a simple interface to SQLite3 from QuickJS.
- **qlever** [ğŸ“](./qlever) [ğŸŒ](https://github.com/GerHobbelt/qlever) -- a SPARQL engine that can efficiently index and query very large knowledge graphs with up to 100 billion triples on a single standard PC or server. In particular, QLever is fast for queries that involve large intermediate or final results, which are notoriously hard for engines like Blazegraph or Virtuoso.
- **qoa** [ğŸ“](./qoa) [ğŸŒ](https://github.com/GerHobbelt/qoa) -- QOA - The â€œQuite OK Audio Formatâ€ for fast, lossy audio compression - is a single-file library for C/C++.  More info at: https://qoaformat.org
- **qoi** [ğŸ“](./qoi) [ğŸŒ](https://github.com/GerHobbelt/qoi) -- QOI: the â€œQuite OK Image Formatâ€ for fast, lossless image compression, single-file MIT licensed library for C/C++. Compared to stb_image and stb_image_write QOI offers 20x-50x faster encoding, 3x-4x faster decoding and 20% better compression. It's also stupidly simple and fits in about 300 lines of C.
- **qpdf** [ğŸ“](./qpdf) [ğŸŒ](https://github.com/GerHobbelt/qpdf) -- QPDF is a command-line tool and C++ library that performs content-preserving transformations on PDF files. It supports linearization, encryption, and numerous other features. It can also be used for splitting and merging files, creating PDF files, and inspecting files for study or analysis. QPDF does not render PDFs or perform text extraction, and it does not contain higher-level interfaces for working with page contents. It is a low-level tool for working with the structure of PDF files and can be a valuable tool for anyone who wants to do programmatic or command-line-based manipulation of PDF files.
- **qs_parse** [ğŸ“](./qs_parse) [ğŸŒ](https://github.com/GerHobbelt/qs_parse) -- a set of simple and easy functions for parsing URL query strings, such as those generated in an HTTP GET form submission.
- **quadsort** [ğŸ“](./quadsort) [ğŸŒ](https://github.com/GerHobbelt/quadsort) -- a high performance stable bottom-up adaptive branchless merge sort algorithm.
- **QuantLib** [ğŸ“](./QuantLib) [ğŸŒ](https://github.com/GerHobbelt/QuantLib) -- the free/open-source library for quantitative finance, providing a comprehensive software framework for quantitative finance. QuantLib is a free/open-source library for modeling, trading, and risk management in real-life.
- **quantum** [ğŸ“](./quantum) [ğŸŒ](https://github.com/GerHobbelt/quantum) -- a full-featured and powerful C++ framework build on top of the [Boost coroutine](https://www.boost.org/doc/libs/1_65_0/libs/coroutine2/doc/html/index.html) library. The framework allows users to dispatch units of work (a.k.a. _tasks_) as coroutines and execute them concurrently using the 'reactor' pattern.
- **QuickJS** [ğŸ“](./QuickJS) [ğŸŒ](https://github.com/GerHobbelt/quickjs) -- a small and embeddable Javascript engine. It supports the <a href="https://tc39.github.io/ecma262/">ES2020</a> specification including modules, asynchronous generators, proxies and BigInt. It optionally supports mathematical extensions such as big decimal floating point numbers (BigDecimal), big binary floating point numbers (BigFloat) and operator overloading.
  
  - **libbf** [ğŸ“](./libbf) [ğŸŒ](https://github.com/GerHobbelt/libbf) -- a small library to handle arbitrary precision binary or decimal floating point numbers
  - **QuickJS-C++-Wrapper** [ğŸ“](./QuickJS-C++-Wrapper) [ğŸŒ](https://github.com/GerHobbelt/quickjscpp) -- quickjscpp is a header-only wrapper around the [quickjs](https://bellard.org/quickjs/) JavaScript engine, which allows easy integration into C++11 code. This wrapper also automatically tracks the lifetime of values and objects, is exception-safe, and automates clean-up.
  - **QuickJS-C++-Wrapper2** [ğŸ“](./QuickJS-C++-Wrapper2) [ğŸŒ](https://github.com/GerHobbelt/quickjspp) -- QuickJSPP is QuickJS wrapper for C++. It allows you to easily embed Javascript engine into your program.
  - **txiki** [ğŸ“](./txiki.js) [ğŸŒ](https://github.com/GerHobbelt/txiki.js) -- uses QuickJS as its kernel

- **QuickJS-C++-Wrapper** [ğŸ“](./QuickJS-C++-Wrapper) [ğŸŒ](https://github.com/GerHobbelt/quickjscpp) -- quickjscpp is a header-only wrapper around the [quickjs](https://bellard.org/quickjs/) JavaScript engine, which allows easy integration into C++11 code. This wrapper also automatically tracks the lifetime of values and objects, is exception-safe, and automates clean-up.
- **QuickJS-C++-Wrapper2** [ğŸ“](./QuickJS-C++-Wrapper2) [ğŸŒ](https://github.com/GerHobbelt/quickjspp) -- QuickJSPP is QuickJS wrapper for C++. It allows you to easily embed Javascript engine into your program.
- **quickjs-ffi** [ğŸ“](./quickjs-ffi) [ğŸŒ](https://github.com/GerHobbelt/quickjs-ffi) -- libffi wrapper for QuickJS. Now supports almost every features of C including primitive types, structs, callbacks and so on.
- **quill-logging** [ğŸ“](./quill-logging) [ğŸŒ](https://github.com/GerHobbelt/quill) -- asynchronous cross-platform low latency logging library based on C++14/C++17.
- **quirc** [ğŸ“](./quirc) [ğŸŒ](https://github.com/GerHobbelt/quirc) -- a library for extracting and decoding QR codes, which are a type of high-density matrix barcodes, from images. It features a fast, robust and tolerant recognition algorithm. It can correctly recognise and decode QR codes which are rotated and/or oblique to the camera. It can also distinguish and decode multiple codes within the same image.
- **r8brain-free-src** [ğŸ“](./r8brain-free-src) [ğŸŒ](https://github.com/GerHobbelt/r8brain-free-src) -- high-quality professional audio sample rate converter (SRC) / resampler C++ library.  Features routines for SRC, both up- and downsampling, to/from any sample rate, including non-integer sample rates: it can be also used for conversion to/from SACD/DSD sample rates, and even go beyond that. Also suitable for fast general-purpose 1D time-series resampling / interpolation (with relaxed filter parameters).
- **radamsa** [ğŸ“](./radamsa) [ğŸŒ](https://github.com/GerHobbelt/radamsa) -- Radamsa is a test case generator for robustness testing, a.k.a. a fuzzer. It is typically used to test how well a program can withstand malformed and potentially malicious inputs. It works by reading sample files of valid data and generating interestingly different outputs from them. The main selling points of radamsa are that it has already found a slew of bugs in programs that actually matter, it is easily scriptable and easy to get up and running.
- **radon-tf** [ğŸ“](./radon-tf) [ğŸŒ](https://github.com/GerHobbelt/radon-tf) -- simple implementation of the radon transform. Faster when using more than one thread to execute it. No inverse function is provided. CPU implementation only.
- **ragel** [ğŸ“](./ragel) [ğŸŒ](https://github.com/GerHobbelt/ragel) -- State Machine Compiler
- **RAKE** [ğŸ“](./RAKE) [ğŸŒ](https://github.com/GerHobbelt/RAKE) -- the Rapid Automatic Keyword Extraction (RAKE) algorithm as described in: Rose, S., Engel, D., Cramer, N., & Cowley, W. (2010). Automatic Keyword Extraction from Individual Documents. In M. W. Berry & J. Kogan (Eds.), Text Mining: Theory and Applications: John Wiley & Sons.
- **randen** [ğŸ“](./randen) [ğŸŒ](https://github.com/GerHobbelt/randen) -- What if we could default to attack-resistant random generators without excessive CPU cost? We introduce 'Randen', a new generator with security guarantees; it outperforms MT19937, pcg64_c32, Philox, ISAAC and ChaCha8 in real-world benchmarks. This is made possible by AES hardware acceleration and a large Feistel permutation.
- **random** [ğŸ“](./random) [ğŸŒ](https://github.com/GerHobbelt/random) -- random for modern C++ with a convenient API.
- **random-forest** [ğŸ“](./random-forest) [ğŸŒ](https://github.com/GerHobbelt/random-forest) -- a Fast C++ Implementation of Random Forests as described in: Leo Breiman. Random Forests. Machine Learning 45(1):5-32, 2001.
- **RandomizedRedundantDCTDenoising** [ğŸ“](./RandomizedRedundantDCTDenoising) [ğŸŒ](https://github.com/GerHobbelt/RandomizedRedundantDCTDenoising) -- demonstrates the paper S. Fujita, N. Fukushima, M. Kimura, and Y. Ishibashi, "Randomized redundant DCT: Efficient denoising by using random subsampling of DCT patches," Proc. Siggraph Asia, Technical Brief, Nov. 2015. In this paper, the DCT-based denoising is accelerated by using a randomized algorithm. The DCT is based on the fastest algorithm and is SIMD vectorized by using SSE. Some modifications improve denoising performance in term of PSNR. The code is 100x faster than the OpenCV's implementation (cv::xphoto::dctDenoising) for the paper. Optionally, we can use DHT (discrete Walshâ€“Hadamard transform) for fast computation instead of using DCT.
- **RapidFuzz** [ğŸ“](./RapidFuzz) [ğŸŒ](https://github.com/GerHobbelt/RapidFuzz) -- rapid fuzzy string matching in Python and C++ using the Levenshtein Distance.
- **rapidJSON** [ğŸ“](./rapidJSON) [ğŸŒ](https://github.com/GerHobbelt/rapidjson) -- TenCent's fast JSON parser/generator for C++ with both SAX & DOM style APIs.
- **rapidxml** [ğŸ“](./rapidxml) [ğŸŒ](https://github.com/GerHobbelt/rapidxml) -- RapidXML is an ancient C++ library for parsing XML quickly and flexibly.
- **rapidyaml** [ğŸ“](./rapidyaml) [ğŸŒ](https://github.com/GerHobbelt/rapidyaml) -- *Rapid YAML*, or `ryml`, for short. ryml is a C++ library to parse and emit YAML, and do it fast, on everything from x64 to bare-metal chips without operating system. `ryml` parses both read-only and in-situ source buffers; the resulting data nodes hold only views to sub-ranges of the source buffer. No string copies or duplications are done, and no virtual functions are used. The data tree is a flat index-based structure stored in a single array. Serialization happens only at your direct request, after parsing / before emitting. Internally, the data tree representation stores only string views and has no knowledge of types, but of course, every node can have a YAML type tag. `ryml` makes it easy and fast to read and modify the data tree.
- **rclone** [ğŸ“](./rclone) [ğŸŒ](https://github.com/GerHobbelt/rclone) -- Rclone *("rsync for cloud storage")* is a command-line program to sync files and directories to and from different cloud storage providers. See [the full list of all storage providers and their features](https://rclone.org/overview/).
- **re2** [ğŸ“](./re2) [ğŸŒ](https://github.com/GerHobbelt/re2) -- RE2, a regular expression library.
- **re2c** [ğŸ“](./re2c) [ğŸŒ](https://github.com/GerHobbelt/re2c) -- a lexer generator for C/C++, Go and Rust. Its main goal is generating fast lexers: at least as fast as their reasonably optimized hand-coded counterparts. Instead of using traditional table-driven approach, re2c encodes the generated finite state automata directly in the form of conditional jumps and comparisons. The resulting programs are faster and often smaller than their table-driven analogues, and they are much easier to debug and understand. re2c applies quite a few optimizations in order to speed up and compress the generated code.  Another distinctive feature is its flexible interface: instead of assuming a fixed program template, re2c lets the programmer write most of the interface code and adapt the generated lexer to any particular environment.
- **readerwriterqueue** [ğŸ“](./readerwriterqueue) [ğŸŒ](https://github.com/GerHobbelt/readerwriterqueue) -- a single-producer, single-consumer lock-free queue for C++.
- **reckless** [ğŸ“](./reckless) [ğŸŒ](https://github.com/GerHobbelt/reckless) -- Reckless is an extremely low-latency, high-throughput logging library.
- **RectangleBinPack** [ğŸ“](./RectangleBinPack) [ğŸŒ](https://github.com/GerHobbelt/RectangleBinPack) -- the source code used in "A Thousand Ways to Pack the Bin - A Practical Approach to Two-Dimensional Rectangle Bin Packing." The code can be
- **recycle** [ğŸ“](./recycle) [ğŸŒ](https://github.com/GerHobbelt/recycle) -- an implementation of a simple resource pool for recycling resources in C++.
- **refl-cpp** [ğŸ“](./refl-cpp) [ğŸŒ](https://github.com/GerHobbelt/refl-cpp) -- static reflection for C++17 (compile-time enumeration, attributes, proxies, overloads, template functions, metaprogramming).
- **RE-flex** [ğŸ“](./RE-flex) [ğŸŒ](https://github.com/GerHobbelt/RE-flex) -- the regex-centric, fast lexical analyzer generator for C++ with full Unicode support. Faster than Flex. Accepts Flex specifications. Generates reusable source code that is easy to understand. Introduces indent/dedent anchors, lazy quantifiers, functions for lex/syntax error reporting and more. Seamlessly integrates with Bison and other parsers.
  
  The RE/flex matcher tracks line numbers, column numbers, and indentations, whereas Flex does not (option `noyylineno`) and neither do the other regex matchers (except PCRE2 and Boost.Regex when used with RE/flex).
  Tracking this information incurs some overhead. RE/flex also automatically decodes UTF-8/16/32 input and accepts `std::istream`, strings, and wide strings as input.
  
  RE/flex runs equally fast or slightly faster than the best times of Flex.

- **remake** [ğŸ“](./remake) [ğŸŒ](https://github.com/GerHobbelt/remake) -- a patched GNU Make 4.3 sourcecode adding improved error reporting, tracing, target listing, graph visualization, profiling, and more. It also contains a [debugger](https://remake.readthedocs.io/en/latest/debugger.html).
- **replxx** [ğŸ“](./replxx) [ğŸŒ](https://github.com/GerHobbelt/replxx) -- REPL CLI component: `readline` simile for REPL/interactive runs in a CLI
- **reproc** [ğŸ“](./reproc) [ğŸŒ](https://github.com/GerHobbelt/reproc) -- reproc (Redirected Process) is a cross-platform C/C++ library that simplifies starting, stopping and communicating with external programs. The main use case is executing command line applications directly from C or C++ code and retrieving their output.
- **restc-cpp** [ğŸ“](./restc-cpp) [ğŸŒ](https://github.com/GerHobbelt/restc-cpp) -- a modern C++ REST Client library. The magic that takes the pain out of accessing JSON API's from C++. The design goal of this project is to make external REST API's simple and safe to use in C++ projects, but still fast and memory efficient.
- **result-cpp** [ğŸ“](./result-cpp) [ğŸŒ](https://github.com/GerHobbelt/result) -- `Result<T, E>` is a modern, simple, and light-weight error-handling alternative to C++ exceptions with a rich feature-set.
- **resumable-assert** [ğŸ“](./resumable-assert) [ğŸŒ](https://github.com/GerHobbelt/resumable-assert) -- `assert` replacement to continue execution in debugger. In any large app, it sometimes happens that some asserts are failing in code you don't currently care about, and blocking the entire team from being able to run the app until the issue is fixed is not the best workflow. So we usually end up moving the execution marker past the assert line in IDE or debugger, or even comment the assert out, recompile and relaunch. With Resumable Assert, you can simply continue execution when an assertion fails in debugger, or even disable asserts that you are not interested in, so that those never bother you again.
- **retinex** [ğŸ“](./retinex) [ğŸŒ](https://github.com/GerHobbelt/retinex) -- the Retinex algorithm for intrinsic image decomposition. The provided code computes image gradients, and assembles a sparse linear "Ax = b" system. The system is solved using Eigen.
- **rgf** [ğŸ“](./rgf) [ğŸŒ](https://github.com/GerHobbelt/rgf) -- Regularized Greedy Forest (RGF) is a tree ensemble machine learning method described in [this paper](https://arxiv.org/abs/1109.0887). RGF can deliver better results than gradient boosted decision trees (GBDT) on a number of datasets and it has been used to win a few Kaggle competitions. Unlike the traditional boosted decision tree approach, RGF works directly with the underlying forest structure. RGF integrates two ideas: one is to include tree-structured regularization into the learning formulation; and the other is to employ the fully-corrective regularized greedy algorithm.
- **riegeli** [ğŸ“](./riegeli) [ğŸŒ](https://github.com/GerHobbelt/riegeli) -- *Riegeli/records* is a file format for storing a sequence of string records, typically serialized protocol buffers. It supports dense compression, fast decoding, seeking, detection and optional skipping of data corruption, filtering of proto message fields for even faster decoding, and parallel encoding.
- **RNGSobol** [ğŸ“](./RNGSobol) [ğŸŒ](https://github.com/GerHobbelt/RNGSobol) -- Sobol quadi-random numbers generator (C++). Note that unlike pseudo-random numbers, quasi-random numbers care about dimensionality of points.
- **RoaringBitmap** [ğŸ“](./RoaringBitmap) [ğŸŒ](https://github.com/GerHobbelt/RoaringBitmap) -- Roaring bitmaps are compressed bitmaps which tend to outperform conventional compressed bitmaps such as WAH, EWAH or Concise. In some instances, roaring bitmaps can be hundreds of times faster and they often offer significantly better compression. They can even be faster than uncompressed bitmaps.
- **robin-hood-hashing** [ğŸ“](./robin-hood-hashing) [ğŸŒ](https://github.com/GerHobbelt/robin-hood-hashing) -- robin_hood unordered map & set.
- **robin-map** [ğŸ“](./robin-map) [ğŸŒ](https://github.com/GerHobbelt/robin-map) -- a C++ implementation of a fast hash map and hash set using open-addressing and linear robin hood hashing with backward shift deletion to resolve collisions.
- **robotstxt** [ğŸ“](./robotstxt) [ğŸŒ](https://github.com/GerHobbelt/robotstxt) -- Google `robots.txt` Parser and Matcher Library. The Robots Exclusion Protocol (REP) is a standard that enables website owners to control which URLs may be accessed by automated clients (i.e. crawlers) through a simple text file with a specific syntax. It's one of the basic building blocks of the internet as we know it and what allows search engines to operate. Because the REP was only a de-facto standard for the past 25 years, different implementers implement parsing of robots.txt slightly differently, leading to confusion. This project aims to fix that by releasing the parser that Google uses.
- **rollinghashcpp** [ğŸ“](./rollinghashcpp) [ğŸŒ](https://github.com/GerHobbelt/rollinghashcpp) -- randomized rolling hash functions in C++. This is a set of C++ classes implementing various recursive n-gram hashing techniques, also called rolling hashing (http://en.wikipedia.org/wiki/Rolling_hash), including Randomized Karp-Rabin (sometimes called Rabin-Karp), Hashing by Cyclic Polynomials (also known as Buzhash) and Hashing by Irreducible Polynomials.
- **rotate** [ğŸ“](./rotate) [ğŸŒ](https://github.com/GerHobbelt/rotate) -- provides several classic, commonly used and novel rotation algorithms (aka block swaps), which were documented since around 1981 up to 2021: three novel rotation algorithms were introduced in 2021, notably the [trinity rotation](https://github.com/scandum/rotate#Trinity-Rotation).
- **rotate_detection** [ğŸ“](./rotate_detection) [ğŸŒ](https://github.com/GerHobbelt/rotate_detection) -- angle rotation detection on scanned documents. Designed for embedding in systems using tesseract OCR. The detection algorithm based on [RÃ©nyi entropy](https://en.wikipedia.org/wiki/R%C3%A9nyi_entropy).
- **RRD** [ğŸ“](./RRD) [ğŸŒ](https://github.com/GerHobbelt/RRD) -- RRD: Rotation-Sensitive Regression for Oriented Scene Text Detection
- **RRPN** [ğŸ“](./RRPN) [ğŸŒ](https://github.com/GerHobbelt/RRPN) -- (Arbitrary-Oriented Scene Text Detection via Rotation Proposals)[https://arxiv.org/abs/1703.01086]
- **rsync** [ğŸ“](./rsync) [ğŸŒ](https://github.com/GerHobbelt/rsync) -- Rsync is a fast and extraordinarily versatile file copying tool for both remote and local files. Rsync uses a delta-transfer algorithm which provides a very fast method for bringing remote files into sync.
- **rtl** [ğŸ“](./rtl) [ğŸŒ](https://github.com/GerHobbelt/rtl) -- _RANSAC Template Library (RTL)_ is an open-source robust regression tool especially with RANSAC family. RTL aims to provide fast, accurate, and easy ways to estimate any model parameters with data contaminated with outliers (incorrect data). RTL includes recent RANSAC variants with their performance evaluation with several models with synthetic and real data. _RANdom SAmple Consensus (RANSAC)_ is an iterative method to make any parameter estimator strong against outliers. For example of line fitting, RANSAC enable to estimate a line parameter even though data points include wrong point observations far from the true line.
- **rttr** [ğŸ“](./rttr) [ğŸŒ](https://github.com/GerHobbelt/rttr) -- RTTR - Run Time Type Reflection - provides the ability to introspect and modify an object at runtime and is written in C++. Features:
- **RuntimeCompiledCPlusPlus** [ğŸ“](./RuntimeCompiledCPlusPlus) [ğŸŒ](https://github.com/GerHobbelt/RuntimeCompiledCPlusPlus) -- Runtime-Compiled C++ (RCC++) is a way to reliably make major changes to your C++ code at runtime and see the results immediately. It's aimed at games development but could be useful in any industry where turnaround times are a bottleneck. RCC++ is primarily designed to shorten iteration times in development - developers can build their project, run it, make changes during runtime and see the results almost immediately. If needed, shipping code can [disable runtime compilation](https://github.com/RuntimeCompiledCPlusPlus/RuntimeCompiledCPlusPlus/wiki/Disabling-runtime-compilation) in a number of ways. RCC++ is not intended as a method to allow end users of a shipped binary to compile modifications, though with some work it can be used this way.
- **ruy** [ğŸ“](./ruy) [ğŸŒ](https://github.com/GerHobbelt/ruy) -- a matrix multiplication library. Its focus is to cover the matrix multiplication needs of neural network inference engines. Its initial user has been TensorFlow Lite, where it is used by default on the ARM CPU architecture. `ruy` supports both floating-point and 8-bit-integer-quantized matrices.
- **RxCpp** [ğŸ“](./RxCpp) [ğŸŒ](https://github.com/GerHobbelt/RxCpp) -- the Reactive Extensions for C++ (__RxCpp__) is a library of algorithms for values-distributed-in-time. The [__Range-v3__](https://github.com/ericniebler/range-v3) library does the same for values-distributed-in-space.
- **sac** [ğŸ“](./sac) [ğŸŒ](https://github.com/GerHobbelt/sac) -- a state-of-the-art lossless audio compression model. Lossless audio compression is a complex problem, because PCM data is highly non-stationary and uses high sample resolution (typically >=16bit). That's why classic context modelling suffers from context dilution problems. Sac employs a simple OLS-NLMS predictor per frame including bias correction. Prediction residuals are encoded using a sophisticated bitplane coder including SSE and various forms of probability estimations. Meta-parameters of the predictor are optimized via binary search (or [DDS](https://agupubs.onlinelibrary.wiley.com/doi/10.1029/2005WR004723)) on by-frame basis. This results in a highly asymmetric codec design. We throw a lot of muscles at the problem and archive only little gains - by practically predicting noise.
- **safeclib** [ğŸ“](./safeclib) [ğŸŒ](https://github.com/GerHobbelt/safeclib) -- Safe C Library implements the secure C11 Annex K[^5] functions on top of most libc implementations, which are missing from them. The ISO TR24731 Bounds Checking Interface documents indicate that the key motivation for the new specification is to help mitigate the ever increasing security attacks, specifically the buffer overrun.
- **safestringlib** [ğŸ“](./safestringlib) [ğŸŒ](https://github.com/GerHobbelt/safestringlib) -- The Safe String Library is based on the Safe C Library by Cisco, and provides routines for safe string operations (like `strcpy`) and memory routines (like `memcpy`) that are recommended for Linux/Android operating systems, and will also work for Windows. This library is especially useful for cross-platform situations where one library for these routines is preferred.
- **salieri** [ğŸ“](./salieri) [ğŸŒ](https://github.com/GerHobbelt/salieri) -- provides function arguments' in/out annotation definitions for Microsoft's [source-code annotation language (SAL)](https://msdn.microsoft.com/en-us/library/hh916383.aspx). SAL provides lots of annotations you can use to describe the behavior
- **sally** [ğŸ“](./sally) [ğŸŒ](https://github.com/GerHobbelt/sally) -- a Tool for Embedding Strings in Vector Spaces. This mapping is referred to as embedding and allows for applying techniques of machine learning and data mining for analysis of string data.  Sally can be applied to several types of strings, such as text documents, DNA sequences or log files, where it can handle common formats such as directories, archives and text files of string data. Sally implements a standard technique for mapping strings to a vector space that can be referred to as generalized bag-of-words model.  The strings are characterized by a set of features, where each feature is associated with one dimension of the vector space.  The following types of features are supported by Sally: bytes, tokens (words), n-grams of bytes and n-grams of tokens.
- **Sancho.Panza.on.tesseract.OCR** [ğŸ“](./Sancho.Panza.on.tesseract.OCR) [ğŸŒ](https://github.com/GerHobbelt/Sancho.Panza.on.tesseract.OCR) -- a book about tesseract OCR programming and usage.
- **sbcl** [ğŸ“](./sbcl) [ğŸŒ](https://github.com/GerHobbelt/sbcl) -- SBCL is an implementation of ANSI Common Lisp, featuring a high-performance native compiler, native threads on several platforms, a socket interface, a source-level debugger, a statistical profiler, and much more.
- **scantailor** [ğŸ“](./scantailor) [ğŸŒ](https://github.com/GerHobbelt/scantailor-advanced) -- [scantailor_advanced](https://github.com/4lex4/scantailor-advanced) is the [ScanTailor](https://github.com/scantailor/scantailor) version that merges the features of the *ScanTailor Featured* and *ScanTailor Enhanced* versions, brings new ones and fixes. ScanTailor is an interactive post-processing tool for scanned pages. It performs operations such as page splitting, deskewing, adding/removing borders, selecting content, ... and many others.
- **scilab** [ğŸ“](./scilab) [ğŸŒ](https://github.com/GerHobbelt/scilab) -- Scilab includes hundreds of mathematical functions. It has a high-level programming language allowing access to advanced data structures, 2-D and 3-D graphical functions.
- **scintilla** [ğŸ“](./scintilla) [ğŸŒ](https://github.com/GerHobbelt/scintilla) -- text editor
- **ScriptX** [ğŸ“](./ScriptX) [ğŸŒ](https://github.com/GerHobbelt/ScriptX) -- wrapper for V8, QuickJS, Lua, Python, ...
- **scws-chinese-word-segmentation** [ğŸ“](./scws-chinese-word-segmentation) [ğŸŒ](https://github.com/GerHobbelt/scws) -- SCWS (Simple Chinese Word Segmentation) (i.e.: Simple Chinese Word Segmentation System). This is a mechanical Chinese word segmentation engine based on word frequency dictionary, which can basically correctly segment a whole paragraph of Chinese text into words. A word is the smallest morpheme unit in Chinese, but when writing, it does not separate words with spaces like English, so how to segment words accurately and quickly has always been a difficult problem in Chinese word segmentation. SCWS supports Chinese encoding includes `GBK`, `UTF-8`, etc.
  
  There are not many innovative elements in the word segmentation algorithm. It uses a word frequency dictionary collected by itself, supplemented by certain proper names, names of people, and place names. Basic word segmentation is achieved by identifying rules such as digital age. After small-scale testing, the accuracy is between 90% and 95%, which can basically satisfy some use in small search engines, keyword extraction and other occasions. The first prototype version was released in late 2005.

- **sdcc** [ğŸ“](./sdcc) [ğŸŒ](https://github.com/GerHobbelt/sdcc) -- SDCC is the free open source, retargettable, optimizing ISO C compiler for small devices, including the Intel MCS-51 based microprocessors (8031, 8032, 8051, 8052, etc.), Maxim (formerly Dallas) DS80C390 variants, Freescale (formerly Motorola) HC08 based (hc08, s08), Zilog Z80 based MCUs (Z80, Z80N, Z180, SM83 (e.g. Game Boy), Rabbit 2000, Rabbit 2000A/3000, Rabbit 3000A, TLCS-90, R800), STMicroelectronics STM8, Padauk PDK14 and PDK15 and MOS 6502. Work is in progress on supporting the Padauk PDK13 target. There are unmaintained Microchip PIC16 and PIC18 targets.
- **sdhash** [ğŸ“](./sdhash) [ğŸŒ](https://github.com/GerHobbelt/sdhash) -- a tool which allows two arbitrary blobs of data to be compared for similarity based on common strings of binary data. It is designed to provide quick results during triage and initial investigation phases.
- **sdsl-lite** [ğŸ“](./sdsl-lite) [ğŸŒ](https://github.com/GerHobbelt/sdsl-lite) -- The Succinct Data Structure Library (SDSL) is a powerful and flexible C++11 library implementing succinct data structures. In total, the library contains the highlights of 40 [research publications][SDSLLIT]. Succinct data structures can represent an object (such as a bitvector or a tree) in space close to the information-theoretic lower bound of the object while supporting operations of the original object efficiently. The theoretical time complexity of an operation performed on the classical data structure and the equivalent succinct data structure are (most of the time) identical.
- **Sealighter** [ğŸ“](./Sealighter) [ğŸŒ](https://github.com/GerHobbelt/Sealighter) -- Sysmon-Like research tool for ETW: helps non-developers dive into researching Event Tracing for Windows (ETW) and Windows PreProcessor Tracing (WPP).
- **see-phit** [ğŸ“](./see-phit) [ğŸŒ](https://github.com/GerHobbelt/see-phit) -- a compile time HTML templating library written in modern C++/14. You write plain HTML as C++ string literals and it is parsed at compile time into a DOM like data structure. It makes your "stringly typed" HTML text into an actual strongly typed DSL.
- **semimap** [ğŸ“](./semimap) [ğŸŒ](https://github.com/GerHobbelt/semimap) -- semi::static_map and semi::map: associative map containers with compile-time lookup! Normally, associative containers require some runtime overhead when looking up their values from a key. However, when the key is known at compile-time (for example, when the key is a literal) then this run-time lookup could technically be avoided. This is exactly what the goal of `semi::static_map` and `semi::map` is.
- **sent2vec** [ğŸ“](./sent2vec) [ğŸŒ](https://github.com/GerHobbelt/sent2vec) -- a tool and pre-trained models related to the [Bi-Sent2vec](https://arxiv.org/abs/1912.12481). The cross-lingual extension of Sent2Vec can be found [here](https://github.com/epfml/Bi-sent2vec). This library provides numerical representations (features) for words, short texts, or sentences, which can be used as input to any machine learning task.
- **sentencepiece** [ğŸ“](./sentencepiece) [ğŸŒ](https://github.com/GerHobbelt/sentencepiece) -- text tokenization
- **sentence-tokenizer** [ğŸ“](./sentence-tokenizer) [ğŸŒ](https://github.com/GerHobbelt/Tokenizer) -- text tokenization
- **sequential-line-search** [ğŸ“](./sequential-line-search) [ğŸŒ](https://github.com/GerHobbelt/sequential-line-search) -- a C++ library for performing the **sequential line search** method (which is a human-in-the-loop variant of **Bayesian optimization**), following the paper "Yuki Koyama, Issei Sato, Daisuke Sakamoto, and Takeo Igarashi. 2017. Sequential Line Search for Efficient Visual Design Optimization by Crowds. ACM Trans. Graph. 36, 4, pp.48:1--48:11 (2017). (a.k.a. Proceedings of SIGGRAPH 2017), DOI: https://doi.org/10.1145/3072959.3073598"
- **serde-cpp** [ğŸ“](./serde-cpp) [ğŸŒ](https://github.com/GerHobbelt/serde-cpp) -- serialization framework for C++17, inspired by Rust [serde](https://serde.rs/) project.
- **serdepp** [ğŸ“](./serdepp) [ğŸŒ](https://github.com/GerHobbelt/serdepp) -- a C++17 low cost serialize deserialize adaptor library like Rust [serde](https://serde.rs/) project.
- **shadesmar** [ğŸ“](./shadesmar) [ğŸŒ](https://github.com/GerHobbelt/shadesmar) -- an IPC library that uses the system's shared memory to pass messages. Supports publish-subscribe and RPC.
- **ShapeCrawler** [ğŸ“](./ShapeCrawler) [ğŸŒ](https://github.com/GerHobbelt/ShapeCrawler) -- a .NET library for manipulating PowerPoint presentations.
- **sharedhashfile** [ğŸ“](./sharedhashfile) [ğŸŒ](https://github.com/GerHobbelt/sharedhashfile) -- share hash tables with stable key hints stored in memory mapped files between arbitrary processes.
- **SheenBidi** [ğŸ“](./SheenBidi) [ğŸŒ](https://github.com/GerHobbelt/SheenBidi) -- implements Unicode Bidirectional Algorithm available at http://www.unicode.org/reports/tr9. It is a sophisticated implementation which provides the developers an easy way to use UBA in their applications.
- **Sherwood** [ğŸ“](./Sherwood) [ğŸŒ](https://github.com/GerHobbelt/Sherwood) -- Sherwood: a library for decision forest inference, which was written by Duncan Robertson (duncan.robertson@redimension.co.uk) to accompany the book "A. Criminisi and J. Shotton. Decision Forests: for Computer Vision and Medical Image Analysis. Springer,  2013." The Sherwood library comprises a general purpose, object-oriented software framework for applying decision forests to a wide range of inference problems.
- **Shifted-Hamming-Distance** [ğŸ“](./Shifted-Hamming-Distance) [ğŸŒ](https://github.com/GerHobbelt/Shifted-Hamming-Distance) -- Shifted Hamming Distance (SHD) is an edit-distance based filter that can quickly check whether the minimum number of edits (including insertions, deletions and substitutions) between two strings is smaller than a user defined threshold **T** (the number of allowed edits between the two strings).  Testing if two stings differs by a small amount is a prevalent function that is used in many applications. One of its biggest usage, perhaps, is in DNA or protein mapping, where a short DNA or protein string is compared against an enormous database, in order to find similar matches. In such applications, a query string is usually compared against multiple candidate strings in the database. Only candidates that are similar to the query are considered **matches** and recorded.  SHD expands the basic Hamming distance computation, which only detects substitutions, into a full-fledged edit-distance filter, which counts not only substitutions but **insertions and deletions** as well.
- **shmdata** [ğŸ“](./shmdata) [ğŸŒ](https://github.com/GerHobbelt/shmdata) -- shares streams of framed data between processes (1 writer to many readers) via shared memory. It supports any kind of data stream:  it has been used with multichannel audio, video frames, 3D models, OSC messages, and various others types of data. Shmdata is very fast and allows processes to access data streams without the need for extra copies.
- **shoco** [ğŸ“](./shoco) [ğŸŒ](https://github.com/GerHobbelt/shoco) -- a fast compressor for short strings
- **Signals** [ğŸ“](./Signals) [ğŸŒ](https://github.com/GerHobbelt/Signals) -- a lightweight "signals and slots" implementation using fast delegates. When GUI programming in C++, delegates and the signals and slots paradigm can vastly simplify your code. It implements the Observer pattern while avoiding all the boilerplate code. I needed a lightweight and efficient implementation that I could just drop into my projects and use without adding weird macros, inheriting from crazy templates or having external dependencies. I wanted something simpler and more efficient than libsigc++, sigslot, and boost.signals.
- **sile-typesetter** [ğŸ“](./sile-typesetter) [ğŸŒ](https://github.com/GerHobbelt/sile) -- SILE is a typesetting system; its job is to produce beautiful printed documents. Conceptually, SILE is similar to TeXâ€”from which it borrows some concepts and even syntax and algorithmsâ€”but the similarities end there. Rather than being a derivative of the TeX family SILE is a new typesetting and layout engine written from the ground up using modern technologies and borrowing some ideas from graphical systems such as Adobe InDesign.
- **silk-codec** [ğŸ“](./silk-codec) [ğŸŒ](https://github.com/GerHobbelt/silk-codec) -- a library to convert PCM to TenCent Silk files and vice versa.
- **SilkETW** [ğŸ“](./SilkETW) [ğŸŒ](https://github.com/GerHobbelt/SilkETW) -- SilkETW & SilkService are flexible C# wrappers for ETW, they are meant to abstract away the complexities of ETW and give people a simple interface to perform research and introspection. While both projects have obvious defensive (and offensive) applications they should primarily be considered as research tools.
- **silk-v3-decoder** [ğŸ“](./silk-v3-decoder) [ğŸŒ](https://github.com/GerHobbelt/silk-v3-decoder) -- decodes Silk v3 audio files (like WeChat amr, aud files, qq slk files) and converts to other formats (like mp3).
- **simdcomp** [ğŸ“](./simdcomp) [ğŸŒ](https://github.com/GerHobbelt/simdcomp) -- SIMDComp is a simple C library for compressing lists of integers using binary packing and SIMD instructions. The assumption is either that you have a list of 32-bit integers where most of them are small, or a list of 32-bit integers where differences between successive integers are small. No software is able to reliably compress an array of 32-bit random numbers.
- **simd-imgproc** [ğŸ“](./simd-imgproc) [ğŸŒ](https://github.com/GerHobbelt/Simd) -- the Simd Library is an image processing and machine learning library designed for C and C++ programmers. It provides many useful high performance algorithms for image processing such as: pixel format conversion, image scaling and filtration, extraction of statistic information from images, motion detection, object detection (HAAR and LBP classifier cascades) and classification, neural network.
  
  The algorithms are optimized, using different SIMD CPU extensions where available. The library supports following CPU extensions: SSE, AVX, AVX-512 and AMX for x86/x64, VMX(Altivec) and VSX(Power7) for PowerPC (big-endian), NEON for ARM.

- **simdjson** [ğŸ“](./simdjson) [ğŸŒ](https://github.com/GerHobbelt/simdjson) -- simdjson : Parsing gigabytes of JSON per second. For NDJSON files, we can exceed 3 GB/s with our multithreaded parsing functions](https://github.com/simdjson/simdjson/blob/master/doc/parse_many.md).
- **SIMDString** [ğŸ“](./SIMDString) [ğŸŒ](https://github.com/GerHobbelt/SIMDString) -- a [MIT-licensed](https://opensource.org/licenses/MIT) open source implementation of a fast C++ string class designed for use in games. It is a drop-in replacement for `std::string` that is 10-100x faster for many common operations, such as small `string::operator+=(const char*)`, `string::string(const string&)`, `string::string(const char*)`, and `string::c_str()`.
- **simhash-cpp** [ğŸ“](./simhash-cpp) [ğŸŒ](https://github.com/GerHobbelt/simhash-cpp) -- Simhash Near-Duplicate Detection enables the identification of all fingerprints that are nearly identical to a query fingerprint. In this context, a fingerprint is an unsigned 64-bit integer. It also comes with an auxillary function designed to generate a fingerprint given a `char*` and a length. This fingeprint is generated with a tokenizer and a hash function (both of which may be provided as template parameters). Using a cyclic hash function, it then performs simhash on a moving window of tokens (as defined by the tokenizer).
- **sioyek** [ğŸ“](./sioyek) [ğŸŒ](https://github.com/GerHobbelt/sioyek) -- a PDF viewer with a focus on textbooks and research papers.
- **SipHash** [ğŸ“](./SipHash) [ğŸŒ](https://github.com/GerHobbelt/SipHash) -- SipHash is a family of pseudorandom functions (PRFs) optimized for speed on short messages. This is the reference C code of SipHash: portable, simple, optimized for clarity and debugging. SipHash was designed in 2012 by [Jean-Philippe Aumasson](https://aumasson.jp) and [Daniel J. Bernstein](https://cr.yp.to) as a defense against [hash-flooding DoS attacks](https://aumasson.jp/siphash/siphashdos_29c3_slides.pdf).
  
  It is *simpler and faster* on short messages than previous cryptographic algorithms, such as MACs based on universal hashing, *competitive in performance* with insecure non-cryptographic algorithms, such as [fhhash](https://github.com/cbreeden/fxhash), *cryptographically secure*, with no sign of weakness despite multiple [cryptanalysis](https://eprint.iacr.org/2019/865) [projects](https://eprint.iacr.org/2019/865) by leading cryptographers, *battle-tested*, with successful integration in OSs (Linux kernel, OpenBSD, FreeBSD, FreeRTOS), languages (Perl, Python, Ruby, etc.), libraries (OpenSSL libcrypto, Sodium, etc.) and applications (Wireguard, Redis, etc.).
  
  As a secure pseudorandom function (a.k.a. keyed hash function), SipHash can also be used as a secure message authentication code (MAC). But SipHash is *not a hash* in the sense of general-purpose key-less hash function such as BLAKE3 or SHA-3. SipHash should therefore always be used with a secret key in order to be secure.

- **siridb-server** [ğŸ“](./siridb-server) [ğŸŒ](https://github.com/GerHobbelt/siridb-server) -- SiriDB Server is a highly-scalable, robust and super fast time series database. SiriDB uses a unique mechanism to operate without a global index and allows server resources to be added on the fly. SiriDBâ€™s unique query language includes dynamic grouping of time series for easy analysis over large amounts of time series. SiriDB is scalable on the fly and has no downtime while updating or expanding your database. The scalable possibilities enable you to enlarge the database time after time without losing speed. SiriDB is developed to give an unprecedented performance without downtime. A SiriDB cluster distributes time series across multiple pools. Each pool supports active replicas for load balancing and redundancy. When one of the replicas is not available the database is still accessible.
- **sist2** [ğŸ“](./sist2) [ğŸŒ](https://github.com/GerHobbelt/sist2) -- sist2 (Simple incremental search tool) is a fast, low memory usage, multi-threaded application, which scans drives and directory trees, extracts text and metadata from common file types, generates thumbnails and comes with OCR support (with tesseract) and  Named-Entity Recognition (using pre-trained client-side tensorflow models).
- **slot_map** [ğŸ“](./slot_map) [ğŸŒ](https://github.com/GerHobbelt/slot_map) -- a Slot Map is a high-performance associative container with persistent unique keys to access stored values. Upon insertion, a key is returned that can be used to later access or remove the values. Insertion, removal, and access are all guaranteed to take `O(1)` time (best, worst, and average case). Great for storing collections of objects that need stable, safe references but have no clear ownership. The difference between a `std::unordered_map` and a `dod::slot_map` is that the slot map generates and returns the key when inserting a value. A key is always unique and will only refer to the value that was inserted.
- **smhasher** [ğŸ“](./smhasher) [ğŸŒ](https://github.com/GerHobbelt/smhasher) -- benchmark and collection of fast hash functions for symbol tables or hash tables.
- **snap** [ğŸ“](./snap) [ğŸŒ](https://github.com/GerHobbelt/snap) -- Stanford Network Analysis Platform (SNAP) is a general purpose, high performance system for analysis and manipulation of large networks. SNAP scales to massive graphs with hundreds of millions of nodes and billions of edges.
- **snappy** [ğŸ“](./snappy) [ğŸŒ](https://github.com/GerHobbelt/snappy) -- an up-to-date fork of google/snappy, a fast compression/decompression library. It does not aim for maximum compression, or compatibility with any other compression library; instead, it aims for very high speeds and reasonable compression.
  
  - **second-choice**; reason: see `lzo2` above. LZ4 either overtakes this one or is on par (anno 2022 AD) and I don't see a lot happening here, so the coolness factor is slowly fading. See also [How do I decide between LZ4 and Snappy compression?](https://stackoverflow.com/questions/67537111/how-do-i-decide-between-lz4-and-snappy-compression)

- **snmalloc** [ğŸ“](./snmalloc) [ğŸŒ](https://github.com/GerHobbelt/snmalloc) -- a high-performance allocator.
- **snowball** [ğŸ“](./snowball) [ğŸŒ](https://github.com/GerHobbelt/snowball) -- SnowBall stemming compiler (code generator)
- **Solo** [ğŸ“](./Solo) [ğŸŒ](https://github.com/GerHobbelt/Solo) -- Agora SOLO is a speech codec, developed based on Silk with BWE(Bandwidth Extension) and MDC(Multi Description Coding). With these technologies, SOLO is able to resist weak networks at low bitrates. The main reason for SOLO to use bandwidth expansion is to reduce the computational complexity.
- **somoclu** [ğŸ“](./somoclu) [ğŸŒ](https://github.com/GerHobbelt/somoclu) -- a massively parallel implementation of self-organizing maps. It exploits multicore CPUs, it is able to rely on MPI for distributing the workload in a cluster, and it can be accelerated by CUDA. A sparse kernel is also included, which is useful for training maps on vector spaces generated in text mining processes.
- **Sophus** [ğŸ“](./Sophus) [ğŸŒ](https://github.com/GerHobbelt/Sophus) -- a C++ implementation of Lie groups commonly used for 2d and 3d geometric problems (i.e. for Computer Vision or Robotics applications). Among others, this package includes the special orthogonal groups SO(2) and SO(3) to present rotations in 2d and 3d as well as the special Euclidean group SE(2) and SE(3) to represent rigid body transformations (i.e. rotations and translations) in 2d and 3d.
- **sparsehash** [ğŸ“](./sparsehash) [ğŸŒ](https://github.com/GerHobbelt/sparsehash) -- fast (non-cryptographic) hash algorithms
- **sparsepp** [ğŸ“](./sparsepp) [ğŸŒ](https://github.com/GerHobbelt/sparsepp) -- a fast, memory efficient hash map for C++. Sparsepp is derived from Google's excellent [sparsehash](https://github.com/sparsehash/sparsehash) implementation.
- **spdlog** [ğŸ“](./spdlog) [ğŸŒ](https://github.com/GerHobbelt/spdlog) -- very fast, header-only/compiled, C++ logging library.
- **spdlog_setup** [ğŸ“](./spdlog_setup) [ğŸŒ](https://github.com/GerHobbelt/spdlog_setup) -- file-based setup library for convenience in initializing spdlog.
- **spdlog_sqlite_sink** [ğŸ“](./spdlog_sqlite_sink) [ğŸŒ](https://github.com/GerHobbelt/sqlite_sink) -- SQLite 3 database sink for `spdlog`: a simple custom sink made for spdlog that writes to SQLite database.
- **spdmon** [ğŸ“](./spdmon) [ğŸŒ](https://github.com/GerHobbelt/spdmon) -- a progress monitor based on spdlog library. In just one function call visualize your loop progress!
- **speex** [ğŸ“](./speex) [ğŸŒ](https://github.com/GerHobbelt/speex) -- a patent-free voice codec. Unlike other codecs like MP3 and Ogg Vorbis, Speex is designed to compress voice at bitrates in the 2-45 kbps range. Possible applications include VoIP, internet audio streaming, archiving of speech data (e.g. voice mail), and audio books.
- **spherical-k-means** [ğŸ“](./spherical-k-means) [ğŸŒ](https://github.com/GerHobbelt/spherical-k-means) -- the spherical K-means algorithm in Matlab and C++. The C++ version emphasizes a multithreaded implementation and features three ways of running the algorithm. It can be executed with a single-thread (same as the Matlab implementation), or using OpenMP or Galois (http://iss.ices.utexas.edu/?p=projects/galois). The purpose of this code is to optimize and compare the different parallel paradigms to maximize the efficiency of the algorithm.
- **spline** [ğŸ“](./spline) [ğŸŒ](https://github.com/GerHobbelt/spline) -- a lightweight C++ cubic spline interpolation library.
- **splinter** [ğŸ“](./splinter) [ğŸŒ](https://github.com/GerHobbelt/splinter) -- SPLINTER (SPLine INTERpolation) is a library for *multivariate function approximation with splines*. The library can be used for function approximation, regression, data smoothing, data reduction, and much more. Spline approximations are represented by a speedy C++ implementation of the tensor product B-spline. The B-spline consists of piecewise polynomial basis functions, offering a high flexibility and smoothness. The B-spline can be fitted to data using ordinary least squares (OLS), possibly with regularization. The library also offers construction of penalized splines (P-splines).
- **splitmerge** [ğŸ“](./splitmerge) [ğŸŒ](https://github.com/GerHobbelt/splitmerge) -- simple binary file splitter and (re)merger tool.
- **spookyhash** [ğŸ“](./spookyhash) [ğŸŒ](https://github.com/GerHobbelt/spookyhash) -- a very fast non cryptographic hash function, [designed by Bob Jenkins](http://burtleburtle.net/bob/hash/spooky.html). It produces well-distributed 128-bit hash values for byte arrays of any length. It can produce 64-bit and 32-bit hash values too, at the same speed.
- **SPSCQueue** [ğŸ“](./SPSCQueue) [ğŸŒ](https://github.com/GerHobbelt/SPSCQueue) -- a single producer single consumer wait-free and lock-free fixed size queue written in C++11.
- **spy-build-sysinfo** [ğŸ“](./spy-build-sysinfo) [ğŸŒ](https://github.com/GerHobbelt/spy) -- build system info
- **sqawk** [ğŸ“](./sqawk) [ğŸŒ](https://github.com/GerHobbelt/sqawk) -- apply SQL on CSV files in the shell: `sqawk` imports CSV files into an on-the-fly SQLite database, and runs a user-supplied query on the data.
- **sqlcipher** [ğŸ“](./sqlcipher) [ğŸŒ](https://github.com/GerHobbelt/sqlcipher) -- SQLCipher is a standalone fork of the [SQLite](https://www.sqlite.org/) database library that adds 256 bit AES encryption of database files and other security features.
- **sqlean** [ğŸ“](./sqlean) [ğŸŒ](https://github.com/GerHobbelt/sqlean) -- The ultimate set of SQLite extensions: SQLite has few functions compared to other database management systems. SQLite authors see this as a feature rather than a problem, because SQLite has an extension mechanism in place. There are a lot of SQLite extensions out there, but they are incomplete, inconsistent and scattered across the internet. sqlean brings them together, neatly packaged into domain modules, documented, tested, and built for Linux, Windows and macOS.
- **sqleet** [ğŸ“](./sqleet) [ğŸŒ](https://github.com/GerHobbelt/sqleet) -- an encryption extension for [SQLite3](https://www.sqlite.org/). The encryption is transparent (*on-the-fly*) and based on modern cryptographic algorithms designed for high performance in software and robust side-channel resistance.
- **sqlite** [ğŸ“](./sqlite) [ğŸŒ](https://github.com/GerHobbelt/sqlite) -- the complete [SQLite database engine](https://sqlite.org/).
- **sqlite3-compression-encryption-vfs** [ğŸ“](./sqlite3-compression-encryption-vfs) [ğŸŒ](https://github.com/GerHobbelt/sqlite3-compression-encryption-vfs) -- CEVFS: Compression & Encryption VFS for SQLite 3 is a SQLite 3 Virtual File System for compressing and encrypting data at the pager level. Once set up, you use SQLite as you normally would and the compression and encryption is transparently handled during database read/write operations via the SQLite pager.
- **sqlite3pp** [ğŸ“](./sqlite3pp) [ğŸŒ](https://github.com/GerHobbelt/sqlite3pp) -- a minimal ORM wrapper for SQLite et al.
- **sqlite-amalgamation** [ğŸ“](./sqlite-amalgamation) [ğŸŒ](https://github.com/GerHobbelt/sqlite-amalgamation) -- the [SQLite](http://www.sqlite.org/download.html) amalgamation, which is the recommended method of building SQLite into larger projects.
- **SQLiteCpp** [ğŸ“](./SQLiteCpp) [ğŸŒ](https://github.com/GerHobbelt/SQLiteCpp) -- a smart and easy to use C++ SQLite3 wrapper. SQLiteC++ offers an encapsulation around the native C APIs of SQLite, with a few intuitive and well documented C++ classes.
- **sqlite-fts5-snowball** [ğŸ“](./sqlite-fts5-snowball) [ğŸŒ](https://github.com/GerHobbelt/fts5-snowball) -- a simple extension for use with FTS5 within SQLite. It allows FTS5 to use Martin Porter's Snowball stemmers (libstemmer), which are available in several languages. Check http://snowballstem.org/ for more information about them.
- **sqlite_fts_tokenizer_chinese_simple** [ğŸ“](./sqlite_fts_tokenizer_chinese_simple) [ğŸŒ](https://github.com/GerHobbelt/simple) -- an extension of [sqlite3 fts5](https://www.sqlite.org/fts5.html) that supports Chinese and Pinyin. It fully provides a [solution to the multi-phonetic word problem of full-text retrieval on WeChat mobile terminal](https://cloud.tencent.com/developer/article/1198371): solution 4 in the article, very simple and efficient support for Chinese and Pinyin searches.
  
  On this basis we also support more accurate phrase matching through [cppjieba](https://github.com/yanyiwu/cppjieba). See the introduction article at https://www.wangfenjin.com/posts/simple-jieba-tokenizer/

- **SQLiteHistograms** [ğŸ“](./SQLiteHistograms) [ğŸŒ](https://github.com/GerHobbelt/SQLiteHistograms) -- an SQLite extension library for creating histogram tables, tables of ratio between histograms and interpolation tables of scatter point tables.
- **sqliteodbc** [ğŸ“](./sqliteodbc) [ğŸŒ](https://github.com/GerHobbelt/sqliteodbc) -- SQLite ODBC Driver for the wonderful SQLite 2.8.* and SQLite 3.* Database Engine/Library.
- **sqlite-parquet-vtable** [ğŸ“](./sqlite-parquet-vtable) [ğŸŒ](https://github.com/GerHobbelt/sqlite-parquet-vtable) -- an SQLite [virtual table](https://sqlite.org/vtab.html) extension to expose Parquet files as SQL tables. You may also find [csv2parquet](https://github.com/cldellow/csv2parquet/) useful. This [blog post](https://cldellow.com/2018/06/22/sqlite-parquet-vtable.html) provides some context on why you might use this.
- **sqlite-stats** [ğŸ“](./sqlite-stats) [ğŸŒ](https://github.com/GerHobbelt/sqlite-stats) -- provides common statistical functions for SQLite.
- **sqlite_wrapper** [ğŸ“](./sqlite_wrapper) [ğŸŒ](https://github.com/GerHobbelt/sqlite_wrapper) -- an easy-to-use, lightweight and concurrency-friendly SQLite wrapper written in C++17.
- **sqlite_zstd_vfs** [ğŸ“](./sqlite_zstd_vfs) [ğŸŒ](https://github.com/GerHobbelt/sqlite_zstd_vfs) -- SQLite VFS extension providing streaming storage compression using Zstandard (Zstd), transparently compressing pages of the main database file as they're written out and later decompressing them as they're read in. It runs page de/compression on background threads and occasionally generates dictionaries to improve subsequent compression.
- **sqlplot-tools** [ğŸ“](./sqlplot-tools) [ğŸŒ](https://github.com/GerHobbelt/sqlplot-tools) -- a tool to **process data series** from algorithm experiments **using SQL statements** and embed the results in **gnuplot** datafiles or **pgfplots** LaTeX files. Using SQL to generate plots can be see as **cracking a nut with a sledgehammer**, but it really works well in practice.
- **sqlpp11** [ğŸ“](./sqlpp11) [ğŸŒ](https://github.com/GerHobbelt/sqlpp11) -- a type safe embedded domain specific language for SQL queries and results in C++.
- **squash** [ğŸ“](./squash) [ğŸŒ](https://github.com/GerHobbelt/squash) -- an abstraction library which provides a single API to access many compression libraries, allowing applications a great deal of flexibility when choosing a compression algorithm, or allowing a choice between several of them.
- **ssdeep** [ğŸ“](./ssdeep) [ğŸŒ](https://github.com/GerHobbelt/ssdeep) -- fuzzy hashing library, can be used to assist with identifying almost identical files using context triggered piecewise hashing.
- **sse-popcount** [ğŸ“](./sse-popcount) [ğŸŒ](https://github.com/GerHobbelt/sse-popcount) -- SIMD popcount; sample programs for my article http://0x80.pl/articles/sse-popcount.html / Faster Population Counts using AVX2 Instructions (https://arxiv.org/abs/1611.07612)
- **ssimulacra2** [ğŸ“](./ssimulacra2) [ğŸŒ](https://github.com/GerHobbelt/ssimulacra2) -- Structural SIMilarity Unveiling Local And Compression Related Artifacts metric developed by Jon Sneyers. SSIMULACRA 2 is based on the concept of the multi-scale structural similarity index measure (MS-SSIM), computed in a perceptually relevant color space, adding two other (asymmetric) error maps, and aggregating using two different norms.
- **stan** [ğŸ“](./stan) [ğŸŒ](https://github.com/GerHobbelt/stan) -- Stan is a C++ package providing (1) full Bayesian inference using the No-U-Turn sampler (NUTS), a variant of Hamiltonian Monte Carlo (HMC), (2) approximate Bayesian inference using automatic differentiation variational inference (ADVI), and (3) penalized maximum likelihood estimation (MLE) using L-BFGS optimization. It is built on top of the [Stan Math library](https://github.com/stan-dev/math).
- **stan-math** [ğŸ“](./stan-math) [ğŸŒ](https://github.com/GerHobbelt/stan-math) -- the Stan Math Library is a C++, reverse-mode automatic differentiation library designed to be usable, extensive and extensible, efficient, scalable, stable, portable, and redistributable in order to facilitate the construction and utilization of algorithms that utilize derivatives.
- **StarSpace** [ğŸ“](./StarSpace) [ğŸŒ](https://github.com/GerHobbelt/StarSpace) -- a general-purpose neural model for efficient learning of entity embeddings for solving a wide variety of problems.
- **stateline** [ğŸ“](./stateline) [ğŸŒ](https://github.com/GerHobbelt/stateline) -- a framework for distributed Markov Chain Monte Carlo (MCMC) sampling written in C++. It implements random walk Metropolis-Hastings with parallel tempering to improve chain mixing, provides an adaptive proposal distribution to speed up convergence, and allows the user to factorise their likelihoods (eg. over sensors or data).
- **state-threads** [ğŸ“](./state-threads) [ğŸŒ](https://github.com/GerHobbelt/state-threads) -- a lightweight thread library for C/C++ coroutine (similar to goroutine), for high performance network servers: the State Threads Library is a small application library which provides a foundation for writing fast and highly scalable Internet applications (such as web servers, proxy servers, mail transfer agents, and so on) on UNIX-like platforms.
- **stats** [ğŸ“](./stats) [ğŸŒ](https://github.com/GerHobbelt/stats) -- StatsLib is a templated C++ library of statistical distribution functions, featuring unique compile-time computing capabilities and seamless integration with several popular linear algebra libraries. Features a header-only library of probability density functions, cumulative distribution functions, quantile functions, and random sampling methods. Functions are written in C++11 `constexpr` format, enabling the library to operate as both a compile-time and run-time computation engine. Provides functions to compute the cdf, pdf, quantile, as well as random sampling methods, are available for the following distributions: Bernoulli, Beta, Binomial, Cauchy, Chi-squared, Exponential, F, Gamma, Inverse-Gamma, Inverse-Gaussian, Laplace, Logistic, Log-Normal, Normal (Gaussian), Poisson, Rademacher, Student's t, Uniform and Weibull. In addition, pdf and random sampling functions are available for several multivariate distributions: inverse-Wishart, Multivariate Normal and Wishart.
- **statsite** [ğŸ“](./statsite) [ğŸŒ](https://github.com/GerHobbelt/statsite) -- a metrics aggregation server. Statsite is based heavily on Etsy's StatsD <https://github.com/etsy/statsd>, and is wire compatible.
- **stdext-path** [ğŸ“](./stdext-path) [ğŸŒ](https://github.com/GerHobbelt/stdext-path) -- path manipulations (`dirname` et al)
- **stlcache** [ğŸ“](./stlcache) [ğŸŒ](https://github.com/GerHobbelt/stlcache) -- STL::Cache is an in-memory cache for C++ applications. STL::Cache is just a simple wrapper over standard map, that implements some cache algorithms, thus allowing you to limit the storage size and automatically remove unused items from it. It is intended to be used for keeping any key/value data, especially when data's size are too big, to just put it into the map and keep the whole thing. With STL::Cache you could put enormous (really unlimited) amount of data into it, but it will store only some small part of your data. So re-usable data will be kept near your code and not so popular data will not spend expensive memory. STL::Cache uses configurable policies, for decisions, whether data are good, to be kept in cache or they should be thrown away. It is shipped with 8 policies and you are free to implement your own.
- **stopwords** [ğŸ“](./stopwords) [ğŸŒ](https://github.com/GerHobbelt/stopwords) -- default English stop words from different sources.
- **stringi** [ğŸ“](./stringi) [ğŸŒ](https://github.com/GerHobbelt/stringi) -- fast and portable character string processing in R (with the Unicode ICU).
- **strings2** [ğŸ“](./strings2) [ğŸŒ](https://github.com/GerHobbelt/strings2) -- Strings2 is a Windows command-line tool for extracting strings from binary data: either binary files or process memory. On top of the classic Sysinternals strings approach, this tool includes multi-lingual string extraction, such as Russian, Chinese, etc. while a machine learning model filters out junk erroneous string extractions to reduce noise.
- **StringZilla** [ğŸ“](./StringZilla) [ğŸŒ](https://github.com/GerHobbelt/StringZilla) -- StringZilla ğŸ¦– : The world wastes a minimum of $100M annually due to inefficient string operations. A typical codebase processes strings character by character, resulting in too many branches and data-dependencies, neglecting 90% of modern CPU's potential. That's why StringZilla was created. To provide predictably high performance, portable to any modern platform, operating system, and programming language. StringZilla is the GodZilla of string libraries, using SIMD and SWAR to accelerate string operations on modern CPUs. It is up to __10x faster than the default and even other SIMD-accelerated string libraries__ in C, C++, Python, and other languages, while covering broad functionality. It __accelerates exact and fuzzy string matching, edit distance computations, sorting, lazily-evaluated ranges to avoid memory allocations, and even random-string generators__.
- **StronglyUniversalStringHashing** [ğŸ“](./StronglyUniversalStringHashing) [ğŸŒ](https://github.com/GerHobbelt/StronglyUniversalStringHashing) -- very fast [universal hash families](https://en.wikipedia.org/wiki/Universal_hashing) on strings.
- **strtk** [ğŸ“](./strtk) [ğŸŒ](https://github.com/GerHobbelt/strtk) -- the C++ String Toolkit Library (StrTk) consists of robust, optimized and portable string processing algorithms for the C++ language. StrTk is designed to be easy to use and integrate within existing code bases. Furthermore the library has a rich set of features  that makes light work of any kind of string processing task.
- **stx-error-handling** [ğŸ“](./stx-error-handling) [ğŸŒ](https://github.com/GerHobbelt/STX) -- C++ 17 & C++ 20 error-handling and utility extensions.
- **subprocess** [ğŸ“](./subprocess) [ğŸŒ](https://github.com/GerHobbelt/subprocess) -- cross platform subprocess library for C++ similar to design of Python `subprocess`.
- **subprocess-cpp** [ğŸ“](./subprocess-cpp) [ğŸŒ](https://github.com/GerHobbelt/subprocess-cpp) -- a no nonsense library for writing shell commands in C++.
- **subprocess_h** [ğŸ“](./subprocess_h) [ğŸŒ](https://github.com/GerHobbelt/subprocess.h) -- ğŸœ a simple one header solution to launching processes and interacting with them for C/C++.
- **SuiteSparse** [ğŸ“](./SuiteSparse) [ğŸŒ](https://github.com/GerHobbelt/SuiteSparse) -- a set of sparse-matrix-related packages written or co-authored by Tim Davis, available at https://github.com/DrTimothyAldenDavis/SuiteSparse . Packages:
  
  * `AMD` - approximate minimum degree ordering.  This is the built-in AMD function in MATLAB.
  * `BTF` - permutation to block triangular form
  * `CAMD` - constrained approximate minimum degree ordering
  * `CCOLAMD` - constrained column approximate minimum degree ordering
  * `CHOLMOD` - sparse Cholesky factorization.  Requires AMD, COLAMD, CCOLAMD, the BLAS, and LAPACK.  Optionally uses METIS.  This is `chol` and `x=A\b` in MATLAB.
  * `COLAMD` - column approximate minimum degree ordering.  This is the built-in COLAMD function in MATLAB.
  * `CSparse` - a concise sparse matrix package, developed for my book, "Direct Methods for Sparse Linear Systems", published by SIAM.  Intended primarily for teaching. For production, use `CXSparse` instead.
  * `CXSparse` - CSparse Extended.  Includes support for complex matrices and both int or long integers.  Use this instead of CSparse for production use; it creates a libcsparse.so (or dylib on the Mac) with the same name as CSparse.  It is a superset of CSparse.
  * `GraphBLAS` - graph algorithms in the language of linear algebra. https://graphblas.org
  * `KLU` - sparse LU factorization, primarily for circuit simulation.  Requires AMD, COLAMD, and BTF.  Optionally uses CHOLMOD, CAMD, CCOLAMD, and METIS.
  * `LAGraph` - a graph algorithms library based on GraphBLAS.  See also https://github.com/GraphBLAS/LAGraph
  * `LDL` - a very concise LDL' factorization package

- **sumatrapdf** [ğŸ“](./sumatrapdf) [ğŸŒ](https://github.com/GerHobbelt/sumatrapdf) -- SumatraPDF is a multi-format (PDF, EPUB, MOBI, CBZ, CBR, FB2, CHM, XPS, DjVu) reader for Windows.
- **SuperString** [ğŸ“](./SuperString) [ğŸŒ](https://github.com/GerHobbelt/SuperString) -- an efficient string library for C++, that achieves a remarkable memory and CPU optimization. SuperString uses Rope (data structure) and optimization techniques.
- **svg-charter** [ğŸ“](./svg-charter) [ğŸŒ](https://github.com/GerHobbelt/charter) -- SVG chart renderer
- **swig** [ğŸ“](./swig) [ğŸŒ](https://github.com/GerHobbelt/swig) -- SWIG (Simplified Wrapper and Interface Generator) is a software development tool (code generator) that connects programs written in C and C++ with a variety of high-level programming languages. It is used for building scripting language interfaces to C and C++ programs. SWIG simplifies development by largely automating the task of scripting language integration, allowing developers and users to focus on more important problems.
  
  *[SWIG ğŸŒ](https://swig.readthedocs.io/en/latest/Manual/SWIG.html) was not considered initially; more suitable for RPC than what we have in mind, which is purely data messages enchange. MAY be of use for transitional applications which are mixed-(programming-)language based, e.g. where we want to mix C/C++ and C# in a single Test Application.*

- **SymSpell** [ğŸ“](./SymSpell) [ğŸŒ](https://github.com/GerHobbelt/SymSpell) -- spelling correction & fuzzy search: **1 million times faster** through Symmetric Delete spelling correction algorithm. The Symmetric Delete spelling correction algorithm reduces the complexity of edit candidate generation and dictionary lookup for a given Damerau-Levenshtein distance. It is six orders of magnitude faster ([than the standard approach with deletes + transposes + replaces + inserts](http://norvig.com/spell-correct.html)) and language independent.
- **SymspellCPP** [ğŸ“](./SymspellCPP) [ğŸŒ](https://github.com/GerHobbelt/SymspellCPP) -- a C++ port from https://github.com/wolfgarbe/SymSpell v6.5
- **SZ** [ğŸ“](./SZ) [ğŸŒ](https://github.com/GerHobbelt/SZ) -- SZ2: Error-bounded Lossy Compressor for HPC Data, (C) 2016-2022 by Mathematics and Computer Science (MCS), Argonne National Laboratory.
- **SZ3** [ğŸ“](./SZ3) [ğŸŒ](https://github.com/GerHobbelt/SZ3) -- SZ3: A Modular Error-bounded Lossy Compression Framework for Scientific Datasets, 2016 by Mathematics and Computer Science (MCS), Argonne National Laboratory.
- **tab** [ğŸ“](./tab) [ğŸŒ](https://github.com/GerHobbelt/tab) -- a tutorial and reference for [tab](http://tab-lang.xyz), a kind of programming language/shell calculator.
- **tabulate** [ğŸ“](./tabulate) [ğŸŒ](https://github.com/GerHobbelt/tabulate) -- Table Maker for Modern C++, for when you want to display table formatted data in the terminal/console text window.
- **taglib** [ğŸ“](./taglib) [ğŸŒ](https://github.com/GerHobbelt/taglib) -- TagLib is a library for reading and editing the metadata of several popular audio formats. Currently it supports both ID3v1 and [ID3v2][] for MP3 files, [Ogg Vorbis][] comments and ID3 tags in [FLAC][], MPC, Speex, WavPack, TrueAudio, WAV, AIFF, MP4, APE, and ASF files.
- **tao-json** [ğŸ“](./tao-json) [ğŸŒ](https://github.com/GerHobbelt/tao-json) -- taoJSON is a C++ header-only JSON library that provides a generic [Value Class](doc/Value-Class.md), uses [Type Traits](doc/Type-Traits.md) to interoperate with C++ types, uses an [Events Interface](doc/Events-Interface.md) to convert from and to JSON, JAXN, CBOR, MsgPack and UBJSON, and much more...
- **taolog** [ğŸ“](./taolog) [ğŸŒ](https://github.com/GerHobbelt/taolog) -- a Win32 logger based on DebugView & ETW.
- **tapkee** [ğŸ“](./tapkee) [ğŸŒ](https://github.com/GerHobbelt/tapkee) -- a C++ template library for dimensionality reduction with some bias on spectral methods. The Tapkee origins from the code developed during [GSoC 2011](http://www.google-melange.com/gsoc/homepage/google/gsoc2011) as the part of the [Shogun machine learning toolbox](https://github.com/shogun-toolbox/shogun). The project aim is to provide efficient and flexible standalone library for dimensionality reduction which can be easily integrated to existing codebases. Tapkee leverages capabilities of effective [Eigen3 linear algebra library](http://eigen.tuxfamily.org) and optionally makes use of the [ARPACK eigensolver](http://www.caam.rice.edu/software/ARPACK/). The library uses CoverTree and VP-tree data structures to compute nearest neighbors. To achieve greater flexibility we provide a callback interface which decouples dimension reduction algorithms from the data representation and storage schemes.
- **taskflow** [ğŸ“](./taskflow) [ğŸŒ](https://github.com/GerHobbelt/taskflow) -- quickly write parallel and heterogeneous task programs in modern C++. Taskflow is faster, more expressive, and easier for drop-in integration than many of existing task programming frameworks in handling complex parallel workloads.
- **tcl** [ğŸ“](./tcl) [ğŸŒ](https://github.com/GerHobbelt/tcl) -- the latest **Tcl** source distribution. Tcl provides a powerful platform for creating integration applications that tie together diverse applications, protocols, devices, and frameworks.
- **tclap** [ğŸ“](./tclap) [ğŸŒ](https://github.com/GerHobbelt/tclap) -- TCLAP (Templatized Command Line Argument Parser) is a simple C++ library that facilitates parsing command line arguments in a type independent manner. It doesn't conform exactly to either the GNU or POSIX standards, although it is close.
- **tclclockmod** [ğŸ“](./tclclockmod) [ğŸŒ](https://github.com/GerHobbelt/tclclockmod) -- TclClockMod is the fastest, most powerful Tcl clock engine written in C. This Tcl clock extension is the faster Tcl-module for the replacement of the standard "clock" ensemble of tcl.
- **tcllib** [ğŸ“](./tcllib) [ğŸŒ](https://github.com/GerHobbelt/tcllib) -- the Tcl Standard Library.
- **tcp_pubsub** [ğŸ“](./tcp_pubsub) [ğŸŒ](https://github.com/GerHobbelt/tcp_pubsub) -- a minimal publish-subscribe library that transports data via TCP. `tcp_pubsub` does not define a message format but only transports binary blobs. It does however define a protocol around that, which is kept as lightweight as possible.
- **tcpshm** [ğŸ“](./tcpshm) [ğŸŒ](https://github.com/GerHobbelt/tcpshm) -- a connection-oriented persistent message queue framework based on TCP or SHM IPC for Linux. TCPSHM provides a reliable and efficient solution based on a sequence number and acknowledge mechanism, that every sent out msg is persisted in a send queue until sender got ack that it's been consumed by the receiver, so that disconnects/crashes are tolerated and the recovery process is purely automatic.
- **tee-win32** [ğŸ“](./tee-win32) [ğŸŒ](https://github.com/GerHobbelt/tee-win32) -- a simple [**`tee`**](https://en.wikipedia.org/wiki/Tee_(command)) implementation for Microsoft Windows.
- **telegram-bot-api** [ğŸ“](./telegram-bot-api) [ğŸŒ](https://github.com/GerHobbelt/telegram-bot-api) -- the Telegram Bot API provides an HTTP API for creating Telegram Bots.
- **telegram-td** [ğŸ“](./telegram-td) [ğŸŒ](https://github.com/GerHobbelt/td) -- TDLib (Telegram Database library) is a cross-platform library for building [Telegram](https://telegram.org) clients. It can be easily used from almost any programming language.
- **TelemetrySourcerer** [ğŸ“](./TelemetrySourcerer) [ğŸŒ](https://github.com/GerHobbelt/TelemetrySourcerer) -- Telemetry Sourcerer can enumerate and disable common sources of telemetry used by AV/EDR on Windows. Red teamers and security enthusiasts can use this tool in a lab environment for various purposes, including ETW event monitoring.
- **tempo** [ğŸ“](./tempo) [ğŸŒ](https://github.com/GerHobbelt/tempo) -- Grafana Tempo is an open source, easy-to-use and high-scale distributed tracing backend. Tempo is cost-efficient, requiring only object storage to operate, and is deeply integrated with Grafana, Prometheus, and Loki. Tempo is Jaeger, Zipkin, Kafka, OpenCensus and OpenTelemetry compatible.  It ingests batches in any of the mentioned formats, buffers them and then writes them to Azure, GCS, S3 or local disk.  As such it is robust, cheap and easy to operate! Tempo implements [TraceQL](https://grafana.com/docs/tempo/latest/traceql/), a traces-first query language inspired by LogQL and PromQL. This query language allows users to very precisely and easily select spans and jump directly to these spans.
- **tensorflow** [ğŸ“](./tensorflow) [ğŸŒ](https://github.com/GerHobbelt/tensorflow) -- an end-to-end open source platform for machine learning.
- **tensorflow-docs** [ğŸ“](./tensorflow-docs) [ğŸŒ](https://github.com/GerHobbelt/tensorflow-docs) -- TensorFlow documentation
- **tensorflow-io** [ğŸ“](./tensorflow-io) [ğŸŒ](https://github.com/GerHobbelt/tensorflow-io) -- TensorFlow I/O is a collection of file systems and file formats that are not available in TensorFlow's built-in support. A full list of supported file systems and file formats by TensorFlow I/O can be found [here](https://www.tensorflow.org/io/api_docs/python/tfio).
- **tensorflow-text** [ğŸ“](./tensorflow-text) [ğŸŒ](https://github.com/GerHobbelt/tensorflow-text) -- TensorFlow Text provides a collection of text related classes and ops ready to use with TensorFlow 2.0. The library can perform the preprocessing regularly required by text-based models, and includes other features useful for sequence modeling not provided by core TensorFlow.
- **tensorstore** [ğŸ“](./tensorstore) [ğŸŒ](https://github.com/GerHobbelt/tensorstore) -- TensorStore is an open-source C++ and Python software library designed for storage and manipulation of large multi-dimensional arrays.
- **termcolor** [ğŸ“](./termcolor) [ğŸŒ](https://github.com/GerHobbelt/termcolor) -- a header-only C++ library for printing colored messages to the terminal. Termcolor uses ANSI color formatting, so you can use it on every system that is used such terminals (most *nix systems, including Linux and Mac OS).
  
  On MS Windows the Windows API is used instead of escape codes but some limitations apply (not everything is supported). That's why it's recommended to enter virtual terminal processing mode and set the TERMCOLOR_USE_ANSI_ESCAPE_SEQUENCES macro to trick termcolor to use ANSI color codes.

- **tessconfigs** [ğŸ“](../../thirdparty/tessconfigs) [ğŸŒ](https://github.com/GerHobbelt/tessconfigs) -- Tesseract Config files
- **tessdata** [ğŸ“](../../thirdparty/tessdata) [ğŸŒ](https://github.com/GerHobbelt/tessdata) -- trained models for Tesseract. These have models for legacy tesseract engine (--oem 0) as well as the new LSTM neural net based engine (--oem 1). The LSTM models (--oem 1) in these files have been updated to the integerized versions of [tessdata_best](https://github.com/tesseract-ocr/tessdata_best) on GitHub. So, they should be faster but probably a little less accurate than tessdata_best.
- **tessdata_best** [ğŸ“](../../thirdparty/tessdata_best) [ğŸŒ](https://github.com/GerHobbelt/tessdata_best) -- the best trained models for the [Tesseract Open Source OCR Engine](https://github.com/tesseract-ocr/tesseract). These models only work with the LSTM OCR engine of Tesseract 4 / 5.
- **tessdata_contrib** [ğŸ“](../../thirdparty/tessdata_contrib) [ğŸŒ](https://github.com/GerHobbelt/tessdata_contrib) -- user contributions (non Google) for Tesseract 4 / 5.
- **tessdata_fast** [ğŸ“](../../thirdparty/tessdata_fast) [ğŸŒ](https://github.com/GerHobbelt/tessdata_fast) -- fast integer versions of trained models for the [Tesseract Open Source OCR Engine](https://github.com/tesseract-ocr/tesseract). These models only work with the LSTM OCR engine of Tesseract 4 / 5.
- **tessdoc** [ğŸ“](../../thirdparty/tessdoc) [ğŸŒ](https://github.com/GerHobbelt/tessdoc) -- user manual for Tesseract versions `5.x`.
- **tesseract** [ğŸ“](../../thirdparty/tesseract) [ğŸŒ](https://github.com/GerHobbelt/tesseract) -- `tesseract-ocr` with `--visible-pdf-image` and other tweaks.
- **tesseract-dev-mailing-list-archive** [ğŸ“](./tesseract-dev-mailing-list-archive) [ğŸŒ](https://github.com/GerHobbelt/tesseract-dev-mailing-list-archive) -- tesseract-dev mailing list archive, Mechanical Turked because Google does not offer this and has, through their actions, persistently obstructed any and all automation efforts to date.
- **tesseract_docs** [ğŸ“](../../thirdparty/tesseract_docs) [ğŸŒ](https://github.com/GerHobbelt/tesseract_docs) -- various documents related to Tesseract OCR.
- **tesseract-gImgRdrGui** [ğŸ“](./tesseract-gImgRdrGui) [ğŸŒ](https://github.com/GerHobbelt/gImageReader) -- a Gtk/Qt front-end to tesseract-ocr.
- **tesseract_langdata** [ğŸ“](../../thirdparty/tesseract_langdata) [ğŸŒ](https://github.com/GerHobbelt/langdata) -- source training data for Tesseract for lots of languages.
- **tesseract-ocr-mailing-list-archive** [ğŸ“](./tesseract-ocr-mailing-list-archive) [ğŸŒ](https://github.com/GerHobbelt/tesseract-ocr-mailing-list-archive) -- tesseract-ocr mailing list archive, Mechanical Turked because Google does not offer this and has, through their actions, persistently obstructed any and all automation efforts to date.
- **tesslinesplit** [ğŸ“](./tesslinesplit) [ğŸŒ](https://github.com/GerHobbelt/tesslinesplit) -- a standalone program for using Tesseract's line segmentation algorithm to split up document images.
- **tesstrain** [ğŸ“](../../thirdparty/tesstrain) [ğŸŒ](https://github.com/GerHobbelt/tesstrain) -- training workflow for Tesseract 4.
- **textflowcpp** [ğŸ“](./textflowcpp) [ğŸŒ](https://github.com/GerHobbelt/textflowcpp) -- a simple way to wrap a string at different line lengths, optionally with indents.
- **text-wrangler** [ğŸ“](./text-wrangler) [ğŸŒ](https://github.com/GerHobbelt/text-wrangler) -- a library + utility for text wrangling: text from in images, text from text. text line detection, text keyphrase extraction, text metadata extraction, ...
- **theoretica** [ğŸ“](./theoretica) [ğŸŒ](https://github.com/GerHobbelt/theoretica) -- a numerical and automatic math library for scientific research and graphical applications. Theoretica is a header-only mathematical library which provides algorithms for **systems simulation**, **statistical analysis** of lab data and **numerical approximation**, using a **functional** oriented paradigm to mimic **mathematical notation** and formulas. The aim of the library is to provide _simple_ access to powerful algorithms while keeping an _elegant_ and _transparent_ interface, enabling the user to focus on the problem at hand.
- **thread-pool** [ğŸ“](./thread-pool) [ğŸŒ](https://github.com/GerHobbelt/thread-pool) -- `BS::thread_pool`: a fast, lightweight, and easy-to-use C++17 thread pool library (by Barak Shoshany)
- **thread-pool-c** [ğŸ“](./thread-pool-c) [ğŸŒ](https://github.com/GerHobbelt/C-Thread-Pool) -- a minimal but advanced threadpool implementation.
- **thread-pool-cpp** [ğŸ“](./thread-pool-cpp) [ğŸŒ](https://github.com/GerHobbelt/thread-pool-cpp) -- highly scalable and fast thread pool. It implements both work-stealing and work-distribution balancing startegies. It implements cooperative scheduling strategy.
- **thrift** [ğŸ“](./thrift) [ğŸŒ](https://github.com/GerHobbelt/thrift) -- Apache Thrift is a lightweight, language-independent software stack for point-to-point RPC implementation. Thrift provides clean abstractions and implementations for data transport, data serialization, and application level processing. The code generation system takes a simple definition language as input and generates code across programming languages that uses the abstracted stack to build interoperable RPC clients and servers.
- **thunderSVM** [ğŸ“](./thunderSVM) [ğŸŒ](https://github.com/GerHobbelt/thundersvm) -- ThunderSVM exploits GPUs and multi-core CPUs to achieve high efficiency, supporting all functionalities of LibSVM such as one-class SVMs, SVC, SVR and probabilistic SVMs.
- **ticpp** [ğŸ“](./ticpp) [ğŸŒ](https://github.com/GerHobbelt/ticpp) -- TinyXML++: XML read/write
- **tidy-html5** [ğŸ“](./tidy-html5) [ğŸŒ](https://github.com/GerHobbelt/tidy-html5) -- clean up HTML documents before archiving/processing
- **tink** [ğŸ“](./tink) [ğŸŒ](https://github.com/GerHobbelt/tink) -- A multi-language, cross-platform library that provides cryptographic APIs that are secure, easy to use correctly, and hard(er) to misuse.
- **tink-cc** [ğŸ“](./tink-cc) [ğŸŒ](https://github.com/GerHobbelt/tink-cc) -- Tink C++: Using crypto in your application shouldn't feel like juggling chainsaws in the dark. Tink is a crypto library written by a group of cryptographers and security engineers at Google. It was born out of our extensive experience working with Google's product teams, [fixing weaknesses in implementations](https://github.com/google/wycheproof), and providing simple APIs that can be used safely without needing a crypto background. Tink provides secure APIs that are easy to use correctly and hard(er) to misuse. It reduces common crypto pitfalls with user-centered design, careful implementation and code reviews, and extensive testing. At Google, Tink is one of the standard crypto libraries, and has been deployed in hundreds of products and systems.
- **tinn** [ğŸ“](./tinn) [ğŸŒ](https://github.com/GerHobbelt/tinn) -- Tinn (Tiny Neural Network) is a 200 line dependency free neural network library written in C99.
- **tinycbor** [ğŸ“](./tinycbor) [ğŸŒ](https://github.com/GerHobbelt/tinycbor) -- Concise Binary Object Representation (CBOR) library for serializing data to disk or message channel.
- **tinycolormap** [ğŸ“](./tinycolormap) [ğŸŒ](https://github.com/GerHobbelt/tinycolormap) -- a header-only, single-file library for colormaps written in C++11.
- **tinydir** [ğŸ“](./tinydir) [ğŸŒ](https://github.com/GerHobbelt/tinydir) -- lightweight, portable and easy to integrate C directory and file reader. TinyDir wraps `dirent` for POSIX and `FindFirstFile` for Windows. Windows unicode is supported.
- **tiny-dnn** [ğŸ“](./tiny-dnn) [ğŸŒ](https://github.com/GerHobbelt/tiny-dnn) -- a C++14 implementation of deep learning. It is suitable for deep learning on limited computational resource, embedded systems and IoT devices.
- **tinyexpr** [ğŸ“](./tinyexpr) [ğŸŒ](https://github.com/GerHobbelt/tinyexpr) -- a very small recursive descent parser and evaluation engine for math expressions.
- **tinyexr** [ğŸ“](./tinyexr) [ğŸŒ](https://github.com/GerHobbelt/tinyexr) -- Tiny OpenEXR: `tinyexr` is a small, single header-only library to load and save OpenEXR (.exr) images.
- **tinygettext** [ğŸ“](./tinygettext) [ğŸŒ](https://github.com/GerHobbelt/tinygettext) -- a minimal replacement for gettext written in C++. It can read `.po` files directly and doesn't need `.mo` files generated from `.po`. It also can read the `.po` files from arbitrary locations, so it's better suited for non-Unix systems and situations in which one wants to store or distribute `.po` files separately from the software itself.
- **tinynurbs** [ğŸ“](./tinynurbs) [ğŸŒ](https://github.com/GerHobbelt/tinynurbs) -- a lightweight header-only C++14 library for Non-Uniform Rational B-Spline curves and surfaces. The API is simple to use and the code is readable while being efficient.
- **tiny-process-library** [ğŸ“](./tiny-process-library) [ğŸŒ](https://github.com/GerHobbelt/tiny-process-library) -- small platform independent library making it simple to create and stop new processes, as well as writing to stdin and reading from stdout and stderr of a new process.
- **tinyspline** [ğŸ“](./tinyspline) [ğŸŒ](https://github.com/GerHobbelt/tinyspline) -- TinySpline is a small, yet powerful library for interpolating, transforming, and querying arbitrary NURBS, B-Splines, and BÃ©zier curves.
- **tiny-utf8** [ğŸ“](./tiny-utf8) [ğŸŒ](https://github.com/GerHobbelt/tiny-utf8) -- a library for extremely easy integration of Unicode into an arbitrary C++11 project. The library consists solely of the class `utf8_string`, which acts as a drop-in replacement for `std::string`. Its implementation is successfully in the middle between small memory footprint and fast access. All functionality of `std::string` is therefore replaced by the corresponding codepoint-based UTF-32 version - translating every access to UTF-8 under the hood.
- **tlsh** [ğŸ“](./tlsh) [ğŸŒ](https://github.com/GerHobbelt/tlsh) -- TLSH - Trend Micro Locality Sensitive Hash - is a fuzzy matching library. Given a byte stream with a minimum length of 50 bytes TLSH generates a hash value which can be used for similarity comparisons. Similar objects will have similar hash values which allows for the detection of similar objects by comparing their hash values.  Note that the byte stream should have a sufficient amount of complexity.  For example, a byte stream of identical bytes will not generate a hash value.
- **tlx** [ğŸ“](./tlx) [ğŸŒ](https://github.com/GerHobbelt/tlx) -- a collection of C++ helpers and extensions universally needed, but not found in the STL.
- **tlx-btree** [ğŸ“](./tlx-btree) [ğŸŒ](https://github.com/GerHobbelt/tlx) -- in-memory B+-tree: an alternative for the priority queue as we expect the queue to grow huge, given past experience with Qiqqa.
- **tmap** [ğŸ“](./tmap) [ğŸŒ](https://github.com/GerHobbelt/tmap) -- a very fast visualization library for large, high-dimensional data sets. tmap's graph layouts are based on the [OGDF](https://ogdf.uos.de/) library.
- **TNN** [ğŸ“](./TNN) [ğŸŒ](https://github.com/GerHobbelt/TNN) -- a high-performance, lightweight neural network inference framework open sourced by Tencent Youtu Lab. It also has many outstanding advantages such as cross-platform, high performance, model compression, and code tailoring. The TNN framework further strengthens the support and performance optimization of mobile devices on the basis of the original Rapidnet and ncnn frameworks. At the same time, it refers to the high performance and good scalability characteristics of the industry's mainstream open source frameworks, and expands the support for X86 and NV GPUs. On the mobile phone, TNN has been used by many applications such as mobile QQ, weishi, and Pitu. As a basic acceleration framework for Tencent Cloud AI, TNN has provided acceleration support for the implementation of many businesses. Everyone is welcome to participate in the collaborative construction to promote the further improvement of the TNN inference framework.
- **toml11** [ğŸ“](./toml11) [ğŸŒ](https://github.com/GerHobbelt/toml11) -- a C++11 header-only TOML parser/encoder depending only on C++ standard library, compatible to the latest version of [TOML v1.0.0](https://toml.io/en/v1.0.0), including UTF-8 support.
- **tomlpp** [ğŸ“](./tomlpp) [ğŸŒ](https://github.com/GerHobbelt/tomlplusplus) -- TOML++
- **TraceETW** [ğŸ“](./TraceETW) [ğŸŒ](https://github.com/GerHobbelt/TraceEtw) -- [Event Tracing for Windows (ETW)](http://msdn.microsoft.com/en-us/library/windows/desktop/aa363668(v=vs.85).aspx) is  powerful but notoriously complex. In C#, [EventSource](http://msdn.microsoft.com/en-us/library/system.diagnostics.tracing.eventsource(v=vs.110).aspx) made that technology much more approachable. This project aims at providing a similar solution for C++, both for Desktop apps and for Windows/Windows Phone Universal Store apps.
- **tracelogging-for-ETW** [ğŸ“](./tracelogging-for-ETW) [ğŸŒ](https://github.com/GerHobbelt/tracelogging) -- C++ Wrapper for Windows ETW TraceLogging
- **transwarp** [ğŸ“](./transwarp) [ğŸŒ](https://github.com/GerHobbelt/transwarp) -- a header-only C++ library for task concurrency. It allows you to easily create a graph of tasks where every task can be executed synchronously. transwarp is written in C++17 and only depends on the standard library.
- **tray** [ğŸ“](./tray) [ğŸŒ](https://github.com/GerHobbelt/tray) -- cross-platform, single header, super tiny C99 implementation of a system tray icon with a popup menu.
- **tre** [ğŸ“](./tre) [ğŸŒ](https://github.com/GerHobbelt/tre) -- TRE is a lightweight, robust, and efficient POSIX compliant regexp matching library with some exciting features such as approximate (fuzzy) matching. The matching algorithm used in TRE uses linear worst-case time in the length of the text being searched, and quadratic worst-case time in the length of the used regular expression.
- **treelite** [ğŸ“](./treelite) [ğŸŒ](https://github.com/GerHobbelt/treelite) -- **Treelite** is a universal model exchange and serialization format for decision tree forests. Treelite aims to be a small library that enables other C++ applications to exchange and store decision trees on the disk as well as the network.
- **trng4** [ğŸ“](./trng4) [ğŸŒ](https://github.com/GerHobbelt/trng4) -- Tinaâ€™s Random Number Generator Library (TRNG) is a state of the art C++ pseudo-random number generator library for sequential and parallel Monte Carlo simulations. Its design principles are based on the extensible random number generator facility that was introduced in the C++11 standard. The TRNG library features an object oriented design, is easy to use and has been speed optimized. Its implementation does not depend on any communication library or hardware architecture.
- **tsf** [ğŸ“](./tsf) [ğŸŒ](https://github.com/GerHobbelt/tsf) -- type-safe printf equivalent for C++ (used by the uberlog submodule)
- **tvision** [ğŸ“](./tvision) [ğŸŒ](https://github.com/GerHobbelt/tvision) -- a modern port of Borland's Turbo Vision 2.0, the classical framework for text-based user interfaces. Now cross-platform and with Unicode support. (**retro fun**)
- **twain_library** [ğŸ“](./twain_library) [ğŸŒ](https://github.com/GerHobbelt/twain_library) -- the DTWAIN Library, **Version 5.x**, from Dynarithmic Software.  DTWAIN is an open source programmer's library that will allow applications to acquire images from TWAIN-enabled devices using a simple Application Programmer's Interface (API).
- **tweeny** [ğŸ“](./tweeny) [ğŸŒ](https://github.com/GerHobbelt/tweeny) -- an inbetweening library designed for the creation of complex animations for games and other beautiful interactive software. It leverages features of modern C++ to empower developers with an intuitive API for declaring tweenings of any type of value, as long as they support arithmetic operations. The goal of Tweeny is to provide means to create fluid interpolations when animating position, scale, rotation, frames or other values of screen objects, by setting their values as the tween starting point and then, after each tween step, plugging back the result.
- **txiki** [ğŸ“](./txiki.js) [ğŸŒ](https://github.com/GerHobbelt/txiki.js) -- a small and powerful JavaScript runtime. It's built on the shoulders of giants: it uses [QuickJS] as its JavaScript engine, [libuv] as the platform layer, [wasm3] as the WebAssembly engine and [curl] as the HTTP / WebSocket client.
- **txiki.js** [ğŸ“](./txiki.js) [ğŸŒ](https://github.com/GerHobbelt/txiki.js) -- a small and powerful JavaScript runtime.  It targets ECMAScript 2020 and implements many web platform features.
- **typesense** [ğŸ“](./typesense) [ğŸŒ](https://github.com/GerHobbelt/typesense) -- a fast, typo-tolerant search engine for building delightful search experiences. Open Source alternative to Algolia and an Easier-to-Use alternative to ElasticSearch. âš¡ğŸ”âœ¨ Fast, typo tolerant, in-memory fuzzy Search Engine for building delightful search experiences.
- **u8g2** [ğŸ“](./u8g2) [ğŸŒ](https://github.com/GerHobbelt/u8g2) -- a monochrome graphics library for embedded devices. U8g2 supports monochrome OLEDs and LCDs, which include the following controllers: SSD1305, SSD1306, SSD1309, SSD1312, SSD1316, SSD1318, SSD1320, SSD1322, SSD1325, SSD1327, SSD1329, SSD1606, SSD1607, SH1106, SH1107, SH1108, SH1122, T6963, RA8835, LC7981, PCD8544, PCF8812, HX1230, UC1601, UC1604, UC1608, UC1610, UC1611, UC1617, UC1638, UC1701, ST7511, ST7528, ST7565, ST7567, ST7571, ST7586, ST7588, ST75160, ST75256, ST75320, NT7534, ST7920, IST3020, IST3088, IST7920, LD7032, KS0108, KS0713, HD44102, T7932, SED1520, SBN1661, IL3820, MAX7219, GP1287, GP1247, GU800 (see [here](https://github.com/olikraus/u8g2/wiki/u8g2setupcpp) for a full list).
- **u8_to_std_string** [ğŸ“](./u8_to_std_string) [ğŸŒ](https://github.com/GerHobbelt/u8_to_std_string) -- C++ u8_to_std_string (`u8` and `char8_t` based string to `std::string`) inlines to convert between `u8` (`char8_t[]`) string constants and `char`-based `std::string` types to shut up C++17 âœ C++20 transitioning codebases & compilers.
- **uberlog** [ğŸ“](./uberlog) [ğŸŒ](https://github.com/GerHobbelt/uberlog) -- a cross platform C++ logging system that is focused on fast and small, writing to a shared memory ring buffer.
- **uchardet** [ğŸ“](./uchardet) [ğŸŒ](https://github.com/GerHobbelt/uchardet) -- [uchardet](https://www.freedesktop.org/wiki/Software/uchardet/) is an encoding and language detector library, which attempts to determine the encoding of the text. It can reliably detect many charsets. Moreover it also works as a very good and fast language detector.
- **ucto** [ğŸ“](./ucto) [ğŸŒ](https://github.com/GerHobbelt/ucto) -- text tokenization
  
  - **libfolia** [ğŸ“](./libfolia) [ğŸŒ](https://github.com/GerHobbelt/libfolia) -- working with the Format for Linguistic Annotation (FoLiA). Provides a high-level API to read, manipulate, and create FoLiA documents.
  - **uctodata** [ğŸ“](./uctodata) [ğŸŒ](https://github.com/GerHobbelt/uctodata) -- data for `ucto` library

- **uctodata** [ğŸ“](./uctodata) [ğŸŒ](https://github.com/GerHobbelt/uctodata) -- data for `ucto` library
- **ucx** [ğŸ“](./ucx) [ğŸŒ](https://github.com/GerHobbelt/ucx) -- Unified Communication X (UCX) is an optimized production proven-communication framework for modern, high-bandwidth and low-latency networks. UCX exposes a set of abstract communication primitives that utilize the best of available hardware resources and offloads. These include RDMA (InfiniBand and RoCE), TCP, GPUs, shared memory, and network atomic operations.
- **ugrep** [ğŸ“](./ugrep) [ğŸŒ](https://github.com/GerHobbelt/ugrep) -- search for anything in everything... ultra fast. "*`grep` for arbitrary binary files*."
- **UIforETW** [ğŸ“](./UIforETW) [ğŸŒ](https://github.com/GerHobbelt/UIforETW) -- Bruce Dawson's user interface for recording ETW (Event Tracing for Windows) traces, which allow amazingly deep investigations of performance problems on Windows.
- **uint128_t** [ğŸ“](./uint128_t) [ğŸŒ](https://github.com/GerHobbelt/uint128_t) -- an unsigned 128 bit integer type for C++.
- **unblending** [ğŸ“](./unblending) [ğŸŒ](https://github.com/GerHobbelt/unblending) -- a C++ library for decomposing a target image into a set of semi-transparent layers associated with *advanced color-blend modes* (e.g., "multiply" and "color-dodge"). Output layers can be imported to Adobe Photoshop, Adobe After Effects, GIMP, Krita, etc. and are useful for performing complex edits that are otherwise difficult.
- **unicode-cldr** [ğŸ“](./unicode-cldr) [ğŸŒ](https://github.com/GerHobbelt/cldr) -- Unicode CLDR Project: provides key building blocks for software to support the world's languages, with the largest and most extensive standard repository of locale data available. This data is used by a wide spectrum of companies for their software internationalization and localization, adapting software to the conventions of different languages for such common software tasks.
- **unicode-cldr-data** [ğŸ“](./unicode-cldr-data) [ğŸŒ](https://github.com/GerHobbelt/cldr-json) -- the JSON distribution of CLDR locale data for internationalization. While XML (not JSON) is the "official" format for all CLDR data, this data is programatically generated from the corresponding XML, using the CLDR tooling. This JSON data is generated using only data that has achieved draft="contributed" or draft="approved" status in the CLDR. This is the same threshhold as is used by the ICU (International Components for Unicode).
- **unicode-icu** [ğŸ“](./unicode-icu) [ğŸŒ](https://github.com/GerHobbelt/icu) -- the [International Components for Unicode](https://icu.unicode.org/).
- **unicode-icu-data** [ğŸ“](./unicode-icu-data) [ğŸŒ](https://github.com/GerHobbelt/icu-data) -- International Components for Unicode: Data Repository. This is an auxiliary repository for the International Components for Unicode.
- **unicode-icu-demos** [ğŸ“](./unicode-icu-demos) [ğŸŒ](https://github.com/GerHobbelt/icu-demos) -- ICU Demos contains sample applications built using the International Components for Unicode (ICU) C++ library ICU4C.
- **unilib** [ğŸ“](./unilib) [ğŸŒ](https://github.com/GerHobbelt/unilib) -- an embeddable C++17 Unicode library.
- **units** [ğŸ“](./units) [ğŸŒ](https://github.com/GerHobbelt/units) -- the Units library provides a means of working with units of measurement at runtime, including conversion to and from strings. It provides a small number of types for working with units and measurements and operations necessary for user input and output with units.
- **universal-numbers** [ğŸ“](./universal-numbers) [ğŸŒ](https://github.com/GerHobbelt/universal) -- a header-only C++ template library for universal number arithmetic. The goal of the Universal Numbers Library is to offer applications alternatives to IEEE floating-point that are more efficient and mathematically robust. The Universal library is a ready-to-use header-only library that provides plug-in replacement for native types, and provides a low-friction environment to start exploring alternatives to IEEE floating-point in your own algorithms.
- **unixODBC** [ğŸ“](./unixODBC) [ğŸŒ](https://github.com/GerHobbelt/unixODBC) -- an Open Source ODBC sub-system and an ODBC SDK for Linux, Mac OSX, and UNIX.
- **UnofficialLeptDocs** [ğŸ“](./UnofficialLeptDocs) [ğŸŒ](https://github.com/GerHobbelt/UnofficialLeptDocs) -- unofficial Sphinx-generated documentation for the Leptonica image processing library.
- **uno-solver** [ğŸ“](./uno-solver) [ğŸŒ](https://github.com/GerHobbelt/Uno) -- a modern, modular solver for nonlinearly constrained nonconvex optimization.
- **unpaper** [ğŸ“](./unpaper) [ğŸŒ](https://github.com/GerHobbelt/unpaper) -- a post-processing tool for scanned sheets of paper, especially for book pages that have been scanned from previously created photocopies.  The main purpose is to make scanned book pages better readable on screen after conversion to PDF. The program also tries to detect misaligned centering and rotation of ages and will automatically straighten each page by rotating it to the correct angle (a.k.a. deskewing).
- **unqlite** [ğŸ“](./unqlite) [ğŸŒ](https://github.com/GerHobbelt/unqlite) -- UnQLite is a Transactional Embedded Database Engine, an in-process software library which implements a self-contained, serverless, zero-configuration, transactional NoSQL database engine. UnQLite is a document store database similar to MongoDB, Redis, CouchDB etc. as well a standard Key/Value store similar to BerkeleyDB, LevelDB, etc.
  
  Unlike most other NoSQL databases, UnQLite does not have a separate server process. UnQLite reads and writes directly to ordinary disk files.
  A complete database with multiple collections is contained in a single disk file.
  The database file format is cross-platform; you can freely copy a database between 32-bit and 64-bit systems or between big-endian and little-endian architectures.
  
  - BSD licensed product.
  - Built with a powerful disk storage engine which support O(1) lookup.
  - Cross-platform file format.
  - Document store (JSON) database via Jx9.
  - Pluggable run-time interchangeable storage engine.
  - Serverless, NoSQL database engine.
  - Simple, Clean and easy to use API.
  - Single database file, does not use temporary files.
  - Standard Key/Value store.
  - Support cursors for linear records traversal.
  - Support for on-disk as well in-memory databases.
  - Support Terabyte sized databases.
  - Thread safe and full reentrant.
  - Transactional (ACID) database.
  - UnQLite is a Self-Contained C library without dependency.
  - Zero configuration.

- **unsmear** [ğŸ“](./unsmear) [ğŸŒ](https://github.com/GerHobbelt/unsmear) -- converts precisely between timestamps in the timescale of [UTC with smeared leap seconds](https://developers.google.com/time/smear) and the unsmeared [TAI](https://en.wikipedia.org/wiki/International_Atomic_Time) and GPS timescales. This allows smeared time to be stored and distributed exclusively, then converted to and from other timescales in applications where the smear's 11.6 ppm frequency change is consequential. No parallel time distribution systems are required, nor is any mechanism necessary for a system to record what timescale its system clock is using. In other words, the smear is not a way of approximately smudging the clock; it is a defined, precise, and reversible conversion. Rather than having seconds of constant length and minutes with a variable number of seconds, there are always 60 seconds in a minute and the length of a second sometimes differs from those of TAI.
- **upscaledb** [ğŸ“](./upscaledb) [ğŸŒ](https://github.com/GerHobbelt/hamsterdb) -- a.k.a. hamsterdb: a thread-safe key/value database engine. It supports a B+Tree index structure, uses memory mapped I/O (if available), fast Cursors and variable length keys and can create In-Memory Databases.
- **upskirt-markdown** [ğŸ“](./upskirt-markdown) [ğŸŒ](https://github.com/GerHobbelt/soldout) -- MarkDown renderer
- **URI-Encode-C** [ğŸ“](./URI-Encode-C) [ğŸŒ](https://github.com/GerHobbelt/URI-Encode-C) -- an optimized C library for percent encoding/decoding text, i.e. a URI encoder/decoder written in C based on [RFC3986](https://tools.ietf.org/html/rfc3986).
- **url** [ğŸ“](./url) [ğŸŒ](https://github.com/GerHobbelt/url) -- URI parsing and other utility functions
- **URL-Detector** [ğŸ“](./URL-Detector) [ğŸŒ](https://github.com/GerHobbelt/URL-Detector) -- Url Detector is a library created by the Linkedin Security Team to detect and extract urls in a long piece of text. Keep in mind that for security purposes, its better to overdetect urls: instead of complying with RFC 3986 (http://www.ietf.org/rfc/rfc3986.txt), we try to detect based on browser behavior, optimizing detection for urls that are visitable through the address bar of Chrome, Firefox, Internet Explorer, and Safari. It is also able to identify the parts of the identified urls.
- **url-parser** [ğŸ“](./url-parser) [ğŸŒ](https://github.com/GerHobbelt/url.h) -- parse URLs much like Node's [url](http://nodejs.org/api/url.html) module.
- **usearch** [ğŸ“](./usearch) [ğŸŒ](https://github.com/GerHobbelt/usearch) -- smaller & faster Single-File Similarity Search Engine for vectors & texts.
- **userver** [ğŸ“](./userver) [ğŸŒ](https://github.com/GerHobbelt/userver) -- an open source asynchronous framework with a rich set of abstractions for fast and comfortable creation of C++ microservices, services and utilities. The framework solves the problem of efficient I/O interactions transparently for the developers. Operations that would typically suspend the thread of execution do not suspend it. Instead of that, the thread processes other requests and tasks and returns to the handling of the operation only when it is guaranteed to execute immediately. As a result you get straightforward source code and avoid CPU-consuming context switches from OS, efficiently utilizing the CPU with a small amount of execution threads.
- **utf8proc** [ğŸ“](./utf8proc) [ğŸŒ](https://github.com/GerHobbelt/utf8proc) -- [utf8proc](http://juliastrings.github.io/utf8proc/) is a small, clean C library that provides Unicode normalization, case-folding, and other operations for data in the [UTF-8 encoding](http://en.wikipedia.org/wiki/UTF-8).
- **utfcpp** [ğŸ“](./utfcpp) [ğŸŒ](https://github.com/GerHobbelt/utfcpp) -- UTF-8 with C++ in a Portable Way
- **uvw** [ğŸ“](./uvw) [ğŸŒ](https://github.com/GerHobbelt/uvw) -- `libuv` wrapper in modern C++. `uvw` started as a header-only, event based, tiny and easy to use wrapper for [`libuv`](https://github.com/libuv/libuv) written in modern C++.  Now it's finally available also as a compilable static library. The basic idea is to wrap the *C-ish* interface of `libuv` behind a graceful C++ API.
- **variadic_table** [ğŸ“](./variadic_table) [ğŸŒ](https://github.com/GerHobbelt/variadic_table) -- for "pretty-printing" a formatted table of data to the console. It uses "variadic templates" to allow you to specify the types of data in each column.
- **vcopy** [ğŸ“](./vcopy) [ğŸŒ](https://github.com/GerHobbelt/vcopy) -- tool to safely copy files across various (local) hardware under circumstances where there may be another file writer active at the same time and/or the (USB?) connection is sometimes flakey or system I/O drivers buggered.
- **vcpkg** [ğŸ“](./vcpkg) [ğŸŒ](https://github.com/GerHobbelt/vcpkg) -- `Vcpkg` helps you manage C and C++ libraries on Windows, Linux and MacOS.
- **velocypack** [ğŸ“](./velocypack) [ğŸŒ](https://github.com/GerHobbelt/velocypack) -- a fast and compact format for serialization and storage.  These days, JSON (JavaScript Object Notation, see ECMA-404) is used in many cases where data has to be exchanged. Lots of protocols between different services use it, databases store JSON (document stores naturally, but others increasingly as well). It is popular, because it is simple, human-readable, and yet surprisingly versatile, despite its limitations. At the same time there is a plethora of alternatives ranging from XML over Universal Binary JSON, MongoDB's BSON, MessagePack, BJSON (binary JSON), Apache Thrift till Google's protocol buffers and ArangoDB's shaped JSON. When looking into this, we were surprised to find that none of these formats manages to combine compactness, platform independence, fast access to sub-objects and rapid conversion from and to JSON.
- **Verify** [ğŸ“](./Verify) [ğŸŒ](https://github.com/GerHobbelt/Verify) -- a snapshot tool that simplifies the assertion of complex data models and documents. Verify is called on the test result during the assertion phase. It serializes that result and stores it in a file that matches the test name. On the next test execution, the result is again serialized and compared to the existing file. The test will fail if the two snapshots do not match: either the change is unexpected, or the reference snapshot needs to be updated to the new result.
- **visible-url-detector** [ğŸ“](./visible-url-detector) [ğŸŒ](https://github.com/GerHobbelt/visible-url-detector) -- console app for listing active tab from browsers (Windows)
- **VisualScriptEngine** [ğŸ“](./VisualScriptEngine) [ğŸŒ](https://github.com/GerHobbelt/VisualScriptEngine) -- A visual scripting engine designed for embedding. The engine is written in modern C++ and compiles on several platforms with no external dependencies.
- **vizzu** [ğŸ“](./vizzu) [ğŸŒ](https://github.com/GerHobbelt/vizzu-lib) -- Vizzu is a Javascript/C++ library for animated data visualizations and data stories, utilizing a generic dataviz engine that generates many types of charts and seamlessly animates between them. It can be used to create static charts but more importantly, it is designed for building animated data stories and interactive explorers as Vizzu enables showing different perspectives of the data that the viewers can easily follow due to the animation.
- **vmaf** [ğŸ“](./vmaf) [ğŸŒ](https://github.com/GerHobbelt/vmaf) -- VMAF (Video Multi-Method Assessment Fusion) is an [Emmy-winning](https://theemmys.tv/) perceptual video quality assessment algorithm developed by Netflix. It also provides a set of tools that allows a user to train and test a custom VMAF model.
- **vmem** [ğŸ“](./vmem) [ğŸŒ](https://github.com/GerHobbelt/vmem) -- **libvmem** and **libvmmalloc** are a couple of libraries for using persistent memory for malloc-like volatile uses.  They have historically been a part of [PMDK](https://pmem.io/pmdk) despite being solely for volatile uses. You may want consider using [memkind](https://github.com/memkind/memkind) instead in code that benefits from extra features like NUMA awareness.
- **vmemcache** [ğŸ“](./vmemcache) [ğŸŒ](https://github.com/GerHobbelt/vmemcache) -- **libvmemcache** is an embeddable and lightweight in-memory buffered LRU caching solution. It's designed to fully take advantage of large capacity memory, such as Persistent Memory with DAX, through memory mapping in an efficient and scalable way.
- **VQMT** [ğŸ“](./VQMT) [ğŸŒ](https://github.com/GerHobbelt/VQMT) -- VQMT (Video Quality Measurement Tool) provides fast implementations of the following objective metrics:
  
  - **MS-SSIM**: Multi-Scale Structural Similarity,
  - **PSNR**: Peak Signal-to-Noise Ratio,
  - **PSNR-HVS**: Peak Signal-to-Noise Ratio taking into account Contrast Sensitivity Function (CSF),
  - **PSNR-HVS-M**: Peak Signal-to-Noise Ratio taking into account Contrast Sensitivity Function (CSF) and between-coefficient contrast masking of DCT basis functions.
  - **SSIM**: Structural Similarity,
  - **VIFp**: Visual Information Fidelity, pixel domain version
  
  The above metrics are implemented in C++ with the help of OpenCV and are based on the original Matlab implementations provided by their developers.

- **VSNASM** [ğŸ“](./VSNASM) [ğŸŒ](https://github.com/GerHobbelt/VSNASM) -- a set of build customisations that can be used within Visual Studio to compile assembly code using NASM. Visual Studio integration for the NASM assembler.
- **VTK** [ğŸ“](./VTK) [ğŸŒ](https://github.com/GerHobbelt/VTK) -- VTK - The Visualization Toolkit - is an open-source software system for image processing, 3D graphics, volume rendering and visualization. VTK includes many advanced algorithms (e.g., surface reconstruction, implicit modeling, decimation) and rendering techniques (e.g., hardware-accelerated volume rendering, LOD control).
- **vtm** [ğŸ“](./vtm) [ğŸŒ](https://github.com/GerHobbelt/vtm) -- Terminal multiplexer with window manager and session sharing. Text-based desktop environment inside your terminal. Includes `destopio`, a text/terminal oriented layout engine.
- **vxl** [ğŸ“](./vxl) [ğŸŒ](https://github.com/GerHobbelt/vxl) -- VXL (the Vision-something-Libraries) is a collection of C++ libraries designed for computer vision research and implementation. It was created from TargetJr and the IUE with the aim of making a light, fast and consistent system.
- **waifu2x-ncnn-vulkan** [ğŸ“](./waifu2x-ncnn-vulkan) [ğŸŒ](https://github.com/GerHobbelt/waifu2x-ncnn-vulkan) -- waifu2x ncnn Vulkan: an [ncnn project](https://github.com/Tencent/ncnn) implementation of the waifu2x converter. Runs fast on Intel / AMD / Nvidia / Apple-Silicon with Vulkan API.
- **warc2text** [ğŸ“](./warc2text) [ğŸŒ](https://github.com/GerHobbelt/warc2text) -- Extracts plain text, language identification and more metadata from WARC records.
- **warp-ctc** [ğŸ“](./warp-ctc) [ğŸŒ](https://github.com/GerHobbelt/warp-ctc) -- A fast parallel implementation of CTC, on both CPU and GPU. Connectionist Temporal Classification (CTC) is a loss function useful for performing supervised learning on sequence data, without needing an alignment between input data and labels. For example, CTC can be used to train end-to-end systems for speech recognition.
- **warpLDA** [ğŸ“](./warpLDA) [ğŸŒ](https://github.com/GerHobbelt/warplda) -- a cache efficient implementation for Latent Dirichlet Allocation.
- **wavelib** [ğŸ“](./wavelib) [ğŸŒ](https://github.com/GerHobbelt/wavelib) -- C implementation of Discrete Wavelet Transform (DWT,SWT and MODWT), Continuous Wavelet transform (CWT) and Discrete Packet Transform ( Full Tree Decomposition and Best Basis DWPT).
- **wcwidth9** [ğŸ“](./wcwidth9) [ğŸŒ](https://github.com/GerHobbelt/wcwidth9) -- platform independent, header only, `wcwidth` with full Unicode 9 wide character support.
- **wdenoise** [ğŸ“](./wdenoise) [ğŸŒ](https://github.com/GerHobbelt/wdenoise) -- Wavelet Denoising in ANSI C using empirical bayes thresholding and a host of other thresholding methods.
- **websocket-sharp** [ğŸ“](./websocket-sharp) [ğŸŒ](https://github.com/GerHobbelt/websocket-sharp) -- a C# implementation of the WebSocket protocol client and server.
- **webview** [ğŸ“](./webview) [ğŸŒ](https://github.com/GerHobbelt/webview) -- cross-platform embedding of the system-default web browser: a tiny cross-platform webview library for C/C++/Golang to build modern cross-platform GUIs. The goal of the project is to create a common HTML5 UI abstraction layer for the most widely used platforms. It supports two-way JavaScript bindings (to call JavaScript from C/C++/Go and to call C/C++/Go from JavaScript).
- **WebView2Browser** [ğŸ“](./WebView2Browser) [ğŸŒ](https://github.com/GerHobbelt/WebView2Browser) -- a web browser built with the [Microsoft Edge WebView2](https://aka.ms/webview2) control. WebView2Browser is a sample Windows desktop application demonstrating the WebView2 control capabilities. It is built as a Win32 [Visual Studio 2019](https://visualstudio.microsoft.com/vs/) project and makes use of both C++ and JavaScript in the WebView2 environment to power its features.
- **WebView2Samples** [ğŸ“](./WebView2Samples) [ğŸŒ](https://github.com/GerHobbelt/WebView2Samples) -- contains getting started apps as well as sample apps that demonstrate the features and usage patterns of [WebView2](https://aka.ms/webview2). As we add more features to WebView2, we will regularly update our samples.
- **we-love-colors** [ğŸ“](./we-love-colors) [ğŸŒ](https://github.com/GerHobbelt/we-love-colors) -- a library to easily generate **color palettes**.
- **wesanderson** [ğŸ“](./wesanderson) [ğŸŒ](https://github.com/GerHobbelt/wesanderson) -- Wes Anderson color palettes demo.  Hereâ€™s the most indie thing you can do to your plots.  ;-)
- **wget** [ğŸ“](./wget) [ğŸŒ](https://github.com/GerHobbelt/wget) -- GNU Wget is a free utility for non-interactive download of files from the Web.  It supports HTTP, HTTPS, and FTP protocols, as well as retrieval through HTTP proxies.
- **wget2** [ğŸ“](./wget2) [ğŸŒ](https://github.com/GerHobbelt/wget2) -- GNU Wget2 is the successor of GNU Wget, a file and recursive website downloader. Designed and written from scratch it wraps around libwget, that provides the basic functions needed by a web client. Wget2 works multi-threaded and uses many features to allow fast operation. In many cases Wget2 downloads much faster than Wget1.x due to HTTP2, HTTP compression, parallel connections and use of If-Modified-Since HTTP header.
- **wil-Win32-Interface-Library** [ğŸ“](./wil-Win32-Interface-Library) [ğŸŒ](https://github.com/GerHobbelt/wil) -- The Windows Implementation Libraries (WIL) is a header-only C++ library created to make life easier for developers on Windows through readable type-safe C++ interfaces for common Windows coding patterns.
- **win32-dpi** [ğŸ“](./win32-dpi) [ğŸŒ](https://github.com/GerHobbelt/win32-dpi) -- Win32 DPI-aware window example, showcasing how to write a Win32 DPI-aware GUI application that scales properly on everything starting from Windows XP up to and including latest Windows 11.
- **Win32_read_directory_changes** [ğŸ“](./Win32_read_directory_changes) [ğŸŒ](https://github.com/GerHobbelt/readdirectorychanges) -- sample code which goes with [Understanding ReadDirectoryChangesW](http://qualapps.blogspot.com/2010/05/understanding-readdirectorychangesw.html)
- **Win32_read_directory_changes_IOCP** [ğŸ“](./Win32_read_directory_changes_IOCP) [ğŸŒ](https://github.com/GerHobbelt/ReadDirectoryChangesIOCP) -- inspired by jimbeveridge's artical [Understanding ReadDirectoryChangesW](http://qualapps.blogspot.com/2010/05/understanding-readdirectorychangesw.html)! The project shows how to read directory changes by IO completion port on windows platform.
- **Windows10EtwEvents** [ğŸ“](./Windows10EtwEvents) [ğŸŒ](https://github.com/GerHobbelt/Windows10EtwEvents) -- Events from all manifest-based and mof-based ETW providers across Windows 10 versions.
- **winflexbison** [ğŸ“](./winflexbison) [ğŸŒ](https://github.com/GerHobbelt/winflexbison) -- Flex and Bison for Microsoft Windows :: a Windows port of Flex (the fast lexical analyser) and GNU Bison (parser generator). Both `win_flex` and `win_bison` are based on upstream sources but depend on system libraries only.
- **WinHttpPAL** [ğŸ“](./WinHttpPAL) [ğŸŒ](https://github.com/GerHobbelt/WinHttpPAL) -- implements [WinHttp API](https://docs.microsoft.com/en-us/windows/win32/winhttp/winhttp-start-page) Platform Abstraction Layer for POSIX systems using libcurl
- **win-iconv** [ğŸ“](./win-iconv) [ğŸŒ](https://github.com/GerHobbelt/win-iconv) -- an `iconv` implementation using Win32 API to convert.
- **WinToast** [ğŸ“](./WinToast) [ğŸŒ](https://github.com/GerHobbelt/WinToast) -- a library which delivers a complete integration of the modern **toast notifications** of **Windows 8**, **Windows 10** and **Windows 11**.  Toast notifications allows your app to inform the users about relevant information and timely events that they should see and take action upon inside your app, such as a new instant message, a new friend request, breaking news, or a calendar event.
- **wolfsort** [ğŸ“](./wolfsort) [ğŸŒ](https://github.com/GerHobbelt/wolfsort) -- a stable adaptive hybrid bucket / quick / merge / drop sort named wolfsort. The bucket sort, forming the core of wolfsort, is not a comparison sort, so wolfsort can be considered a member of the radix-sort family. Quicksort and mergesort are well known. Dropsort gained popularity after it was reinvented as Stalin sort.
- **word2vec** [ğŸ“](./word2vec) [ğŸŒ](https://github.com/GerHobbelt/word2vec) -- Word2Vec in C++ 11.
- **word2vec-GloVe** [ğŸ“](./word2vec-GloVe) [ğŸŒ](https://github.com/GerHobbelt/GloVe) -- an implementation of the GloVe (*Global Vectors for Word Representation*) model for learning word representations.
- **worde_butcher** [ğŸ“](./worde_butcher) [ğŸŒ](https://github.com/GerHobbelt/worde_butcher) -- a tool for text segmentation, keyword extraction and speech tagging. Butchers any text into prime word / phrase cuts, deboning all incoming based on our definitive set of stopwords for all languages.
- **wordfreq** [ğŸ“](./wordfreq) [ğŸŒ](https://github.com/GerHobbelt/wordfreq) -- wordfreq is a Python library for looking up the frequencies of words in many languages, based on many sources of data.
- **wordfrequency** [ğŸ“](./wordfrequency) [ğŸŒ](https://github.com/GerHobbelt/FrequencyWords) -- FrequencyWords: Frequency Word List Generator and processed files.
- **wxCharts** [ğŸ“](./wxCharts) [ğŸŒ](https://github.com/GerHobbelt/wxCharts) -- charts for wxWidgets
- **wxCurl** [ğŸ“](./wxCurl) [ğŸŒ](https://github.com/GerHobbelt/wxCurl) -- clone of improved wxCurl from OpenCPN. wxCURL is a simplified and integrated interface between LibCURL and wxWidgets. wxCURL provides several sub-classes for simplified interfaces to HTTP, WebDAV, FTP and Telnet based resources, threads specialized for non-blocking downloads/uploads, stock download and upload dialogs.
- **wxDatabase** [ğŸ“](./wxDatabase) [ğŸŒ](https://github.com/GerHobbelt/wxDatabase) -- wxDatabase is built on the excellent work of Joseph Blough called DatabaseLayer. The wxDatabase classes provide a database independent interface similar to JDBC (but only VERY basic functionality). So far, the only database backends supported are SQLite3, MySQL, PostGreSQL, ODBC, and TDS.
- **wxExamples** [ğŸ“](./wxExamples) [ğŸŒ](https://github.com/GerHobbelt/Examples_wxWidgets) -- examples using wxWidgets
- **wxFormBuilder** [ğŸ“](./wxFormBuilder) [ğŸŒ](https://github.com/GerHobbelt/wxFormBuilder) -- resource editor and GUI designer for wxWidgets
- **wxMEdit** [ğŸ“](./wxMEdit) [ğŸŒ](https://github.com/GerHobbelt/wxMEdit) -- a cross-platform Text/Hex Editor written in C++ & wxWidgets. wxMEdit supports many useful functions, e.g. Bookmark, Syntax Highlightings, Word Wraps, Encodings and Column/Hex Modes.
- **wxPdfDocument** [ğŸ“](./wxPdfDocument) [ğŸŒ](https://github.com/GerHobbelt/wxpdfdoc) -- **wxPdfDocument** allows wxWidgets applications to generate PDF documents. The code is a port of FPDF - a free PHP class for generating PDF files - to C++ using the wxWidgets library. Several add-on PHP scripts found on the FPDF web site are incorporated into wxPdfDocument.
- **wxPDFView** [ğŸ“](./wxPDFView) [ğŸŒ](https://github.com/GerHobbelt/wxPDFView) -- wxWidgets PDF viewer/reader control
- **wxSQLite3** [ğŸ“](./wxSQLite3) [ğŸŒ](https://github.com/GerHobbelt/wxsqlite3) -- a C++ wrapper around the SQLite 3.x database and is specifically designed for use in programs based on the wxWidgets library. **wxSQLite3** does not try to hide the underlying database, in contrary almost all special features of the current SQLite3 version are supported, like for example the creation of user defined scalar or aggregate functions.
- **wxVisualScriptEngine** [ğŸ“](./wxVisualScriptEngine) [ğŸŒ](https://github.com/GerHobbelt/VisualScriptEngineWxWidgets) -- a utility module for [VisualScriptEngine](https://github.com/kovacsv/VisualScriptEngine) which provides helper classes for embedding the engine in a wxWidgets application.
- **wxWebViewChromium** [ğŸ“](./wxWebViewChromium) [ğŸŒ](https://github.com/GerHobbelt/wxWebViewChromium) -- Chromium CEF3-based embedded browser for wxWidgets
- **wxWidgets** [ğŸ“](./wxWidgets) [ğŸŒ](https://github.com/GerHobbelt/wxWidgets) -- cross-platform GUI framework.
- **wyhash** [ğŸ“](./wyhash) [ğŸŒ](https://github.com/GerHobbelt/wyhash) -- No hash function is perfect, but some are useful. `wyhash` and `wyrand` are the ideal 64-bit hash function and PRNG respectively: solid, portable, fastest (especially for short keys), salted (using a dynamic secret to avoid intended attack).
- **xbrzscale** [ğŸ“](./xbrzscale) [ğŸŒ](https://github.com/GerHobbelt/xbrzscale) -- xBRZ upscaling commandline tool. This tool allows you to scale your graphics with xBRZ algorithm, see https://en.wikipedia.org/wiki/Pixel-art_scaling_algorithms#xBR_family
- **xcdat** [ğŸ“](./xcdat) [ğŸŒ](https://github.com/GerHobbelt/xcdat) -- a C++17 header-only library of a fast compressed string dictionary based on an improved double-array trie structure described in the paper: [Compressed double-array tries for string dictionaries supporting fast lookup](https://doi.org/10.1007/s10115-016-0999-8), *Knowledge and Information Systems*, 2017, available [here](https://kampersanda.github.io/pdf/KAIS2017.pdf).
- **xdelta** [ğŸ“](./xdelta) [ğŸŒ](https://github.com/GerHobbelt/xdelta) -- a C library and command-line tool for delta compression using VCDIFF/RFC 3284 streams.
- **xgboost** [ğŸ“](./xgboost) [ğŸŒ](https://github.com/GerHobbelt/xgboost) -- an optimized distributed gradient boosting library designed to be highly efficient, flexible and portable. It implements machine learning algorithms under the Gradient Boosting framework. XGBoost provides a parallel tree boosting (also known as GBDT, GBM) that solve many data science problems in a fast and accurate way. The same code runs on major distributed environment (Kubernetes, Hadoop, SGE, MPI, Dask) and can solve problems beyond billions of examples.
- **xlnt** [ğŸ“](./xlnt) [ğŸŒ](https://github.com/GerHobbelt/xlnt) -- a modern C++ library for manipulating spreadsheets in memory and reading/writing them from/to XLSX files as described in [ECMA 376 4th edition](http://www.ecma-international.org/publications/standards/Ecma-376.htm).
- **xml-pugixml** [ğŸ“](./xml-pugixml) [ğŸŒ](https://github.com/GerHobbelt/pugixml) -- light-weight, simple and fast XML parser for C++ with XPath support.
- **XMP-Toolkit-SDK** [ğŸ“](./XMP-Toolkit-SDK) [ğŸŒ](https://github.com/GerHobbelt/XMP-Toolkit-SDK) -- the XMP Toolkit allows you to integrate XMP functionality into your product, supplying an API for locating, adding, or updating the XMP metadata in a file.
- **xmunch** [ğŸ“](./xmunch) [ğŸŒ](https://github.com/GerHobbelt/xmunch) -- xmunch essentially does, what the 'munch' command of, for example, hunspell does, but is not compatible with hunspell affix definition files. So why use it then? What makes xmunch different from the other tools is the ability to extend incomplete word-lists. For hunspell's munch to identify a stem and add an affix mark, every word formed by the affix with the stem has to be in the original word-list. This makes sense for a compression tool. However if your word list is incomplete, you have to add all possible word-forms of a word first, before any compression is done. Using xmunch instead, you can define a subset of forms which are required to be in the word-list to allow the word to be used as stem. Like this, you can extend the word-list.
- **xnnpack** [ğŸ“](./xnnpack) [ğŸŒ](https://github.com/GerHobbelt/XNNPACK) -- a highly optimized library of floating-point neural network inference operators for ARM, WebAssembly, and x86 platforms. XNNPACK is not intended for direct use by deep learning practitioners and researchers; instead it provides low-level performance primitives for accelerating high-level machine learning frameworks, such as TensorFlow Lite, TensorFlow.js, PyTorch, and MediaPipe.
- **xor-and-binary-fuse-filter** [ğŸ“](./xor-and-binary-fuse-filter) [ğŸŒ](https://github.com/GerHobbelt/xor_singleheader) -- XOR and Binary Fuse Filter library: Bloom filters are used to quickly check whether an element is part of a set. Xor filters and binary fuse filters are faster and more concise alternative to Bloom filters. They are also smaller than cuckoo filters. They are used in [production systems](https://github.com/datafuselabs/databend).
- **Xoshiro-cpp** [ğŸ“](./Xoshiro-cpp) [ğŸŒ](https://github.com/GerHobbelt/Xoshiro-cpp) -- a header-only pseudorandom number generator library for modern C++. Based on **David Blackman and Sebastiano Vigna's [xoshiro/xoroshiro generators](http://prng.di.unimi.it/)**.
- **xpdf** [ğŸ“](./xpdf) [ğŸŒ](https://github.com/GerHobbelt/xpdf) -- Xpdf is an open source viewer for Portable Document Format (PDF) files.
- **xsg** [ğŸ“](./xsg) [ğŸŒ](https://github.com/GerHobbelt/xsg) -- XOR [BST](https://en.wikipedia.org/wiki/Binary_search_tree) implementations are related to the [XOR linked list](https://en.wikipedia.org/wiki/XOR_linked_list), a [doubly linked list](https://en.wikipedia.org/wiki/Doubly_linked_list) variant, from where we borrow the idea about how links between nodes are to be implemented. Modest resource requirements and simplicity make XOR [scapegoat trees](https://en.wikipedia.org/wiki/Scapegoat_tree) stand out of the [BST](https://en.wikipedia.org/wiki/Binary_search_tree) crowd. All iterators (except `end()` iterators), but not references and pointers, are invalidated, after inserting or erasing from this XOR [scapegoat tree](https://en.wikipedia.org/wiki/Scapegoat_tree) implementation. You can dereference invalidated iterators, if they were not erased, but you cannot iterate with them. `end()` iterators are constant and always valid, but dereferencing them results in undefined behavior.
- **xsimd** [ğŸ“](./xsimd) [ğŸŒ](https://github.com/GerHobbelt/xsimd) -- SIMD (Single Instruction, Multiple Data) instructions differ between microprocessor vendors and compilers. `xsimd` provides a unified means for using these features for library authors. It enables manipulation of batches of numbers with the same arithmetic operators as for single values. It also provides accelerated implementation of common mathematical functions operating on batches.
- **xsldbg** [ğŸ“](./xsldbg) [ğŸŒ](https://github.com/GerHobbelt/xsldbg) -- a debugger for xsl/xslt stylesheets which has functionality similar to a Unix/Linux "gdb", using libxml2 and libxslt.
- **xtensor** [ğŸ“](./xtensor) [ğŸŒ](https://github.com/GerHobbelt/xtensor) -- C++ tensors with broadcasting and lazy computing. `xtensor` is a C++ library meant for numerical analysis with multi-dimensional array expressions.
- **xtensor-blas** [ğŸ“](./xtensor-blas) [ğŸŒ](https://github.com/GerHobbelt/xtensor-blas) -- an extension to the `xtensor` library, offering bindings to BLAS and LAPACK libraries through `cxxblas` and `cxxlapack`.
- **xtensor-io** [ğŸ“](./xtensor-io) [ğŸŒ](https://github.com/GerHobbelt/xtensor-io) -- a `xtensor` plugin to read and write images, audio files, NumPy (compressed) NPZ and HDF5 files.
- **xtl** [ğŸ“](./xtl) [ğŸŒ](https://github.com/GerHobbelt/xtl) -- xtensor core library
- **xxHash** [ğŸ“](./xxHash) [ğŸŒ](https://github.com/GerHobbelt/xxHash) -- fast (non-cryptographic) hash algorithm
- **YACLib** [ğŸ“](./YACLib) [ğŸŒ](https://github.com/GerHobbelt/YACLib) -- YACLib is a lightweight C++ library for concurrent and parallel task execution.
- **yake** [ğŸ“](./yake) [ğŸŒ](https://github.com/GerHobbelt/yake) -- Yet Another Keyword Extractor (Yake) is a light-weight unsupervised automatic keyword extraction method which rests on text statistical features extracted from single documents to select the most important keywords of a text. Our system does not need to be trained on a particular set of documents, neither it depends on dictionaries, external-corpus, size of the text, language or domain.
- **yaml-cpp** [ğŸ“](./yaml-cpp) [ğŸŒ](https://github.com/GerHobbelt/yaml-cpp) -- a YAML parser and emitter in C++ matching the YAML 1.2 spec.
- **yaml-test-suite** [ğŸ“](./yaml-test-suite) [ğŸŒ](https://github.com/GerHobbelt/yaml-test-suite) -- comprehensive Test Suite for YAML
- **yara-pattern-matcher** [ğŸ“](./yara-pattern-matcher) [ğŸŒ](https://github.com/GerHobbelt/yara) -- for automated and user-specified pattern recognition in custom document & metadata *cleaning* / processing tasks
- **yasl** [ğŸ“](./yasl) [ğŸŒ](https://github.com/GerHobbelt/yasl) -- Bytecode Interpreter for Yet Another Scripting Language (YASL).
- **yggdrasil-decision-forests** [ğŸ“](./yggdrasil-decision-forests) [ğŸŒ](https://github.com/GerHobbelt/yggdrasil-decision-forests) -- Yggdrasil Decision Forests (YDF) is a production-grade collection of algorithms for the training, serving, and interpretation of decision forest models. YDF is open-source and is available in C++, command-line interface (CLI), TensorFlow (under the name [TensorFlow Decision Forests](https://github.com/tensorflow/decision-forests); TF-DF), JavaScript (inference only), and Go (inference only).
- **you-token-to-me** [ğŸ“](./you-token-to-me) [ğŸŒ](https://github.com/GerHobbelt/YouTokenToMe) -- text tokenization
- **yy_color_convertor** [ğŸ“](./yy_color_convertor) [ğŸŒ](https://github.com/GerHobbelt/yy_color_convertor) -- convert color between RGB,HSL,HSB,CMYK,YUV,YIQ,XYZ,xyY,Lab,Luv,LCH ...
- **yyjson** [ğŸ“](./yyjson) [ğŸŒ](https://github.com/GerHobbelt/yyjson) -- allegedly the fastest JSON library in C.
- **zfp-compressed-arrays** [ğŸ“](./zfp-compressed-arrays) [ğŸŒ](https://github.com/GerHobbelt/zfp) -- zfp is a compressed format for representing multidimensional floating-point and integer arrays. zfp provides compressed-array classes that support high throughput read and write random access to individual array elements. zfp also supports serial and parallel (OpenMP and CUDA) compression of whole arrays, e.g., for applications that read and write large data sets to and from disk.
- **zlib** [ğŸ“](../../thirdparty/zlib) [ğŸŒ](https://github.com/GerHobbelt/thirdparty-zlib) -- zlib-ng: zlib data compression library for the next generation systems.
- **ZLMediaKit** [ğŸ“](./ZLMediaKit) [ğŸŒ](https://github.com/GerHobbelt/ZLMediaKit) -- a high-performance operational-level streaming media service framework based on C++11, supporting multiple protocols (RTSP/RTMP/HLS/HTTP-FLV/WebSocket-FLV/GB28181/HTTP-TS/WebSocket-TS/HTTP-fMP4/WebSocket-fMP4/MP4/WebRTC) and protocol conversion.
  
  This extension supports a set of similarity algorithms. The most known algorithms are covered by this extension. You must be aware that each algorithm is suited for a specific domain. The following algorithms are provided.
  
  - Cosine Distance;
  - Dice Coefficient;
  - Euclidean Distance;
  - Hamming Distance;
  - Jaccard Coefficient;
  - Jaro Distance;
  - Jaro-Winkler Distance;
  - L1 Distance (as known as City Block or Manhattan Distance);
  - Levenshtein Distance;
  - Matching Coefficient;
  - Monge-Elkan Coefficient;
  - Needleman-Wunsch Coefficient;
  - Overlap Coefficient;
  - Q-Gram Distance;
  - Smith-Waterman Coefficient;
  - Smith-Waterman-Gotoh Coefficient;
  - Soundex Distance.

- **zotero** [ğŸ“](./zotero) [ğŸŒ](https://github.com/GerHobbelt/zotero) -- [Zotero](https://www.zotero.org/) is a free, easy-to-use tool to help you collect, organize, cite, and share your research sources.
- **zotero-better-bibtex** [ğŸ“](./zotero-better-bibtex) [ğŸŒ](https://github.com/GerHobbelt/zotero-better-bibtex) -- Better BibTeX (BBT) is an extension for Zotero and Juris-M that makes it easier to manage bibliographic data, especially for people authoring documents using text-based toolchains (e.g. based on LaTeX / Markdown).
- **zotero-bib** [ğŸ“](./zotero-bib) [ğŸŒ](https://github.com/GerHobbelt/bib) -- Zotero Translation Client is a library that can process URLs and identifiers (such as ISBN or DOI) into CSL-JSON bibliography items using a translation server.
- **zotero-build** [ğŸ“](./zotero-build) [ğŸŒ](https://github.com/GerHobbelt/zotero-build) -- Zotero client build scripts.
- **zotero-connectors** [ğŸ“](./zotero-connectors) [ğŸŒ](https://github.com/GerHobbelt/zotero-connectors) -- Chrome, Firefox, and Safari browser extensions for Zotero.
- **zotero-google-docs-integration** [ğŸ“](./zotero-google-docs-integration) [ğŸŒ](https://github.com/GerHobbelt/zotero-google-docs-integration) -- a Zotero integration plugin that communicates between Google Docs and Zotero via the Connector.
- **zotero-libreoffice-integration** [ğŸ“](./zotero-libreoffice-integration) [ğŸŒ](https://github.com/GerHobbelt/zotero-libreoffice-integration) -- comprises extensions for LibreOffice/OpenOffice.org/NeoOffice and Zotero communicating using local web servers.
- **zotero-scholar-citations** [ğŸ“](./zotero-scholar-citations) [ğŸŒ](https://github.com/GerHobbelt/zotero-scholar-citations) -- an add-on for Zotero. The add-on automatically fetches numbers of citations of your Zotero items from Google Scholar and makes it possible to sort your items by the citations. Moreover, it allows batch updating the citations, as they may change over time.
  
  **When updating multiple citations in a batch, it may happen that citation queries are blocked by Google Scholar for multiple automated requests. If a blockage happens, the add-on opens a browser window and directs it to http://scholar.google.com/, where you should see a Captcha displayed by Google Scholar, which you need to enter to get unblocked and then re-try updating the citations. It may happen that Google Scholar displays a message like the following "*We're sorry... but your computer or network may be sending automated queries. To protect our users, we can't process your request right now.*" In that case, the only solution is to wait for a while until Google unblocks you.**

- **zotero-shortdoi** [ğŸ“](./zotero-shortdoi) [ğŸŒ](https://github.com/GerHobbelt/zotero-shortdoi) -- an add-on for Zotero. The add-on can auto-fetch DOI names for journal articles using the CrossRef API, as well as look up shortDOI names using http://shortdoi.org. The add-on additionally verifies that stored DOIs are valid and marks invalid DOIs.
- **zotero-standalone-build** [ğŸ“](./zotero-standalone-build) [ğŸŒ](https://github.com/GerHobbelt/zotero-standalone-build) -- build scripts used to bundle the Zotero core into distributable bundles for Mac, Windows, and Linux.
- **zotero-translate** [ğŸ“](./zotero-translate) [ğŸŒ](https://github.com/GerHobbelt/translate) -- browser-based standalone zotero translator.
- **zotero-translation-server** [ğŸ“](./zotero-translation-server) [ğŸŒ](https://github.com/GerHobbelt/translation-server) -- lets you use Zotero translators without the Zotero client.
- **zotero-translators** [ğŸ“](./zotero-translators) [ğŸŒ](https://github.com/GerHobbelt/translators) -- Zotero Translators : automatically detect journal articles, library records, news items, and other objects you might like to save to your Zotero library. Zotero uses so-called â€œtranslatorsâ€ to detect and import data from websites. There are currently more than 600 different translators, facilitating data import from countless sites.
- **zotero-web-library** [ğŸ“](./zotero-web-library) [ğŸŒ](https://github.com/GerHobbelt/web-library) -- a Web Library capable of being installed/run on other websites. It is a single-page application implemented in Javascript. It uses Zotero API via CORS requests.
- **zotero-word-for-windows-integration** [ğŸ“](./zotero-word-for-windows-integration) [ğŸŒ](https://github.com/GerHobbelt/zotero-word-for-windows-integration) -- a Firefox add-on that consists of a library written in C++ that communicates with Microsoft Word out of process using OLE Automation, a js-ctypes wrapper for said library, and a template that is installed into Microsoft Word to communicate with Zotero.
- **zotero-zotfile** [ğŸ“](./zotero-zotfile) [ğŸŒ](https://github.com/GerHobbelt/zotfile) -- Zotero plugin to manage your attachments: automatically rename, move, and attach PDFs (or other files) to Zotero items, sync PDFs from your Zotero library to your (mobile) PDF reader (e.g. an iPad, Android tablet, etc.), and extract PDF annotations.
- **zpp_bits** [ğŸ“](./zpp_bits) [ğŸŒ](https://github.com/GerHobbelt/zpp_bits) -- A modern, *fast*, C++20 binary serialization and RPC library, with just one header file.See also the [benchmark](https://github.com/GerHobbelt/zpp_bits#benchmark).
- **ZQCNN** [ğŸ“](./ZQCNN) [ğŸŒ](https://github.com/GerHobbelt/ZQCNN) -- ZQCNN is an inference framework that can run under windows, linux and arm-linux. At the same time, there are some demos related to face detection and recognition.
- **zstd** [ğŸ“](./zstd) [ğŸŒ](https://github.com/GerHobbelt/zstd) -- Zstandard, a.k.a. `zstd`, is a fast lossless compression algorithm, targeting real-time compression scenarios at zlib-level and better compression ratios.
- **zsv** [ğŸ“](./zsv) [ğŸŒ](https://github.com/GerHobbelt/zsv) -- the world's fastest (SIMD) CSV parser, with an extensible CLI for SQL querying, format conversion and more.
- **zsync2** [ğŸ“](./zsync2) [ğŸŒ](https://github.com/GerHobbelt/zsync2) -- the advanced file download/sync tool zsync. zsync is a well known tool for downloading and updating local files from HTTP servers using the well known algorithms rsync used for diffing binary files. Therefore, it becomes possible to synchronize modifications by exchanging the changed blocks locally using `Range:` requests. The system is based on meta files called `.zsync` files. They contain hash sums for every block of data. The file is generated from and stored along with the actual file it refers to. Due to how system works, nothing but a "dumb" HTTP server is required to make use of zsync2. This makes it easy to integrate zsync2 into existing systems.
- **zvec** [ğŸ“](./zvec) [ğŸŒ](https://github.com/GerHobbelt/zvec) -- _zip_vector_ is a compressed variable length array that uses vectorized block codecs to compress and decompress integers using variable bit-width deltas. The integer block codecs are optimized for vector instruction sets using Google's Highway C++ library for portable SIMD/vector intrinsics.
- **zxing-cpp** [ğŸ“](./zxing-cpp) [ğŸŒ](https://github.com/GerHobbelt/zxing-cpp) -- ZXing-C++ ("zebra crossing") is a multi-format linear/matrix (1D/2D) barcode image processing library implemented in C++. Supported formats include: UPC-A, UPC-E, EAN-8, EAN-13, Code 39, Code 128, QR Code, PDF417, DataMatrix, CodaBar, DataBar, ITF.
- https://github.com/alxvasilev/cpp-promise -- Javascript-like C++ promise library
- https://github.com/arun11299/cpp-subprocess -- as close as possible to Python2.7 `subprocess` module in dealing with processes.
- https://github.com/fxsjy/jieba -- a Chinese text tokenizer (done in Python)
- https://github.com/pnappa/subprocesscpp -- A header-only library that allows you to execute processes either synchronously or asynchronously, whilst providing input and output handling. No more calling `exec` in C++!
- https://github.com/rajatjain1997/subprocess -- A C++ high level library for running shell processes
- https://github.com/rhashimoto/poolqueue -- C++ Asynchronous Promises, inspired by Promises/A+.
- https://github.com/sheredom/subprocess.h -- A one header solution to launching processes and interacting with them for C/C++.
- https://github.com/YACLib/YACLib -- Yet Another lightweight C++ library for concurrent and parallel task execution.
- **Imath** [ğŸŒ](https://github.com/AcademySoftwareFoundation/Imath) -- float16 support lib for OpenEXR format
  
  - **optional**; reason: considered *overkill* for the projects I'm currently involved in, including Qiqqa. Those can use [Apache Tika](https://tika.apache.org/), [ImageMagick](https://imagemagick.org/) or other thirdparty pipelines to convert to & from supported formats.

- **OpenImageIO** [ğŸŒ](https://github.com/OpenImageIO/oiio) -- a library for reading, writing, and processing images in a wide variety of file formats, using a format-agnostic API, aimed at VFX applications.
  
  - **tentative/pending**; reason: considered nice & cool but still *overkill*. Qiqqa tooling can use [Apache Tika](https://tika.apache.org/), [ImageMagick](https://imagemagick.org/) or other thirdparty pipelines to convert to & from supported formats.

- ~~**circlehash** [ğŸ“](./circlehash) [ğŸŒ](https://github.com/GerHobbelt/circlehash) -- a family of non-cryptographic hash functions that pass every test in SMHasher.~~
  
  - **removed**; reason: written in Go; port to C/C++ is easy but just too much effort for too little gain; when we're looking for *fast* non-cryptographic hashes like this, we don't it to include 128-bit / 64-bit multiplications as those are generally slower than shift, add, xor. While this will surely be a nice hash, it doesn't fit our purposes.

- ~~**cpuinfo** [ğŸ“](./cpuinfo) [ğŸŒ](https://github.com/GerHobbelt/cpuinfo) -- CPU & hardware info~~
  
  - **removed**; reason: Linux-only, non-portable, deemed unsuitable for our needs.

- ~~**h2o-server** [ğŸ“](./h2o-server) [ğŸŒ](https://github.com/GerHobbelt/h2o) -- an optimized HTTP/1, HTTP/2, HTTP/3 server.~~
  
  - **removed**; reason: we've decided on using `crow` as the main server framework. Second choice is `civetweb`. As we're looking for a non-public-facing web server, we don't need h2o and it's complexity.

- ~~**libjxl** [ğŸ“](./libjxl) [ğŸŒ](https://github.com/GerHobbelt/libjxl) -- JPEG XL reference implementation~~
  
  **NOTICE**: due to historical reasons on my side, this code is tracked at https://github.com/GerHobbelt/jpeg-xl: see there for future track/update work of the JPEG-XL library.

- ~~**merror** [ğŸ“](./merror) [ğŸŒ](https://github.com/GerHobbelt/merror) -- a library for error handling in C++ without exceptions.~~
  
  - **removed**; reason: code is non-portable to compilers other than GCC, or at least would require more effort than we're willing to expend on this.

- ~~**binary_bakery** [ğŸŒ](https://github.com/s9w/binary_bakery) -- resource compiler-like tool: embed any data in your C/C++ application~~
  
  - **removed**; reason: we already have `bin2coff` from MuPDF, which serves this purpose well enough.

- ~~**bzip2** [ğŸŒ](https://github.com/nemequ/bzip2)~~
  
  - **removed**; reason: see `lzo` below. When we want this, we can go through [Apache Tika](https://tika.apache.org/) or other thirdparty pipelines.

- ~~**Catch2** [ğŸŒ](https://github.com/catchorg/Catch2)~~
  
  - **removed**; reason: we've decided to standardize on a single unittest library (which is well supported in Microsoft Visual Studio, including the Test Explorer view there); where necessary, we'll have to provide a translation layer instead when existing submodules use different test rigs originally.

- ~~**cgohlke::imagecodecs** [ğŸŒ](https://github.com/cgohlke/imagecodecs) (*not included; see also DICOM slot above*)~~
- ~~**clippson** [ğŸŒ](https://github.com/heavywatal/clippson) -- commandline parser + JSON data diagnostical dumper~~
  
  - **removed**; reason: deemed cool but unsuitable for our needs. Besides, we intend to use `cli11` instead of `clipp` for that library is easier to read and support is more active there.

- ~~**cpu_features** [ğŸŒ](https://github.com/google/cpu_features)~~
  
  - **removed**; reason: Linux-only, non-portable, deemed unsuitable for our needs.

- ~~**cpu_stat** [ğŸŒ](https://github.com/vivaladav/cpu-stat)~~
  
  - **removed**; reason: Linux-only, non-portable, deemed unsuitable for our needs.

- ~~**CPython** [ğŸŒ](https://github.com/python/cpython)~~
  
  - **removed**; reason: we've decided to offer any application user facing scripting features in JavaScript only: Python and the others can use socket-based messaging when someone wants to write their user scripts in any of those languages.

- ~~[DICOM to NIfTI](https://github.com/rordenlab/dcm2niix) (*not included; see also DICOM slot above*)~~
- ~~**docopt** [ğŸŒ](https://github.com/docopt/docopt.cpp) -- generate documentation for command line options~~
  
  - **removed**; reason: deemed cool but unsuitable for our needs. We intend to use `cli11` instead.

- ~~**EasyLogger** [ğŸŒ](https://github.com/armink/EasyLogger) -- an ultra-lightweight (ROM<1.6K, RAM<0.3K), high-performance C/C++ log library, very suitable for resource-sensitive software projects. Compared with the well-known C/C++ log libraries such as log4c and zlog, EasyLogger has simpler functions and provides fewer interfaces to users, but it will be quick to get started. More practical functions support dynamic expansion in the form of plug-ins.~~
  
  - **removed**; reason: we've decided on using `glog` as the logging library for everything: while that one isn't perfect, most of the other stuff we've been looking at is using that one already and it matches our needs 80% of the time, while I'm okay with patching that library for the other 20% (syslog-like use, i.e. logging to localhost logging server where all logging is collected -- these log messages should travel across as part of the ZeroMQ message streams.)

- ~~**FastBinaryEncoding** [ğŸŒ](https://github.com/chronoxor/FastBinaryEncoding)~~
  
  - **removed**; reason: for binary format record serialization we will be using `bebop` exclusively. All other communications will be JSON/JSON5/XML based.

- ~~**flatbuffers** [ğŸŒ](https://github.com/google/flatbuffers)~~
  
  - **removed**; reason: see `protobuf`: same smell rising. Faster at run time, but still a bit hairy to my tastes while `bebop` et al are on to something *potentially nice*.

- ~~**flatcc** [ğŸŒ](https://github.com/dvidelabs/flatcc)~~
  
  - **removed**; reason: see `flatbuffers`. When we don't dig `flatbuffers`, then `flatcc` is automatically pretty useless to us. Let's rephrase that professionally: "`flatcc` has moved out of scope for our project."

- ~~**GDCM-Grassroots-DICOM** [ğŸŒ](https://github.com/malaterre/GDCM)~~
  
  - **removed**; reason: not a frequently used format; the filter codes can be found in other libraries. *Overkill*. Qiqqa tooling can use [Apache Tika](https://tika.apache.org/), [ImageMagick](https://imagemagick.org/) or other thirdparty pipelines to convert to & from supported formats.

- ~~**gmime** [ğŸŒ](https://github.com/jstedfast/gmime) (alternative repo [here](https://github.com/GNOME/gmime)) -- multipart MIME library; serves as a fundamental building block for full MHTML file format I/O support~~
  
  - **removed**; reason: GNOME libraries are horrible to integrate with other codebases.

- ~~**HDF5** [ğŸŒ](https://github.com/HDFGroup/hdf5)~~
  
  - **removed**; reason: HDF5 is a nice concept but considered *overkill* right now; where we need disk stores, we'll be using SQLite or LMDB-like key-value stores instead. Such stores are not meant to be interchangeable with other software in their raw shape and we'll provide public access APIs instead, where applicable.

- ~~**HighFive-HDF5** [ğŸŒ](https://github.com/BlueBrain/HighFive)~~
  
  - **removed**; reason: see the `HDF5` entry above.

- ~~**ice** [ğŸŒ](https://github.com/zeroc-ice/ice) -- Comprehensive RPC Framework: helps you network your software with minimal effort.~~
  
  - **removed**; reason: has a strong focus on the *remote*, i.e. `R` in `RPC` (thus a focus on things such as encryption, authentication, firewalling, etc.), which we don't want or need: all services are supposed to run on a single machine and comms go through `localhost` *only*. When folks find they need to distribute the workload across multiple machines, then we'll be entering a new era in Qiqqa usage and then will be soon enough to (re-)investigate the usefulness of this package.

- ~~**inih** [ğŸŒ](https://github.com/benhoyt/inih)~~
  
  - **removed**; reason: we've decided on using `libconfig` for configuration files.

- ~~**iniparser** [ğŸŒ](https://github.com/ndevilla/iniparser)~~
  
  - **removed**; reason: we've decided on using `libconfig` for configuration files.

- ~~**libmicrohttpd** [ğŸŒ](https://github.com/Karlson2k/libmicrohttpd)~~
  
  - **removed**; reason: we've decided on using `crow` as the main server framework. Second choices are `civetweb` and `h2o`. This GNU library is way too 'Unix-is-the-world' oriented for a smooth portable dev experience.

- ~~**libsmile** [ğŸŒ](https://github.com/pierre/libsmile) -- ["Smile" format](https://en.wikipedia.org/wiki/Smile_%28data_interchange_format%29), i.e. a compact binary JSON format~~
  
  - **removed**; reason: for binary format record serialization we will be using `bebop` exclusively. All other communications will be JSON/JSON5/XML based.

- ~~**log4cplus** [ğŸŒ](https://github.com/log4cplus/log4cplus)~~
  
  - **removed**; reason: we've decided on using `glog` as the logging library for everything. log4cplus, at the same time, is a tad too much. (I consider `log4j` et al *overdone* as it caters to every need instead of just providing those things as contrib code which can be integrated at need -- should not be as far run-time configurable as it currently is.)

- ~~**lua** [ğŸŒ](https://github.com/lua/lua)~~
  
  - **removed**; reason: we've decided to offer any application user facing scripting features in JavaScript only: Python and the others can use socket-based messaging when someone wants to write their user scripts in any of those languages. See also the `CPython` entry.

- ~~**luaJIT** [ğŸŒ](https://github.com/LuaJIT/LuaJIT)~~
  
  - **removed**; reason: see the `lua` entry above.

- ~~**lzo** [ğŸŒ](https://github.com/nemequ/lzo)~~
  
  - **removed**; reason: gone as part of the first round of compression libraries' cleanup: we intend to support lz4 for fast work, plus zstd and *maybe* brotli for higher compression ratios, while we won't bother with anything else: the rest can be dealt with through [Apache Tika](https://tika.apache.org/) or other thirdparty pipelines when we need to read (or write) them. See also: [7zip-Zstd](https://github.com/mcmilk/7-Zip-zstd), which is what I use for accessing almost all compressed material anywhere.

- ~~**lzsse** [ğŸŒ](https://github.com/ConorStokes/LZSSE)~~
  
  - **removed**; reason: see `lzo` above. LZ4 either overtakes this one or is on par (anno 2022 AD) and I don't see a lot happening here, so the coolness factor is slowly fading...

- ~~**oatpp** [ğŸŒ](https://github.com/oatpp/oatpp) -- IPC / server framework~~
  
  - **removed**; reason: see `crow`. We have picked `crow` as the preferred way forward, so any similar/competing product is out of scope unless `crow` throws a tantrum on our test bench after all, the chances of that being *very slim*.

- ~~**pithy** [ğŸŒ](https://github.com/johnezang/pithy)~~
  
  - **removed**; reason: see `lzo` above. LZ4 either overtakes this one or is on par (anno 2022 AD) and I don't see a lot happening here, so the coolness factor is slowly fading...

- ~~**spdlog** [ğŸŒ](https://github.com/gabime/spdlog)~~
  
  - **removed**; reason: we've decided on using `glog` as the logging library for everything. `spdlog` has some nice features but in the end it was ease of cross-platform compilation and installed base that won out here...

- ~~**xz-utils** [ğŸŒ](https://github.com/xz-mirror/xz)~~
  
  - **removed**; reason: see `lzo2` above. When we want this, we can go through [Apache Tika](https://tika.apache.org/) or other thirdparty pipelines.

- ~~**zlog** [ğŸŒ](https://github.com/HardySimpson/zlog)~~
  
  - **removed**; `zlog` has a nice overall design but is too 'Unix-is-the-world' in its coding: in the end it was ease of cross-platform compilation of `glog` that won the day and I'm okay with layering on top of that one to get the zlog category and other channel features, once I really need them.






---













# TBD: Libraries which still need to be moved into the overview / categories above...




